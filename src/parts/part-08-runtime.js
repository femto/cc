    Dq2 = UR(),
    Hm5 = Rz(),
    Eq2 = XE(),
    zm5 = q7(),
    Um5 = "ip_resolver";
  function Hq2(A) {
    zm5.trace(rA1.LogVerbosity.DEBUG, Um5, A);
  }
  var Uo1 = "ipv4",
    wo1 = "ipv6",
    wm5 = 443;
  class $o1 {
    constructor(A, B, Q) {
      var I;
      ((this.listener = B),
        (this.endpoints = []),
        (this.error = null),
        (this.hasReturnedResult = !1),
        Hq2("Resolver constructed for target " + (0, Eq2.uriToString)(A)));
      let G = [];
      if (!(A.scheme === Uo1 || A.scheme === wo1)) {
        this.error = {
          code: rA1.Status.UNAVAILABLE,
          details: `Unrecognized scheme ${A.scheme} in IP resolver`,
          metadata: new zo1.Metadata(),
        };
        return;
      }
      let Z = A.path.split(",");
      for (let Y of Z) {
        let J = (0, Eq2.splitHostPort)(Y);
        if (J === null) {
          this.error = {
            code: rA1.Status.UNAVAILABLE,
            details: `Failed to parse ${A.scheme} address ${Y}`,
            metadata: new zo1.Metadata(),
          };
          return;
        }
        if (
          (A.scheme === Uo1 && !(0, Vq2.isIPv4)(J.host)) ||
          (A.scheme === wo1 && !(0, Vq2.isIPv6)(J.host))
        ) {
          this.error = {
            code: rA1.Status.UNAVAILABLE,
            details: `Failed to parse ${A.scheme} address ${Y}`,
            metadata: new zo1.Metadata(),
          };
          return;
        }
        G.push({
          host: J.host,
          port: (I = J.port) !== null && I !== void 0 ? I : wm5,
        });
      }
      ((this.endpoints = G.map((Y) => ({ addresses: [Y] }))),
        Hq2(
          "Parsed " +
            A.scheme +
            " address list " +
            G.map(Hm5.subchannelAddressToString),
        ));
    }
    updateResolution() {
      if (!this.hasReturnedResult)
        ((this.hasReturnedResult = !0),
          process.nextTick(() => {
            if (this.error)
              this.listener(
                (0, Kq2.statusOrFromError)(this.error),
                {},
                null,
                "",
              );
            else
              this.listener(
                (0, Kq2.statusOrFromValue)(this.endpoints),
                {},
                null,
                "",
              );
          }));
    }
    destroy() {
      this.hasReturnedResult = !1;
    }
    static getDefaultAuthority(A) {
      return A.path.split(",")[0];
    }
  }
  function $m5() {
    ((0, Dq2.registerResolver)(Uo1, $o1), (0, Dq2.registerResolver)(wo1, $o1));
  }
});
var Oq2 = z((Lq2) => {
  Object.defineProperty(Lq2, "__esModule", { value: !0 });
  Lq2.RoundRobinLoadBalancer = void 0;
  Lq2.setup = Tm5;
  var qq2 = Oc(),
    wV = WE(),
    YwA = Ab(),
    Nm5 = q7(),
    Lm5 = u8(),
    wq2 = Rz(),
    Mm5 = GwA(),
    Om5 = "round_robin";
  function $q2(A) {
    Nm5.trace(Lm5.LogVerbosity.DEBUG, Om5, A);
  }
  var oA1 = "round_robin";
  class tA1 {
    getLoadBalancerName() {
      return oA1;
    }
    constructor() {}
    toJsonObject() {
      return { [oA1]: {} };
    }
    static createFromJson(A) {
      return new tA1();
    }
  }
  class Nq2 {
    constructor(A, B = 0) {
      ((this.children = A), (this.nextIndex = B));
    }
    pick(A) {
      let B = this.children[this.nextIndex].picker;
      return (
        (this.nextIndex = (this.nextIndex + 1) % this.children.length),
        B.pick(A)
      );
    }
    peekNextEndpoint() {
      return this.children[this.nextIndex].endpoint;
    }
  }
  function Rm5(A, B) {
    return [...A.slice(B), ...A.slice(0, B)];
  }
  class qo1 {
    constructor(A) {
      ((this.channelControlHelper = A),
        (this.children = []),
        (this.currentState = wV.ConnectivityState.IDLE),
        (this.currentReadyPicker = null),
        (this.updatesPaused = !1),
        (this.lastError = null),
        (this.childChannelControlHelper = (0,
        qq2.createChildChannelControlHelper)(A, {
          updateState: (B, Q, I) => {
            if (
              this.currentState === wV.ConnectivityState.READY &&
              B !== wV.ConnectivityState.READY
            )
              this.channelControlHelper.requestReresolution();
            if (I) this.lastError = I;
            this.calculateAndUpdateState();
          },
        })));
    }
    countChildrenWithState(A) {
      return this.children.filter((B) => B.getConnectivityState() === A).length;
    }
    calculateAndUpdateState() {
      if (this.updatesPaused) return;
      if (this.countChildrenWithState(wV.ConnectivityState.READY) > 0) {
        let A = this.children.filter(
            (Q) => Q.getConnectivityState() === wV.ConnectivityState.READY,
          ),
          B = 0;
        if (this.currentReadyPicker !== null) {
          let Q = this.currentReadyPicker.peekNextEndpoint();
          if (
            ((B = A.findIndex((I) =>
              (0, wq2.endpointEqual)(I.getEndpoint(), Q),
            )),
            B < 0)
          )
            B = 0;
        }
        this.updateState(
          wV.ConnectivityState.READY,
          new Nq2(
            A.map((Q) => ({
              endpoint: Q.getEndpoint(),
              picker: Q.getPicker(),
            })),
            B,
          ),
          null,
        );
      } else if (
        this.countChildrenWithState(wV.ConnectivityState.CONNECTING) > 0
      )
        this.updateState(
          wV.ConnectivityState.CONNECTING,
          new YwA.QueuePicker(this),
          null,
        );
      else if (
        this.countChildrenWithState(wV.ConnectivityState.TRANSIENT_FAILURE) > 0
      ) {
        let A = `round_robin: No connection established. Last error: ${this.lastError}`;
        this.updateState(
          wV.ConnectivityState.TRANSIENT_FAILURE,
          new YwA.UnavailablePicker({ details: A }),
          A,
        );
      } else
        this.updateState(
          wV.ConnectivityState.IDLE,
          new YwA.QueuePicker(this),
          null,
        );
      for (let A of this.children)
        if (A.getConnectivityState() === wV.ConnectivityState.IDLE)
          A.exitIdle();
    }
    updateState(A, B, Q) {
      if (
        ($q2(
          wV.ConnectivityState[this.currentState] +
            " -> " +
            wV.ConnectivityState[A],
        ),
        A === wV.ConnectivityState.READY)
      )
        this.currentReadyPicker = B;
      else this.currentReadyPicker = null;
      ((this.currentState = A), this.channelControlHelper.updateState(A, B, Q));
    }
    resetSubchannelList() {
      for (let A of this.children) A.destroy();
      this.children = [];
    }
    updateAddressList(A, B, Q, I) {
      if (!(B instanceof tA1)) return !1;
      if (!A.ok) {
        if (this.children.length === 0)
          this.updateState(
            wV.ConnectivityState.TRANSIENT_FAILURE,
            new YwA.UnavailablePicker(A.error),
            A.error.details,
          );
        return !0;
      }
      let G = (Math.random() * A.value.length) | 0,
        Z = Rm5(A.value, G);
      if ((this.resetSubchannelList(), Z.length === 0)) {
        let Y = `No addresses resolved. Resolution note: ${I}`;
        this.updateState(
          wV.ConnectivityState.TRANSIENT_FAILURE,
          new YwA.UnavailablePicker({ details: Y }),
          Y,
        );
      }
      ($q2("Connect to endpoint list " + Z.map(wq2.endpointToString)),
        (this.updatesPaused = !0),
        (this.children = Z.map(
          (Y) =>
            new Mm5.LeafLoadBalancer(Y, this.childChannelControlHelper, Q, I),
        )));
      for (let Y of this.children) Y.startConnecting();
      return ((this.updatesPaused = !1), this.calculateAndUpdateState(), !0);
    }
    exitIdle() {}
    resetBackoff() {}
    destroy() {
      this.resetSubchannelList();
    }
    getTypeName() {
      return oA1;
    }
  }
  Lq2.RoundRobinLoadBalancer = qo1;
  function Tm5() {
    (0, qq2.registerLoadBalancerType)(oA1, qo1, tA1);
  }
});
var _q2 = z((yq2) => {
  var No1;
  Object.defineProperty(yq2, "__esModule", { value: !0 });
  yq2.OutlierDetectionLoadBalancer = yq2.OutlierDetectionLoadBalancingConfig =
    void 0;
  yq2.setup = gm5;
  var jm5 = WE(),
    Rq2 = u8(),
    bo = BwA(),
    Tq2 = Ho1(),
    Sm5 = Oc(),
    ym5 = neA(),
    km5 = Ab(),
    Lo1 = Rz(),
    _m5 = eUA(),
    xm5 = q7(),
    vm5 = "outlier_detection";
  function pF(A) {
    xm5.trace(Rq2.LogVerbosity.DEBUG, vm5, A);
  }
  var Ro1 = "outlier_detection",
    bm5 =
      ((No1 = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !==
        null && No1 !== void 0
        ? No1
        : "true") === "true",
    fm5 = {
      stdev_factor: 1900,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 100,
    },
    hm5 = {
      threshold: 85,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 50,
    };
  function f3A(A, B, Q, I) {
    if (B in A && A[B] !== void 0 && typeof A[B] !== Q) {
      let G = I ? `${I}.${B}` : B;
      throw Error(
        `outlier detection config ${G} parse error: expected ${Q}, got ${typeof A[B]}`,
      );
    }
  }
  function Mo1(A, B, Q) {
    let I = Q ? `${Q}.${B}` : B;
    if (B in A && A[B] !== void 0) {
      if (!(0, bo.isDuration)(A[B]))
        throw Error(
          `outlier detection config ${I} parse error: expected Duration, got ${typeof A[B]}`,
        );
      if (
        !(
          A[B].seconds >= 0 &&
          A[B].seconds <= 315576000000 &&
          A[B].nanos >= 0 &&
          A[B].nanos <= 999999999
        )
      )
        throw Error(
          `outlier detection config ${I} parse error: values out of range for non-negative Duaration`,
        );
    }
  }
  function eA1(A, B, Q) {
    let I = Q ? `${Q}.${B}` : B;
    if (
      (f3A(A, B, "number", Q),
      B in A && A[B] !== void 0 && !(A[B] >= 0 && A[B] <= 100))
    )
      throw Error(
        `outlier detection config ${I} parse error: value out of range for percentage (0-100)`,
      );
  }
  class JwA {
    constructor(A, B, Q, I, G, Z, Y) {
      if (((this.childPolicy = Y), Y.getLoadBalancerName() === "pick_first"))
        throw Error(
          "outlier_detection LB policy cannot have a pick_first child policy",
        );
      ((this.intervalMs = A !== null && A !== void 0 ? A : 1e4),
        (this.baseEjectionTimeMs = B !== null && B !== void 0 ? B : 30000),
        (this.maxEjectionTimeMs = Q !== null && Q !== void 0 ? Q : 300000),
        (this.maxEjectionPercent = I !== null && I !== void 0 ? I : 10),
        (this.successRateEjection = G
          ? Object.assign(Object.assign({}, fm5), G)
          : null),
        (this.failurePercentageEjection = Z
          ? Object.assign(Object.assign({}, hm5), Z)
          : null));
    }
    getLoadBalancerName() {
      return Ro1;
    }
    toJsonObject() {
      var A, B;
      return {
        outlier_detection: {
          interval: (0, bo.msToDuration)(this.intervalMs),
          base_ejection_time: (0, bo.msToDuration)(this.baseEjectionTimeMs),
          max_ejection_time: (0, bo.msToDuration)(this.maxEjectionTimeMs),
          max_ejection_percent: this.maxEjectionPercent,
          success_rate_ejection:
            (A = this.successRateEjection) !== null && A !== void 0
              ? A
              : void 0,
          failure_percentage_ejection:
            (B = this.failurePercentageEjection) !== null && B !== void 0
              ? B
              : void 0,
          child_policy: [this.childPolicy.toJsonObject()],
        },
      };
    }
    getIntervalMs() {
      return this.intervalMs;
    }
    getBaseEjectionTimeMs() {
      return this.baseEjectionTimeMs;
    }
    getMaxEjectionTimeMs() {
      return this.maxEjectionTimeMs;
    }
    getMaxEjectionPercent() {
      return this.maxEjectionPercent;
    }
    getSuccessRateEjectionConfig() {
      return this.successRateEjection;
    }
    getFailurePercentageEjectionConfig() {
      return this.failurePercentageEjection;
    }
    getChildPolicy() {
      return this.childPolicy;
    }
    static createFromJson(A) {
      var B;
      if (
        (Mo1(A, "interval"),
        Mo1(A, "base_ejection_time"),
        Mo1(A, "max_ejection_time"),
        eA1(A, "max_ejection_percent"),
        "success_rate_ejection" in A && A.success_rate_ejection !== void 0)
      ) {
        if (typeof A.success_rate_ejection !== "object")
          throw Error(
            "outlier detection config success_rate_ejection must be an object",
          );
        (f3A(
          A.success_rate_ejection,
          "stdev_factor",
          "number",
          "success_rate_ejection",
        ),
          eA1(
            A.success_rate_ejection,
            "enforcement_percentage",
            "success_rate_ejection",
          ),
          f3A(
            A.success_rate_ejection,
            "minimum_hosts",
            "number",
            "success_rate_ejection",
          ),
          f3A(
            A.success_rate_ejection,
            "request_volume",
            "number",
            "success_rate_ejection",
          ));
      }
      if (
        "failure_percentage_ejection" in A &&
        A.failure_percentage_ejection !== void 0
      ) {
        if (typeof A.failure_percentage_ejection !== "object")
          throw Error(
            "outlier detection config failure_percentage_ejection must be an object",
          );
        (eA1(
          A.failure_percentage_ejection,
          "threshold",
          "failure_percentage_ejection",
        ),
          eA1(
            A.failure_percentage_ejection,
            "enforcement_percentage",
            "failure_percentage_ejection",
          ),
          f3A(
            A.failure_percentage_ejection,
            "minimum_hosts",
            "number",
            "failure_percentage_ejection",
          ),
          f3A(
            A.failure_percentage_ejection,
            "request_volume",
            "number",
            "failure_percentage_ejection",
          ));
      }
      if (!("child_policy" in A) || !Array.isArray(A.child_policy))
        throw Error("outlier detection config child_policy must be an array");
      let Q = (0, Sm5.selectLbConfigFromList)(A.child_policy);
      if (!Q)
        throw Error(
          "outlier detection config child_policy: no valid recognized policy found",
        );
      return new JwA(
        A.interval ? (0, bo.durationToMs)(A.interval) : null,
        A.base_ejection_time
          ? (0, bo.durationToMs)(A.base_ejection_time)
          : null,
        A.max_ejection_time ? (0, bo.durationToMs)(A.max_ejection_time) : null,
        (B = A.max_ejection_percent) !== null && B !== void 0 ? B : null,
        A.success_rate_ejection,
        A.failure_percentage_ejection,
        Q,
      );
    }
  }
  yq2.OutlierDetectionLoadBalancingConfig = JwA;
  class Pq2 extends _m5.BaseSubchannelWrapper {
    constructor(A, B) {
      super(A);
      ((this.mapEntry = B), (this.refCount = 0));
    }
    ref() {
      (this.child.ref(), (this.refCount += 1));
    }
    unref() {
      if ((this.child.unref(), (this.refCount -= 1), this.refCount <= 0)) {
        if (this.mapEntry) {
          let A = this.mapEntry.subchannelWrappers.indexOf(this);
          if (A >= 0) this.mapEntry.subchannelWrappers.splice(A, 1);
        }
      }
    }
    eject() {
      this.setHealthy(!1);
    }
    uneject() {
      this.setHealthy(!0);
    }
    getMapEntry() {
      return this.mapEntry;
    }
    getWrappedSubchannel() {
      return this.child;
    }
  }
  function Oo1() {
    return { success: 0, failure: 0 };
  }
  class jq2 {
    constructor() {
      ((this.activeBucket = Oo1()), (this.inactiveBucket = Oo1()));
    }
    addSuccess() {
      this.activeBucket.success += 1;
    }
    addFailure() {
      this.activeBucket.failure += 1;
    }
    switchBuckets() {
      ((this.inactiveBucket = this.activeBucket), (this.activeBucket = Oo1()));
    }
    getLastSuccesses() {
      return this.inactiveBucket.success;
    }
    getLastFailures() {
      return this.inactiveBucket.failure;
    }
  }
  class Sq2 {
    constructor(A, B) {
      ((this.wrappedPicker = A), (this.countCalls = B));
    }
    pick(A) {
      let B = this.wrappedPicker.pick(A);
      if (B.pickResultType === km5.PickResultType.COMPLETE) {
        let Q = B.subchannel,
          I = Q.getMapEntry();
        if (I) {
          let G = B.onCallEnded;
          if (this.countCalls)
            G = (Z, Y, J) => {
              var X;
              if (Z === Rq2.Status.OK) I.counter.addSuccess();
              else I.counter.addFailure();
              (X = B.onCallEnded) === null ||
                X === void 0 ||
                X.call(B, Z, Y, J);
            };
          return Object.assign(Object.assign({}, B), {
            subchannel: Q.getWrappedSubchannel(),
            onCallEnded: G,
          });
        } else
          return Object.assign(Object.assign({}, B), {
            subchannel: Q.getWrappedSubchannel(),
          });
      } else return B;
    }
  }
  class To1 {
    constructor(A) {
      ((this.entryMap = new Lo1.EndpointMap()),
        (this.latestConfig = null),
        (this.timerStartTime = null),
        (this.childBalancer = new ym5.ChildLoadBalancerHandler(
          (0, Tq2.createChildChannelControlHelper)(A, {
            createSubchannel: (B, Q) => {
              let I = A.createSubchannel(B, Q),
                G = this.entryMap.getForSubchannelAddress(B),
                Z = new Pq2(I, G);
              if (
                (G === null || G === void 0
                  ? void 0
                  : G.currentEjectionTimestamp) !== null
              )
                Z.eject();
              return (
                G === null || G === void 0 || G.subchannelWrappers.push(Z),
                Z
              );
            },
            updateState: (B, Q, I) => {
              if (B === jm5.ConnectivityState.READY)
                A.updateState(B, new Sq2(Q, this.isCountingEnabled()), I);
              else A.updateState(B, Q, I);
            },
          }),
        )),
        (this.ejectionTimer = setInterval(() => {}, 0)),
        clearInterval(this.ejectionTimer));
    }
    isCountingEnabled() {
      return (
        this.latestConfig !== null &&
        (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
          this.latestConfig.getFailurePercentageEjectionConfig() !== null)
      );
    }
    getCurrentEjectionPercent() {
      let A = 0;
      for (let B of this.entryMap.values())
        if (B.currentEjectionTimestamp !== null) A += 1;
      return (A * 100) / this.entryMap.size;
    }
    runSuccessRateCheck(A) {
      if (!this.latestConfig) return;
      let B = this.latestConfig.getSuccessRateEjectionConfig();
      if (!B) return;
      pF("Running success rate check");
      let Q = B.request_volume,
        I = 0,
        G = [];
      for (let [F, C] of this.entryMap.entries()) {
        let V = C.counter.getLastSuccesses(),
          K = C.counter.getLastFailures();
        if (
          (pF(
            "Stats for " +
              (0, Lo1.endpointToString)(F) +
              ": successes=" +
              V +
              " failures=" +
              K +
              " targetRequestVolume=" +
              Q,
          ),
          V + K >= Q)
        )
          ((I += 1), G.push(V / (V + K)));
      }
      if (
        (pF(
          "Found " +
            I +
            " success rate candidates; currentEjectionPercent=" +
            this.getCurrentEjectionPercent() +
            " successRates=[" +
            G +
            "]",
        ),
        I < B.minimum_hosts)
      )
        return;
      let Z = G.reduce((F, C) => F + C) / G.length,
        Y = 0;
      for (let F of G) {
        let C = F - Z;
        Y += C * C;
      }
      let J = Y / G.length,
        X = Math.sqrt(J),
        W = Z - X * (B.stdev_factor / 1000);
      pF("stdev=" + X + " ejectionThreshold=" + W);
      for (let [F, C] of this.entryMap.entries()) {
        if (
          this.getCurrentEjectionPercent() >=
          this.latestConfig.getMaxEjectionPercent()
        )
          break;
        let V = C.counter.getLastSuccesses(),
          K = C.counter.getLastFailures();
        if (V + K < Q) continue;
        let D = V / (V + K);
        if ((pF("Checking candidate " + F + " successRate=" + D), D < W)) {
          let E = Math.random() * 100;
          if (
            (pF(
              "Candidate " +
                F +
                " randomNumber=" +
                E +
                " enforcement_percentage=" +
                B.enforcement_percentage,
            ),
            E < B.enforcement_percentage)
          )
            (pF("Ejecting candidate " + F), this.eject(C, A));
        }
      }
    }
    runFailurePercentageCheck(A) {
      if (!this.latestConfig) return;
      let B = this.latestConfig.getFailurePercentageEjectionConfig();
      if (!B) return;
      pF(
        "Running failure percentage check. threshold=" +
          B.threshold +
          " request volume threshold=" +
          B.request_volume,
      );
      let Q = 0;
      for (let I of this.entryMap.values()) {
        let G = I.counter.getLastSuccesses(),
          Z = I.counter.getLastFailures();
        if (G + Z >= B.request_volume) Q += 1;
      }
      if (Q < B.minimum_hosts) return;
      for (let [I, G] of this.entryMap.entries()) {
        if (
          this.getCurrentEjectionPercent() >=
          this.latestConfig.getMaxEjectionPercent()
        )
          break;
        let Z = G.counter.getLastSuccesses(),
          Y = G.counter.getLastFailures();
        if (
          (pF("Candidate successes=" + Z + " failures=" + Y),
          Z + Y < B.request_volume)
        )
          continue;
        if ((Y * 100) / (Y + Z) > B.threshold) {
          let X = Math.random() * 100;
          if (
            (pF(
              "Candidate " +
                I +
                " randomNumber=" +
                X +
                " enforcement_percentage=" +
                B.enforcement_percentage,
            ),
            X < B.enforcement_percentage)
          )
            (pF("Ejecting candidate " + I), this.eject(G, A));
        }
      }
    }
    eject(A, B) {
      ((A.currentEjectionTimestamp = new Date()),
        (A.ejectionTimeMultiplier += 1));
      for (let Q of A.subchannelWrappers) Q.eject();
    }
    uneject(A) {
      A.currentEjectionTimestamp = null;
      for (let B of A.subchannelWrappers) B.uneject();
    }
    switchAllBuckets() {
      for (let A of this.entryMap.values()) A.counter.switchBuckets();
    }
    startTimer(A) {
      var B, Q;
      ((this.ejectionTimer = setTimeout(() => this.runChecks(), A)),
        (Q = (B = this.ejectionTimer).unref) === null ||
          Q === void 0 ||
          Q.call(B));
    }
    runChecks() {
      let A = new Date();
      if (
        (pF("Ejection timer running"),
        this.switchAllBuckets(),
        !this.latestConfig)
      )
        return;
      ((this.timerStartTime = A),
        this.startTimer(this.latestConfig.getIntervalMs()),
        this.runSuccessRateCheck(A),
        this.runFailurePercentageCheck(A));
      for (let [B, Q] of this.entryMap.entries())
        if (Q.currentEjectionTimestamp === null) {
          if (Q.ejectionTimeMultiplier > 0) Q.ejectionTimeMultiplier -= 1;
        } else {
          let I = this.latestConfig.getBaseEjectionTimeMs(),
            G = this.latestConfig.getMaxEjectionTimeMs(),
            Z = new Date(Q.currentEjectionTimestamp.getTime());
          if (
            (Z.setMilliseconds(
              Z.getMilliseconds() +
                Math.min(I * Q.ejectionTimeMultiplier, Math.max(I, G)),
            ),
            Z < new Date())
          )
            (pF("Unejecting " + B), this.uneject(Q));
        }
    }
    updateAddressList(A, B, Q, I) {
      if (!(B instanceof JwA)) return !1;
      if (
        (pF(
          "Received update with config: " +
            JSON.stringify(B.toJsonObject(), void 0, 2),
        ),
        A.ok)
      ) {
        for (let Z of A.value)
          if (!this.entryMap.has(Z))
            (pF("Adding map entry for " + (0, Lo1.endpointToString)(Z)),
              this.entryMap.set(Z, {
                counter: new jq2(),
                currentEjectionTimestamp: null,
                ejectionTimeMultiplier: 0,
                subchannelWrappers: [],
              }));
        this.entryMap.deleteMissing(A.value);
      }
      let G = B.getChildPolicy();
      if (
        (this.childBalancer.updateAddressList(A, G, Q, I),
        B.getSuccessRateEjectionConfig() ||
          B.getFailurePercentageEjectionConfig())
      )
        if (this.timerStartTime) {
          (pF("Previous timer existed. Replacing timer"),
            clearTimeout(this.ejectionTimer));
          let Z =
            B.getIntervalMs() -
            (new Date().getTime() - this.timerStartTime.getTime());
          this.startTimer(Z);
        } else
          (pF("Starting new timer"),
            (this.timerStartTime = new Date()),
            this.startTimer(B.getIntervalMs()),
            this.switchAllBuckets());
      else {
        (pF("Counting disabled. Cancelling timer."),
          (this.timerStartTime = null),
          clearTimeout(this.ejectionTimer));
        for (let Z of this.entryMap.values())
          (this.uneject(Z), (Z.ejectionTimeMultiplier = 0));
      }
      return ((this.latestConfig = B), !0);
    }
    exitIdle() {
      this.childBalancer.exitIdle();
    }
    resetBackoff() {
      this.childBalancer.resetBackoff();
    }
    destroy() {
      (clearTimeout(this.ejectionTimer), this.childBalancer.destroy());
    }
    getTypeName() {
      return Ro1;
    }
  }
  yq2.OutlierDetectionLoadBalancer = To1;
  function gm5() {
    if (bm5) (0, Tq2.registerLoadBalancerType)(Ro1, To1, JwA);
  }
});
var fq2 = z((vq2) => {
  Object.defineProperty(vq2, "__esModule", { value: !0 });
  vq2.PriorityQueue = void 0;
  var h3A = 0,
    Po1 = (A) => Math.floor(A / 2),
    A11 = (A) => A * 2 + 1,
    XwA = (A) => A * 2 + 2;
  class xq2 {
    constructor(A = (B, Q) => B > Q) {
      ((this.comparator = A), (this.heap = []));
    }
    size() {
      return this.heap.length;
    }
    isEmpty() {
      return this.size() == 0;
    }
    peek() {
      return this.heap[h3A];
    }
    push(...A) {
      return (
        A.forEach((B) => {
          (this.heap.push(B), this.siftUp());
        }),
        this.size()
      );
    }
    pop() {
      let A = this.peek(),
        B = this.size() - 1;
      if (B > h3A) this.swap(h3A, B);
      return (this.heap.pop(), this.siftDown(), A);
    }
    replace(A) {
      let B = this.peek();
      return ((this.heap[h3A] = A), this.siftDown(), B);
    }
    greater(A, B) {
      return this.comparator(this.heap[A], this.heap[B]);
    }
    swap(A, B) {
      [this.heap[A], this.heap[B]] = [this.heap[B], this.heap[A]];
    }
    siftUp() {
      let A = this.size() - 1;
      while (A > h3A && this.greater(A, Po1(A)))
        (this.swap(A, Po1(A)), (A = Po1(A)));
    }
    siftDown() {
      let A = h3A;
      while (
        (A11(A) < this.size() && this.greater(A11(A), A)) ||
        (XwA(A) < this.size() && this.greater(XwA(A), A))
      ) {
        let B =
          XwA(A) < this.size() && this.greater(XwA(A), A11(A))
            ? XwA(A)
            : A11(A);
        (this.swap(A, B), (A = B));
      }
    }
  }
  vq2.PriorityQueue = xq2;
});
var iq2 = z((pq2) => {
  Object.defineProperty(pq2, "__esModule", { value: !0 });
  pq2.WeightedRoundRobinLoadBalancingConfig = void 0;
  pq2.setup = tm5;
  var lF = WE(),
    dm5 = u8(),
    fw = BwA(),
    uq2 = Oc(),
    cm5 = GwA(),
    pm5 = q7(),
    mq2 = cA1(),
    g3A = Ab(),
    lm5 = fq2(),
    hq2 = Rz(),
    im5 = "weighted_round_robin";
  function jo1(A) {
    pm5.trace(dm5.LogVerbosity.DEBUG, im5, A);
  }
  var So1 = "weighted_round_robin",
    nm5 = 1e4,
    am5 = 1e4,
    sm5 = 180000,
    rm5 = 1000,
    om5 = 1;
  function gq2(A, B, Q) {
    if (B in A && A[B] !== void 0 && typeof A[B] !== Q)
      throw Error(
        `weighted round robin config ${B} parse error: expected ${Q}, got ${typeof A[B]}`,
      );
  }
  function B11(A, B) {
    if (B in A && A[B] !== void 0 && A[B] !== null) {
      let Q;
      if ((0, fw.isDuration)(A[B])) Q = A[B];
      else if ((0, fw.isDurationMessage)(A[B]))
        Q = (0, fw.durationMessageToDuration)(A[B]);
      else if (typeof A[B] === "string") {
        let I = (0, fw.parseDuration)(A[B]);
        if (!I)
          throw Error(
            `weighted round robin config ${B}: failed to parse duration string ${A[B]}`,
          );
        Q = I;
      } else
        throw Error(
          `weighted round robin config ${B}: expected duration, got ${typeof A[B]}`,
        );
      return (0, fw.durationToMs)(Q);
    }
    return null;
  }
  class WwA {
    constructor(A, B, Q, I, G, Z) {
      ((this.enableOobLoadReport = A !== null && A !== void 0 ? A : !1),
        (this.oobLoadReportingPeriodMs = B !== null && B !== void 0 ? B : nm5),
        (this.blackoutPeriodMs = Q !== null && Q !== void 0 ? Q : am5),
        (this.weightExpirationPeriodMs = I !== null && I !== void 0 ? I : sm5),
        (this.weightUpdatePeriodMs = Math.max(
          G !== null && G !== void 0 ? G : rm5,
          100,
        )),
        (this.errorUtilizationPenalty = Z !== null && Z !== void 0 ? Z : om5));
    }
    getLoadBalancerName() {
      return So1;
    }
    toJsonObject() {
      return {
        enable_oob_load_report: this.enableOobLoadReport,
        oob_load_reporting_period: (0, fw.durationToString)(
          (0, fw.msToDuration)(this.oobLoadReportingPeriodMs),
        ),
        blackout_period: (0, fw.durationToString)(
          (0, fw.msToDuration)(this.blackoutPeriodMs),
        ),
        weight_expiration_period: (0, fw.durationToString)(
          (0, fw.msToDuration)(this.weightExpirationPeriodMs),
        ),
        weight_update_period: (0, fw.durationToString)(
          (0, fw.msToDuration)(this.weightUpdatePeriodMs),
        ),
        error_utilization_penalty: this.errorUtilizationPenalty,
      };
    }
    static createFromJson(A) {
      if (
        (gq2(A, "enable_oob_load_report", "boolean"),
        gq2(A, "error_utilization_penalty", "number"),
        A.error_utilization_penalty < 0)
      )
        throw Error(
          "weighted round robin config error_utilization_penalty < 0",
        );
      return new WwA(
        A.enable_oob_load_report,
        B11(A, "oob_load_reporting_period"),
        B11(A, "blackout_period"),
        B11(A, "weight_expiration_period"),
        B11(A, "weight_update_period"),
        A.error_utilization_penalty,
      );
    }
    getEnableOobLoadReport() {
      return this.enableOobLoadReport;
    }
    getOobLoadReportingPeriodMs() {
      return this.oobLoadReportingPeriodMs;
    }
    getBlackoutPeriodMs() {
      return this.blackoutPeriodMs;
    }
    getWeightExpirationPeriodMs() {
      return this.weightExpirationPeriodMs;
    }
    getWeightUpdatePeriodMs() {
      return this.weightUpdatePeriodMs;
    }
    getErrorUtilizationPenalty() {
      return this.errorUtilizationPenalty;
    }
  }
  pq2.WeightedRoundRobinLoadBalancingConfig = WwA;
  class dq2 {
    constructor(A, B) {
      ((this.metricsHandler = B),
        (this.queue = new lm5.PriorityQueue(
          (G, Z) => G.deadline < Z.deadline,
        )));
      let Q = A.filter((G) => G.weight > 0),
        I;
      if (Q.length < 2) I = 1;
      else {
        let G = 0;
        for (let { weight: Z } of Q) G += Z;
        I = G / Q.length;
      }
      for (let G of A) {
        let Z = G.weight > 0 ? 1 / G.weight : I;
        this.queue.push({
          endpointName: G.endpointName,
          picker: G.picker,
          period: Z,
          deadline: Math.random() * Z,
        });
      }
    }
    pick(A) {
      let B = this.queue.pop();
      this.queue.push(
        Object.assign(Object.assign({}, B), {
          deadline: B.deadline + B.period,
        }),
      );
      let Q = B.picker.pick(A);
      if (Q.pickResultType === g3A.PickResultType.COMPLETE)
        if (this.metricsHandler)
          return Object.assign(Object.assign({}, Q), {
            onCallEnded: (0, mq2.createMetricsReader)(
              (I) => this.metricsHandler(I, B.endpointName),
              Q.onCallEnded,
            ),
          });
        else {
          let I = Q.subchannel;
          return Object.assign(Object.assign({}, Q), {
            subchannel: I.getWrappedSubchannel(),
          });
        }
      else return Q;
    }
  }
  class cq2 {
    constructor(A) {
      ((this.channelControlHelper = A),
        (this.latestConfig = null),
        (this.children = new Map()),
        (this.currentState = lF.ConnectivityState.IDLE),
        (this.updatesPaused = !1),
        (this.lastError = null),
        (this.weightUpdateTimer = null));
    }
    countChildrenWithState(A) {
      let B = 0;
      for (let Q of this.children.values())
        if (Q.child.getConnectivityState() === A) B += 1;
      return B;
    }
    updateWeight(A, B) {
      var Q, I;
      let { rps_fractional: G, application_utilization: Z } = B;
      if (Z > 0 && G > 0)
        Z +=
          (B.eps / G) *
          ((I =
            (Q = this.latestConfig) === null || Q === void 0
              ? void 0
              : Q.getErrorUtilizationPenalty()) !== null && I !== void 0
            ? I
            : 0);
      let Y = Z === 0 ? 0 : G / Z;
      if (Y === 0) return;
      let J = new Date();
      if (A.nonEmptySince === null) A.nonEmptySince = J;
      ((A.lastUpdated = J), (A.weight = Y));
    }
    getWeight(A) {
      if (!this.latestConfig) return 0;
      let B = new Date().getTime();
      if (
        B - A.lastUpdated.getTime() >=
        this.latestConfig.getWeightExpirationPeriodMs()
      )
        return ((A.nonEmptySince = null), 0);
      let Q = this.latestConfig.getBlackoutPeriodMs();
      if (
        Q > 0 &&
        (A.nonEmptySince === null || B - A.nonEmptySince.getTime() < Q)
      )
        return 0;
      return A.weight;
    }
    calculateAndUpdateState() {
      if (this.updatesPaused || !this.latestConfig) return;
      if (this.countChildrenWithState(lF.ConnectivityState.READY) > 0) {
        let A = [];
        for (let [Q, I] of this.children) {
          if (I.child.getConnectivityState() !== lF.ConnectivityState.READY)
            continue;
          A.push({
            endpointName: Q,
            picker: I.child.getPicker(),
            weight: this.getWeight(I),
          });
        }
        jo1(
          "Created picker with weights: " +
            A.map((Q) => Q.endpointName + ":" + Q.weight).join(","),
        );
        let B;
        if (!this.latestConfig.getEnableOobLoadReport())
          B = (Q, I) => {
            let G = this.children.get(I);
            if (G) this.updateWeight(G, Q);
          };
        else B = null;
        this.updateState(lF.ConnectivityState.READY, new dq2(A, B), null);
      } else if (
        this.countChildrenWithState(lF.ConnectivityState.CONNECTING) > 0
      )
        this.updateState(
          lF.ConnectivityState.CONNECTING,
          new g3A.QueuePicker(this),
          null,
        );
      else if (
        this.countChildrenWithState(lF.ConnectivityState.TRANSIENT_FAILURE) > 0
      ) {
        let A = `weighted_round_robin: No connection established. Last error: ${this.lastError}`;
        this.updateState(
          lF.ConnectivityState.TRANSIENT_FAILURE,
          new g3A.UnavailablePicker({ details: A }),
          A,
        );
      } else
        this.updateState(
          lF.ConnectivityState.IDLE,
          new g3A.QueuePicker(this),
          null,
        );
      for (let { child: A } of this.children.values())
        if (A.getConnectivityState() === lF.ConnectivityState.IDLE)
          A.exitIdle();
    }
    updateState(A, B, Q) {
      (jo1(
        lF.ConnectivityState[this.currentState] +
          " -> " +
          lF.ConnectivityState[A],
      ),
        (this.currentState = A),
        this.channelControlHelper.updateState(A, B, Q));
    }
    updateAddressList(A, B, Q, I) {
      var G, Z;
      if (!(B instanceof WwA)) return !1;
      if (!A.ok) {
        if (this.children.size === 0)
          this.updateState(
            lF.ConnectivityState.TRANSIENT_FAILURE,
            new g3A.UnavailablePicker(A.error),
            A.error.details,
          );
        return !0;
      }
      if (A.value.length === 0) {
        let X = `No addresses resolved. Resolution note: ${I}`;
        return (
          this.updateState(
            lF.ConnectivityState.TRANSIENT_FAILURE,
            new g3A.UnavailablePicker({ details: X }),
            X,
          ),
          !1
        );
      }
      jo1("Connect to endpoint list " + A.value.map(hq2.endpointToString));
      let Y = new Date(),
        J = new Set();
      ((this.updatesPaused = !0), (this.latestConfig = B));
      for (let X of A.value) {
        let W = (0, hq2.endpointToString)(X);
        J.add(W);
        let F = this.children.get(W);
        if (!F)
          ((F = {
            child: new cm5.LeafLoadBalancer(
              X,
              (0, uq2.createChildChannelControlHelper)(
                this.channelControlHelper,
                {
                  updateState: (C, V, K) => {
                    if (
                      this.currentState === lF.ConnectivityState.READY &&
                      C !== lF.ConnectivityState.READY
                    )
                      this.channelControlHelper.requestReresolution();
                    if (C === lF.ConnectivityState.READY)
                      F.nonEmptySince = null;
                    if (K) this.lastError = K;
                    this.calculateAndUpdateState();
                  },
                  createSubchannel: (C, V) => {
                    let K = this.channelControlHelper.createSubchannel(C, V);
                    if (
                      F === null || F === void 0 ? void 0 : F.oobMetricsListener
                    )
                      return new mq2.OrcaOobMetricsSubchannelWrapper(
                        K,
                        F.oobMetricsListener,
                        this.latestConfig.getOobLoadReportingPeriodMs(),
                      );
                    else return K;
                  },
                },
              ),
              Q,
              I,
            ),
            lastUpdated: Y,
            nonEmptySince: null,
            weight: 0,
            oobMetricsListener: null,
          }),
            this.children.set(W, F));
        if (B.getEnableOobLoadReport())
          F.oobMetricsListener = (C) => {
            this.updateWeight(F, C);
          };
        else F.oobMetricsListener = null;
      }
      for (let [X, W] of this.children)
        if (J.has(X)) W.child.startConnecting();
        else (W.child.destroy(), this.children.delete(X));
      if (
        ((this.updatesPaused = !1),
        this.calculateAndUpdateState(),
        this.weightUpdateTimer)
      )
        clearInterval(this.weightUpdateTimer);
      return (
        (this.weightUpdateTimer =
          (Z = (G = setInterval(() => {
            if (this.currentState === lF.ConnectivityState.READY)
              this.calculateAndUpdateState();
          }, B.getWeightUpdatePeriodMs())).unref) === null || Z === void 0
            ? void 0
            : Z.call(G)),
        !0
      );
    }
    exitIdle() {}
    resetBackoff() {}
    destroy() {
      for (let A of this.children.values()) A.child.destroy();
      if ((this.children.clear(), this.weightUpdateTimer))
        clearInterval(this.weightUpdateTimer);
    }
    getTypeName() {
      return So1;
    }
  }
  function tm5() {
    (0, uq2.registerLoadBalancerType)(So1, cq2, WwA);
  }
});
var FwA = z((N3) => {
  Object.defineProperty(N3, "__esModule", { value: !0 });
  N3.experimental =
    N3.ServerMetricRecorder =
    N3.ServerInterceptingCall =
    N3.ResponderBuilder =
    N3.ServerListenerBuilder =
    N3.addAdminServicesToServer =
    N3.getChannelzHandlers =
    N3.getChannelzServiceDefinition =
    N3.InterceptorConfigurationError =
    N3.InterceptingCall =
    N3.RequesterBuilder =
    N3.ListenerBuilder =
    N3.StatusBuilder =
    N3.getClientChannel =
    N3.ServerCredentials =
    N3.Server =
    N3.setLogVerbosity =
    N3.setLogger =
    N3.load =
    N3.loadObject =
    N3.CallCredentials =
    N3.ChannelCredentials =
    N3.waitForClientReady =
    N3.closeClient =
    N3.Channel =
    N3.makeGenericClientConstructor =
    N3.makeClientConstructor =
    N3.loadPackageDefinition =
    N3.Client =
    N3.compressionAlgorithms =
    N3.propagate =
    N3.connectivityState =
    N3.status =
    N3.logVerbosity =
    N3.Metadata =
    N3.credentials =
      void 0;
  var Q11 = geA();
  Object.defineProperty(N3, "CallCredentials", {
    enumerable: !0,
    get: function () {
      return Q11.CallCredentials;
    },
  });
  var Ad5 = js1();
  Object.defineProperty(N3, "Channel", {
    enumerable: !0,
    get: function () {
      return Ad5.ChannelImplementation;
    },
  });
  var Bd5 = Tr1();
  Object.defineProperty(N3, "compressionAlgorithms", {
    enumerable: !0,
    get: function () {
      return Bd5.CompressionAlgorithms;
    },
  });
  var Qd5 = WE();
  Object.defineProperty(N3, "connectivityState", {
    enumerable: !0,
    get: function () {
      return Qd5.ConnectivityState;
    },
  });
  var I11 = C3A();
  Object.defineProperty(N3, "ChannelCredentials", {
    enumerable: !0,
    get: function () {
      return I11.ChannelCredentials;
    },
  });
  var nq2 = Ps1();
  Object.defineProperty(N3, "Client", {
    enumerable: !0,
    get: function () {
      return nq2.Client;
    },
  });
  var yo1 = u8();
  Object.defineProperty(N3, "logVerbosity", {
    enumerable: !0,
    get: function () {
      return yo1.LogVerbosity;
    },
  });
  Object.defineProperty(N3, "status", {
    enumerable: !0,
    get: function () {
      return yo1.Status;
    },
  });
  Object.defineProperty(N3, "propagate", {
    enumerable: !0,
    get: function () {
      return yo1.Propagate;
    },
  });
  var aq2 = q7(),
    ko1 = oeA();
  Object.defineProperty(N3, "loadPackageDefinition", {
    enumerable: !0,
    get: function () {
      return ko1.loadPackageDefinition;
    },
  });
  Object.defineProperty(N3, "makeClientConstructor", {
    enumerable: !0,
    get: function () {
      return ko1.makeClientConstructor;
    },
  });
  Object.defineProperty(N3, "makeGenericClientConstructor", {
    enumerable: !0,
    get: function () {
      return ko1.makeClientConstructor;
    },
  });
  var Id5 = mF();
  Object.defineProperty(N3, "Metadata", {
    enumerable: !0,
    get: function () {
      return Id5.Metadata;
    },
  });
  var Gd5 = u$2();
  Object.defineProperty(N3, "Server", {
    enumerable: !0,
    get: function () {
      return Gd5.Server;
    },
  });
  var Zd5 = mA1();
  Object.defineProperty(N3, "ServerCredentials", {
    enumerable: !0,
    get: function () {
      return Zd5.ServerCredentials;
    },
  });
  var Yd5 = p$2();
  Object.defineProperty(N3, "StatusBuilder", {
    enumerable: !0,
    get: function () {
      return Yd5.StatusBuilder;
    },
  });
  N3.credentials = {
    combineChannelCredentials: (A, ...B) => {
      return B.reduce((Q, I) => Q.compose(I), A);
    },
    combineCallCredentials: (A, ...B) => {
      return B.reduce((Q, I) => Q.compose(I), A);
    },
    createInsecure: I11.ChannelCredentials.createInsecure,
    createSsl: I11.ChannelCredentials.createSsl,
    createFromSecureContext: I11.ChannelCredentials.createFromSecureContext,
    createFromMetadataGenerator:
      Q11.CallCredentials.createFromMetadataGenerator,
    createFromGoogleCredential: Q11.CallCredentials.createFromGoogleCredential,
    createEmpty: Q11.CallCredentials.createEmpty,
  };
  var Jd5 = (A) => A.close();
  N3.closeClient = Jd5;
  var Xd5 = (A, B, Q) => A.waitForReady(B, Q);
  N3.waitForClientReady = Xd5;
  var Wd5 = (A, B) => {
    throw Error(
      "Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead",
    );
  };
  N3.loadObject = Wd5;
  var Fd5 = (A, B, Q) => {
    throw Error(
      "Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead",
    );
  };
  N3.load = Fd5;
  var Cd5 = (A) => {
    aq2.setLogger(A);
  };
  N3.setLogger = Cd5;
  var Vd5 = (A) => {
    aq2.setLoggerVerbosity(A);
  };
  N3.setLogVerbosity = Vd5;
  var Kd5 = (A) => {
    return nq2.Client.prototype.getChannel.call(A);
  };
  N3.getClientChannel = Kd5;
  var G11 = Rs1();
  Object.defineProperty(N3, "ListenerBuilder", {
    enumerable: !0,
    get: function () {
      return G11.ListenerBuilder;
    },
  });
  Object.defineProperty(N3, "RequesterBuilder", {
    enumerable: !0,
    get: function () {
      return G11.RequesterBuilder;
    },
  });
  Object.defineProperty(N3, "InterceptingCall", {
    enumerable: !0,
    get: function () {
      return G11.InterceptingCall;
    },
  });
  Object.defineProperty(N3, "InterceptorConfigurationError", {
    enumerable: !0,
    get: function () {
      return G11.InterceptorConfigurationError;
    },
  });
  var sq2 = kc();
  Object.defineProperty(N3, "getChannelzServiceDefinition", {
    enumerable: !0,
    get: function () {
      return sq2.getChannelzServiceDefinition;
    },
  });
  Object.defineProperty(N3, "getChannelzHandlers", {
    enumerable: !0,
    get: function () {
      return sq2.getChannelzHandlers;
    },
  });
  var Dd5 = seA();
  Object.defineProperty(N3, "addAdminServicesToServer", {
    enumerable: !0,
    get: function () {
      return Dd5.addAdminServicesToServer;
    },
  });
  var _o1 = Xo1();
  Object.defineProperty(N3, "ServerListenerBuilder", {
    enumerable: !0,
    get: function () {
      return _o1.ServerListenerBuilder;
    },
  });
  Object.defineProperty(N3, "ResponderBuilder", {
    enumerable: !0,
    get: function () {
      return _o1.ResponderBuilder;
    },
  });
  Object.defineProperty(N3, "ServerInterceptingCall", {
    enumerable: !0,
    get: function () {
      return _o1.ServerInterceptingCall;
    },
  });
  var Ed5 = cA1();
  Object.defineProperty(N3, "ServerMetricRecorder", {
    enumerable: !0,
    get: function () {
      return Ed5.ServerMetricRecorder;
    },
  });
  var Hd5 = Ho1();
  N3.experimental = Hd5;
  var zd5 = hr1(),
    Ud5 = Cq2(),
    wd5 = Uq2(),
    $d5 = GwA(),
    qd5 = Oq2(),
    Nd5 = _q2(),
    Ld5 = iq2(),
    Md5 = kc();
  (() => {
    (zd5.setup(),
      Ud5.setup(),
      wd5.setup(),
      $d5.setup(),
      qd5.setup(),
      Nd5.setup(),
      Ld5.setup(),
      Md5.setup());
  })();
});
var eq2 = z((oq2) => {
  Object.defineProperty(oq2, "__esModule", { value: !0 });
  oq2.createServiceClientConstructor = void 0;
  var _d5 = FwA();
  function xd5(A, B) {
    let Q = {
      export: {
        path: A,
        requestStream: !1,
        responseStream: !1,
        requestSerialize: (I) => {
          return I;
        },
        requestDeserialize: (I) => {
          return I;
        },
        responseSerialize: (I) => {
          return I;
        },
        responseDeserialize: (I) => {
          return I;
        },
      },
    };
    return _d5.makeGenericClientConstructor(Q, B);
  }
  oq2.createServiceClientConstructor = xd5;
});
var CwA = z((AN2) => {
  Object.defineProperty(AN2, "__esModule", { value: !0 });
  AN2.createOtlpGrpcExporterTransport =
    AN2.GrpcExporterTransport =
    AN2.createEmptyMetadata =
    AN2.createSslCredentials =
    AN2.createInsecureCredentials =
      void 0;
  var vd5 = 0,
    bd5 = 2;
  function fd5(A) {
    return A === "gzip" ? bd5 : vd5;
  }
  function hd5() {
    let { credentials: A } = FwA();
    return A.createInsecure();
  }
  AN2.createInsecureCredentials = hd5;
  function gd5(A, B, Q) {
    let { credentials: I } = FwA();
    return I.createSsl(A, B, Q);
  }
  AN2.createSslCredentials = gd5;
  function ud5() {
    let { Metadata: A } = FwA();
    return new A();
  }
  AN2.createEmptyMetadata = ud5;
  class xo1 {
    _parameters;
    _client;
    _metadata;
    constructor(A) {
      this._parameters = A;
    }
    shutdown() {
      this._client?.close();
    }
    send(A, B) {
      let Q = Buffer.from(A);
      if (this._client == null) {
        let { createServiceClientConstructor: I } = eq2();
        try {
          this._metadata = this._parameters.metadata();
        } catch (Z) {
          return Promise.resolve({ status: "failure", error: Z });
        }
        let G = I(this._parameters.grpcPath, this._parameters.grpcName);
        try {
          this._client = new G(
            this._parameters.address,
            this._parameters.credentials(),
            {
              "grpc.default_compression_algorithm": fd5(
                this._parameters.compression,
              ),
            },
          );
        } catch (Z) {
          return Promise.resolve({ status: "failure", error: Z });
        }
      }
      return new Promise((I) => {
        let G = Date.now() + B;
        if (this._metadata == null)
          return I({ error: Error("metadata was null"), status: "failure" });
        this._client.export(Q, this._metadata, { deadline: G }, (Z, Y) => {
          if (Z) I({ status: "failure", error: Z });
          else I({ data: Y, status: "success" });
        });
      });
    }
  }
  AN2.GrpcExporterTransport = xo1;
  function md5(A) {
    return new xo1(A);
  }
  AN2.createOtlpGrpcExporterTransport = md5;
});
var GN2 = z((QN2) => {
  Object.defineProperty(QN2, "__esModule", { value: !0 });
  QN2.VERSION = void 0;
  QN2.VERSION = "0.204.0";
});
var CN2 = z((WN2) => {
  Object.defineProperty(WN2, "__esModule", { value: !0 });
  WN2.getOtlpGrpcDefaultConfiguration =
    WN2.mergeOtlpGrpcConfigurationWithDefaults =
    WN2.validateAndNormalizeUrl =
      void 0;
  var JN2 = hS(),
    VwA = CwA(),
    id5 = GN2(),
    nd5 = EA("url"),
    ZN2 = o2();
  function XN2(A) {
    if (((A = A.trim()), !A.match(/^([\w]{1,8}):\/\//))) A = `https://${A}`;
    let Q = new nd5.URL(A);
    if (Q.protocol === "unix:") return A;
    if (Q.pathname && Q.pathname !== "/")
      ZN2.diag.warn(
        "URL path should not be set when using grpc, the path part of the URL will be ignored.",
      );
    if (Q.protocol !== "" && !Q.protocol?.match(/^(http)s?:$/))
      ZN2.diag.warn("URL protocol should be http(s)://. Using http://.");
    return Q.host;
  }
  WN2.validateAndNormalizeUrl = XN2;
  function YN2(A, B) {
    for (let [Q, I] of Object.entries(B.getMap()))
      if (A.get(Q).length < 1) A.set(Q, I);
  }
  function ad5(A, B, Q) {
    let I = A.url ?? B.url ?? Q.url;
    return {
      ...(0, JN2.mergeOtlpSharedConfigurationWithDefaults)(A, B, Q),
      metadata: () => {
        let G = Q.metadata();
        return (
          YN2(G, A.metadata?.().clone() ?? (0, VwA.createEmptyMetadata)()),
          YN2(G, B.metadata?.() ?? (0, VwA.createEmptyMetadata)()),
          G
        );
      },
      url: XN2(I),
      credentials: A.credentials ?? B.credentials?.(I) ?? Q.credentials(I),
    };
  }
  WN2.mergeOtlpGrpcConfigurationWithDefaults = ad5;
  function sd5() {
    return {
      ...(0, JN2.getSharedConfigurationDefaults)(),
      metadata: () => {
        let A = (0, VwA.createEmptyMetadata)();
        return (
          A.set("User-Agent", `OTel-OTLP-Exporter-JavaScript/${id5.VERSION}`),
          A
        );
      },
      url: "http://localhost:4317",
      credentials: (A) => {
        if (A.startsWith("http://"))
          return () => (0, VwA.createInsecureCredentials)();
        else return () => (0, VwA.createSslCredentials)();
      },
    };
  }
  WN2.getOtlpGrpcDefaultConfiguration = sd5;
});
var UN2 = z((HN2) => {
  Object.defineProperty(HN2, "__esModule", { value: !0 });
  HN2.getOtlpGrpcConfigurationFromEnv = void 0;
  var VN2 = M6(),
    KwA = CwA(),
    td5 = qc(),
    ed5 = EA("fs"),
    Ac5 = EA("path"),
    DN2 = o2();
  function vo1(A, B) {
    if (A != null && A !== "") return A;
    if (B != null && B !== "") return B;
    return;
  }
  function Bc5(A) {
    let B = process.env[`OTEL_EXPORTER_OTLP_${A}_HEADERS`]?.trim(),
      Q = process.env.OTEL_EXPORTER_OTLP_HEADERS?.trim(),
      I = (0, VN2.parseKeyPairsIntoRecord)(B),
      G = (0, VN2.parseKeyPairsIntoRecord)(Q);
    if (Object.keys(I).length === 0 && Object.keys(G).length === 0) return;
    let Z = Object.assign({}, G, I),
      Y = (0, KwA.createEmptyMetadata)();
    for (let [J, X] of Object.entries(Z)) Y.set(J, X);
    return Y;
  }
  function Qc5(A) {
    let B = Bc5(A);
    if (B == null) return;
    return () => B;
  }
  function Ic5(A) {
    let B = process.env[`OTEL_EXPORTER_OTLP_${A}_ENDPOINT`]?.trim(),
      Q = process.env.OTEL_EXPORTER_OTLP_ENDPOINT?.trim();
    return vo1(B, Q);
  }
  function Gc5(A) {
    let B = process.env[`OTEL_EXPORTER_OTLP_${A}_INSECURE`]
        ?.toLowerCase()
        .trim(),
      Q = process.env.OTEL_EXPORTER_OTLP_INSECURE?.toLowerCase().trim();
    return vo1(B, Q) === "true";
  }
  function bo1(A, B, Q) {
    let I = process.env[A]?.trim(),
      G = process.env[B]?.trim(),
      Z = vo1(I, G);
    if (Z != null)
      try {
        return ed5.readFileSync(Ac5.resolve(process.cwd(), Z));
      } catch {
        DN2.diag.warn(Q);
        return;
      }
    else return;
  }
  function Zc5(A) {
    return bo1(
      `OTEL_EXPORTER_OTLP_${A}_CLIENT_CERTIFICATE`,
      "OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE",
      "Failed to read client certificate chain file",
    );
  }
  function Yc5(A) {
    return bo1(
      `OTEL_EXPORTER_OTLP_${A}_CLIENT_KEY`,
      "OTEL_EXPORTER_OTLP_CLIENT_KEY",
      "Failed to read client certificate private key file",
    );
  }
  function KN2(A) {
    return bo1(
      `OTEL_EXPORTER_OTLP_${A}_CERTIFICATE`,
      "OTEL_EXPORTER_OTLP_CERTIFICATE",
      "Failed to read root certificate file",
    );
  }
  function EN2(A) {
    let B = Yc5(A),
      Q = Zc5(A),
      I = KN2(A),
      G = B != null && Q != null;
    if (I != null && !G)
      return (
        DN2.diag.warn(
          "Client key and certificate must both be provided, but one was missing - attempting to create credentials from just the root certificate",
        ),
        (0, KwA.createSslCredentials)(KN2(A))
      );
    return (0, KwA.createSslCredentials)(I, B, Q);
  }
  function Jc5(A) {
    if (Gc5(A)) return (0, KwA.createInsecureCredentials)();
    return EN2(A);
  }
  function Xc5(A) {
    return {
      ...(0, td5.getSharedConfigurationFromEnvironment)(A),
      metadata: Qc5(A),
      url: Ic5(A),
      credentials: (B) => {
        if (B.startsWith("http://"))
          return () => {
            return (0, KwA.createInsecureCredentials)();
          };
        else if (B.startsWith("https://"))
          return () => {
            return EN2(A);
          };
        return () => {
          return Jc5(A);
        };
      },
    };
  }
  HN2.getOtlpGrpcConfigurationFromEnv = Xc5;
});
var NN2 = z(($N2) => {
  Object.defineProperty($N2, "__esModule", { value: !0 });
  $N2.convertLegacyOtlpGrpcOptions = void 0;
  var Wc5 = o2(),
    wN2 = CN2(),
    Fc5 = CwA(),
    Cc5 = UN2();
  function Vc5(A, B) {
    if (A.headers) Wc5.diag.warn("Headers cannot be set when using grpc");
    let Q = A.credentials;
    return (0, wN2.mergeOtlpGrpcConfigurationWithDefaults)(
      {
        url: A.url,
        metadata: () => {
          return A.metadata ?? (0, Fc5.createEmptyMetadata)();
        },
        compression: A.compression,
        timeoutMillis: A.timeoutMillis,
        concurrencyLimit: A.concurrencyLimit,
        credentials: Q != null ? () => Q : void 0,
      },
      (0, Cc5.getOtlpGrpcConfigurationFromEnv)(B),
      (0, wN2.getOtlpGrpcDefaultConfiguration)(),
    );
  }
  $N2.convertLegacyOtlpGrpcOptions = Vc5;
});
var ON2 = z((LN2) => {
  Object.defineProperty(LN2, "__esModule", { value: !0 });
  LN2.createOtlpGrpcExportDelegate = void 0;
  var Kc5 = hS(),
    Dc5 = CwA();
  function Ec5(A, B, Q, I) {
    return (0, Kc5.createOtlpNetworkExportDelegate)(
      A,
      B,
      (0, Dc5.createOtlpGrpcExporterTransport)({
        address: A.url,
        compression: A.compression,
        credentials: A.credentials,
        metadata: A.metadata,
        grpcName: Q,
        grpcPath: I,
      }),
    );
  }
  LN2.createOtlpGrpcExportDelegate = Ec5;
});
var Y11 = z((Z11) => {
  Object.defineProperty(Z11, "__esModule", { value: !0 });
  Z11.createOtlpGrpcExportDelegate = Z11.convertLegacyOtlpGrpcOptions = void 0;
  var Hc5 = NN2();
  Object.defineProperty(Z11, "convertLegacyOtlpGrpcOptions", {
    enumerable: !0,
    get: function () {
      return Hc5.convertLegacyOtlpGrpcOptions;
    },
  });
  var zc5 = ON2();
  Object.defineProperty(Z11, "createOtlpGrpcExportDelegate", {
    enumerable: !0,
    get: function () {
      return zc5.createOtlpGrpcExportDelegate;
    },
  });
});
var SN2 = z((PN2) => {
  Object.defineProperty(PN2, "__esModule", { value: !0 });
  PN2.OTLPMetricExporter = void 0;
  var wc5 = xeA(),
    RN2 = Y11(),
    $c5 = mS();
  class TN2 extends wc5.OTLPMetricExporterBase {
    constructor(A) {
      super(
        (0, RN2.createOtlpGrpcExportDelegate)(
          (0, RN2.convertLegacyOtlpGrpcOptions)(A ?? {}, "METRICS"),
          $c5.ProtobufMetricsSerializer,
          "MetricsExportService",
          "/opentelemetry.proto.collector.metrics.v1.MetricsService/Export",
        ),
        A,
      );
    }
  }
  PN2.OTLPMetricExporter = TN2;
});
var yN2 = z((fo1) => {
  Object.defineProperty(fo1, "__esModule", { value: !0 });
  fo1.OTLPMetricExporter = void 0;
  var qc5 = SN2();
  Object.defineProperty(fo1, "OTLPMetricExporter", {
    enumerable: !0,
    get: function () {
      return qc5.OTLPMetricExporter;
    },
  });
});
var uo1 = z((vN2) => {
  Object.defineProperty(vN2, "__esModule", { value: !0 });
  vN2.PrometheusSerializer = void 0;
  var Lc5 = o2(),
    fo = Ec(),
    kN2 = M6();
  function X11(A) {
    return A.replace(/\\/g, "\\\\").replace(/\n/g, "\\n");
  }
  function _N2(A = "") {
    if (typeof A !== "string") A = JSON.stringify(A);
    return X11(A).replace(/"/g, '\\"');
  }
  var Mc5 = /[^a-z0-9_]/gi,
    Oc5 = /_{2,}/g;
  function go1(A) {
    return A.replace(Mc5, "_").replace(Oc5, "_");
  }
  function ho1(A, B) {
    if (
      !A.endsWith("_total") &&
      B.dataPointType === fo.DataPointType.SUM &&
      B.isMonotonic
    )
      A = A + "_total";
    return A;
  }
  function Rc5(A) {
    if (A === 1 / 0) return "+Inf";
    else if (A === -1 / 0) return "-Inf";
    else return `${A}`;
  }
  function Tc5(A) {
    switch (A.dataPointType) {
      case fo.DataPointType.SUM:
        if (A.isMonotonic) return "counter";
        return "gauge";
      case fo.DataPointType.GAUGE:
        return "gauge";
      case fo.DataPointType.HISTOGRAM:
        return "histogram";
      default:
        return "untyped";
    }
  }
  function J11(A, B, Q, I, G) {
    let Z = !1,
      Y = "";
    for (let [J, X] of Object.entries(B)) {
      let W = go1(J);
      ((Z = !0), (Y += `${Y.length > 0 ? "," : ""}${W}="${_N2(X)}"`));
    }
    if (G)
      for (let [J, X] of Object.entries(G)) {
        let W = go1(J);
        ((Z = !0), (Y += `${Y.length > 0 ? "," : ""}${W}="${_N2(X)}"`));
      }
    if (Z) A += `{${Y}}`;
    return `${A} ${Rc5(Q)}${I !== void 0 ? " " + String(I) : ""}
`;
  }
  var Pc5 = "# no registered metrics";
  class xN2 {
    _prefix;
    _appendTimestamp;
    _additionalAttributes;
    _withResourceConstantLabels;
    constructor(A, B = !1, Q) {
      if (A) this._prefix = A + "_";
      ((this._appendTimestamp = B), (this._withResourceConstantLabels = Q));
    }
    serialize(A) {
      let B = "";
      this._additionalAttributes = this._filterResourceConstantLabels(
        A.resource.attributes,
        this._withResourceConstantLabels,
      );
      for (let Q of A.scopeMetrics) B += this._serializeScopeMetrics(Q);
      if (B === "") B += Pc5;
      return this._serializeResource(A.resource) + B;
    }
    _filterResourceConstantLabels(A, B) {
      if (B) {
        let Q = {};
        for (let [I, G] of Object.entries(A)) if (I.match(B)) Q[I] = G;
        return Q;
      }
      return;
    }
    _serializeScopeMetrics(A) {
      let B = "";
      for (let Q of A.metrics)
        B +=
          this._serializeMetricData(Q) +
          `
`;
      return B;
    }
    _serializeMetricData(A) {
      let B = go1(X11(A.descriptor.name));
      if (this._prefix) B = `${this._prefix}${B}`;
      let Q = A.dataPointType;
      B = ho1(B, A);
      let I = `# HELP ${B} ${X11(A.descriptor.description || "description missing")}`,
        G = A.descriptor.unit
          ? `
# UNIT ${B} ${X11(A.descriptor.unit)}`
          : "",
        Z = `# TYPE ${B} ${Tc5(A)}`,
        Y = "";
      switch (Q) {
        case fo.DataPointType.SUM:
        case fo.DataPointType.GAUGE: {
          Y = A.dataPoints
            .map((J) => this._serializeSingularDataPoint(B, A, J))
            .join("");
          break;
        }
        case fo.DataPointType.HISTOGRAM: {
          Y = A.dataPoints
            .map((J) => this._serializeHistogramDataPoint(B, A, J))
            .join("");
          break;
        }
        default:
          Lc5.diag.error(
            `Unrecognizable DataPointType: ${Q} for metric "${B}"`,
          );
      }
      return `${I}${G}
${Z}
${Y}`.trim();
    }
    _serializeSingularDataPoint(A, B, Q) {
      let I = "";
      A = ho1(A, B);
      let { value: G, attributes: Z } = Q,
        Y = (0, kN2.hrTimeToMilliseconds)(Q.endTime);
      return (
        (I += J11(
          A,
          Z,
          G,
          this._appendTimestamp ? Y : void 0,
          this._additionalAttributes,
        )),
        I
      );
    }
    _serializeHistogramDataPoint(A, B, Q) {
      let I = "";
      A = ho1(A, B);
      let { attributes: G, value: Z } = Q,
        Y = (0, kN2.hrTimeToMilliseconds)(Q.endTime);
      for (let F of ["count", "sum"]) {
        let C = Z[F];
        if (C != null)
          I += J11(
            A + "_" + F,
            G,
            C,
            this._appendTimestamp ? Y : void 0,
            this._additionalAttributes,
          );
      }
      let J = 0,
        X = Z.buckets.counts.entries(),
        W = !1;
      for (let [F, C] of X) {
        J += C;
        let V = Z.buckets.boundaries[F];
        if (V === void 0 && W) break;
        if (V === 1 / 0) W = !0;
        I += J11(
          A + "_bucket",
          G,
          J,
          this._appendTimestamp ? Y : void 0,
          Object.assign({}, this._additionalAttributes ?? {}, {
            le: V === void 0 || V === 1 / 0 ? "+Inf" : String(V),
          }),
        );
      }
      return I;
    }
    _serializeResource(A) {
      return `# HELP target_info Target metadata
# TYPE target_info gauge
${J11("target_info", A.attributes, 1).trim()}
`;
    }
  }
  vN2.PrometheusSerializer = xN2;
});
var gN2 = z((fN2) => {
  Object.defineProperty(fN2, "__esModule", { value: !0 });
  fN2.PrometheusExporter = void 0;
  var DwA = o2(),
    jc5 = M6(),
    mo1 = Ec(),
    Sc5 = EA("http"),
    yc5 = uo1(),
    kc5 = EA("url");
  class hc extends mo1.MetricReader {
    static DEFAULT_OPTIONS = {
      host: void 0,
      port: 9464,
      endpoint: "/metrics",
      prefix: "",
      appendTimestamp: !1,
      withResourceConstantLabels: void 0,
    };
    _host;
    _port;
    _baseUrl;
    _endpoint;
    _server;
    _prefix;
    _appendTimestamp;
    _serializer;
    _startServerPromise;
    constructor(A = {}, B = () => {}) {
      super({
        aggregationSelector: (I) => {
          return { type: mo1.AggregationType.DEFAULT };
        },
        aggregationTemporalitySelector: (I) =>
          mo1.AggregationTemporality.CUMULATIVE,
        metricProducers: A.metricProducers,
      });
      ((this._host =
        A.host ||
        process.env.OTEL_EXPORTER_PROMETHEUS_HOST ||
        hc.DEFAULT_OPTIONS.host),
        (this._port =
          A.port ||
          Number(process.env.OTEL_EXPORTER_PROMETHEUS_PORT) ||
          hc.DEFAULT_OPTIONS.port),
        (this._prefix = A.prefix || hc.DEFAULT_OPTIONS.prefix),
        (this._appendTimestamp =
          typeof A.appendTimestamp === "boolean"
            ? A.appendTimestamp
            : hc.DEFAULT_OPTIONS.appendTimestamp));
      let Q =
        A.withResourceConstantLabels ||
        hc.DEFAULT_OPTIONS.withResourceConstantLabels;
      if (
        ((this._server = (0, Sc5.createServer)(this._requestHandler).unref()),
        (this._serializer = new yc5.PrometheusSerializer(
          this._prefix,
          this._appendTimestamp,
          Q,
        )),
        (this._baseUrl = `http://${this._host}:${this._port}/`),
        (this._endpoint = (A.endpoint || hc.DEFAULT_OPTIONS.endpoint).replace(
          /^([^/])/,
          "/$1",
        )),
        A.preventServerStart !== !0)
      )
        this.startServer().then(B, (I) => {
          (DwA.diag.error(I), B(I));
        });
      else if (B) queueMicrotask(B);
    }
    async onForceFlush() {}
    onShutdown() {
      return this.stopServer();
    }
    stopServer() {
      if (!this._server)
        return (
          DwA.diag.debug(
            "Prometheus stopServer() was called but server was never started.",
          ),
          Promise.resolve()
        );
      else
        return new Promise((A) => {
          this._server.close((B) => {
            if (!B) DwA.diag.debug("Prometheus exporter was stopped");
            else if (B.code !== "ERR_SERVER_NOT_RUNNING")
              (0, jc5.globalErrorHandler)(B);
            A();
          });
        });
    }
    startServer() {
      return (
        (this._startServerPromise ??= new Promise((A, B) => {
          (this._server.once("error", B),
            this._server.listen({ port: this._port, host: this._host }, () => {
              (DwA.diag.debug(
                `Prometheus exporter server started: ${this._host}:${this._port}/${this._endpoint}`,
              ),
                A());
            }));
        })),
        this._startServerPromise
      );
    }
    getMetricsRequestHandler(A, B) {
      this._exportMetrics(B);
    }
    _requestHandler = (A, B) => {
      if (
        A.url != null &&
        new kc5.URL(A.url, this._baseUrl).pathname === this._endpoint
      )
        this._exportMetrics(B);
      else this._notFound(B);
    };
    _exportMetrics = (A) => {
      ((A.statusCode = 200),
        A.setHeader("content-type", "text/plain"),
        this.collect().then(
          (B) => {
            let { resourceMetrics: Q, errors: I } = B;
            if (I.length)
              DwA.diag.error(
                "PrometheusExporter: metrics collection errors",
                ...I,
              );
            A.end(this._serializer.serialize(Q));
          },
          (B) => {
            A.end(`# failed to export metrics: ${B}`);
          },
        ));
    };
    _notFound = (A) => {
      ((A.statusCode = 404), A.end());
    };
  }
  fN2.PrometheusExporter = hc;
});
var uN2 = z((W11) => {
  Object.defineProperty(W11, "__esModule", { value: !0 });
  W11.PrometheusSerializer = W11.PrometheusExporter = void 0;
  var _c5 = gN2();
  Object.defineProperty(W11, "PrometheusExporter", {
    enumerable: !0,
    get: function () {
      return _c5.PrometheusExporter;
    },
  });
  var xc5 = uo1();
  Object.defineProperty(W11, "PrometheusSerializer", {
    enumerable: !0,
    get: function () {
      return xc5.PrometheusSerializer;
    },
  });
});
var pN2 = z((dN2) => {
  Object.defineProperty(dN2, "__esModule", { value: !0 });
  dN2.LogRecordImpl = void 0;
  var ho = o2(),
    F11 = M6();
  class mN2 {
    hrTime;
    hrTimeObserved;
    spanContext;
    resource;
    instrumentationScope;
    attributes = {};
    _severityText;
    _severityNumber;
    _body;
    _eventName;
    totalAttributesCount = 0;
    _isReadonly = !1;
    _logRecordLimits;
    set severityText(A) {
      if (this._isLogRecordReadonly()) return;
      this._severityText = A;
    }
    get severityText() {
      return this._severityText;
    }
    set severityNumber(A) {
      if (this._isLogRecordReadonly()) return;
      this._severityNumber = A;
    }
    get severityNumber() {
      return this._severityNumber;
    }
    set body(A) {
      if (this._isLogRecordReadonly()) return;
      this._body = A;
    }
    get body() {
      return this._body;
    }
    get eventName() {
      return this._eventName;
    }
    set eventName(A) {
      if (this._isLogRecordReadonly()) return;
      this._eventName = A;
    }
    get droppedAttributesCount() {
      return this.totalAttributesCount - Object.keys(this.attributes).length;
    }
    constructor(A, B, Q) {
      let {
          timestamp: I,
          observedTimestamp: G,
          eventName: Z,
          severityNumber: Y,
          severityText: J,
          body: X,
          attributes: W = {},
          context: F,
        } = Q,
        C = Date.now();
      if (
        ((this.hrTime = (0, F11.timeInputToHrTime)(I ?? C)),
        (this.hrTimeObserved = (0, F11.timeInputToHrTime)(G ?? C)),
        F)
      ) {
        let V = ho.trace.getSpanContext(F);
        if (V && ho.isSpanContextValid(V)) this.spanContext = V;
      }
      ((this.severityNumber = Y),
        (this.severityText = J),
        (this.body = X),
        (this.resource = A.resource),
        (this.instrumentationScope = B),
        (this._logRecordLimits = A.logRecordLimits),
        (this._eventName = Z),
        this.setAttributes(W));
    }
    setAttribute(A, B) {
      if (this._isLogRecordReadonly()) return this;
      if (B === null) return this;
      if (A.length === 0)
        return (ho.diag.warn(`Invalid attribute key: ${A}`), this);
      if (
        !(0, F11.isAttributeValue)(B) &&
        !(
          typeof B === "object" &&
          !Array.isArray(B) &&
          Object.keys(B).length > 0
        )
      )
        return (
          ho.diag.warn(`Invalid attribute value set for key: ${A}`),
          this
        );
      if (
        ((this.totalAttributesCount += 1),
        Object.keys(this.attributes).length >=
          this._logRecordLimits.attributeCountLimit &&
          !Object.prototype.hasOwnProperty.call(this.attributes, A))
      ) {
        if (this.droppedAttributesCount === 1)
          ho.diag.warn("Dropping extra attributes.");
        return this;
      }
      if ((0, F11.isAttributeValue)(B))
        this.attributes[A] = this._truncateToSize(B);
      else this.attributes[A] = B;
      return this;
    }
    setAttributes(A) {
      for (let [B, Q] of Object.entries(A)) this.setAttribute(B, Q);
      return this;
    }
    setBody(A) {
      return ((this.body = A), this);
    }
    setEventName(A) {
      return ((this.eventName = A), this);
    }
    setSeverityNumber(A) {
      return ((this.severityNumber = A), this);
    }
    setSeverityText(A) {
      return ((this.severityText = A), this);
    }
    _makeReadonly() {
      this._isReadonly = !0;
    }
    _truncateToSize(A) {
      let B = this._logRecordLimits.attributeValueLengthLimit;
      if (B <= 0)
        return (
          ho.diag.warn(`Attribute value limit must be positive, got ${B}`),
          A
        );
      if (typeof A === "string") return this._truncateToLimitUtil(A, B);
      if (Array.isArray(A))
        return A.map((Q) =>
          typeof Q === "string" ? this._truncateToLimitUtil(Q, B) : Q,
        );
      return A;
    }
    _truncateToLimitUtil(A, B) {
      if (A.length <= B) return A;
      return A.substring(0, B);
    }
    _isLogRecordReadonly() {
      if (this._isReadonly)
        ho.diag.warn("Can not execute the operation on emitted log record");
      return this._isReadonly;
    }
  }
  dN2.LogRecordImpl = mN2;
});
var aN2 = z((iN2) => {
  Object.defineProperty(iN2, "__esModule", { value: !0 });
  iN2.Logger = void 0;
  var bc5 = o2(),
    fc5 = pN2();
  class lN2 {
    instrumentationScope;
    _sharedState;
    constructor(A, B) {
      ((this.instrumentationScope = A), (this._sharedState = B));
    }
    emit(A) {
      let B = A.context || bc5.context.active(),
        Q = new fc5.LogRecordImpl(
          this._sharedState,
          this.instrumentationScope,
          { context: B, ...A },
        );
      (this._sharedState.activeProcessor.onEmit(Q, B), Q._makeReadonly());
    }
  }
  iN2.Logger = lN2;
});
var oN2 = z((sN2) => {
  Object.defineProperty(sN2, "__esModule", { value: !0 });
  sN2.reconfigureLimits = sN2.loadDefaultConfig = void 0;
  var u3A = M6();
  function hc5() {
    return {
      forceFlushTimeoutMillis: 30000,
      logRecordLimits: {
        attributeValueLengthLimit:
          (0, u3A.getNumberFromEnv)(
            "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
          ) ?? 1 / 0,
        attributeCountLimit:
          (0, u3A.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ??
          128,
      },
      includeTraceContext: !0,
    };
  }
  sN2.loadDefaultConfig = hc5;
  function gc5(A) {
    return {
      attributeCountLimit:
        A.attributeCountLimit ??
        (0, u3A.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ??
        (0, u3A.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ??
        128,
      attributeValueLengthLimit:
        A.attributeValueLengthLimit ??
        (0, u3A.getNumberFromEnv)(
          "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
        ) ??
        (0, u3A.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
        1 / 0,
    };
  }
  sN2.reconfigureLimits = gc5;
});
var do1 = z((eN2) => {
  Object.defineProperty(eN2, "__esModule", { value: !0 });
  eN2.NoopLogRecordProcessor = void 0;
  class tN2 {
    forceFlush() {
      return Promise.resolve();
    }
    onEmit(A, B) {}
    shutdown() {
      return Promise.resolve();
    }
  }
  eN2.NoopLogRecordProcessor = tN2;
});
var GL2 = z((QL2) => {
  Object.defineProperty(QL2, "__esModule", { value: !0 });
  QL2.MultiLogRecordProcessor = void 0;
  var mc5 = M6();
  class BL2 {
    processors;
    forceFlushTimeoutMillis;
    constructor(A, B) {
      ((this.processors = A), (this.forceFlushTimeoutMillis = B));
    }
    async forceFlush() {
      let A = this.forceFlushTimeoutMillis;
      await Promise.all(
        this.processors.map((B) => (0, mc5.callWithTimeout)(B.forceFlush(), A)),
      );
    }
    onEmit(A, B) {
      this.processors.forEach((Q) => Q.onEmit(A, B));
    }
    async shutdown() {
      await Promise.all(this.processors.map((A) => A.shutdown()));
    }
  }
  QL2.MultiLogRecordProcessor = BL2;
});
var XL2 = z((YL2) => {
  Object.defineProperty(YL2, "__esModule", { value: !0 });
  YL2.LoggerProviderSharedState = void 0;
  var dc5 = do1(),
    cc5 = GL2();
  class ZL2 {
    resource;
    forceFlushTimeoutMillis;
    logRecordLimits;
    processors;
    loggers = new Map();
    activeProcessor;
    registeredLogRecordProcessors = [];
    constructor(A, B, Q, I) {
      if (
        ((this.resource = A),
        (this.forceFlushTimeoutMillis = B),
        (this.logRecordLimits = Q),
        (this.processors = I),
        I.length > 0)
      )
        ((this.registeredLogRecordProcessors = I),
          (this.activeProcessor = new cc5.MultiLogRecordProcessor(
            this.registeredLogRecordProcessors,
            this.forceFlushTimeoutMillis,
          )));
      else this.activeProcessor = new dc5.NoopLogRecordProcessor();
    }
  }
  YL2.LoggerProviderSharedState = ZL2;
});
var EL2 = z((VL2) => {
  Object.defineProperty(VL2, "__esModule", { value: !0 });
  VL2.LoggerProvider = VL2.DEFAULT_LOGGER_NAME = void 0;
  var C11 = o2(),
    pc5 = Wn1(),
    lc5 = eIA(),
    WL2 = M6(),
    ic5 = aN2(),
    FL2 = oN2(),
    nc5 = XL2();
  VL2.DEFAULT_LOGGER_NAME = "unknown";
  class CL2 {
    _shutdownOnce;
    _sharedState;
    constructor(A = {}) {
      let B = (0, WL2.merge)({}, (0, FL2.loadDefaultConfig)(), A),
        Q = A.resource ?? (0, lc5.defaultResource)();
      ((this._sharedState = new nc5.LoggerProviderSharedState(
        Q,
        B.forceFlushTimeoutMillis,
        (0, FL2.reconfigureLimits)(B.logRecordLimits),
        A?.processors ?? [],
      )),
        (this._shutdownOnce = new WL2.BindOnceFuture(this._shutdown, this)));
    }
    getLogger(A, B, Q) {
      if (this._shutdownOnce.isCalled)
        return (
          C11.diag.warn("A shutdown LoggerProvider cannot provide a Logger"),
          pc5.NOOP_LOGGER
        );
      if (!A)
        C11.diag.warn("Logger requested without instrumentation scope name.");
      let I = A || VL2.DEFAULT_LOGGER_NAME,
        G = `${I}@${B || ""}:${Q?.schemaUrl || ""}`;
      if (!this._sharedState.loggers.has(G))
        this._sharedState.loggers.set(
          G,
          new ic5.Logger(
            { name: I, version: B, schemaUrl: Q?.schemaUrl },
            this._sharedState,
          ),
        );
      return this._sharedState.loggers.get(G);
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled)
        return (
          C11.diag.warn(
            "invalid attempt to force flush after LoggerProvider shutdown",
          ),
          this._shutdownOnce.promise
        );
      return this._sharedState.activeProcessor.forceFlush();
    }
    shutdown() {
      if (this._shutdownOnce.isCalled)
        return (
          C11.diag.warn("shutdown may only be called once per LoggerProvider"),
          this._shutdownOnce.promise
        );
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._sharedState.activeProcessor.shutdown();
    }
  }
  VL2.LoggerProvider = CL2;
});
var $L2 = z((UL2) => {
  Object.defineProperty(UL2, "__esModule", { value: !0 });
  UL2.ConsoleLogRecordExporter = void 0;
  var HL2 = M6();
  class zL2 {
    export(A, B) {
      this._sendLogRecords(A, B);
    }
    shutdown() {
      return Promise.resolve();
    }
    _exportInfo(A) {
      return {
        resource: { attributes: A.resource.attributes },
        instrumentationScope: A.instrumentationScope,
        timestamp: (0, HL2.hrTimeToMicroseconds)(A.hrTime),
        traceId: A.spanContext?.traceId,
        spanId: A.spanContext?.spanId,
        traceFlags: A.spanContext?.traceFlags,
        severityText: A.severityText,
        severityNumber: A.severityNumber,
        body: A.body,
        attributes: A.attributes,
      };
    }
    _sendLogRecords(A, B) {
      for (let Q of A) console.dir(this._exportInfo(Q), { depth: 3 });
      B?.({ code: HL2.ExportResultCode.SUCCESS });
    }
  }
  UL2.ConsoleLogRecordExporter = zL2;
});
var ML2 = z((NL2) => {
  Object.defineProperty(NL2, "__esModule", { value: !0 });
  NL2.SimpleLogRecordProcessor = void 0;
  var m3A = M6();
  class qL2 {
    _exporter;
    _shutdownOnce;
    _unresolvedExports;
    constructor(A) {
      ((this._exporter = A),
        (this._shutdownOnce = new m3A.BindOnceFuture(this._shutdown, this)),
        (this._unresolvedExports = new Set()));
    }
    onEmit(A) {
      if (this._shutdownOnce.isCalled) return;
      let B = () =>
        m3A.internal
          ._export(this._exporter, [A])
          .then((Q) => {
            if (Q.code !== m3A.ExportResultCode.SUCCESS)
              (0, m3A.globalErrorHandler)(
                Q.error ??
                  Error(
                    `SimpleLogRecordProcessor: log record export failed (status ${Q})`,
                  ),
              );
          })
          .catch(m3A.globalErrorHandler);
      if (A.resource.asyncAttributesPending) {
        let Q = A.resource.waitForAsyncAttributes?.().then(() => {
          return (this._unresolvedExports.delete(Q), B());
        }, m3A.globalErrorHandler);
        if (Q != null) this._unresolvedExports.add(Q);
      } else B();
    }
    async forceFlush() {
      await Promise.all(Array.from(this._unresolvedExports));
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  NL2.SimpleLogRecordProcessor = qL2;
});
var jL2 = z((TL2) => {
  Object.defineProperty(TL2, "__esModule", { value: !0 });
  TL2.InMemoryLogRecordExporter = void 0;
  var OL2 = M6();
  class RL2 {
    _finishedLogRecords = [];
    _stopped = !1;
    export(A, B) {
      if (this._stopped)
        return B({
          code: OL2.ExportResultCode.FAILED,
          error: Error("Exporter has been stopped"),
        });
      (this._finishedLogRecords.push(...A),
        B({ code: OL2.ExportResultCode.SUCCESS }));
    }
    shutdown() {
      return ((this._stopped = !0), this.reset(), Promise.resolve());
    }
    getFinishedLogRecords() {
      return this._finishedLogRecords;
    }
    reset() {
      this._finishedLogRecords = [];
    }
  }
  TL2.InMemoryLogRecordExporter = RL2;
});
var _L2 = z((yL2) => {
  Object.defineProperty(yL2, "__esModule", { value: !0 });
  yL2.BatchLogRecordProcessorBase = void 0;
  var ac5 = o2(),
    hw = M6();
  class SL2 {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _finishedLogRecords = [];
    _timer;
    _shutdownOnce;
    constructor(A, B) {
      if (
        ((this._exporter = A),
        (this._maxExportBatchSize =
          B?.maxExportBatchSize ??
          (0, hw.getNumberFromEnv)("OTEL_BLRP_MAX_EXPORT_BATCH_SIZE") ??
          512),
        (this._maxQueueSize =
          B?.maxQueueSize ??
          (0, hw.getNumberFromEnv)("OTEL_BLRP_MAX_QUEUE_SIZE") ??
          2048),
        (this._scheduledDelayMillis =
          B?.scheduledDelayMillis ??
          (0, hw.getNumberFromEnv)("OTEL_BLRP_SCHEDULE_DELAY") ??
          5000),
        (this._exportTimeoutMillis =
          B?.exportTimeoutMillis ??
          (0, hw.getNumberFromEnv)("OTEL_BLRP_EXPORT_TIMEOUT") ??
          30000),
        (this._shutdownOnce = new hw.BindOnceFuture(this._shutdown, this)),
        this._maxExportBatchSize > this._maxQueueSize)
      )
        (ac5.diag.warn(
          "BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize",
        ),
          (this._maxExportBatchSize = this._maxQueueSize));
    }
    onEmit(A) {
      if (this._shutdownOnce.isCalled) return;
      this._addToBuffer(A);
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) return this._shutdownOnce.promise;
      return this._flushAll();
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    async _shutdown() {
      (this.onShutdown(),
        await this._flushAll(),
        await this._exporter.shutdown());
    }
    _addToBuffer(A) {
      if (this._finishedLogRecords.length >= this._maxQueueSize) return;
      (this._finishedLogRecords.push(A), this._maybeStartTimer());
    }
    _flushAll() {
      return new Promise((A, B) => {
        let Q = [],
          I = Math.ceil(
            this._finishedLogRecords.length / this._maxExportBatchSize,
          );
        for (let G = 0; G < I; G++) Q.push(this._flushOneBatch());
        Promise.all(Q)
          .then(() => {
            A();
          })
          .catch(B);
      });
    }
    _flushOneBatch() {
      if ((this._clearTimer(), this._finishedLogRecords.length === 0))
        return Promise.resolve();
      return new Promise((A, B) => {
        (0, hw.callWithTimeout)(
          this._export(
            this._finishedLogRecords.splice(0, this._maxExportBatchSize),
          ),
          this._exportTimeoutMillis,
        )
          .then(() => A())
          .catch(B);
      });
    }
    _maybeStartTimer() {
      if (this._timer !== void 0) return;
      ((this._timer = setTimeout(() => {
        this._flushOneBatch()
          .then(() => {
            if (this._finishedLogRecords.length > 0)
              (this._clearTimer(), this._maybeStartTimer());
          })
          .catch((A) => {
            (0, hw.globalErrorHandler)(A);
          });
      }, this._scheduledDelayMillis)),
        (0, hw.unrefTimer)(this._timer));
    }
    _clearTimer() {
      if (this._timer !== void 0)
        (clearTimeout(this._timer), (this._timer = void 0));
    }
    _export(A) {
      let B = () =>
          hw.internal
            ._export(this._exporter, A)
            .then((I) => {
              if (I.code !== hw.ExportResultCode.SUCCESS)
                (0, hw.globalErrorHandler)(
                  I.error ??
                    Error(
                      `BatchLogRecordProcessor: log record export failed (status ${I})`,
                    ),
                );
            })
            .catch(hw.globalErrorHandler),
        Q = A.map((I) => I.resource).filter((I) => I.asyncAttributesPending);
      if (Q.length === 0) return B();
      else
        return Promise.all(Q.map((I) => I.waitForAsyncAttributes?.())).then(
          B,
          hw.globalErrorHandler,
        );
    }
  }
  yL2.BatchLogRecordProcessorBase = SL2;
});
var fL2 = z((vL2) => {
  Object.defineProperty(vL2, "__esModule", { value: !0 });
  vL2.BatchLogRecordProcessor = void 0;
  var sc5 = _L2();
  class xL2 extends sc5.BatchLogRecordProcessorBase {
    onShutdown() {}
  }
  vL2.BatchLogRecordProcessor = xL2;
});
var hL2 = z((co1) => {
  Object.defineProperty(co1, "__esModule", { value: !0 });
  co1.BatchLogRecordProcessor = void 0;
  var rc5 = fL2();
  Object.defineProperty(co1, "BatchLogRecordProcessor", {
    enumerable: !0,
    get: function () {
      return rc5.BatchLogRecordProcessor;
    },
  });
});
var gL2 = z((po1) => {
  Object.defineProperty(po1, "__esModule", { value: !0 });
  po1.BatchLogRecordProcessor = void 0;
  var tc5 = hL2();
  Object.defineProperty(po1, "BatchLogRecordProcessor", {
    enumerable: !0,
    get: function () {
      return tc5.BatchLogRecordProcessor;
    },
  });
});
var lo1 = z((gc) => {
  Object.defineProperty(gc, "__esModule", { value: !0 });
  gc.BatchLogRecordProcessor =
    gc.InMemoryLogRecordExporter =
    gc.SimpleLogRecordProcessor =
    gc.ConsoleLogRecordExporter =
    gc.NoopLogRecordProcessor =
    gc.LoggerProvider =
      void 0;
  var Ap5 = EL2();
  Object.defineProperty(gc, "LoggerProvider", {
    enumerable: !0,
    get: function () {
      return Ap5.LoggerProvider;
    },
  });
  var Bp5 = do1();
  Object.defineProperty(gc, "NoopLogRecordProcessor", {
    enumerable: !0,
    get: function () {
      return Bp5.NoopLogRecordProcessor;
    },
  });
  var Qp5 = $L2();
  Object.defineProperty(gc, "ConsoleLogRecordExporter", {
    enumerable: !0,
    get: function () {
      return Qp5.ConsoleLogRecordExporter;
    },
  });
  var Ip5 = ML2();
  Object.defineProperty(gc, "SimpleLogRecordProcessor", {
    enumerable: !0,
    get: function () {
      return Ip5.SimpleLogRecordProcessor;
    },
  });
  var Gp5 = jL2();
  Object.defineProperty(gc, "InMemoryLogRecordExporter", {
    enumerable: !0,
    get: function () {
      return Gp5.InMemoryLogRecordExporter;
    },
  });
  var Zp5 = gL2();
  Object.defineProperty(gc, "BatchLogRecordProcessor", {
    enumerable: !0,
    get: function () {
      return Zp5.BatchLogRecordProcessor;
    },
  });
});
var dL2 = z((uL2) => {
  Object.defineProperty(uL2, "__esModule", { value: !0 });
  uL2.VERSION = void 0;
  uL2.VERSION = "0.204.0";
});
var nL2 = z((lL2) => {
  Object.defineProperty(lL2, "__esModule", { value: !0 });
  lL2.OTLPLogExporter = void 0;
  var Jp5 = hS(),
    Xp5 = mS(),
    cL2 = qc(),
    Wp5 = dL2();
  class pL2 extends Jp5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, cL2.createOtlpHttpExportDelegate)(
          (0, cL2.convertLegacyHttpOptions)(A, "LOGS", "v1/logs", {
            "User-Agent": `OTel-OTLP-Exporter-JavaScript/${Wp5.VERSION}`,
            "Content-Type": "application/x-protobuf",
          }),
          Xp5.ProtobufLogsSerializer,
        ),
      );
    }
  }
  lL2.OTLPLogExporter = pL2;
});
var aL2 = z((io1) => {
  Object.defineProperty(io1, "__esModule", { value: !0 });
  io1.OTLPLogExporter = void 0;
  var Fp5 = nL2();
  Object.defineProperty(io1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Fp5.OTLPLogExporter;
    },
  });
});
var sL2 = z((no1) => {
  Object.defineProperty(no1, "__esModule", { value: !0 });
  no1.OTLPLogExporter = void 0;
  var Vp5 = aL2();
  Object.defineProperty(no1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Vp5.OTLPLogExporter;
    },
  });
});
var rL2 = z((ao1) => {
  Object.defineProperty(ao1, "__esModule", { value: !0 });
  ao1.OTLPLogExporter = void 0;
  var Dp5 = sL2();
  Object.defineProperty(ao1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Dp5.OTLPLogExporter;
    },
  });
});
var BM2 = z((eL2) => {
  Object.defineProperty(eL2, "__esModule", { value: !0 });
  eL2.OTLPLogExporter = void 0;
  var oL2 = Y11(),
    Hp5 = mS(),
    zp5 = hS();
  class tL2 extends zp5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, oL2.createOtlpGrpcExportDelegate)(
          (0, oL2.convertLegacyOtlpGrpcOptions)(A, "LOGS"),
          Hp5.ProtobufLogsSerializer,
          "LogsExportService",
          "/opentelemetry.proto.collector.logs.v1.LogsService/Export",
        ),
      );
    }
  }
  eL2.OTLPLogExporter = tL2;
});
var QM2 = z((so1) => {
  Object.defineProperty(so1, "__esModule", { value: !0 });
  so1.OTLPLogExporter = void 0;
  var Up5 = BM2();
  Object.defineProperty(so1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Up5.OTLPLogExporter;
    },
  });
});
var ZM2 = z((IM2) => {
  Object.defineProperty(IM2, "__esModule", { value: !0 });
  IM2.VERSION = void 0;
  IM2.VERSION = "0.204.0";
});
var FM2 = z((XM2) => {
  Object.defineProperty(XM2, "__esModule", { value: !0 });
  XM2.OTLPLogExporter = void 0;
  var $p5 = hS(),
    qp5 = mS(),
    Np5 = ZM2(),
    YM2 = qc();
  class JM2 extends $p5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, YM2.createOtlpHttpExportDelegate)(
          (0, YM2.convertLegacyHttpOptions)(A, "LOGS", "v1/logs", {
            "User-Agent": `OTel-OTLP-Exporter-JavaScript/${Np5.VERSION}`,
            "Content-Type": "application/json",
          }),
          qp5.JsonLogsSerializer,
        ),
      );
    }
  }
  XM2.OTLPLogExporter = JM2;
});
var CM2 = z((ro1) => {
  Object.defineProperty(ro1, "__esModule", { value: !0 });
  ro1.OTLPLogExporter = void 0;
  var Lp5 = FM2();
  Object.defineProperty(ro1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Lp5.OTLPLogExporter;
    },
  });
});
var VM2 = z((oo1) => {
  Object.defineProperty(oo1, "__esModule", { value: !0 });
  oo1.OTLPLogExporter = void 0;
  var Op5 = CM2();
  Object.defineProperty(oo1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Op5.OTLPLogExporter;
    },
  });
});
var KM2 = z((to1) => {
  Object.defineProperty(to1, "__esModule", { value: !0 });
  to1.OTLPLogExporter = void 0;
  var Tp5 = VM2();
  Object.defineProperty(to1, "OTLPLogExporter", {
    enumerable: !0,
    get: function () {
      return Tp5.OTLPLogExporter;
    },
  });
});
var HM2 = z((DM2) => {
  Object.defineProperty(DM2, "__esModule", { value: !0 });
  DM2.ExceptionEventName = void 0;
  DM2.ExceptionEventName = "exception";
});
var $M2 = z((UM2) => {
  Object.defineProperty(UM2, "__esModule", { value: !0 });
  UM2.SpanImpl = void 0;
  var CL = o2(),
    iK = M6(),
    go = Wo(),
    jp5 = HM2();
  class zM2 {
    _spanContext;
    kind;
    parentSpanContext;
    attributes = {};
    links = [];
    events = [];
    startTime;
    resource;
    instrumentationScope;
    _droppedAttributesCount = 0;
    _droppedEventsCount = 0;
    _droppedLinksCount = 0;
    name;
    status = { code: CL.SpanStatusCode.UNSET };
    endTime = [0, 0];
    _ended = !1;
    _duration = [-1, -1];
    _spanProcessor;
    _spanLimits;
    _attributeValueLengthLimit;
    _performanceStartTime;
    _performanceOffset;
    _startTimeProvided;
    constructor(A) {
      let B = Date.now();
      if (
        ((this._spanContext = A.spanContext),
        (this._performanceStartTime = iK.otperformance.now()),
        (this._performanceOffset =
          B - (this._performanceStartTime + (0, iK.getTimeOrigin)())),
        (this._startTimeProvided = A.startTime != null),
        (this._spanLimits = A.spanLimits),
        (this._attributeValueLengthLimit =
          this._spanLimits.attributeValueLengthLimit || 0),
        (this._spanProcessor = A.spanProcessor),
        (this.name = A.name),
        (this.parentSpanContext = A.parentSpanContext),
        (this.kind = A.kind),
        (this.links = A.links || []),
        (this.startTime = this._getTime(A.startTime ?? B)),
        (this.resource = A.resource),
        (this.instrumentationScope = A.scope),
        A.attributes != null)
      )
        this.setAttributes(A.attributes);
      this._spanProcessor.onStart(this, A.context);
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(A, B) {
      if (B == null || this._isSpanEnded()) return this;
      if (A.length === 0)
        return (CL.diag.warn(`Invalid attribute key: ${A}`), this);
      if (!(0, iK.isAttributeValue)(B))
        return (
          CL.diag.warn(`Invalid attribute value set for key: ${A}`),
          this
        );
      let { attributeCountLimit: Q } = this._spanLimits;
      if (
        Q !== void 0 &&
        Object.keys(this.attributes).length >= Q &&
        !Object.prototype.hasOwnProperty.call(this.attributes, A)
      )
        return (this._droppedAttributesCount++, this);
      return ((this.attributes[A] = this._truncateToSize(B)), this);
    }
    setAttributes(A) {
      for (let [B, Q] of Object.entries(A)) this.setAttribute(B, Q);
      return this;
    }
    addEvent(A, B, Q) {
      if (this._isSpanEnded()) return this;
      let { eventCountLimit: I } = this._spanLimits;
      if (I === 0)
        return (
          CL.diag.warn("No events allowed."),
          this._droppedEventsCount++,
          this
        );
      if (I !== void 0 && this.events.length >= I) {
        if (this._droppedEventsCount === 0)
          CL.diag.debug("Dropping extra events.");
        (this.events.shift(), this._droppedEventsCount++);
      }
      if ((0, iK.isTimeInput)(B)) {
        if (!(0, iK.isTimeInput)(Q)) Q = B;
        B = void 0;
      }
      let G = (0, iK.sanitizeAttributes)(B);
      return (
        this.events.push({
          name: A,
          attributes: G,
          time: this._getTime(Q),
          droppedAttributesCount: 0,
        }),
        this
      );
    }
    addLink(A) {
      return (this.links.push(A), this);
    }
    addLinks(A) {
      return (this.links.push(...A), this);
    }
    setStatus(A) {
      if (this._isSpanEnded()) return this;
      if (
        ((this.status = { ...A }),
        this.status.message != null && typeof A.message !== "string")
      )
        (CL.diag.warn(
          `Dropping invalid status.message of type '${typeof A.message}', expected 'string'`,
        ),
          delete this.status.message);
      return this;
    }
    updateName(A) {
      if (this._isSpanEnded()) return this;
      return ((this.name = A), this);
    }
    end(A) {
      if (this._isSpanEnded()) {
        CL.diag.error(
          `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`,
        );
        return;
      }
      if (
        ((this._ended = !0),
        (this.endTime = this._getTime(A)),
        (this._duration = (0, iK.hrTimeDuration)(this.startTime, this.endTime)),
        this._duration[0] < 0)
      )
        (CL.diag.warn(
          "Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.",
          this.startTime,
          this.endTime,
        ),
          (this.endTime = this.startTime.slice()),
          (this._duration = [0, 0]));
      if (this._droppedEventsCount > 0)
        CL.diag.warn(
          `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`,
        );
      this._spanProcessor.onEnd(this);
    }
    _getTime(A) {
      if (typeof A === "number" && A <= iK.otperformance.now())
        return (0, iK.hrTime)(A + this._performanceOffset);
      if (typeof A === "number") return (0, iK.millisToHrTime)(A);
      if (A instanceof Date) return (0, iK.millisToHrTime)(A.getTime());
      if ((0, iK.isTimeInputHrTime)(A)) return A;
      if (this._startTimeProvided) return (0, iK.millisToHrTime)(Date.now());
      let B = iK.otperformance.now() - this._performanceStartTime;
      return (0, iK.addHrTimes)(this.startTime, (0, iK.millisToHrTime)(B));
    }
    isRecording() {
      return this._ended === !1;
    }
    recordException(A, B) {
      let Q = {};
      if (typeof A === "string") Q[go.ATTR_EXCEPTION_MESSAGE] = A;
      else if (A) {
        if (A.code) Q[go.ATTR_EXCEPTION_TYPE] = A.code.toString();
        else if (A.name) Q[go.ATTR_EXCEPTION_TYPE] = A.name;
        if (A.message) Q[go.ATTR_EXCEPTION_MESSAGE] = A.message;
        if (A.stack) Q[go.ATTR_EXCEPTION_STACKTRACE] = A.stack;
      }
      if (Q[go.ATTR_EXCEPTION_TYPE] || Q[go.ATTR_EXCEPTION_MESSAGE])
        this.addEvent(jp5.ExceptionEventName, Q, B);
      else CL.diag.warn(`Failed to record an exception ${A}`);
    }
    get duration() {
      return this._duration;
    }
    get ended() {
      return this._ended;
    }
    get droppedAttributesCount() {
      return this._droppedAttributesCount;
    }
    get droppedEventsCount() {
      return this._droppedEventsCount;
    }
    get droppedLinksCount() {
      return this._droppedLinksCount;
    }
    _isSpanEnded() {
      if (this._ended) {
        let A = Error(
          `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,
        );
        CL.diag.warn(
          `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,
          A,
        );
      }
      return this._ended;
    }
    _truncateToLimitUtil(A, B) {
      if (A.length <= B) return A;
      return A.substring(0, B);
    }
    _truncateToSize(A) {
      let B = this._attributeValueLengthLimit;
      if (B <= 0)
        return (
          CL.diag.warn(`Attribute value limit must be positive, got ${B}`),
          A
        );
      if (typeof A === "string") return this._truncateToLimitUtil(A, B);
      if (Array.isArray(A))
        return A.map((Q) =>
          typeof Q === "string" ? this._truncateToLimitUtil(Q, B) : Q,
        );
      return A;
    }
  }
  UM2.SpanImpl = zM2;
});
var EwA = z((qM2) => {
  Object.defineProperty(qM2, "__esModule", { value: !0 });
  qM2.SamplingDecision = void 0;
  var Sp5;
  (function (A) {
    ((A[(A.NOT_RECORD = 0)] = "NOT_RECORD"),
      (A[(A.RECORD = 1)] = "RECORD"),
      (A[(A.RECORD_AND_SAMPLED = 2)] = "RECORD_AND_SAMPLED"));
  })((Sp5 = qM2.SamplingDecision || (qM2.SamplingDecision = {})));
});
var V11 = z((LM2) => {
  Object.defineProperty(LM2, "__esModule", { value: !0 });
  LM2.AlwaysOffSampler = void 0;
  var yp5 = EwA();
  class NM2 {
    shouldSample() {
      return { decision: yp5.SamplingDecision.NOT_RECORD };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  LM2.AlwaysOffSampler = NM2;
});
var K11 = z((RM2) => {
  Object.defineProperty(RM2, "__esModule", { value: !0 });
  RM2.AlwaysOnSampler = void 0;
  var kp5 = EwA();
  class OM2 {
    shouldSample() {
      return { decision: kp5.SamplingDecision.RECORD_AND_SAMPLED };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  RM2.AlwaysOnSampler = OM2;
});
var Bt1 = z((SM2) => {
  Object.defineProperty(SM2, "__esModule", { value: !0 });
  SM2.ParentBasedSampler = void 0;
  var D11 = o2(),
    _p5 = M6(),
    PM2 = V11(),
    At1 = K11();
  class jM2 {
    _root;
    _remoteParentSampled;
    _remoteParentNotSampled;
    _localParentSampled;
    _localParentNotSampled;
    constructor(A) {
      if (((this._root = A.root), !this._root))
        ((0, _p5.globalErrorHandler)(
          Error("ParentBasedSampler must have a root sampler configured"),
        ),
          (this._root = new At1.AlwaysOnSampler()));
      ((this._remoteParentSampled =
        A.remoteParentSampled ?? new At1.AlwaysOnSampler()),
        (this._remoteParentNotSampled =
          A.remoteParentNotSampled ?? new PM2.AlwaysOffSampler()),
        (this._localParentSampled =
          A.localParentSampled ?? new At1.AlwaysOnSampler()),
        (this._localParentNotSampled =
          A.localParentNotSampled ?? new PM2.AlwaysOffSampler()));
    }
    shouldSample(A, B, Q, I, G, Z) {
      let Y = D11.trace.getSpanContext(A);
      if (!Y || !(0, D11.isSpanContextValid)(Y))
        return this._root.shouldSample(A, B, Q, I, G, Z);
      if (Y.isRemote) {
        if (Y.traceFlags & D11.TraceFlags.SAMPLED)
          return this._remoteParentSampled.shouldSample(A, B, Q, I, G, Z);
        return this._remoteParentNotSampled.shouldSample(A, B, Q, I, G, Z);
      }
      if (Y.traceFlags & D11.TraceFlags.SAMPLED)
        return this._localParentSampled.shouldSample(A, B, Q, I, G, Z);
      return this._localParentNotSampled.shouldSample(A, B, Q, I, G, Z);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  SM2.ParentBasedSampler = jM2;
});
var Qt1 = z((xM2) => {
  Object.defineProperty(xM2, "__esModule", { value: !0 });
  xM2.TraceIdRatioBasedSampler = void 0;
  var xp5 = o2(),
    kM2 = EwA();
  class _M2 {
    _ratio;
    _upperBound;
    constructor(A = 0) {
      ((this._ratio = A),
        (this._ratio = this._normalize(A)),
        (this._upperBound = Math.floor(this._ratio * 4294967295)));
    }
    shouldSample(A, B) {
      return {
        decision:
          (0, xp5.isValidTraceId)(B) && this._accumulate(B) < this._upperBound
            ? kM2.SamplingDecision.RECORD_AND_SAMPLED
            : kM2.SamplingDecision.NOT_RECORD,
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(A) {
      if (typeof A !== "number" || isNaN(A)) return 0;
      return A >= 1 ? 1 : A <= 0 ? 0 : A;
    }
    _accumulate(A) {
      let B = 0;
      for (let Q = 0; Q < A.length / 8; Q++) {
        let I = Q * 8,
          G = parseInt(A.slice(I, I + 8), 16);
        B = (B ^ G) >>> 0;
      }
      return B;
    }
  }
  xM2.TraceIdRatioBasedSampler = _M2;
});
var Zt1 = z((uM2) => {
  Object.defineProperty(uM2, "__esModule", { value: !0 });
  uM2.buildSamplerFromEnv = uM2.loadDefaultConfig = void 0;
  var Gt1 = o2(),
    Ay = M6(),
    bM2 = V11(),
    It1 = K11(),
    E11 = Bt1(),
    fM2 = Qt1(),
    By;
  (function (A) {
    ((A.AlwaysOff = "always_off"),
      (A.AlwaysOn = "always_on"),
      (A.ParentBasedAlwaysOff = "parentbased_always_off"),
      (A.ParentBasedAlwaysOn = "parentbased_always_on"),
      (A.ParentBasedTraceIdRatio = "parentbased_traceidratio"),
      (A.TraceIdRatio = "traceidratio"));
  })(By || (By = {}));
  var H11 = 1;
  function vp5() {
    return {
      sampler: gM2(),
      forceFlushTimeoutMillis: 30000,
      generalLimits: {
        attributeValueLengthLimit:
          (0, Ay.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
          1 / 0,
        attributeCountLimit:
          (0, Ay.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128,
      },
      spanLimits: {
        attributeValueLengthLimit:
          (0, Ay.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
          1 / 0,
        attributeCountLimit:
          (0, Ay.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? 128,
        linkCountLimit:
          (0, Ay.getNumberFromEnv)("OTEL_SPAN_LINK_COUNT_LIMIT") ?? 128,
        eventCountLimit:
          (0, Ay.getNumberFromEnv)("OTEL_SPAN_EVENT_COUNT_LIMIT") ?? 128,
        attributePerEventCountLimit:
          (0, Ay.getNumberFromEnv)(
            "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
          ) ?? 128,
        attributePerLinkCountLimit:
          (0, Ay.getNumberFromEnv)(
            "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
          ) ?? 128,
      },
    };
  }
  uM2.loadDefaultConfig = vp5;
  function gM2() {
    let A =
      (0, Ay.getStringFromEnv)("OTEL_TRACES_SAMPLER") ?? By.ParentBasedAlwaysOn;
    switch (A) {
      case By.AlwaysOn:
        return new It1.AlwaysOnSampler();
      case By.AlwaysOff:
        return new bM2.AlwaysOffSampler();
      case By.ParentBasedAlwaysOn:
        return new E11.ParentBasedSampler({ root: new It1.AlwaysOnSampler() });
      case By.ParentBasedAlwaysOff:
        return new E11.ParentBasedSampler({ root: new bM2.AlwaysOffSampler() });
      case By.TraceIdRatio:
        return new fM2.TraceIdRatioBasedSampler(hM2());
      case By.ParentBasedTraceIdRatio:
        return new E11.ParentBasedSampler({
          root: new fM2.TraceIdRatioBasedSampler(hM2()),
        });
      default:
        return (
          Gt1.diag.error(
            `OTEL_TRACES_SAMPLER value "${A}" invalid, defaulting to "${By.ParentBasedAlwaysOn}".`,
          ),
          new E11.ParentBasedSampler({ root: new It1.AlwaysOnSampler() })
        );
    }
  }
  uM2.buildSamplerFromEnv = gM2;
  function hM2() {
    let A = (0, Ay.getNumberFromEnv)("OTEL_TRACES_SAMPLER_ARG");
    if (A == null)
      return (
        Gt1.diag.error(
          `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${H11}.`,
        ),
        H11
      );
    if (A < 0 || A > 1)
      return (
        Gt1.diag.error(
          `OTEL_TRACES_SAMPLER_ARG=${A} was given, but it is out of range ([0..1]), defaulting to ${H11}.`,
        ),
        H11
      );
    return A;
  }
});
var Yt1 = z((cM2) => {
  Object.defineProperty(cM2, "__esModule", { value: !0 });
  cM2.reconfigureLimits =
    cM2.mergeConfig =
    cM2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT =
    cM2.DEFAULT_ATTRIBUTE_COUNT_LIMIT =
      void 0;
  var dM2 = Zt1(),
    z11 = M6();
  cM2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  cM2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0;
  function fp5(A) {
    let B = { sampler: (0, dM2.buildSamplerFromEnv)() },
      Q = (0, dM2.loadDefaultConfig)(),
      I = Object.assign({}, Q, B, A);
    return (
      (I.generalLimits = Object.assign(
        {},
        Q.generalLimits,
        A.generalLimits || {},
      )),
      (I.spanLimits = Object.assign({}, Q.spanLimits, A.spanLimits || {})),
      I
    );
  }
  cM2.mergeConfig = fp5;
  function hp5(A) {
    let B = Object.assign({}, A.spanLimits);
    return (
      (B.attributeCountLimit =
        A.spanLimits?.attributeCountLimit ??
        A.generalLimits?.attributeCountLimit ??
        (0, z11.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ??
        (0, z11.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ??
        cM2.DEFAULT_ATTRIBUTE_COUNT_LIMIT),
      (B.attributeValueLengthLimit =
        A.spanLimits?.attributeValueLengthLimit ??
        A.generalLimits?.attributeValueLengthLimit ??
        (0, z11.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
        (0, z11.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
        cM2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT),
      Object.assign({}, A, { spanLimits: B })
    );
  }
  cM2.reconfigureLimits = hp5;
});
var rM2 = z((aM2) => {
  Object.defineProperty(aM2, "__esModule", { value: !0 });
  aM2.BatchSpanProcessorBase = void 0;
  var d3A = o2(),
    Qy = M6();
  class nM2 {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _isExporting = !1;
    _finishedSpans = [];
    _timer;
    _shutdownOnce;
    _droppedSpansCount = 0;
    constructor(A, B) {
      if (
        ((this._exporter = A),
        (this._maxExportBatchSize =
          typeof B?.maxExportBatchSize === "number"
            ? B.maxExportBatchSize
            : ((0, Qy.getNumberFromEnv)("OTEL_BSP_MAX_EXPORT_BATCH_SIZE") ??
              512)),
        (this._maxQueueSize =
          typeof B?.maxQueueSize === "number"
            ? B.maxQueueSize
            : ((0, Qy.getNumberFromEnv)("OTEL_BSP_MAX_QUEUE_SIZE") ?? 2048)),
        (this._scheduledDelayMillis =
          typeof B?.scheduledDelayMillis === "number"
            ? B.scheduledDelayMillis
            : ((0, Qy.getNumberFromEnv)("OTEL_BSP_SCHEDULE_DELAY") ?? 5000)),
        (this._exportTimeoutMillis =
          typeof B?.exportTimeoutMillis === "number"
            ? B.exportTimeoutMillis
            : ((0, Qy.getNumberFromEnv)("OTEL_BSP_EXPORT_TIMEOUT") ?? 30000)),
        (this._shutdownOnce = new Qy.BindOnceFuture(this._shutdown, this)),
        this._maxExportBatchSize > this._maxQueueSize)
      )
        (d3A.diag.warn(
          "BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize",
        ),
          (this._maxExportBatchSize = this._maxQueueSize));
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) return this._shutdownOnce.promise;
      return this._flushAll();
    }
    onStart(A, B) {}
    onEnd(A) {
      if (this._shutdownOnce.isCalled) return;
      if ((A.spanContext().traceFlags & d3A.TraceFlags.SAMPLED) === 0) return;
      this._addToBuffer(A);
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return Promise.resolve()
        .then(() => {
          return this.onShutdown();
        })
        .then(() => {
          return this._flushAll();
        })
        .then(() => {
          return this._exporter.shutdown();
        });
    }
    _addToBuffer(A) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0)
          d3A.diag.debug("maxQueueSize reached, dropping spans");
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0)
        (d3A.diag.warn(
          `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`,
        ),
          (this._droppedSpansCount = 0));
      (this._finishedSpans.push(A), this._maybeStartTimer());
    }
    _flushAll() {
      return new Promise((A, B) => {
        let Q = [],
          I = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
        for (let G = 0, Z = I; G < Z; G++) Q.push(this._flushOneBatch());
        Promise.all(Q)
          .then(() => {
            A();
          })
          .catch(B);
      });
    }
    _flushOneBatch() {
      if ((this._clearTimer(), this._finishedSpans.length === 0))
        return Promise.resolve();
      return new Promise((A, B) => {
        let Q = setTimeout(() => {
          B(Error("Timeout"));
        }, this._exportTimeoutMillis);
        d3A.context.with((0, Qy.suppressTracing)(d3A.context.active()), () => {
          let I;
          if (this._finishedSpans.length <= this._maxExportBatchSize)
            ((I = this._finishedSpans), (this._finishedSpans = []));
          else I = this._finishedSpans.splice(0, this._maxExportBatchSize);
          let G = () =>
              this._exporter.export(I, (Y) => {
                if ((clearTimeout(Q), Y.code === Qy.ExportResultCode.SUCCESS))
                  A();
                else
                  B(Y.error ?? Error("BatchSpanProcessor: span export failed"));
              }),
            Z = null;
          for (let Y = 0, J = I.length; Y < J; Y++) {
            let X = I[Y];
            if (
              X.resource.asyncAttributesPending &&
              X.resource.waitForAsyncAttributes
            )
              ((Z ??= []), Z.push(X.resource.waitForAsyncAttributes()));
          }
          if (Z === null) G();
          else
            Promise.all(Z).then(G, (Y) => {
              ((0, Qy.globalErrorHandler)(Y), B(Y));
            });
        });
      });
    }
    _maybeStartTimer() {
      if (this._isExporting) return;
      let A = () => {
        ((this._isExporting = !0),
          this._flushOneBatch()
            .finally(() => {
              if (((this._isExporting = !1), this._finishedSpans.length > 0))
                (this._clearTimer(), this._maybeStartTimer());
            })
            .catch((B) => {
              ((this._isExporting = !1), (0, Qy.globalErrorHandler)(B));
            }));
      };
      if (this._finishedSpans.length >= this._maxExportBatchSize) return A();
      if (this._timer !== void 0) return;
      ((this._timer = setTimeout(() => A(), this._scheduledDelayMillis)),
        (0, Qy.unrefTimer)(this._timer));
    }
    _clearTimer() {
      if (this._timer !== void 0)
        (clearTimeout(this._timer), (this._timer = void 0));
    }
  }
  aM2.BatchSpanProcessorBase = nM2;
});
var AO2 = z((tM2) => {
  Object.defineProperty(tM2, "__esModule", { value: !0 });
  tM2.BatchSpanProcessor = void 0;
  var up5 = rM2();
  class oM2 extends up5.BatchSpanProcessorBase {
    onShutdown() {}
  }
  tM2.BatchSpanProcessor = oM2;
});
var YO2 = z((GO2) => {
  Object.defineProperty(GO2, "__esModule", { value: !0 });
  GO2.RandomIdGenerator = void 0;
  var mp5 = 8,
    QO2 = 16;
  class IO2 {
    generateTraceId = BO2(QO2);
    generateSpanId = BO2(mp5);
  }
  GO2.RandomIdGenerator = IO2;
  var U11 = Buffer.allocUnsafe(QO2);
  function BO2(A) {
    return function () {
      for (let Q = 0; Q < A / 4; Q++)
        U11.writeUInt32BE((Math.random() * 4294967296) >>> 0, Q * 4);
      for (let Q = 0; Q < A; Q++)
        if (U11[Q] > 0) break;
        else if (Q === A - 1) U11[A - 1] = 1;
      return U11.toString("hex", 0, A);
    };
  }
});
var JO2 = z((w11) => {
  Object.defineProperty(w11, "__esModule", { value: !0 });
  w11.RandomIdGenerator = w11.BatchSpanProcessor = void 0;
  var dp5 = AO2();
  Object.defineProperty(w11, "BatchSpanProcessor", {
    enumerable: !0,
    get: function () {
      return dp5.BatchSpanProcessor;
    },
  });
  var cp5 = YO2();
  Object.defineProperty(w11, "RandomIdGenerator", {
    enumerable: !0,
    get: function () {
      return cp5.RandomIdGenerator;
    },
  });
});
var Jt1 = z(($11) => {
  Object.defineProperty($11, "__esModule", { value: !0 });
  $11.RandomIdGenerator = $11.BatchSpanProcessor = void 0;
  var XO2 = JO2();
  Object.defineProperty($11, "BatchSpanProcessor", {
    enumerable: !0,
    get: function () {
      return XO2.BatchSpanProcessor;
    },
  });
  Object.defineProperty($11, "RandomIdGenerator", {
    enumerable: !0,
    get: function () {
      return XO2.RandomIdGenerator;
    },
  });
});
var VO2 = z((FO2) => {
  Object.defineProperty(FO2, "__esModule", { value: !0 });
  FO2.Tracer = void 0;
  var $V = o2(),
    q11 = M6(),
    ip5 = $M2(),
    np5 = Yt1(),
    ap5 = Jt1();
  class WO2 {
    _sampler;
    _generalLimits;
    _spanLimits;
    _idGenerator;
    instrumentationScope;
    _resource;
    _spanProcessor;
    constructor(A, B, Q, I) {
      let G = (0, np5.mergeConfig)(B);
      ((this._sampler = G.sampler),
        (this._generalLimits = G.generalLimits),
        (this._spanLimits = G.spanLimits),
        (this._idGenerator = B.idGenerator || new ap5.RandomIdGenerator()),
        (this._resource = Q),
        (this._spanProcessor = I),
        (this.instrumentationScope = A));
    }
    startSpan(A, B = {}, Q = $V.context.active()) {
      if (B.root) Q = $V.trace.deleteSpan(Q);
      let I = $V.trace.getSpan(Q);
      if ((0, q11.isTracingSuppressed)(Q))
        return (
          $V.diag.debug("Instrumentation suppressed, returning Noop Span"),
          $V.trace.wrapSpanContext($V.INVALID_SPAN_CONTEXT)
        );
      let G = I?.spanContext(),
        Z = this._idGenerator.generateSpanId(),
        Y,
        J,
        X;
      if (!G || !$V.trace.isSpanContextValid(G))
        J = this._idGenerator.generateTraceId();
      else ((J = G.traceId), (X = G.traceState), (Y = G));
      let W = B.kind ?? $V.SpanKind.INTERNAL,
        F = (B.links ?? []).map((w) => {
          return {
            context: w.context,
            attributes: (0, q11.sanitizeAttributes)(w.attributes),
          };
        }),
        C = (0, q11.sanitizeAttributes)(B.attributes),
        V = this._sampler.shouldSample(Q, J, A, W, C, F);
      X = V.traceState ?? X;
      let K =
          V.decision === $V.SamplingDecision.RECORD_AND_SAMPLED
            ? $V.TraceFlags.SAMPLED
            : $V.TraceFlags.NONE,
        D = { traceId: J, spanId: Z, traceFlags: K, traceState: X };
      if (V.decision === $V.SamplingDecision.NOT_RECORD)
        return (
          $V.diag.debug(
            "Recording is off, propagating context in a non-recording span",
          ),
          $V.trace.wrapSpanContext(D)
        );
      let E = (0, q11.sanitizeAttributes)(Object.assign(C, V.attributes));
      return new ip5.SpanImpl({
        resource: this._resource,
        scope: this.instrumentationScope,
        context: Q,
        spanContext: D,
        name: A,
        kind: W,
        links: F,
        parentSpanContext: Y,
        attributes: E,
        startTime: B.startTime,
        spanProcessor: this._spanProcessor,
        spanLimits: this._spanLimits,
      });
    }
    startActiveSpan(A, B, Q, I) {
      let G, Z, Y;
      if (arguments.length < 2) return;
      else if (arguments.length === 2) Y = B;
      else if (arguments.length === 3) ((G = B), (Y = Q));
      else ((G = B), (Z = Q), (Y = I));
      let J = Z ?? $V.context.active(),
        X = this.startSpan(A, G, J),
        W = $V.trace.setSpan(J, X);
      return $V.context.with(W, Y, void 0, X);
    }
    getGeneralLimits() {
      return this._generalLimits;
    }
    getSpanLimits() {
      return this._spanLimits;
    }
  }
  FO2.Tracer = WO2;
});
var HO2 = z((DO2) => {
  Object.defineProperty(DO2, "__esModule", { value: !0 });
  DO2.MultiSpanProcessor = void 0;
  var sp5 = M6();
  class KO2 {
    _spanProcessors;
    constructor(A) {
      this._spanProcessors = A;
    }
    forceFlush() {
      let A = [];
      for (let B of this._spanProcessors) A.push(B.forceFlush());
      return new Promise((B) => {
        Promise.all(A)
          .then(() => {
            B();
          })
          .catch((Q) => {
            ((0, sp5.globalErrorHandler)(
              Q || Error("MultiSpanProcessor: forceFlush failed"),
            ),
              B());
          });
      });
    }
    onStart(A, B) {
      for (let Q of this._spanProcessors) Q.onStart(A, B);
    }
    onEnd(A) {
      for (let B of this._spanProcessors) B.onEnd(A);
    }
    shutdown() {
      let A = [];
      for (let B of this._spanProcessors) A.push(B.shutdown());
      return new Promise((B, Q) => {
        Promise.all(A).then(() => {
          B();
        }, Q);
      });
    }
  }
  DO2.MultiSpanProcessor = KO2;
});
var qO2 = z((wO2) => {
  Object.defineProperty(wO2, "__esModule", { value: !0 });
  wO2.BasicTracerProvider = wO2.ForceFlushState = void 0;
  var rp5 = M6(),
    op5 = eIA(),
    tp5 = VO2(),
    ep5 = Zt1(),
    Al5 = HO2(),
    Bl5 = Yt1(),
    c3A;
  (function (A) {
    ((A[(A.resolved = 0)] = "resolved"),
      (A[(A.timeout = 1)] = "timeout"),
      (A[(A.error = 2)] = "error"),
      (A[(A.unresolved = 3)] = "unresolved"));
  })((c3A = wO2.ForceFlushState || (wO2.ForceFlushState = {})));
  class UO2 {
    _config;
    _tracers = new Map();
    _resource;
    _activeSpanProcessor;
    constructor(A = {}) {
      let B = (0, rp5.merge)(
        {},
        (0, ep5.loadDefaultConfig)(),
        (0, Bl5.reconfigureLimits)(A),
      );
      ((this._resource = B.resource ?? (0, op5.defaultResource)()),
        (this._config = Object.assign({}, B, { resource: this._resource })));
      let Q = [];
      if (A.spanProcessors?.length) Q.push(...A.spanProcessors);
      this._activeSpanProcessor = new Al5.MultiSpanProcessor(Q);
    }
    getTracer(A, B, Q) {
      let I = `${A}@${B || ""}:${Q?.schemaUrl || ""}`;
      if (!this._tracers.has(I))
        this._tracers.set(
          I,
          new tp5.Tracer(
            { name: A, version: B, schemaUrl: Q?.schemaUrl },
            this._config,
            this._resource,
            this._activeSpanProcessor,
          ),
        );
      return this._tracers.get(I);
    }
    forceFlush() {
      let A = this._config.forceFlushTimeoutMillis,
        B = this._activeSpanProcessor._spanProcessors.map((Q) => {
          return new Promise((I) => {
            let G,
              Z = setTimeout(() => {
                (I(
                  Error(
                    `Span processor did not completed within timeout period of ${A} ms`,
                  ),
                ),
                  (G = c3A.timeout));
              }, A);
            Q.forceFlush()
              .then(() => {
                if ((clearTimeout(Z), G !== c3A.timeout))
                  ((G = c3A.resolved), I(G));
              })
              .catch((Y) => {
                (clearTimeout(Z), (G = c3A.error), I(Y));
              });
          });
        });
      return new Promise((Q, I) => {
        Promise.all(B)
          .then((G) => {
            let Z = G.filter((Y) => Y !== c3A.resolved);
            if (Z.length > 0) I(Z);
            else Q();
          })
          .catch((G) => I([G]));
      });
    }
    shutdown() {
      return this._activeSpanProcessor.shutdown();
    }
  }
  wO2.BasicTracerProvider = UO2;
});
var OO2 = z((LO2) => {
  Object.defineProperty(LO2, "__esModule", { value: !0 });
  LO2.ConsoleSpanExporter = void 0;
  var Xt1 = M6();
  class NO2 {
    export(A, B) {
      return this._sendSpans(A, B);
    }
    shutdown() {
      return (this._sendSpans([]), this.forceFlush());
    }
    forceFlush() {
      return Promise.resolve();
    }
    _exportInfo(A) {
      return {
        resource: { attributes: A.resource.attributes },
        instrumentationScope: A.instrumentationScope,
        traceId: A.spanContext().traceId,
        parentSpanContext: A.parentSpanContext,
        traceState: A.spanContext().traceState?.serialize(),
        name: A.name,
        id: A.spanContext().spanId,
        kind: A.kind,
        timestamp: (0, Xt1.hrTimeToMicroseconds)(A.startTime),
        duration: (0, Xt1.hrTimeToMicroseconds)(A.duration),
        attributes: A.attributes,
        status: A.status,
        events: A.events,
        links: A.links,
      };
    }
    _sendSpans(A, B) {
      for (let Q of A) console.dir(this._exportInfo(Q), { depth: 3 });
      if (B) return B({ code: Xt1.ExportResultCode.SUCCESS });
    }
  }
  LO2.ConsoleSpanExporter = NO2;
});
var SO2 = z((PO2) => {
  Object.defineProperty(PO2, "__esModule", { value: !0 });
  PO2.InMemorySpanExporter = void 0;
  var RO2 = M6();
  class TO2 {
    _finishedSpans = [];
    _stopped = !1;
    export(A, B) {
      if (this._stopped)
        return B({
          code: RO2.ExportResultCode.FAILED,
          error: Error("Exporter has been stopped"),
        });
      (this._finishedSpans.push(...A),
        setTimeout(() => B({ code: RO2.ExportResultCode.SUCCESS }), 0));
    }
    shutdown() {
      return (
        (this._stopped = !0),
        (this._finishedSpans = []),
        this.forceFlush()
      );
    }
    forceFlush() {
      return Promise.resolve();
    }
    reset() {
      this._finishedSpans = [];
    }
    getFinishedSpans() {
      return this._finishedSpans;
    }
  }
  PO2.InMemorySpanExporter = TO2;
});
var xO2 = z((kO2) => {
  Object.defineProperty(kO2, "__esModule", { value: !0 });
  kO2.SimpleSpanProcessor = void 0;
  var Ql5 = o2(),
    N11 = M6();
  class yO2 {
    _exporter;
    _shutdownOnce;
    _pendingExports;
    constructor(A) {
      ((this._exporter = A),
        (this._shutdownOnce = new N11.BindOnceFuture(this._shutdown, this)),
        (this._pendingExports = new Set()));
    }
    async forceFlush() {
      if (
        (await Promise.all(Array.from(this._pendingExports)),
        this._exporter.forceFlush)
      )
        await this._exporter.forceFlush();
    }
    onStart(A, B) {}
    onEnd(A) {
      if (this._shutdownOnce.isCalled) return;
      if ((A.spanContext().traceFlags & Ql5.TraceFlags.SAMPLED) === 0) return;
      let B = this._doExport(A).catch((Q) => (0, N11.globalErrorHandler)(Q));
      (this._pendingExports.add(B),
        B.finally(() => this._pendingExports.delete(B)));
    }
    async _doExport(A) {
      if (A.resource.asyncAttributesPending)
        await A.resource.waitForAsyncAttributes?.();
      let B = await N11.internal._export(this._exporter, [A]);
      if (B.code !== N11.ExportResultCode.SUCCESS)
        throw (
          B.error ??
          Error(`SimpleSpanProcessor: span export failed (status ${B})`)
        );
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  kO2.SimpleSpanProcessor = yO2;
});
var hO2 = z((bO2) => {
  Object.defineProperty(bO2, "__esModule", { value: !0 });
  bO2.NoopSpanProcessor = void 0;
  class vO2 {
    onStart(A, B) {}
    onEnd(A) {}
    shutdown() {
      return Promise.resolve();
    }
    forceFlush() {
      return Promise.resolve();
    }
  }
  bO2.NoopSpanProcessor = vO2;
});
var uO2 = z((jz) => {
  Object.defineProperty(jz, "__esModule", { value: !0 });
  jz.SamplingDecision =
    jz.TraceIdRatioBasedSampler =
    jz.ParentBasedSampler =
    jz.AlwaysOnSampler =
    jz.AlwaysOffSampler =
    jz.NoopSpanProcessor =
    jz.SimpleSpanProcessor =
    jz.InMemorySpanExporter =
    jz.ConsoleSpanExporter =
    jz.RandomIdGenerator =
    jz.BatchSpanProcessor =
    jz.BasicTracerProvider =
      void 0;
  var Il5 = qO2();
  Object.defineProperty(jz, "BasicTracerProvider", {
    enumerable: !0,
    get: function () {
      return Il5.BasicTracerProvider;
    },
  });
  var gO2 = Jt1();
  Object.defineProperty(jz, "BatchSpanProcessor", {
    enumerable: !0,
    get: function () {
      return gO2.BatchSpanProcessor;
    },
  });
  Object.defineProperty(jz, "RandomIdGenerator", {
    enumerable: !0,
    get: function () {
      return gO2.RandomIdGenerator;
    },
  });
  var Gl5 = OO2();
  Object.defineProperty(jz, "ConsoleSpanExporter", {
    enumerable: !0,
    get: function () {
      return Gl5.ConsoleSpanExporter;
    },
  });
  var Zl5 = SO2();
  Object.defineProperty(jz, "InMemorySpanExporter", {
    enumerable: !0,
    get: function () {
      return Zl5.InMemorySpanExporter;
    },
  });
  var Yl5 = xO2();
  Object.defineProperty(jz, "SimpleSpanProcessor", {
    enumerable: !0,
    get: function () {
      return Yl5.SimpleSpanProcessor;
    },
  });
  var Jl5 = hO2();
  Object.defineProperty(jz, "NoopSpanProcessor", {
    enumerable: !0,
    get: function () {
      return Jl5.NoopSpanProcessor;
    },
  });
  var Xl5 = V11();
  Object.defineProperty(jz, "AlwaysOffSampler", {
    enumerable: !0,
    get: function () {
      return Xl5.AlwaysOffSampler;
    },
  });
  var Wl5 = K11();
  Object.defineProperty(jz, "AlwaysOnSampler", {
    enumerable: !0,
    get: function () {
      return Wl5.AlwaysOnSampler;
    },
  });
  var Fl5 = Bt1();
  Object.defineProperty(jz, "ParentBasedSampler", {
    enumerable: !0,
    get: function () {
      return Fl5.ParentBasedSampler;
    },
  });
  var Cl5 = Qt1();
  Object.defineProperty(jz, "TraceIdRatioBasedSampler", {
    enumerable: !0,
    get: function () {
      return Cl5.TraceIdRatioBasedSampler;
    },
  });
  var Vl5 = EwA();
  Object.defineProperty(jz, "SamplingDecision", {
    enumerable: !0,
    get: function () {
      return Vl5.SamplingDecision;
    },
  });
});
var cO2 = z((mO2) => {
  Object.defineProperty(mO2, "__esModule", { value: !0 });
  mO2.VERSION = void 0;
  mO2.VERSION = "0.204.0";
});
var aO2 = z((iO2) => {
  Object.defineProperty(iO2, "__esModule", { value: !0 });
  iO2.OTLPTraceExporter = void 0;
  var Dl5 = hS(),
    El5 = mS(),
    Hl5 = cO2(),
    pO2 = qc();
  class lO2 extends Dl5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, pO2.createOtlpHttpExportDelegate)(
          (0, pO2.convertLegacyHttpOptions)(A, "TRACES", "v1/traces", {
            "User-Agent": `OTel-OTLP-Exporter-JavaScript/${Hl5.VERSION}`,
            "Content-Type": "application/x-protobuf",
          }),
          El5.ProtobufTraceSerializer,
        ),
      );
    }
  }
  iO2.OTLPTraceExporter = lO2;
});
var sO2 = z((Wt1) => {
  Object.defineProperty(Wt1, "__esModule", { value: !0 });
  Wt1.OTLPTraceExporter = void 0;
  var zl5 = aO2();
  Object.defineProperty(Wt1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return zl5.OTLPTraceExporter;
    },
  });
});
var rO2 = z((Ft1) => {
  Object.defineProperty(Ft1, "__esModule", { value: !0 });
  Ft1.OTLPTraceExporter = void 0;
  var wl5 = sO2();
  Object.defineProperty(Ft1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return wl5.OTLPTraceExporter;
    },
  });
});
var oO2 = z((Ct1) => {
  Object.defineProperty(Ct1, "__esModule", { value: !0 });
  Ct1.OTLPTraceExporter = void 0;
  var ql5 = rO2();
  Object.defineProperty(Ct1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return ql5.OTLPTraceExporter;
    },
  });
});
var QR2 = z((AR2) => {
  Object.defineProperty(AR2, "__esModule", { value: !0 });
  AR2.OTLPTraceExporter = void 0;
  var tO2 = Y11(),
    Ll5 = mS(),
    Ml5 = hS();
  class eO2 extends Ml5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, tO2.createOtlpGrpcExportDelegate)(
          (0, tO2.convertLegacyOtlpGrpcOptions)(A, "TRACES"),
          Ll5.ProtobufTraceSerializer,
          "TraceExportService",
          "/opentelemetry.proto.collector.trace.v1.TraceService/Export",
        ),
      );
    }
  }
  AR2.OTLPTraceExporter = eO2;
});
var IR2 = z((Vt1) => {
  Object.defineProperty(Vt1, "__esModule", { value: !0 });
  Vt1.OTLPTraceExporter = void 0;
  var Ol5 = QR2();
  Object.defineProperty(Vt1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return Ol5.OTLPTraceExporter;
    },
  });
});
var YR2 = z((GR2) => {
  Object.defineProperty(GR2, "__esModule", { value: !0 });
  GR2.VERSION = void 0;
  GR2.VERSION = "0.204.0";
});
var CR2 = z((WR2) => {
  Object.defineProperty(WR2, "__esModule", { value: !0 });
  WR2.OTLPTraceExporter = void 0;
  var Tl5 = hS(),
    Pl5 = YR2(),
    jl5 = mS(),
    JR2 = qc();
  class XR2 extends Tl5.OTLPExporterBase {
    constructor(A = {}) {
      super(
        (0, JR2.createOtlpHttpExportDelegate)(
          (0, JR2.convertLegacyHttpOptions)(A, "TRACES", "v1/traces", {
            "User-Agent": `OTel-OTLP-Exporter-JavaScript/${Pl5.VERSION}`,
            "Content-Type": "application/json",
          }),
          jl5.JsonTraceSerializer,
        ),
      );
    }
  }
  WR2.OTLPTraceExporter = XR2;
});
var VR2 = z((Kt1) => {
  Object.defineProperty(Kt1, "__esModule", { value: !0 });
  Kt1.OTLPTraceExporter = void 0;
  var Sl5 = CR2();
  Object.defineProperty(Kt1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return Sl5.OTLPTraceExporter;
    },
  });
});
var KR2 = z((Dt1) => {
  Object.defineProperty(Dt1, "__esModule", { value: !0 });
  Dt1.OTLPTraceExporter = void 0;
  var kl5 = VR2();
  Object.defineProperty(Dt1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return kl5.OTLPTraceExporter;
    },
  });
});
var DR2 = z((Et1) => {
  Object.defineProperty(Et1, "__esModule", { value: !0 });
  Et1.OTLPTraceExporter = void 0;
  var xl5 = KR2();
  Object.defineProperty(Et1, "OTLPTraceExporter", {
    enumerable: !0,
    get: function () {
      return xl5.OTLPTraceExporter;
    },
  });
});
class Ht1 {
  error(A, ...B) {
    BA(Error(A), EM);
  }
  warn(A, ...B) {
    BA(Error(A), zJ0);
  }
  info(A, ...B) {
    return;
  }
  debug(A, ...B) {
    return;
  }
  verbose(A, ...B) {
    return;
  }
}
var ER2 = T(() => {
  c1();
});
async function fl5() {
  let A = $Y();
  if (A.error)
    throw (
      g(`Metrics opt-out check failed: ${A.error}`),
      Error(`Auth error: ${A.error}`)
    );
  let B = {
    "Content-Type": "application/json",
    "User-Agent": WW(),
    ...A.headers,
  };
  try {
    let I = await DB.get(
      "https://api.anthropic.com/api/claude_code/organizations/metrics_enabled",
      { headers: B, timeout: 5000 },
    );
    return (
      g(
        `Metrics opt-out API response: enabled=${I.data.metrics_logging_enabled}, vcsLinking=${I.data.vcs_account_linking_enabled}`,
      ),
      {
        enabled: I.data.metrics_logging_enabled,
        vcsAccountLinkingEnabled: I.data.vcs_account_linking_enabled,
        hasError: !1,
      }
    );
  } catch (Q) {
    return (
      g(
        `Failed to check metrics opt-out status: ${Q instanceof Error ? Q.message : String(Q)}`,
      ),
      BA(Q, wY0),
      { enabled: !1, vcsAccountLinkingEnabled: !1, hasError: !0 }
    );
  }
}
async function L11() {
  try {
    return await hl5();
  } catch (A) {
    return (
      g("Metrics check failed, defaulting to disabled"),
      { enabled: !1, vcsAccountLinkingEnabled: !1, hasError: !0 }
    );
  }
}
var bl5 = 3600000,
  hl5;
var zt1 = T(() => {
  _I();
  avA();
  yH();
  C0();
  c1();
  hl5 = nvA(fl5, bl5);
});
class wt1 {
  endpoint;
  timeout;
  pendingExports = [];
  isShutdown = !1;
  constructor(A = {}) {
    ((this.endpoint = "https://api.anthropic.com/api/claude_code/metrics"),
      (this.timeout = A.timeout || 5000));
  }
  async export(A, B) {
    if (this.isShutdown) {
      B({
        code: p3A.ExportResultCode.FAILED,
        error: Error("Exporter has been shutdown"),
      });
      return;
    }
    let Q = this.doExport(A, B);
    (this.pendingExports.push(Q),
      Q.finally(() => {
        let I = this.pendingExports.indexOf(Q);
        if (I > -1) this.pendingExports.splice(I, 1);
      }));
  }
  async doExport(A, B) {
    try {
      if (!(await L11()).enabled) {
        (g("Metrics export disabled by organization setting"),
          B({ code: p3A.ExportResultCode.SUCCESS }));
        return;
      }
      let I = this.transformMetricsForInternal(A),
        G = $Y();
      if (G.error) {
        (g(`Metrics export failed: ${G.error}`),
          B({ code: p3A.ExportResultCode.FAILED, error: Error(G.error) }));
        return;
      }
      let Z = {
          "Content-Type": "application/json",
          "User-Agent": WW(),
          ...G.headers,
        },
        Y = await DB.post(this.endpoint, I, {
          timeout: this.timeout,
          headers: Z,
        });
      (g("BigQuery metrics exported successfully"),
        g(`BigQuery API Response: ${JSON.stringify(Y.data, null, 2)}`),
        B({ code: p3A.ExportResultCode.SUCCESS }));
    } catch (Q) {
      (g(
        `BigQuery metrics export failed: ${Q instanceof Error ? Q.message : String(Q)}`,
      ),
        BA(Q, EM),
        B({
          code: p3A.ExportResultCode.FAILED,
          error: Q instanceof Error ? Q : Error("Unknown export error"),
        }));
    }
  }
  transformMetricsForInternal(A) {
    let B = A.resource.attributes,
      Q = {
        "service.name": B["service.name"] || "claude-code",
        "service.version": B["service.version"] || "unknown",
        "os.type": B["os.type"] || "unknown",
        "os.version": B["os.version"] || "unknown",
        "host.arch": B["host.arch"] || "unknown",
        "aggregation.temporality":
          this.selectAggregationTemporality() ===
          Ut1.AggregationTemporality.DELTA
            ? "delta"
            : "cumulative",
      };
    if (B["wsl.version"]) Q["wsl.version"] = B["wsl.version"];
    if (nB()) {
      Q["user.customer_type"] = "claude_ai";
      let G = i3();
      if (G) Q["user.subscription_type"] = G;
    } else Q["user.customer_type"] = "api";
    return {
      resource_attributes: Q,
      metrics: A.scopeMetrics.flatMap((G) =>
        G.metrics.map((Z) => ({
          name: Z.descriptor.name,
          description: Z.descriptor.description,
          unit: Z.descriptor.unit,
          data_points: this.extractDataPoints(Z),
        })),
      ),
    };
  }
  extractDataPoints(A) {
    return (A.dataPoints || [])
      .filter((Q) => typeof Q.value === "number")
      .map((Q) => ({
        attributes: this.convertAttributes(Q.attributes),
        value: Q.value,
        timestamp: this.hrTimeToISOString(
          Q.endTime || Q.startTime || [Date.now() / 1000, 0],
        ),
      }));
  }
  async shutdown() {
    ((this.isShutdown = !0),
      await this.forceFlush(),
      g("BigQuery metrics exporter shutdown complete"));
  }
  async forceFlush() {
    (await Promise.all(this.pendingExports),
      g("BigQuery metrics exporter flush complete"));
  }
  convertAttributes(A) {
    let B = {};
    if (A) {
      for (let [Q, I] of Object.entries(A))
        if (I !== void 0 && I !== null) B[Q] = String(I);
    }
    return B;
  }
  hrTimeToISOString(A) {
    let [B, Q] = A;
    return new Date(B * 1000 + Q / 1e6).toISOString();
  }
  selectAggregationTemporality() {
    return Ut1.AggregationTemporality.DELTA;
  }
}
var Ut1, p3A;
var HR2 = T(() => {
  _I();
  C0();
  c1();
  yH();
  zt1();
  F2();
  ((Ut1 = IA(Ec(), 1)), (p3A = IA(M6(), 1)));
});
function dl5() {
  if (N0()?.otelHeadersHelper)
    process.env.OTEL_EXPORTER_OTLP_HEADERS = Object.entries(SR2())
      .map(([B, Q]) => `${B}=${Q}`)
      .join(",");
  if (!process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE)
    process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE = "delta";
}
function cl5() {
  let A = (process.env.OTEL_METRICS_EXPORTER || "")
      .trim()
      .split(",")
      .filter(Boolean),
    B = parseInt(process.env.OTEL_METRIC_EXPORT_INTERVAL || gl5.toString()),
    Q = [];
  for (let I of A)
    if (I === "console") {
      let G = new M11.ConsoleMetricExporter(),
        Z = G.export.bind(G);
      ((G.export = (Y, J) => {
        if (Y.resource && Y.resource.attributes)
          (g(`
=== Resource Attributes ===`),
            g(JSON.stringify(Y.resource.attributes)),
            g(`===========================
`));
        return Z(Y, J);
      }),
        Q.push(G));
    } else if (I === "otlp") {
      let G =
          process.env.OTEL_EXPORTER_OTLP_METRICS_PROTOCOL?.trim() ||
          process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
        Z = Mt1();
      switch (G) {
        case "grpc":
          Q.push(new UR2.OTLPMetricExporter());
          break;
        case "http/json":
          Q.push(new wR2.OTLPMetricExporter(Z));
          break;
        case "http/protobuf":
          Q.push(new zR2.OTLPMetricExporter(Z));
          break;
        default:
          throw Error(
            `Unknown protocol set in OTEL_EXPORTER_OTLP_METRICS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${G}`,
          );
      }
    } else if (I === "prometheus") Q.push(new $R2.PrometheusExporter());
    else
      throw Error(
        `Unknown exporter type set in OTEL_EXPORTER_OTLP_METRICS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${I}`,
      );
  return Q.map((I) => {
    if ("export" in I)
      return new Lt1.PeriodicExportingMetricReader({
        exporter: I,
        exportIntervalMillis: B,
      });
    return I;
  });
}
function pl5() {
  let A = (process.env.OTEL_LOGS_EXPORTER || "")
      .trim()
      .split(",")
      .filter(Boolean),
    B = [];
  for (let Q of A)
    if (Q === "console") B.push(new i3A.ConsoleLogRecordExporter());
    else if (Q === "otlp") {
      let I =
          process.env.OTEL_EXPORTER_OTLP_LOGS_PROTOCOL?.trim() ||
          process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
        G = Mt1();
      switch (I) {
        case "grpc":
          B.push(new NR2.OTLPLogExporter());
          break;
        case "http/json":
          B.push(new LR2.OTLPLogExporter(G));
          break;
        case "http/protobuf":
          B.push(new qR2.OTLPLogExporter(G));
          break;
        default:
          throw Error(
            `Unknown protocol set in OTEL_EXPORTER_OTLP_LOGS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${I}`,
          );
      }
    } else
      throw Error(
        `Unknown exporter type set in OTEL_LOGS_EXPORTER env var: ${Q}`,
      );
  return B;
}
function ll5() {
  let A = (process.env.OTEL_TRACES_EXPORTER || "")
      .trim()
      .split(",")
      .filter(Boolean),
    B = [];
  for (let Q of A)
    if (Q === "console") B.push(new n3A.ConsoleSpanExporter());
    else if (Q === "otlp") {
      let I =
          process.env.OTEL_EXPORTER_OTLP_TRACES_PROTOCOL?.trim() ||
          process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
        G = Mt1();
      switch (I) {
        case "grpc":
          B.push(new OR2.OTLPTraceExporter());
          break;
        case "http/json":
          B.push(new RR2.OTLPTraceExporter(G));
          break;
        case "http/protobuf":
          B.push(new MR2.OTLPTraceExporter(G));
          break;
        default:
          throw Error(
            `Unknown protocol set in OTEL_EXPORTER_OTLP_TRACES_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${I}`,
          );
      }
    } else
      throw Error(
        `Unknown exporter type set in OTEL_TRACES_EXPORTER env var: ${Q}`,
      );
  return B;
}
function $t1() {
  return V0(process.env.CLAUDE_CODE_ENABLE_TELEMETRY);
}
function il5() {
  let A = new wt1();
  return new Lt1.PeriodicExportingMetricReader({
    exporter: A,
    exportIntervalMillis: 300000,
  });
}
function nl5() {
  let A = i3(),
    B = nB() && (A === "enterprise" || A === "team");
  return jR2() || B;
}
function TR2() {
  (dl5(), l3A.diag.setLogger(new Ht1(), l3A.DiagLogLevel.ERROR));
  let A = [];
  if ($t1()) A.push(...cl5());
  if (nl5()) A.push(il5());
  let B = EB(),
    Q = {
      [uc.ATTR_SERVICE_NAME]: "claude-code",
      [uc.ATTR_SERVICE_VERSION]: {
        ISSUES_EXPLAINER:
          "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.claude.com/s/claude-code",
        VERSION: "2.0.42",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
      }.VERSION,
    };
  if (B === "wsl") {
    let V = Ji();
    if (V) Q["wsl.version"] = V;
  }
  let I = OR.resourceFromAttributes(Q),
    G = OR.resourceFromAttributes(OR.osDetector.detect().attributes || {}),
    Z = OR.hostDetector.detect(),
    Y = Z.attributes?.[uc.SEMRESATTRS_HOST_ARCH]
      ? { [uc.SEMRESATTRS_HOST_ARCH]: Z.attributes[uc.SEMRESATTRS_HOST_ARCH] }
      : {},
    J = OR.resourceFromAttributes(Y),
    X = OR.resourceFromAttributes(OR.envDetector.detect().attributes || {}),
    W = I.merge(G).merge(J).merge(X),
    F = new M11.MeterProvider({ resource: W, views: [], readers: A });
  if ((H80(F), $t1())) {
    let V = pl5();
    if (V.length > 0) {
      let K = new i3A.LoggerProvider({
        resource: W,
        processors: V.map(
          (E) =>
            new i3A.BatchLogRecordProcessor(E, {
              scheduledDelayMillis: parseInt(
                process.env.OTEL_LOGS_EXPORT_INTERVAL || ul5.toString(),
              ),
            }),
        ),
      });
      (qt1.logs.setGlobalLoggerProvider(K), V80(K));
      let D = qt1.logs.getLogger(
        "com.anthropic.claude_code.events",
        {
          ISSUES_EXPLAINER:
            "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://docs.claude.com/s/claude-code",
          VERSION: "2.0.42",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
        }.VERSION,
      );
      (D80(D),
        process.on("beforeExit", async () => {
          await K?.forceFlush();
        }),
        process.on("exit", () => {
          K?.forceFlush();
        }));
    }
  }
  if ($t1()) {
    if (V0(process.env.ENABLE_ENHANCED_TELEMETRY_BETA)) {
      let V = ll5();
      if (V.length > 0) {
        let K = V.map(
            (E) =>
              new n3A.BatchSpanProcessor(E, {
                scheduledDelayMillis: parseInt(
                  process.env.OTEL_TRACES_EXPORT_INTERVAL || ml5.toString(),
                ),
              }),
          ),
          D = new n3A.BasicTracerProvider({ resource: W, spanProcessors: K });
        (l3A.trace.setGlobalTracerProvider(D), z80(D));
      }
    }
  }
  return (
    nY(async () => {
      let V = parseInt(
        process.env.CLAUDE_CODE_OTEL_SHUTDOWN_TIMEOUT_MS || "2000",
      );
      try {
        $aA();
        let K = [F.shutdown()],
          D = b91();
        if (D) K.push(D.shutdown());
        let E = f91();
        if (E) K.push(E.shutdown());
        await Promise.race([
          Promise.all(K),
          new Promise((H, w) =>
            setTimeout(() => w(Error("OpenTelemetry shutdown timeout")), V),
          ),
        ]);
      } catch (K) {
        if (K instanceof Error && K.message.includes("timeout"))
          g(
            `
OpenTelemetry telemetry flush timed out after ${V}ms

To resolve this issue, you can:
1. Increase the timeout by setting CLAUDE_CODE_OTEL_SHUTDOWN_TIMEOUT_MS env var (e.g., 5000 for 5 seconds)
2. Check if your OpenTelemetry backend is experiencing scalability issues
3. Disable OpenTelemetry by unsetting CLAUDE_CODE_ENABLE_TELEMETRY env var

Current timeout: ${V}ms
`,
            { level: "error" },
          );
        throw K;
      }
    }),
    F.getMeter(
      "com.anthropic.claude_code",
      {
        ISSUES_EXPLAINER:
          "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.claude.com/s/claude-code",
        VERSION: "2.0.42",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
      }.VERSION,
    )
  );
}
async function PR2() {
  let A = E80();
  if (!A) return;
  let B = parseInt(process.env.CLAUDE_CODE_OTEL_FLUSH_TIMEOUT_MS || "5000");
  try {
    let Q = [A.forceFlush()],
      I = b91();
    if (I) Q.push(I.forceFlush());
    let G = f91();
    if (G) Q.push(G.forceFlush());
    (await Promise.race([
      Promise.all(Q),
      new Promise((Z, Y) =>
        setTimeout(() => Y(Error("OpenTelemetry flush timeout")), B),
      ),
    ]),
      g("Telemetry flushed successfully"));
  } catch (Q) {
    if (Q instanceof Error && Q.message.includes("timeout"))
      g(
        `Telemetry flush timed out after ${B}ms. Some metrics may not be exported.`,
        { level: "warn" },
      );
    else
      g(
        `Telemetry flush failed: ${Q instanceof Error ? Q.message : String(Q)}`,
        { level: "error" },
      );
  }
}
function Mt1() {
  let A = ng(),
    B = wq(),
    Q = process.env.OTEL_EXPORTER_OTLP_ENDPOINT;
  if (!A || (Q && pvA(Q))) return B ? { httpAgentOptions: B } : {};
  return {
    httpAgentOptions: (G) => {
      return B
        ? new Nt1.HttpsProxyAgent(A, {
            cert: B.cert,
            key: B.key,
            passphrase: B.passphrase,
          })
        : new Nt1.HttpsProxyAgent(A);
    },
  };
}
var l3A,
  qt1,
  M11,
  zR2,
  UR2,
  wR2,
  $R2,
  Lt1,
  i3A,
  qR2,
  NR2,
  LR2,
  n3A,
  MR2,
  OR2,
  RR2,
  OR,
  uc,
  Nt1,
  gl5 = 60000,
  ul5 = 5000,
  ml5 = 5000;
var Ot1 = T(() => {
  ER2();
  HR2();
  BU();
  ag();
  F2();
  i0();
  ss();
  E5();
  F2();
  OQ();
  C0();
  Z2A();
  vB();
  ((l3A = IA(o2(), 1)),
    (qt1 = IA(Wn1(), 1)),
    (M11 = IA(Ec(), 1)),
    (zR2 = IA(UD2(), 1)),
    (UR2 = IA(yN2(), 1)),
    (wR2 = IA(xeA(), 1)),
    ($R2 = IA(uN2(), 1)),
    (Lt1 = IA(Ec(), 1)),
    (i3A = IA(lo1(), 1)),
    (qR2 = IA(rL2(), 1)),
    (NR2 = IA(QM2(), 1)),
    (LR2 = IA(KM2(), 1)),
    (n3A = IA(uO2(), 1)),
    (MR2 = IA(oO2(), 1)),
    (OR2 = IA(IR2(), 1)),
    (RR2 = IA(DR2(), 1)),
    (OR = IA(eIA(), 1)),
    (uc = IA(Wo(), 1)),
    (Nt1 = IA(XxA(), 1)));
});
async function Tt1({ clearOnboarding: A = !1 }) {
  (await PR2(), kR2(), kw().delete(), O11());
  let Q = L1();
  if (A) {
    if (
      ((Q.hasCompletedOnboarding = !1),
      (Q.subscriptionNoticeCount = 0),
      (Q.hasAvailableSubscription = !1),
      Q.customApiKeyResponses?.approved)
    )
      Q.customApiKeyResponses.approved = [];
  }
  ((Q.oauthAccount = void 0), n0(Q));
}
var Rt1,
  O11 = () => {
    (G5.cache?.clear?.(),
      JdA(),
      _R2(),
      Iy.cache?.clear?.(),
      Fc.cache?.clear?.());
  },
  yR2;
var R11 = T(() => {
  kB();
  Xx();
  nA();
  F2();
  dtA();
  Jx();
  f4();
  U2A();
  xY();
  iIA();
  Ot1();
  Rt1 = IA(KA(), 1);
  yR2 = {
    type: "local-jsx",
    name: "logout",
    description: "Sign out from your Anthropic account",
    isEnabled: () => !process.env.DISABLE_LOGOUT_COMMAND,
    isHidden: !1,
    async call() {
      (await NY(), await Tt1({ clearOnboarding: !0 }));
      let A = Rt1.createElement(
        U,
        null,
        "Successfully logged out from your Anthropic account.",
      );
      return (
        setTimeout(() => {
          D8(0, "logout");
        }, 200),
        A
      );
    },
    userFacingName() {
      return "logout";
    },
  };
});
class HwA {
  codeVerifier;
  authCodeListener = null;
  port = null;
  manualAuthCodeResolver = null;
  constructor() {
    this.codeVerifier = Q22();
  }
  async startOAuthFlow(A, B) {
    ((this.authCodeListener = new ri1()),
      (this.port = await this.authCodeListener.start()));
    let Q = I22(this.codeVerifier),
      I = G22(),
      G = {
        codeChallenge: Q,
        state: I,
        port: this.port,
        loginWithClaudeAi: B?.loginWithClaudeAi,
        inferenceOnly: B?.inferenceOnly,
        orgUUID: B?.orgUUID,
      },
      Z = ni1({ ...G, isManual: !0 }),
      Y = ni1({ ...G, isManual: !1 }),
      J = await this.waitForAuthorizationCode(I, async () => {
        (await A(Z), await d7(Y));
      }),
      X = this.authCodeListener?.hasPendingResponse() ?? !1;
    GA("tengu_oauth_auth_code_received", { automatic: X });
    try {
      let W = await nQ2(J, I, this.codeVerifier, this.port, !X, B?.expiresIn);
      await Tt1({ clearOnboarding: !1 });
      let F = await ai1(W.access_token);
      if (W.account)
        si1(
          W.account.uuid,
          W.account.email_address,
          W.organization?.uuid,
          F.displayName,
          F.billingType,
        );
      if (X) {
        let C = mtA(W.scope);
        this.authCodeListener?.handleSuccessRedirect(C);
      }
      return this.formatTokens(W, F.subscriptionType, F.rateLimitTier);
    } catch (W) {
      if (X) this.authCodeListener?.handleErrorRedirect();
      throw W;
    } finally {
      this.authCodeListener?.close();
    }
  }
  async waitForAuthorizationCode(A, B) {
    return new Promise((Q, I) => {
      ((this.manualAuthCodeResolver = Q),
        this.authCodeListener
          ?.waitForAuthorization(A, B)
          .then((G) => {
            ((this.manualAuthCodeResolver = null), Q(G));
          })
          .catch((G) => {
            ((this.manualAuthCodeResolver = null), I(G));
          }));
    });
  }
  handleManualAuthCodeInput(A) {
    if (this.manualAuthCodeResolver)
      (this.manualAuthCodeResolver(A.authorizationCode),
        (this.manualAuthCodeResolver = null),
        this.authCodeListener?.close());
  }
  formatTokens(A, B, Q) {
    return {
      accessToken: A.access_token,
      refreshToken: A.refresh_token,
      expiresAt: Date.now() + A.expires_in * 1000,
      scopes: mtA(A.scope),
      subscriptionType: B,
      rateLimitTier: Q,
    };
  }
  cleanup() {
    (this.authCodeListener?.close(), (this.manualAuthCodeResolver = null));
  }
}
var Pt1 = T(() => {
  rq();
  B22();
  Z22();
  VR();
  R11();
  H0();
});
function rl5(A, B) {
  return A + al5(sl5() * (B - A + 1));
}
var al5, sl5, xR2;
var vR2 = T(() => {
  ((al5 = Math.floor), (sl5 = Math.random));
  xR2 = rl5;
});
function ol5(A) {
  var B = A.length;
  return B ? A[xR2(0, B - 1)] : void 0;
}
var T11;
var jt1 = T(() => {
  vR2();
  T11 = ol5;
});
function tl5(A, B) {
  return Oe(B, function (Q) {
    return A[Q];
  });
}
var bR2;
var fR2 = T(() => {
  aNA();
  bR2 = tl5;
});
function el5(A) {
  return A == null ? [] : bR2(A, R$(A));
}
var hR2;
var gR2 = T(() => {
  fR2();
  Gl();
  hR2 = el5;
});
function Ai5(A) {
  return T11(hR2(A));
}
var uR2;
var mR2 = T(() => {
  jt1();
  gR2();
  uR2 = Ai5;
});
function Bi5(A) {
  var B = eI(A) ? T11 : uR2;
  return B(A);
}
var uo;
var P11 = T(() => {
  jt1();
  mR2();
  ED();
  uo = Bi5;
});
async function Qi5() {
  try {
    if (
      V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
      V0(process.env.CLAUDE_CODE_USE_VERTEX)
    )
      return !0;
    return (
      await DB.get("https://api.anthropic.com/api/hello", {
        timeout: 5000,
        headers: { "Cache-Control": "no-cache" },
      }),
      !0
    );
  } catch (A) {
    if (!(A instanceof OV0)) return !0;
    return A.code !== "EHOSTUNREACH";
  }
}
function St1() {
  let [A, B] = j11.useState(null);
  return (
    j11.useEffect(() => {
      let Q = !0;
      if (process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
      let I = async () => {
        if (!Q) return;
        let Z = await Qi5();
        if (Q) B(Z);
      };
      I();
      let G = setInterval(I, Ii5);
      return () => {
        ((Q = !1), clearInterval(G));
      };
    }, []),
    { isConnected: A }
  );
}
var j11,
  Ii5 = 30000;
var dR2 = T(() => {
  _I();
  vB();
  j11 = IA(KA(), 1);
});
class a3A {
  activeOperations = new Set();
  lastUserActivityTime = 0;
  lastCLIRecordedTime = Date.now();
  isCLIActive = !1;
  USER_ACTIVITY_TIMEOUT_MS = 5000;
  static instance = null;
  static getInstance() {
    if (!a3A.instance) a3A.instance = new a3A();
    return a3A.instance;
  }
  recordUserActivity() {
    if (!this.isCLIActive && this.lastUserActivityTime !== 0) {
      let B = (Date.now() - this.lastUserActivityTime) / 1000;
      if (B > 0) {
        let Q = v91();
        if (Q) {
          let I = this.USER_ACTIVITY_TIMEOUT_MS / 1000;
          if (B < I) Q.add(B, { type: "user" });
        }
      }
    }
    this.lastUserActivityTime = Date.now();
  }
  startCLIActivity(A) {
    if (this.activeOperations.has(A)) this.endCLIActivity(A);
    let B = this.activeOperations.size === 0;
    if ((this.activeOperations.add(A), B))
      ((this.isCLIActive = !0), (this.lastCLIRecordedTime = Date.now()));
  }
  endCLIActivity(A) {
    if ((this.activeOperations.delete(A), this.activeOperations.size === 0)) {
      let B = Date.now(),
        Q = (B - this.lastCLIRecordedTime) / 1000;
      if (Q > 0) {
        let I = v91();
        if (I) I.add(Q, { type: "cli" });
      }
      ((this.lastCLIRecordedTime = B), (this.isCLIActive = !1));
    }
  }
  async trackOperation(A, B) {
    this.startCLIActivity(A);
    try {
      return await B();
    } finally {
      this.endCLIActivity(A);
    }
  }
  getActivityStates() {
    return {
      isUserActive:
        (Date.now() - this.lastUserActivityTime) / 1000 <
        this.USER_ACTIVITY_TIMEOUT_MS / 1000,
      isCLIActive: this.isCLIActive,
      activeOperationCount: this.activeOperations.size,
    };
  }
}
var zwA;
var yt1 = T(() => {
  i0();
  zwA = a3A.getInstance();
});
function s3A({ todos: A, isStandalone: B = !1 }) {
  if (A.length === 0) return null;
  let Q = iF.createElement(
    iF.Fragment,
    null,
    A.map((I, G) => {
      let Z = I.status === "completed" ? E1.checkboxOn : E1.checkboxOff;
      return iF.createElement(
        S,
        { key: G },
        iF.createElement(U, { dimColor: I.status === "completed" }, Z, " "),
        iF.createElement(
          U,
          {
            bold: I.status === "in_progress",
            dimColor: I.status === "completed",
            strikethrough: I.status === "completed",
          },
          I.content,
        ),
      );
    }),
  );
  if (B)
    return iF.createElement(
      S,
      { flexDirection: "column", marginTop: 1, marginLeft: 2 },
      iF.createElement(U, { bold: !0, dimColor: !0 }, "Todos"),
      Q,
    );
  return iF.createElement(S, { flexDirection: "column" }, Q);
}
var iF;
var S11 = T(() => {
  nA();
  s2();
  iF = IA(KA(), 1);
});
function cR2({ streamMode: A }) {
  let [B, Q] = UwA.useState(null),
    [I, G] = UwA.useState(null);
  if (
    (UwA.useEffect(() => {
      if (A === "thinking" && B === null) Q(Date.now());
      else if (A !== "thinking" && B !== null) (G(Date.now() - B), Q(null));
    }, [A, B]),
    A === "thinking")
  )
    return RR.createElement(
      S,
      { marginTop: 1 },
      RR.createElement(U, { dimColor: !0 }, " Thinking"),
    );
  if (I !== null)
    return RR.createElement(
      S,
      { marginTop: 1 },
      RR.createElement(
        U,
        { dimColor: !0 },
        " Thought for ",
        Math.max(1, Math.round(I / 1000)),
        "s (",
        RR.createElement(U, { dimColor: !0, bold: !0 }, "ctrl+o"),
        " ",
        "to show thinking)",
      ),
    );
  return null;
}
var RR, UwA;
var pR2 = T(() => {
  nA();
  ((RR = IA(KA(), 1)), (UwA = IA(KA(), 1)));
});
function wwA() {
  if (process.env.TERM === "xterm-ghostty")
    return ["", "", "", "", "", "*"];
  return process.platform === "darwin"
    ? ["", "", "", "", "", ""]
    : ["", "", "*", "", "", ""];
}
function mo(A, B, Q) {
  return {
    r: Math.round(A.r + (B.r - A.r) * Q),
    g: Math.round(A.g + (B.g - A.g) * Q),
    b: Math.round(A.b + (B.b - A.b) * Q),
  };
}
function _t1({ char: A, flashOpacity: B }) {
  let G = mo({ r: 215, g: 119, b: 87 }, { r: 245, g: 149, b: 117 }, B);
  return kt1.createElement(
    jM,
    { transform: (Z) => iA.rgb(G.r, G.g, G.b)(Z) },
    A,
  );
}
var kt1;
var xt1 = T(() => {
  nA();
  f2();
  kt1 = IA(KA(), 1);
});
function vt1({
  message: A,
  mode: B,
  isConnected: Q,
  messageColor: I,
  glimmerIndex: G,
  flashOpacity: Z,
  shimmerColor: Y,
  stalledIntensity: J = 0,
}) {
  if (!A) return null;
  if (Q === !1) return vY.createElement(U, { color: I }, A, " ");
  if (J > 0) {
    let F = mo({ r: 215, g: 119, b: 87 }, { r: 171, g: 43, b: 63 }, J);
    return vY.createElement(
      vY.Fragment,
      null,
      vY.createElement(jM, { transform: (C) => iA.rgb(F.r, F.g, F.b)(C) }, A),
      vY.createElement(jM, { transform: (C) => iA.rgb(F.r, F.g, F.b)(C) }, " "),
    );
  }
  return vY.createElement(
    vY.Fragment,
    null,
    A.split("").map((X, W) => {
      if (B === "tool-use")
        return vY.createElement(_t1, { key: W, char: X, flashOpacity: Z });
      else
        return vY.createElement($2A, {
          key: W,
          char: X,
          index: W,
          glimmerIndex: G,
          messageColor: I,
          shimmerColor: Y,
        });
    }),
    vY.createElement(U, { color: I }, " "),
  );
}
var vY;
var lR2 = T(() => {
  nA();
  xt1();
  CbA();
  f2();
  vY = IA(KA(), 1);
});
function bt1({
  frame: A,
  messageColor: B,
  glimmerIndex: Q,
  stalledIntensity: I = 0,
  isConnected: G,
}) {
  let Z = nR2[A % nR2.length];
  if (G === !1)
    return gw.createElement(
      S,
      { flexWrap: "wrap", height: 1, width: 2 },
      gw.createElement(U, { color: B }, Z),
    );
  if (I > 0) {
    let X = mo({ r: 215, g: 119, b: 87 }, { r: 171, g: 43, b: 63 }, I);
    return gw.createElement(
      S,
      { flexWrap: "wrap", height: 1, width: 2 },
      gw.createElement(jM, { transform: (W) => iA.rgb(X.r, X.g, X.b)(W) }, Z),
    );
  }
  return gw.createElement(
    S,
    { flexWrap: "wrap", height: 1, width: 2 },
    gw.createElement(U, { color: B, dimColor: Q === -1 }, Z),
  );
}
var gw, iR2, nR2;
var aR2 = T(() => {
  nA();
  f2();
  ((gw = IA(KA(), 1)), (iR2 = wwA()), (nR2 = [...iR2, ...[...iR2].reverse()]));
});
function ft1(A) {
  let [B, Q] = sR2.useState(0);
  return (
    GJ(() => {
      if (A === "tool-use")
        Q(() => {
          let I = Date.now() / 1000;
          return (Math.sin(I * Math.PI) + 1) / 2;
        });
      else Q(0);
    }, 50),
    B
  );
}
var sR2;
var rR2 = T(() => {
  vU();
  sR2 = IA(KA(), 1);
});
function ht1(A, B = !1) {
  let [Q, I] = co.useState(0),
    [G, Z] = co.useState(0),
    Y = co.useRef(A);
  (co.useEffect(() => {
    if (A > Y.current) (I(0), Z(0), (Y.current = A));
  }, [A]),
    GJ(() => {
      if (A > 0 && A === Y.current && !B) I((W) => W + 100);
      else if (A === 0 || B) I(0);
    }, 100));
  let J = Q > 3000 && !B,
    X = J ? Math.min((Q - 3000) / 2000, 1) : 0;
  return (
    GJ(() => {
      Z((W) => {
        let F = X,
          C = F - W;
        if (Math.abs(C) < 0.01) return F;
        return W + C * 0.1;
      });
    }, 50),
    { isStalled: J, stalledIntensity: G }
  );
}
var co;
var oR2 = T(() => {
  vU();
  co = IA(KA(), 1);
});
var tR2 = T(() => {
  xt1();
  CbA();
  lR2();
  aR2();
  wU1();
  rR2();
  oR2();
});
function BT2({
  mode: A,
  loadingStartTime: B,
  spinnerTip: Q,
  currentResponseLength: I,
  overrideColor: G,
  overrideShimmerColor: Z,
  overrideMessage: Y,
  spinnerSuffix: J,
  verbose: X,
  todos: W,
  hasActiveTools: F = !1,
}) {
  let C = Ji5(),
    [V, K] = TR.useState(0),
    [D, E] = TR.useState(0),
    [H] = lB(),
    { isConnected: w } = St1(),
    { columns: L } = aB(),
    N = W?.find((rA) => rA.status === "in_progress"),
    $ = W?.find((rA) => rA.status === "pending"),
    O = TR.useMemo(() => uo(C), [C]),
    P = (Y ?? N?.activeForm ?? O) + "",
    { isStalled: k, stalledIntensity: b } = ht1(I, F),
    x = qFA(A, P, w, k),
    n = ft1(A),
    m = TR.useRef(I);
  (TR.useEffect(() => {
    let rA = "spinner-" + A;
    return (
      zwA.startCLIActivity(rA),
      () => {
        zwA.endCLIActivity(rA);
      }
    );
  }, [A]),
    TR.useEffect(() => {
      m.current = I;
    }, [I]),
    GJ(() => {
      if (!w) {
        K(4);
        return;
      }
      K((rA) => rA + 1);
    }, 120),
    GJ(() => {
      E((rA) => {
        let qA = m.current - rA;
        if (qA <= 0) return rA;
        let SA;
        if (qA < 70) SA = 1;
        else if (qA < 200) SA = Math.max(2, Math.ceil(qA * 0.08));
        else SA = 18;
        return Math.min(rA + SA, m.current);
      });
    }, 10));
  let o = Date.now() - B,
    l = P.length + 2,
    y = 16,
    c = L > l + 20,
    e = W && W.length > 0 && c && L > l + y + 25,
    QA = (X || o > Zi5) && c && L > l + y + (e ? 25 : 0) + 25,
    WA = [
      ...(c
        ? [
            NQ.createElement(
              S,
              { key: "esc" },
              NQ.createElement(U, { dimColor: !0, bold: !0 }, "esc", " "),
              NQ.createElement(U, { dimColor: !0 }, "to interrupt"),
            ),
          ]
        : []),
      ...(J ? [NQ.createElement(U, { dimColor: !0, key: "suffix" }, J)] : []),
      ...(e
        ? [
            NQ.createElement(
              U,
              { dimColor: !0, key: "todo" },
              NQ.createElement(U, { dimColor: !0, bold: !0 }, "ctrl+t"),
              " ",
              "to ",
              H.showExpandedTodos ? "hide" : "show",
              " todos",
            ),
          ]
        : []),
      ...(QA
        ? [
            NQ.createElement(U, { dimColor: !0, key: "elapsedTime" }, KU(o)),
            NQ.createElement(
              S,
              { flexDirection: "row", key: "tokens" },
              NQ.createElement(Yi5, { mode: A, key: "spinnerMode" }),
              NQ.createElement(
                U,
                { dimColor: !0 },
                yZ(Math.round(D / 4)),
                " tokens",
              ),
            ),
          ]
        : []),
    ];
  if (w === !1)
    WA.push(
      NQ.createElement(
        S,
        { key: "offline" },
        NQ.createElement(U, { color: "error", bold: !0 }, "offline"),
      ),
    );
  let JA = G ?? (w === !1 ? "inactive" : "claude"),
    wA = Z ?? "claudeShimmer",
    xA =
      WA.length > 0
        ? NQ.createElement(
            NQ.Fragment,
            null,
            NQ.createElement(U, { dimColor: !0 }, "("),
            wW(WA, (rA) =>
              NQ.createElement(
                U,
                { dimColor: !0, key: `separator-${rA}` },
                " ",
                "",
                " ",
              ),
            ),
            NQ.createElement(U, { dimColor: !0 }, ")"),
          )
        : null;
  return NQ.createElement(
    S,
    { flexDirection: "column", width: "100%", alignItems: "flex-start" },
    NQ.createElement(cR2, { streamMode: A }),
    NQ.createElement(
      S,
      { flexDirection: "row", flexWrap: "wrap", marginTop: 1, width: "100%" },
      NQ.createElement(bt1, {
        frame: V,
        messageColor: JA,
        glimmerIndex: x,
        stalledIntensity: b,
        isConnected: w,
      }),
      NQ.createElement(vt1, {
        message: P,
        mode: A,
        isConnected: w,
        messageColor: JA,
        glimmerIndex: x,
        flashOpacity: n,
        shimmerColor: wA,
        stalledIntensity: b,
      }),
      xA,
    ),
    H.showExpandedTodos && W && W.length > 0
      ? NQ.createElement(
          S,
          { width: "100%", flexDirection: "column" },
          NQ.createElement(j0, null, NQ.createElement(s3A, { todos: W })),
        )
      : $ || Q
        ? NQ.createElement(
            S,
            { width: "100%" },
            NQ.createElement(
              j0,
              null,
              NQ.createElement(
                U,
                { dimColor: !0 },
                $ ? `Next: ${$.content}` : `Tip: ${Q}`,
              ),
            ),
          )
        : null,
  );
}
function Yi5({ mode: A }) {
  switch (A) {
    case "tool-input":
    case "tool-use":
    case "responding":
    case "thinking":
      return NQ.createElement(
        S,
        { width: 2 },
        NQ.createElement(U, { dimColor: !0 }, E1.arrowDown),
      );
    case "requesting":
      return NQ.createElement(
        S,
        { width: 2 },
        NQ.createElement(U, { dimColor: !0 }, E1.arrowUp),
      );
  }
}
function E8() {
  let [A, B] = TR.useState(0),
    { isConnected: Q } = St1();
  return (
    GJ(() => {
      B((G) => (G + 1) % AT2.length);
    }, 120),
    NQ.createElement(
      S,
      { flexWrap: "wrap", height: 1, width: 2 },
      NQ.createElement(U, { color: Q === !1 ? "inactive" : "text" }, AT2[A]),
    )
  );
}
function Ji5() {
  return y11("tengu_spinner_words", Gi5).words;
}
var NQ,
  TR,
  eR2,
  AT2,
  Gi5,
  Zi5 = 30000;
var xX = T(() => {
  nA();
  P11();
  vU();
  s2();
  dR2();
  yt1();
  f4();
  L8();
  S11();
  c9();
  N8();
  pR2();
  tR2();
  ((NQ = IA(KA(), 1)),
    (TR = IA(KA(), 1)),
    (eR2 = wwA()),
    (AT2 = [...eR2, ...[...eR2].reverse()]),
    (Gi5 = {
      words: [
        "Accomplishing",
        "Actioning",
        "Actualizing",
        "Baking",
        "Booping",
        "Brewing",
        "Calculating",
        "Cerebrating",
        "Channelling",
        "Churning",
        "Clauding",
        "Coalescing",
        "Cogitating",
        "Computing",
        "Combobulating",
        "Concocting",
        "Considering",
        "Contemplating",
        "Cooking",
        "Crafting",
        "Creating",
        "Crunching",
        "Deciphering",
        "Deliberating",
        "Determining",
        "Discombobulating",
        "Doing",
        "Effecting",
        "Elucidating",
        "Enchanting",
        "Envisioning",
        "Finagling",
        "Flibbertigibbeting",
        "Forging",
        "Forming",
        "Frolicking",
        "Generating",
        "Germinating",
        "Hatching",
        "Herding",
        "Honking",
        "Ideating",
        "Imagining",
        "Incubating",
        "Inferring",
        "Manifesting",
        "Marinating",
        "Meandering",
        "Moseying",
        "Mulling",
        "Mustering",
        "Musing",
        "Noodling",
        "Percolating",
        "Perusing",
        "Philosophising",
        "Pontificating",
        "Pondering",
        "Processing",
        "Puttering",
        "Puzzling",
        "Reticulating",
        "Ruminating",
        "Scheming",
        "Schlepping",
        "Shimmying",
        "Simmering",
        "Smooshing",
        "Spelunking",
        "Spinning",
        "Stewing",
        "Sussing",
        "Synthesizing",
        "Thinking",
        "Tinkering",
        "Transmuting",
        "Unfurling",
        "Unravelling",
        "Vibing",
        "Wandering",
        "Whirring",
        "Wibbling",
        "Working",
        "Wrangling",
      ],
    }));
});
async function QT2(A, B, Q) {
  try {
    let I = $Y();
    if (I.error) return;
    let G = {
        "Content-Type": "application/json",
        "User-Agent": WW(),
        ...I.headers,
      },
      Z = {
        vcs_type: "github",
        vcs_host: B,
        vcs_username: A,
        git_user_email: Q,
      },
      Y = "https://api.anthropic.com/api/claude_code/link_vcs_account";
    await DB.post(Y, Z, { headers: G, timeout: 5000 });
  } catch (I) {}
}
var IT2 = T(() => {
  _I();
  yH();
});
async function Xi5() {
  try {
    let A = await r0("gh", ["auth", "status", "--active", "--json", "hosts"], {
      useCwd: !1,
      timeout: 5000,
    });
    if (A.code !== 0 || !A.stdout.trim()) return null;
    let Q = JSON.parse(A.stdout)?.hosts;
    if (!Q || typeof Q !== "object") return null;
    for (let [I, G] of Object.entries(Q)) {
      if (!Array.isArray(G) || G.length === 0) continue;
      let Z = G[0];
      if (Z?.login) return { username: Z.login, hostname: I };
    }
    return null;
  } catch (A) {
    return null;
  }
}
async function Wi5() {
  try {
    let A = await r0("git", ["config", "--get", "user.email"], {
      useCwd: !1,
      timeout: 5000,
    });
    if (A.code === 0 && A.stdout.trim()) return A.stdout.trim();
    return null;
  } catch (A) {
    return null;
  }
}
async function gt1() {
  if (mc()) return;
  if (!0) {
    let I = await L11();
    if (I.hasError || !I.vcsAccountLinkingEnabled) return;
  }
  let [B, Q] = await Promise.all([Xi5(), Wi5()]);
  if (B || Q) QT2(B?.username ?? "", B?.hostname ?? "", Q ?? "");
}
var GT2 = T(() => {
  Q5();
  IT2();
  F2();
  zt1();
});
function dc({
  onDone: A,
  startingMessage: B,
  mode: Q = "login",
  forceLoginMethod: I,
}) {
  let G = N0() || {},
    Z = I ?? G.forceLoginMethod,
    Y = G.forceLoginOrgUUID,
    J =
      Z === "claudeai"
        ? "Login method pre-selected: Subscription Plan (Claude Pro/Max)"
        : Z === "console"
          ? "Login method pre-selected: API Usage Billing (Anthropic Console)"
          : null,
    [X, W] = G2.useState(() => {
      if (Q === "setup-token") return { state: "ready_to_start" };
      if (Z === "claudeai" || Z === "console")
        return { state: "ready_to_start" };
      return { state: "idle" };
    }),
    [F, C] = G2.useState(""),
    [V, K] = G2.useState(0),
    [D] = G2.useState(() => new HwA()),
    [E, H] = G2.useState(() => {
      return Q === "setup-token" || Z === "claudeai";
    }),
    [w, L] = G2.useState(!1),
    N = aB().columns - ZT2.length - 1;
  (G2.useEffect(() => {
    if (Z === "claudeai") GA("tengu_oauth_claudeai_forced", {});
    else if (Z === "console") GA("tengu_oauth_console_forced", {});
  }, [Z]),
    G2.useEffect(() => {
      if (X.state === "about_to_retry")
        setTimeout(() => {
          W(X.nextState);
        }, 1000);
    }, [X]),
    h1(async (b, x) => {
      if (x.return) {
        if (X.state === "success" && Q !== "setup-token")
          (GA("tengu_oauth_success", { loginWithClaudeAi: E }), A());
        else if (X.state === "error" && X.toRetry)
          (C(""), W({ state: "about_to_retry", nextState: X.toRetry }));
      }
    }));
  async function $(b, x) {
    try {
      let [n, m] = b.split("#");
      if (!n || !m) {
        W({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: { state: "waiting_for_login", url: x },
        });
        return;
      }
      (GA("tengu_oauth_manual_entry", {}),
        D.handleManualAuthCodeInput({ authorizationCode: n, state: m }));
    } catch (n) {
      (BA(n instanceof Error ? n : Error(String(n)), SG0),
        W({
          state: "error",
          message: n.message,
          toRetry: { state: "waiting_for_login", url: x },
        }));
    }
  }
  let O = G2.useCallback(async () => {
      try {
        GA("tengu_oauth_flow_start", { loginWithClaudeAi: E });
        let b = await D.startOAuthFlow(
            async (n) => {
              (W({ state: "waiting_for_login", url: n }),
                setTimeout(() => L(!0), 3000));
            },
            {
              loginWithClaudeAi: E,
              inferenceOnly: Q === "setup-token",
              expiresIn: Q === "setup-token" ? 31536000 : void 0,
              orgUUID: Y,
            },
          ).catch((n) => {
            let m = n.message.includes("Token exchange failed");
            throw (
              W({
                state: "error",
                message: m
                  ? "Failed to exchange authorization code for access token. Please try again."
                  : n.message,
                toRetry:
                  Q === "setup-token"
                    ? { state: "ready_to_start" }
                    : { state: "idle" },
              }),
              GA("tengu_oauth_token_exchange_error", { error: n.message }),
              n
            );
          }),
          x = qwA(b);
        if (x.warning)
          GA("tengu_oauth_storage_warning", { warning: x.warning });
        if (Q === "setup-token") W({ state: "success", token: b.accessToken });
        else if (
          (await sQ2(b.accessToken).catch((n) => {
            throw (
              W({
                state: "error",
                message: "Failed to fetch user roles: " + n.message,
                toRetry: { state: "idle" },
              }),
              GA("tengu_oauth_user_roles_error", { error: n.message }),
              n
            );
          }),
          sv(b.scopes))
        )
          (await KzB(),
            O11(),
            W({ state: "success" }),
            Tr({
              message: "Claude Code login successful",
              notificationType: "auth_success",
            }),
            gt1());
        else if (
          (W({ state: "creating_api_key" }),
          await rQ2(b.accessToken).catch((m) => {
            throw (
              W({
                state: "error",
                message: "Failed to create API key: " + m.message,
                toRetry: { state: "idle" },
              }),
              GA("tengu_oauth_api_key_error", { error: m.message }),
              m
            );
          }))
        )
          (O11(),
            W({ state: "success" }),
            Tr({
              message: "Claude Code login successful",
              notificationType: "auth_success",
            }),
            gt1());
        else
          (W({
            state: "error",
            message:
              "Unable to create API key. The server accepted the request but didn't return a key.",
            toRetry: { state: "idle" },
          }),
            GA("tengu_oauth_api_key_error", {
              error: "server_returned_no_key",
            }));
      } catch (b) {
        let x = b.message;
        GA("tengu_oauth_error", { error: x });
      }
    }, [D, L, E, Q, Y]),
    P = G2.useRef(!1);
  (G2.useEffect(() => {
    if (X.state === "ready_to_start" && !P.current)
      ((P.current = !0),
        process.nextTick(() => {
          (O(), (P.current = !1));
        }));
  }, [X.state, O]),
    G2.useEffect(() => {
      if (Q === "setup-token" && X.state === "success") {
        let b = setTimeout(async () => {
          (GA("tengu_oauth_success", { loginWithClaudeAi: E }), A());
        }, 500);
        return () => clearTimeout(b);
      }
    }, [Q, X, E, A]),
    G2.useEffect(() => {
      return () => {
        D.cleanup();
      };
    }, [D]));
  function k() {
    switch (X.state) {
      case "idle":
        return G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1, marginTop: 1 },
          G2.default.createElement(
            U,
            { bold: !0 },
            B
              ? B
              : "Claude Code can be used with your Claude subscription or billed based on API usage through your Console account.",
          ),
          G2.default.createElement(U, null, "Select login method:"),
          G2.default.createElement(
            S,
            null,
            G2.default.createElement($0, {
              options: [
                {
                  label: `Claude account with subscription  ${iA.dim("Pro, Max, Team, or Enterprise")}
`,
                  value: "claudeai",
                },
                {
                  label: `Anthropic Console account  ${iA.dim("API usage billing")}
`,
                  value: "console",
                },
              ],
              onCancel: () => {},
              onChange: (b) => {
                if ((W({ state: "ready_to_start" }), b === "claudeai"))
                  (GA("tengu_oauth_claudeai_selected", {}), H(!0));
                else (GA("tengu_oauth_console_selected", {}), H(!1));
              },
            }),
          ),
        );
      case "waiting_for_login":
        return G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          J &&
            G2.default.createElement(
              S,
              null,
              G2.default.createElement(U, { dimColor: !0 }, J),
            ),
          !w &&
            G2.default.createElement(
              S,
              null,
              G2.default.createElement(E8, null),
              G2.default.createElement(U, null, "Opening browser to sign in"),
            ),
          w &&
            G2.default.createElement(
              S,
              null,
              G2.default.createElement(U, null, ZT2),
              G2.default.createElement(O4, {
                value: F,
                onChange: C,
                onSubmit: (b) => $(b, X.url),
                cursorOffset: V,
                onChangeCursorOffset: K,
                columns: N,
              }),
            ),
        );
      case "creating_api_key":
        return G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          G2.default.createElement(
            S,
            null,
            G2.default.createElement(E8, null),
            G2.default.createElement(
              U,
              null,
              "Creating API key for Claude Code",
            ),
          ),
        );
      case "about_to_retry":
        return G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          G2.default.createElement(U, { color: "permission" }, "Retrying"),
        );
      case "success":
        return G2.default.createElement(
          S,
          { flexDirection: "column" },
          Q === "setup-token" && X.token
            ? null
            : G2.default.createElement(
                G2.default.Fragment,
                null,
                HG()?.emailAddress
                  ? G2.default.createElement(
                      U,
                      { dimColor: !0 },
                      "Logged in as",
                      " ",
                      G2.default.createElement(U, null, HG()?.emailAddress),
                    )
                  : null,
                G2.default.createElement(
                  U,
                  { color: "success" },
                  "Login successful. Press ",
                  G2.default.createElement(U, { bold: !0 }, "Enter"),
                  " to continue",
                ),
              ),
        );
      case "error":
        return G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          G2.default.createElement(
            U,
            { color: "error" },
            "OAuth error: ",
            X.message,
          ),
          X.toRetry &&
            G2.default.createElement(
              S,
              { marginTop: 1 },
              G2.default.createElement(
                U,
                { color: "permission" },
                "Press ",
                G2.default.createElement(U, { bold: !0 }, "Enter"),
                " to retry.",
              ),
            ),
        );
      default:
        return null;
    }
  }
  return G2.default.createElement(
    S,
    { flexDirection: "column", gap: 1 },
    X.state === "waiting_for_login" &&
      w &&
      G2.default.createElement(
        S,
        { flexDirection: "column", key: "urlToCopy", gap: 1, paddingBottom: 1 },
        G2.default.createElement(
          S,
          { paddingX: 1 },
          G2.default.createElement(
            U,
            { dimColor: !0 },
            "Browser didn't open? Use the url below to sign in:",
          ),
        ),
        G2.default.createElement(
          S,
          { width: 1000 },
          G2.default.createElement(U, { dimColor: !0 }, X.url),
        ),
      ),
    Q === "setup-token" &&
      X.state === "success" &&
      X.token &&
      G2.default.createElement(
        S,
        { key: "tokenOutput", flexDirection: "column", gap: 1, paddingTop: 1 },
        G2.default.createElement(
          U,
          { color: "success" },
          " Long-lived authentication token created successfully!",
        ),
        G2.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          G2.default.createElement(
            U,
            null,
            "Your OAuth token (valid for 1 year):",
          ),
          G2.default.createElement(
            S,
            { width: 1000 },
            G2.default.createElement(U, { color: "warning" }, X.token),
          ),
          G2.default.createElement(
            U,
            { dimColor: !0 },
            "Store this token securely. You won't be able to see it again.",
          ),
          G2.default.createElement(
            U,
            { dimColor: !0 },
            "Use this token by setting: export CLAUDE_CODE_OAUTH_TOKEN=<token>",
          ),
        ),
      ),
    G2.default.createElement(
      S,
      { paddingLeft: 1, flexDirection: "column", gap: 1 },
      k(),
    ),
  );
}
var G2,
  ZT2 = "Paste code here if prompted > ";
var $wA = T(() => {
  nA();
  rG();
  Pt1();
  VR();
  F2();
  H0();
  N8();
  c1();
  xX();
  nrA();
  Z5();
  R11();
  f2();
  OQ();
  Y9();
  GT2();
  G2 = IA(KA(), 1);
});
function YT2({ onStashAndContinue: A, onCancel: B }) {
  let [Q, I] = L3.useState(null),
    G = Q !== null ? [...Q.tracked, ...Q.untracked] : [],
    [Z, Y] = L3.useState(!0),
    [J, X] = L3.useState(!1),
    [W, F] = L3.useState(null);
  L3.useEffect(() => {
    (async () => {
      try {
        let E = await cU1();
        I(E);
      } catch (E) {
        let H = E instanceof Error ? E.message : String(E);
        (g(`Error getting changed files: ${H}`, { level: "error" }),
          F("Failed to get changed files"));
      } finally {
        Y(!1);
      }
    })();
  }, []);
  let C = async () => {
      X(!0);
      try {
        if (
          (g("Stashing changes before teleport..."),
          await NUB("Teleport auto-stash"))
        )
          (g("Successfully stashed changes"), A());
        else F("Failed to stash changes");
      } catch (D) {
        let E = D instanceof Error ? D.message : String(D);
        (g(`Error stashing changes: ${E}`, { level: "error" }),
          F("Failed to stash changes"));
      } finally {
        X(!1);
      }
    },
    V = (D) => {
      if (D === "stash") C();
      else B();
    };
  if (Z)
    return L3.default.createElement(
      S,
      { flexDirection: "column", padding: 1 },
      L3.default.createElement(
        S,
        { marginBottom: 1 },
        L3.default.createElement(E8, null),
        L3.default.createElement(U, null, " Checking git status", E1.ellipsis),
      ),
    );
  if (W)
    return L3.default.createElement(
      S,
      { flexDirection: "column", padding: 1 },
      L3.default.createElement(U, { bold: !0, color: "error" }, "Error: ", W),
      L3.default.createElement(
        S,
        { marginTop: 1 },
        L3.default.createElement(U, { dimColor: !0 }, "Press "),
        L3.default.createElement(U, { bold: !0 }, "Escape"),
        L3.default.createElement(U, { dimColor: !0 }, " to cancel"),
      ),
    );
  let K = G.length > 8;
  return L3.default.createElement(
    Wc,
    { title: "Working Directory Has Changes", onCancel: B, borderDimColor: !0 },
    L3.default.createElement(
      U,
      null,
      "Teleport will switch git branches. The following changes were found:",
    ),
    L3.default.createElement(
      S,
      { flexDirection: "column", paddingLeft: 2 },
      G.length > 0
        ? K
          ? L3.default.createElement(U, null, G.length, " files changed")
          : G.map((D, E) => L3.default.createElement(U, { key: E }, D))
        : L3.default.createElement(U, { dimColor: !0 }, "No changes detected"),
    ),
    L3.default.createElement(
      U,
      null,
      "Would you like to stash these changes and continue with teleport?",
    ),
    J
      ? L3.default.createElement(
          S,
          null,
          L3.default.createElement(E8, null),
          L3.default.createElement(U, null, " Stashing changes..."),
        )
      : L3.default.createElement($0, {
          options: [
            { label: "Stash changes and continue", value: "stash" },
            { label: "Exit", value: "exit" },
          ],
          onChange: V,
          onCancel: () => B(),
        }),
  );
}
var L3;
var JT2 = T(() => {
  nA();
  vC();
  C0();
  xX();
  R5();
  s2();
  lzA();
  L3 = IA(KA(), 1);
});
async function Fb() {
  let A = G0();
  if (NwA.has(A)) return NwA.get(A) ?? null;
  try {
    let B = await dU1();
    if ((g(`Git remote URL: ${B}`), !B))
      return (g("No git remote URL found"), NwA.set(A, null), null);
    let Q = r3A(B);
    return (g(`Parsed repository: ${Q} from URL: ${B}`), NwA.set(A, Q), Q);
  } catch (B) {
    return (g(`Error detecting repository: ${B}`), NwA.set(A, null), null);
  }
}
function r3A(A) {
  let B = A.trim(),
    Q = [
      /github\.com[:/]([^/]+\/[^/.]+?)(\.git)?$/,
      /github\.com[:/]([^/]+\/[^/.]+)$/,
    ];
  for (let I of Q) {
    let G = B.match(I);
    if (G && G[1]) return (g(`Parsed repository: ${G[1]} from ${B}`), G[1]);
  }
  if (!B.includes("://") && !B.includes("@") && B.includes("/")) {
    let I = B.split("/");
    if (I.length === 2 && I[0] && I[1]) {
      let G = I[1].replace(/\.git$/, "");
      return `${I[0]}/${G}`;
    }
  }
  return (g(`Could not parse repository from: ${B}`), null);
}
var NwA;
var o3A = T(() => {
  vC();
  C0();
  V2();
  NwA = new Map();
});
import { randomUUID as Fi5 } from "crypto";
async function k11() {
  let A = G5()?.accessToken;
  if (A === void 0)
    throw Error(
      "Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.",
    );
  let B = await rv();
  if (!B) throw Error("Unable to get organization UUID");
  return { accessToken: A, orgUUID: B };
}
async function XT2() {
  let { accessToken: A, orgUUID: B } = await k11(),
    Q = `${G4().BASE_API_URL}/v1/sessions`;
  try {
    let I = { ...VL(A), "x-organization-uuid": B },
      G = await DB.get(Q, { headers: I });
    if (G.status !== 200)
      throw Error(`Failed to fetch code sessions: ${G.statusText}`);
    return G.data.data.map((Y) => {
      let J = Y.session_context.sources.find(
          (W) => W.type === "git_repository",
        ),
        X = null;
      if (J?.url) {
        let W = r3A(J.url);
        if (W) {
          let [F, C] = W.split("/");
          if (F && C)
            X = {
              name: C,
              owner: { login: F },
              default_branch: J.revision || void 0,
            };
        }
      }
      return {
        id: Y.id,
        title: Y.title || "Untitled",
        description: "",
        status: Y.session_status,
        repo: X,
        turns: [],
        created_at: Y.created_at,
        updated_at: Y.updated_at,
      };
    });
  } catch (I) {
    let G = I instanceof Error ? I : Error(String(I));
    throw (BA(G, QH), I);
  }
}
function VL(A) {
  return {
    Authorization: `Bearer ${A}`,
    "Content-Type": "application/json",
    "anthropic-version": "2023-06-01",
  };
}
async function WT2(A, B) {
  try {
    let { accessToken: Q, orgUUID: I } = await k11(),
      G = `${G4().BASE_API_URL}/v1/sessions/${A}/events`,
      Z = { ...VL(Q), "x-organization-uuid": I },
      J = {
        events: [
          {
            uuid: Fi5(),
            session_id: A,
            type: "user",
            parent_tool_use_id: null,
            message: { role: "user", content: B },
          },
        ],
      },
      X = await DB.post(G, J, { headers: Z, validateStatus: (W) => W < 500 });
    if (X.status === 200 || X.status === 201) return !0;
    return !1;
  } catch {
    return !1;
  }
}
var Ci5, OD7;
var po = T(() => {
  QW();
  F2();
  _I();
  VR();
  c1();
  o3A();
  e2();
  ((Ci5 = PQ.object({
    id: PQ.string(),
    title: PQ.string(),
    description: PQ.string(),
    status: PQ.enum([
      "idle",
      "working",
      "waiting",
      "completed",
      "archived",
      "cancelled",
      "rejected",
    ]),
    repo: PQ.object({
      name: PQ.string(),
      owner: PQ.object({ login: PQ.string() }),
      default_branch: PQ.string().optional(),
    }).nullable(),
    turns: PQ.array(PQ.string()),
    created_at: PQ.string(),
    updated_at: PQ.string(),
  })),
    (OD7 = PQ.array(Ci5)));
});
async function _11() {
  let A = G5()?.accessToken;
  if (!A)
    throw Error(
      "Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.",
    );
  let B = await rv();
  if (!B) throw Error("Unable to get organization UUID");
  let Q = `${G4().BASE_API_URL}/v1/environment_providers`;
  try {
    let I = { ...VL(A), "x-organization-uuid": B },
      G = await DB.get(Q, { headers: I, timeout: 15000 });
    if (G.status !== 200)
      throw Error(`Failed to fetch environments: ${G.status} ${G.statusText}`);
    return G.data.environments;
  } catch (I) {
    let G = I instanceof Error ? I : Error(String(I));
    throw (BA(G, QH), Error(`Failed to fetch environments: ${G.message}`));
  }
}
var ut1 = T(() => {
  _I();
  QW();
  F2();
  VR();
  c1();
  po();
});
async function x11() {
  if (!nB()) return !1;
  return qa();
}
async function FT2() {
  return await P2A();
}
async function CT2() {
  try {
    return (await _11()).length > 0;
  } catch (A) {
    return (
      g(
        `checkHasRemoteEnvironment failed: ${A instanceof Error ? A.message : String(A)}`,
      ),
      !1
    );
  }
}
async function VT2() {
  return (await Fb()) !== null;
}
async function KT2(A, B) {
  try {
    let Q = G5()?.accessToken;
    if (!Q)
      return (
        g(
          "checkGithubAppInstalled: No access token found, assuming app not installed",
        ),
        !1
      );
    let I = await rv();
    if (!I)
      return (
        g(
          "checkGithubAppInstalled: No org UUID found, assuming app not installed",
        ),
        !1
      );
    let G = `${G4().BASE_API_URL}/api/oauth/organizations/${I}/code/repos/${A}/${B}`,
      Z = { ...VL(Q), "x-organization-uuid": I };
    g(`Checking GitHub app installation for ${A}/${B}`);
    let Y = await DB.get(G, { headers: Z, timeout: 15000 });
    if (Y.status === 200 && Y.data.status) {
      let J = Y.data.status.app_installed;
      return (g(`GitHub app ${J ? "is" : "is not"} installed on ${A}/${B}`), J);
    }
    return (
      g(`checkGithubAppInstalled: Unexpected response status ${Y.status}`),
      !1
    );
  } catch (Q) {
    if (DB.isAxiosError(Q)) {
      let I = Q.response?.status;
      if (I && I >= 400 && I < 500)
        return (
          g(
            `checkGithubAppInstalled: Got ${I} error, app likely not installed on ${A}/${B}`,
          ),
          !1
        );
    }
    return (
      g(
        `checkGithubAppInstalled error: ${Q instanceof Error ? Q.message : String(Q)}`,
      ),
      !1
    );
  }
}
var mt1 = T(() => {
  vC();
  F2();
  o3A();
  ut1();
  VR();
  QW();
  po();
  _I();
  C0();
});
function v11({ onComplete: A, errorsToIgnore: B = new Set() }) {
  let [Q, I] = vX.useState(null),
    [G, Z] = vX.useState(!1),
    Y = vX.useCallback(async () => {
      let V = await dt1(),
        K = new Set(Array.from(V).filter((D) => !B.has(D)));
      if (K.size === 0) {
        A();
        return;
      }
      if (K.has("needsLogin")) I("needsLogin");
      else if (K.has("needsGitStash")) I("needsGitStash");
    }, [A, B]);
  vX.useEffect(() => {
    Y();
  }, [Y]);
  let J = vX.useCallback(() => {
      D8(0);
    }, []),
    X = vX.useCallback(() => {
      (Z(!1), Y());
    }, [Y]),
    W = vX.useCallback(() => {
      Z(!0);
    }, [Z]),
    F = vX.useCallback(
      (V) => {
        if (V === "login") W();
        else J();
      },
      [W, J],
    ),
    C = vX.useCallback(() => {
      Y();
    }, [Y]);
  if (!Q) return null;
  switch (Q) {
    case "needsGitStash":
      return vX.default.createElement(YT2, {
        onStashAndContinue: C,
        onCancel: J,
      });
    case "needsLogin": {
      if (G)
        return vX.default.createElement(dc, {
          onDone: X,
          mode: "login",
          forceLoginMethod: "claudeai",
        });
      return vX.default.createElement(
        Wc,
        { title: "Log in to Claude", onCancel: J, borderDimColor: !0 },
        vX.default.createElement(
          S,
          { flexDirection: "column" },
          vX.default.createElement(
            U,
            { dimColor: !0 },
            "Teleport requires a Claude.ai account.",
          ),
          vX.default.createElement(
            U,
            { dimColor: !0 },
            "Your Claude Pro/Max subscription will be used by Claude Code.",
          ),
        ),
        vX.default.createElement($0, {
          options: [
            { label: "Login with Claude account", value: "login" },
            { label: "Exit", value: "exit" },
          ],
          onChange: F,
          onCancel: J,
        }),
      );
    }
  }
}
async function dt1() {
  let A = new Set(),
    [B, Q] = await Promise.all([x11(), FT2()]);
  if (B) A.add("needsLogin");
  if (!Q) A.add("needsGitStash");
  return A;
}
var vX;
var ct1 = T(() => {
  nA();
  lzA();
  R5();
  $wA();
  JT2();
  xY();
  mt1();
  vX = IA(KA(), 1);
});
function DT2(A) {
  if (!A)
    throw (
      GA("tengu_teleport_error_no_url_or_session_id", {}),
      new TZ(
        "No URL or session ID provided for teleport",
        iA.red(`Error: No URL or session ID provided for teleport
`),
      )
    );
  return A;
}
function ET2(A) {
  if (!A) return {};
  try {
    let B = JSON.parse(A);
    if (typeof B !== "object" || B === null || Array.isArray(B))
      throw Error("TELEPORT_HEADERS must be a JSON object");
    return B;
  } catch (B) {
    let Q = B instanceof Error ? B : Error(String(B));
    throw (
      BA(Q, wk),
      GA("tengu_teleport_error_invalid_teleport_headers_json", {}),
      new TZ(
        `Invalid JSON in TELEPORT_HEADERS: ${Q.message}`,
        iA.red(`Error: Invalid JSON in TELEPORT_HEADERS: ${Q.message}
`),
      )
    );
  }
}
function HT2(A) {
  for (let [B, Q] of Object.entries(A))
    if (typeof Q !== "string") {
      let I = Error(
        `Invalid header value for "${B}": headers must be strings, got ${typeof Q}`,
      );
      throw (BA(I, wk), I);
    }
}
var zT2 = T(() => {
  y7();
  f2();
  H0();
  c1();
});
import { randomUUID as Vi5 } from "crypto";
function Ki5(A) {
  if (A === null) return bN("Session resumed", "suggestion");
  let B = A instanceof TZ ? A.formattedMessage : A.message;
  return bN(`Session resumed without branch: ${B}`, "warning");
}
function Di5() {
  return T0({
    content: `This session is being continued from another machine. Application state may have changed. The updated working directory is ${GQ()}`,
    isMeta: !0,
  });
}
async function Hi5(A, B) {
  try {
    let Q = `${Ei5}

Here is the session description:
<description>${A}</description>

Please generate a title for this session.
`,
      I = "<title>",
      Z = (
        await $X({
          systemPrompt: [],
          userPrompt: Q,
          assistantPrompt: "<title>",
          signal: B,
          options: {
            querySource: "teleport_generate_title",
            agents: [],
            isNonInteractiveSession: !1,
            hasAppendSystemPrompt: !1,
            mcpTools: [],
          },
        })
      ).message.content[0];
    if (Z?.type === "text") {
      let J = Z.text.trim();
      if (J.startsWith("<title>")) J = J.slice(7);
      if (J.endsWith("</title>")) J = J.slice(0, -8);
      return J.trim();
    }
  } catch (Q) {
    BA(Error(`Error generating title: ${Q}`), hJ0);
  }
  return A.length > 75 ? A.slice(0, 75) + "" : A;
}
async function b11() {
  if (!(await P2A()))
    throw (
      GA("tengu_teleport_error_git_not_clean", {}),
      new TZ(
        "Git working directory is not clean. Please commit or stash your changes before using --teleport.",
        iA.red(`Error: Git working directory is not clean. Please commit or stash your changes before using --teleport.
`),
      )
    );
}
async function zi5(A) {
  let B = A ? ["fetch", "origin", `${A}:${A}`] : ["fetch", "origin"],
    { code: Q, stderr: I } = await r0("git", B);
  if (Q !== 0)
    if (A && I.includes("refspec")) {
      g(`Specific branch fetch failed, trying to fetch ref: ${A}`);
      let { code: G, stderr: Z } = await r0("git", ["fetch", "origin", A]);
      if (G !== 0) BA(Error(`Failed to fetch from remote origin: ${Z}`), X61);
    } else BA(Error(`Failed to fetch from remote origin: ${I}`), X61);
}
async function Ui5(A) {
  let { code: B } = await r0("git", [
    "rev-parse",
    "--abbrev-ref",
    `${A}@{upstream}`,
  ]);
  if (B === 0) {
    g(`Branch '${A}' already has upstream set`);
    return;
  }
  let { code: Q } = await r0("git", ["rev-parse", "--verify", `origin/${A}`]);
  if (Q === 0) {
    g(`Setting upstream for '${A}' to 'origin/${A}'`);
    let { code: I, stderr: G } = await r0("git", [
      "branch",
      "--set-upstream-to",
      `origin/${A}`,
      A,
    ]);
    if (I !== 0) g(`Failed to set upstream for '${A}': ${G}`);
    else g(`Successfully set upstream for '${A}'`);
  } else
    g(`Remote branch 'origin/${A}' does not exist, skipping upstream setup`);
}
async function wi5(A) {
  let { code: B, stderr: Q } = await r0("git", ["checkout", A]);
  if (B !== 0) {
    g(`Local checkout failed, trying to checkout from origin: ${Q}`);
    let I = await r0("git", ["checkout", "-b", A, "--track", `origin/${A}`]);
    if (((B = I.code), (Q = I.stderr), B !== 0)) {
      g(`Remote checkout with -b failed, trying without -b: ${Q}`);
      let G = await r0("git", ["checkout", "--track", `origin/${A}`]);
      ((B = G.code), (Q = G.stderr));
    }
  }
  if (B !== 0)
    throw (
      GA("tengu_teleport_error_branch_checkout_failed", {}),
      new TZ(
        `Failed to checkout branch '${A}': ${Q}`,
        iA.red(`Failed to checkout branch '${A}'
`),
      )
    );
  await Ui5(A);
}
async function LwA() {
  let { stdout: A } = await r0("git", ["branch", "--show-current"]);
  return A.trim();
}
function UT2(A, B) {
  return [...pzA(A), Di5(), Ki5(B)];
}
async function MwA(A, B) {
  try {
    let Q = await LwA();
    if ((g(`Current branch before teleport: '${Q}'`), B)) {
      (g(`Switching to branch '${B}'...`), await zi5(B), await wi5(B));
      let G = await LwA();
      g(`Branch after checkout: '${G}'`);
    } else g("No branch specified, staying on current branch");
    let I = await LwA();
    return { messages: UT2(A, null), branchName: I, branchError: null };
  } catch (Q) {
    let I = await LwA(),
      G = Q instanceof Error ? Q : Error(String(Q));
    return { messages: UT2(A, G), branchName: I, branchError: G };
  }
}
async function $i5(A, B, Q) {
  let I = await Fb(),
    G = `${G4().BASE_API_URL}/v1/sessions/${A}`,
    Z = { ...Q, "x-organization-uuid": B };
  if (!I) {
    g(`Not in git repo, fetching session metadata to provide guidance: ${G}`);
    let J;
    try {
      J = await DB.get(G, { headers: Z, timeout: 15000 });
    } catch (X) {
      if (DB.isAxiosError(X))
        g(
          `Failed to fetch session metadata - Status: ${X.response?.status}, Message: ${X.message}`,
        );
      throw (
        GA("tengu_teleport_error_repo_validation_failed_sessions_api", {
          sessionId: A,
        }),
        new TZ(
          `You must run claude --teleport ${A} from a checkout of the git repo the session was created in.`,
          iA.red(`You must run claude --teleport ${A} from a checkout of the git repo the session was created in.
`),
        )
      );
    }
    if (J.status === 200) {
      let W = J.data.session_context.sources.find(
        (F) => F.type === "git_repository",
      );
      if (W?.url) {
        let F = r3A(W.url);
        if (F)
          throw (
            GA("tengu_teleport_error_repo_not_in_git_dir_sessions_api", {
              sessionId: A,
            }),
            new TZ(
              `You must run claude --teleport ${A} from a checkout of ${F}.`,
              iA.red(`You must run claude --teleport ${A} from a checkout of ${iA.bold(F)}.
`),
            )
          );
      } else
        g(
          "Session has no repo requirement and not in git directory, proceeding",
        );
    }
    return;
  }
  g(`Fetching session metadata from: ${G}`);
  let Y;
  try {
    Y = await DB.get(G, { headers: Z, timeout: 15000 });
  } catch (J) {
    if (DB.isAxiosError(J)) {
      if (
        (g(
          `Failed to fetch session metadata - Status: ${J.response?.status}, Message: ${J.message}`,
        ),
        J.response?.data)
      )
        g(`Error response data: ${JSON.stringify(J.response.data)}`);
    } else g(`Could not fetch session metadata: ${J}`);
    return;
  }
  if (Y.status === 200) {
    let X = Y.data.session_context.sources.find(
      (W) => W.type === "git_repository",
    );
    if (X?.url) {
      let W = r3A(X.url);
      if (W) {
        if ((g(`Session is for repository: ${W}, current repo: ${I}`), I !== W))
          throw (
            GA("tengu_teleport_error_repo_mismatch_sessions_api", {
              sessionId: A,
            }),
            new TZ(
              `You must run claude --teleport ${A} from a checkout of ${W}.`,
              iA.red(`You must run claude --teleport ${A} from a checkout of ${iA.bold(W)}.
`),
            )
          );
        g("Repository matches, proceeding with teleport");
      }
    } else
      g("Session has no associated repository, proceeding without validation");
  }
}
async function OwA(A) {
  g(`Resuming code session ID: ${A}`);
  try {
    let B = process.env.TELEPORT_RESUME_URL;
    if (B)
      return (
        g("Using TELEPORT_RESUME_URL from environment"),
        await $T2(B, void 0)
      );
    let Q = G5()?.accessToken;
    if (!Q)
      throw (
        GA("tengu_teleport_resume_error", { error_type: "no_access_token" }),
        Error(
          "Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.",
        )
      );
    let I = await rv();
    if (!I)
      throw (
        GA("tengu_teleport_resume_error", { error_type: "no_org_uuid" }),
        Error("Unable to get organization UUID for constructing session URL")
      );
    let G = VL(Q);
    return (
      g("Using Sessions API for resume"),
      await $i5(A, I, G),
      await Ni5(A, I, Q)
    );
  } catch (B) {
    if (B instanceof TZ) throw B;
    let Q = B instanceof Error ? B : Error(String(B));
    throw (
      BA(Q, wk),
      GA("tengu_teleport_resume_error", {
        error_type: "resume_session_id_catch",
      }),
      new TZ(
        Q.message,
        iA.red(`Error: ${Q.message}
`),
      )
    );
  }
}
async function $T2(A, B) {
  g(`Teleporting from URL: ${A}`);
  let Q = ET2(process.env.TELEPORT_HEADERS);
  if (Object.keys(Q).length > 0)
    g(`Parsed ${Object.keys(Q).length} headers from TELEPORT_HEADERS`);
  else g("No TELEPORT_HEADERS environment variable found");
  if (B) {
    HT2(B);
    let I = { ...Q, ...B };
    return (g(`Added ${Object.keys(B).length} additional headers`), wT2(A, I));
  }
  return wT2(A, Q);
}
async function wT2(A, B) {
  try {
    g("Fetching conversation from remote URL...");
    let Q = await cQ2(A, B);
    if (!Q)
      throw (
        BA(Error("Remote URL returned empty response"), gJ0),
        GA("tengu_teleport_resume_error", {
          error_type: "empty_response",
          url_type: A.startsWith("http") ? "http(s)" : "other",
        }),
        GA("tengu_teleport_error_failed_to_load_conversation", {}),
        new TZ(
          "Failed to load conversation from remote URL",
          iA.red(`Error: Failed to load conversation from remote URL
`),
        )
      );
    return (
      g("Successfully loaded conversation from remote URL"),
      g(`Response contains ${Q.log?.length || 0} messages`),
      g(`Response branch: ${Q.branch || "none specified"}`),
      GA("tengu_teleport_resume_success", {
        messages_count: Q.log?.length || 0,
        has_branch: !!Q.branch,
      }),
      Q
    );
  } catch (Q) {
    if (Q instanceof TZ) throw Q;
    let I = Q instanceof Error ? Q : Error(String(Q));
    throw (
      BA(I, wk),
      GA("tengu_teleport_resume_error", {
        error_type: "teleport_from_url_catch",
      }),
      new TZ(
        I.message,
        iA.red(`Error: ${I.message}
`),
      )
    );
  }
}
async function RwA(A) {
  let B = DT2(A);
  if (B.startsWith("http:") || B.startsWith("https:")) return $T2(B, void 0);
  return OwA(B);
}
async function qT2(A) {
  let B = await dt1();
  if (B.size > 0)
    (GA("tengu_teleport_errors_detected", {
      error_types: Array.from(B).join(","),
      errors_ignored: Array.from(A || []).join(","),
    }),
      await new Promise(async (Q) => {
        let { unmount: I } = await I5(
          pt1.default.createElement(
            H3,
            null,
            pt1.default.createElement(v11, {
              errorsToIgnore: A,
              onComplete: () => {
                (GA("tengu_teleport_errors_resolved", {
                  error_types: Array.from(B).join(","),
                }),
                  I(),
                  Q());
              },
            }),
          ),
          { exitOnCtrlC: !1 },
        );
      }));
}
async function NT2(A) {
  return (await qT2(), RwA(A));
}
async function LT2(A, B) {
  return (
    await qT2(new Set(["needsGitStash"])),
    lt1({ initialMessage: A, signal: B })
  );
}
function qi5(A) {
  if (A && typeof A === "object" && "type" in A) {
    if (A.type === "env_manager_log" || A.type === "control_response")
      return null;
    if ("session_id" in A) return A;
  }
  return (g(`Event is not a valid SDKMessage: ${JSON.stringify(A)}`), null);
}
async function Ni5(A, B, Q) {
  let I = VL(Q);
  try {
    let G = `${G4().BASE_API_URL}/v1/sessions/${A}/events`;
    g(`Fetching events from: ${G}`);
    let Z = await DB.get(G, {
      headers: { ...I, "x-organization-uuid": B },
      timeout: 30000,
    });
    if (Z.status !== 200)
      throw Error(`Failed to fetch session events: ${Z.statusText}`);
    let Y = Z.data;
    if (!Y?.data || !Array.isArray(Y.data))
      throw Error("Invalid events response: missing or invalid data array");
    let J = [];
    for (let W of Y.data) {
      let F = qi5(W);
      if (F) J.push(F);
    }
    let X;
    try {
      let W = `${G4().BASE_API_URL}/v1/sessions/${A}`;
      g(`Fetching session details from: ${W}`);
      let F = await DB.get(W, {
        headers: { ...I, "x-organization-uuid": B },
        timeout: 15000,
      });
      if (F.status === 200) {
        g(`Session details: ${JSON.stringify(F.data, null, 2)}`);
        let V = F.data.session_context.outcomes?.find(
          (K) => K.type === "git_repository",
        );
        if (V?.git_info?.branches.length)
          ((X = V.git_info.branches[0]),
            g(`Found branch from session context: ${X}`));
      }
    } catch (W) {
      BA(Error(`Could not fetch session details: ${W}`), QH);
    }
    return { log: J, branch: X };
  } catch (G) {
    let Z = G instanceof Error ? G : Error(String(G));
    if (DB.isAxiosError(G) && G.response?.status === 404)
      throw (
        GA("tengu_teleport_error_session_not_found_404", { sessionId: A }),
        new TZ(
          `${A} not found.`,
          `${A} not found.
${iA.dim("Run /status in Claude Code to check your account.")}`,
        )
      );
    throw (
      BA(Z, QH),
      Error(`Failed to fetch session from Sessions API: ${Z.message}`)
    );
  }
}
async function lt1(A) {
  let { initialMessage: B, description: Q, signal: I } = A;
  try {
    await qa();
    let G = G5()?.accessToken;
    if (!G)
      return (
        BA(Error("No access token found for remote session creation"), QH),
        null
      );
    let Z = await rv();
    if (!Z)
      return (
        BA(
          Error("Unable to get organization UUID for remote session creation"),
          QH,
        ),
        null
      );
    let Y = await Fb(),
      J = null,
      X = null;
    if (Y) {
      let [$, O] = Y.split("/");
      if ($ && O) {
        let P = A.branchName ?? (await LwA());
        ((J = { type: "git_repository", url: `https://github.com/${$}/${O}` }),
          (X = {
            type: "git_repository",
            git_info: {
              type: "github",
              repo: `${$}/${O}`,
              branches: P ? [P] : [],
            },
          }));
      } else
        BA(
          Error(`Invalid repository format: ${Y} - expected 'owner/name'`),
          QH,
        );
    }
    let W = await Hi5(Q || B || "Background task", I),
      F = await _11();
    if (!F || F.length === 0)
      return (
        BA(Error("No environments available for session creation"), QH),
        null
      );
    let C = F[0];
    if (!C)
      return (
        BA(Error("No environments available for session creation"), QH),
        null
      );
    let V = C.environment_id;
    g(`Selected environment: ${V} (${C.name})`);
    let K = `${G4().BASE_API_URL}/v1/sessions`,
      D = { ...VL(G), "x-organization-uuid": Z },
      E = { sources: J ? [J] : [], outcomes: X ? [X] : [], model: mI() },
      H = B
        ? [
            {
              type: "event",
              data: {
                uuid: Vi5(),
                session_id: "",
                type: "user",
                parent_tool_use_id: null,
                message: { role: "user", content: B },
              },
            },
          ]
        : [],
      w = { title: W, events: H, session_context: E, environment_id: V };
    g(`Creating session with payload: ${JSON.stringify(w, null, 2)}`);
    let L = await DB.post(K, w, { headers: D, signal: I });
    if (L.status !== 200 && L.status !== 201)
      return (
        BA(
          Error(`API request failed with status ${L.status}: ${L.statusText}

Response data: ${JSON.stringify(L.data, null, 2)}`),
          QH,
        ),
        null
      );
    let N = L.data;
    if (N && typeof N.id === "string")
      return (
        g(`Successfully created remote session: ${N.id}`),
        { id: N.id, title: N.title || W }
      );
    return (
      BA(
        Error(
          `Cannot determine session ID from API response: ${JSON.stringify(L.data)}`,
        ),
        QH,
      ),
      null
    );
  } catch (G) {
    let Z = G instanceof Error ? G : Error(String(G));
    return (BA(Z, wk), null);
  }
}
var pt1,
  Ei5 = `You are coming up with a succinct title for a coding session based on the provided description. The title should be clear, concise, and accurately reflect the content of the coding task.
You should keep it short and simple, ideally no more than 4 words. Avoid using jargon or overly technical terms unless absolutely necessary. The title should be easy to understand for anyone reading it.
You should wrap the title in <title> XML tags. You MUST return your best attempt for the title.

For example:
<title>Fix login button not working on mobile</title>
<title>Update README with installation instructions</title>
<title>Improve performance of data processing script</title>`;
var lo = T(() => {
  Q5();
  vC();
  dIA();
  f2();
  y7();
  C0();
  c1();
  nA();
  c9();
  ct1();
  F2();
  VR();
  _I();
  QW();
  F2();
  o3A();
  zG();
  Y9();
  H0();
  iB();
  i0();
  po();
  ut1();
  zT2();
  pt1 = IA(KA(), 1);
});
function OT2({ shell: A }) {
  switch (A.status) {
    case "completed":
      return t3A.default.createElement(
        U,
        { color: "success", dimColor: !0 },
        "done",
      );
    case "failed":
      return t3A.default.createElement(
        U,
        { color: "error", dimColor: !0 },
        "error",
      );
    case "killed":
      return t3A.default.createElement(
        U,
        { color: "error", dimColor: !0 },
        "killed",
      );
    case "running": {
      let B = MT2(A.stderr) || MT2(A.stdout);
      if (!B)
        return t3A.default.createElement(U, { dimColor: !0 }, "no output");
      return t3A.default.createElement(U, { dimColor: !0 }, CG(B, 20, !0));
    }
  }
}
function MT2(A) {
  if (!A) return "";
  let B = A.split(`
`);
  for (let Q = B.length - 1; Q >= 0; Q--) {
    let I = B[Q]?.trim();
    if (I) return I;
  }
  return "";
}
var t3A;
var RT2 = T(() => {
  nA();
  t3A = IA(KA(), 1);
});
function f11({ session: A }) {
  if (A.status === "completed")
    return TwA.default.createElement(
      U,
      { bold: !0, color: "success", dimColor: !0 },
      "done",
    );
  if (A.status === "failed")
    return TwA.default.createElement(
      U,
      { bold: !0, color: "error", dimColor: !0 },
      "error",
    );
  if (!A.todoList.length)
    return TwA.default.createElement(U, { dimColor: !0 }, A.status, "");
  let B = A.todoList.filter((I) => I.status === "completed").length,
    Q = A.todoList.length;
  return TwA.default.createElement(U, { dimColor: !0 }, B, "/", Q);
}
var TwA;
var it1 = T(() => {
  nA();
  TwA = IA(KA(), 1);
});
function h11({ task: A }) {
  switch (A.type) {
    case "shell":
      return uw.createElement(
        U,
        null,
        CG(A.command, 40, !0),
        " ",
        uw.createElement(OT2, { shell: A }),
      );
    case "remote_session":
      return uw.createElement(
        U,
        null,
        CG(A.title, 40, !0),
        " ",
        uw.createElement(f11, { session: A }),
      );
    case "async_agent":
      return uw.createElement(
        U,
        null,
        CG(A.description, 40, !0),
        " ",
        uw.createElement(
          U,
          { dimColor: !0 },
          "(",
          A.status,
          A.status === "completed" && !A.retrieved && ", unread",
          ")",
        ),
      );
  }
}
var uw;
var nt1 = T(() => {
  RT2();
  it1();
  nA();
  uw = IA(KA(), 1);
});
async function TT2() {
  let A = [],
    [B, Q, I, G] = await Promise.all([x11(), CT2(), VT2(), Fb()]);
  if (B) A.push({ type: "not_logged_in" });
  if (!Q) A.push({ type: "no_remote_environment" });
  if (!I) A.push({ type: "not_in_git_repo" });
  if (G) {
    let [Z, Y] = G.split("/");
    if (Z && Y) {
      if (!(await KT2(Z, Y))) A.push({ type: "github_app_not_installed" });
    }
  }
  return A;
}
var PT2 = T(() => {
  mt1();
  o3A();
});
function Li5() {
  let A = q80();
  if (A !== void 0) return A;
  let B = process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;
  if (!B) return (ve(null), null);
  let Q = parseInt(B, 10);
  if (Number.isNaN(Q))
    return (
      g(
        `CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${B}`,
        { level: "error" },
      ),
      ve(null),
      null
    );
  try {
    let I = NA(),
      G =
        process.platform === "darwin" || process.platform === "freebsd"
          ? `/dev/fd/${Q}`
          : `/proc/self/fd/${Q}`,
      Z = I.readFileSync(G, { encoding: "utf8" }).trim();
    if (!Z)
      return (
        g("File descriptor contained empty token", { level: "error" }),
        ve(null),
        null
      );
    return (g(`Successfully read token from file descriptor ${Q}`), ve(Z), Z);
  } catch (I) {
    return (
      g(
        `Failed to read token from file descriptor ${Q}: ${I instanceof Error ? I.message : String(I)}`,
        { level: "error" },
      ),
      ve(null),
      null
    );
  }
}
function io() {
  let A = process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;
  if (A) return A;
  return Li5();
}
var g11 = T(() => {
  C0();
  m0();
  i0();
});
function ST2(A) {
  let B = jT2.get(A);
  if (!B) ((B = vP(async (Q, I, G) => await Mi5(A, Q, I, G))), jT2.set(A, B));
  return B;
}
async function Mi5(A, B, Q, I) {
  try {
    let G = st1.get(A);
    if (G) I["Last-Uuid"] = G;
    let Z = await DB.put(Q, B, { headers: I, validateStatus: (Y) => Y < 500 });
    if (Z.status === 200 || Z.status === 201)
      return (
        st1.set(A, B.uuid),
        g(`Successfully persisted session log entry for session ${A}`),
        !0
      );
    if (Z.status === 409) {
      let J = Z.data.error?.message || "Concurrent modification detected";
      return (
        BA(
          Error(
            `Session persistence conflict: UUID mismatch for session ${A}. ${J}`,
          ),
          tY0,
        ),
        !1
      );
    }
    if (Z.status === 401) return (g("Session token expired or invalid"), !1);
    return (
      g(`Failed to persist session log: ${Z.status} ${Z.statusText}`),
      !1
    );
  } catch (G) {
    let Z = G;
    if (Z.response?.status === 409) {
      let Y = Z.response.data;
      return (
        BA(
          Error(
            `Session persistence conflict: UUID mismatch for session ${A}. ${Y?.error?.message || "Concurrent modification detected"}`,
          ),
          eY0,
        ),
        !1
      );
    } else BA(Error(`Error persisting session log: ${Z.message}`), AJ0);
    return !1;
  }
}
async function yT2(A, B, Q) {
  let I = io();
  if (!I) return (g("No session token available for session persistence"), !1);
  let G = { Authorization: `Bearer ${I}`, "Content-Type": "application/json" };
  return await ST2(A)(B, Q, G);
}
async function kT2(A, B) {
  try {
    let { accessToken: Q, orgUUID: I } = await k11(),
      G = `${G4().BASE_API_URL}/v1/session_ingress/session/${A}`,
      Z = { ...VL(Q), "x-organization-uuid": I };
    return await ST2(A)(B, G, Z);
  } catch (Q) {
    return (
      g(
        `Failed to get OAuth credentials: ${Q instanceof Error ? Q.message : String(Q)}`,
      ),
      !1
    );
  }
}
async function _T2(A, B) {
  let Q = io();
  if (!Q)
    return (g("No session token available for fetching session logs"), null);
  try {
    let I = await DB.get(B, {
      headers: { Authorization: `Bearer ${Q}` },
      validateStatus: (G) => G < 500,
    });
    if (I.status === 200) {
      let G = I.data;
      if (!G || typeof G !== "object" || !Array.isArray(G.loglines))
        return (
          BA(
            Error(`Invalid session logs response format: ${JSON.stringify(G)}`),
            oY0,
          ),
          null
        );
      let Z = G.loglines;
      if (!at1.has(A)) at1.set(A, new Set());
      let Y = at1.get(A);
      for (let J of Z) if ("uuid" in J && J.uuid) Y.add(J.uuid);
      if (Array.isArray(Z) && Z.length > 0) {
        let J = Z[Z.length - 1];
        if (J && "uuid" in J && J.uuid) st1.set(A, J.uuid);
      }
      return (g(`Fetched ${Z.length} session logs for session ${A}`), Z);
    }
    if (I.status === 404) return (g(`No existing logs for session ${A}`), []);
    if (I.status === 401) return (g("Session token expired or invalid"), null);
    return (
      g(`Failed to fetch session logs: ${I.status} ${I.statusText}`),
      null
    );
  } catch (I) {
    return (BA(Error(`Error fetching session logs: ${I.message}`), rY0), null);
  }
}
var st1, at1, jT2;
var rt1 = T(() => {
  _I();
  c1();
  C0();
  g11();
  QW();
  po();
  ((st1 = new Map()), (at1 = new Map()), (jT2 = new Map()));
});
function xT2({ issue: A, branchName: B, onDone: Q, color: I = "permission" }) {
  let { hasUncommitted: G, hasUnpushed: Z } = A,
    Y = "";
  if (G && Z) Y = `Uncommitted changes and unpushed commits detected on ${B}`;
  else if (G) Y = "Uncommitted changes detected";
  else Y = `Unpushed commits detected on ${B}`;
  function J(X) {
    Q(X);
  }
  return FE.createElement(
    S,
    {
      flexDirection: "column",
      borderStyle: "round",
      borderColor: I,
      borderLeft: !1,
      borderRight: !1,
      borderBottom: !1,
      marginTop: 1,
    },
    FE.createElement(
      S,
      { paddingX: 1 },
      FE.createElement(
        U,
        { color: I, bold: !0 },
        "Include local changes in the remote task?",
      ),
    ),
    FE.createElement(
      S,
      { flexDirection: "column", paddingX: 1 },
      FE.createElement(U, { dimColor: !0 }, Y),
      FE.createElement(
        S,
        { marginTop: 1 },
        FE.createElement($0, {
          options: [
            { label: "Commit and push my changes", value: "commit-push" },
            {
              label: "Run remote task without my local changes",
              value: "continue",
            },
            { label: "Cancel", value: "cancel" },
          ],
          onChange: J,
          onCancel: () => J("cancel"),
          layout: "compact-vertical",
        }),
      ),
    ),
  );
}
var FE;
var vT2 = T(() => {
  nA();
  Z5();
  FE = IA(KA(), 1);
});
function Ri5(A) {
  switch (A.type) {
    case "not_logged_in":
      return "Please run /login and sign in with your Claude.ai account (not Console).";
    case "no_remote_environment":
      return "No remote environments available. Check your Claude.ai subscription.";
    case "not_in_git_repo":
      return "Background tasks require a git repository. Initialize git or run from a git repository.";
    case "github_app_not_installed":
      return `The Claude GitHub app must be installed on this repository first.
https://github.com/apps/claude/installations/new`;
  }
}
async function bT2(A, B, Q, I, G, Z, Y) {
  (GA("tengu_input_background", {}), Z(!0));
  let J = {
      text: `<background-task-input>${A}</background-task-input>`,
      type: "text",
    },
    X = T0({
      content: Nz({ inputString: J.text, precedingInputBlocks: B }),
      autocheckpoint: Y,
    });
  G({
    jsx: lZ.createElement(
      S,
      { flexDirection: "column" },
      lZ.createElement(X6A, { addMargin: !0, param: J }),
      lZ.createElement(
        j0,
        null,
        lZ.createElement(U, { dimColor: !0 }, "Initializing session"),
      ),
    ),
    shouldHidePromptInput: !1,
  });
  try {
    let W = await TT2();
    if (W.length > 0) {
      let O = W.map(Ri5).join(`

`);
      return {
        messages: [
          OW(),
          X,
          ...Q,
          T0({
            content: `<bash-stderr>Cannot create background session:

${O}</bash-stderr>`,
          }),
        ],
        shouldQuery: !1,
      };
    }
    let F = await $UB(),
      C = await T_(),
      V = await mU1(),
      K = F.commitsAheadOfDefaultBranch === 0;
    if ((F.hasUncommitted || F.hasUnpushed) && !K) {
      let O = await new Promise((P) => {
        G({
          jsx: lZ.createElement(
            S,
            { flexDirection: "column" },
            lZ.createElement(X6A, { addMargin: !0, param: J }),
            lZ.createElement(xT2, {
              issue: F,
              branchName: C,
              onDone: P,
              color: "background",
            }),
          ),
          shouldHidePromptInput: !0,
        });
      });
      if (O === "cancel")
        return {
          messages: [
            OW(),
            X,
            ...Q,
            T0({
              content: "<bash-stderr>Background task cancelled.</bash-stderr>",
            }),
          ],
          shouldQuery: !1,
        };
      if (O === "commit-push") {
        let P = `Background task: ${A.slice(0, 60)}${A.length > 60 ? "..." : ""}`,
          k = await qUB(P);
        if (!k.success)
          return {
            messages: [
              OW(),
              X,
              ...Q,
              T0({
                content: `<bash-stderr>Failed to commit and push changes:
${k.error}</bash-stderr>`,
              }),
            ],
            shouldQuery: !1,
          };
      }
    }
    let D = u11(),
      E = [];
    try {
      E = await Qi(D);
    } catch (O) {
      g(
        `Could not read transcript file: ${O instanceof Error ? O.message : String(O)}`,
      );
    }
    let H = E.filter(tt1);
    G({
      jsx: lZ.createElement(
        S,
        { flexDirection: "column" },
        lZ.createElement(X6A, { addMargin: !0, param: J }),
        lZ.createElement(
          j0,
          null,
          lZ.createElement(U, { dimColor: !0 }, "Creating background task"),
        ),
      ),
      shouldHidePromptInput: !1,
    });
    let w = F.commitsAheadOfDefaultBranch === 0 ? V : C,
      L = await lt1({
        initialMessage: null,
        branchName: w,
        description: A,
        signal: I.abortController.signal,
      });
    if (!L) throw Error("Failed to create remote session");
    if (H.length > 0)
      for (let O = 0; O < H.length; O++) {
        let P = H[O];
        if (!P) continue;
        if (!(await kT2(L.id, P)))
          throw Error(
            `Failed to upload session history (message ${O + 1}/${H.length})`,
          );
      }
    if (!(await WT2(L.id, A)))
      throw Error("Failed to send user task message to remote session");
    I.setAppState((O) => ({
      ...O,
      backgroundTasks: {
        ...O.backgroundTasks,
        [L.id]: {
          id: L.id,
          command: A,
          startTime: Date.now(),
          status: "starting",
          todoList: [],
          title: L.title,
          type: "remote_session",
          deltaSummarySinceLastFlushToAttachment: null,
          log: [],
        },
      },
    }));
    let $ = `https://claude.ai/code/${L.id}`;
    return {
      messages: [
        OW(),
        X,
        ...Q,
        T0({
          content: `<background-task-output>This task is now running in the background.
Monitor it with /tasks or at ${$}

Or, resume it later with: claude --teleport ${L.id}</background-task-output>`,
        }),
      ],
      shouldQuery: !1,
    };
  } catch (W) {
    let F = W instanceof Error ? W.message : String(W);
    return {
      messages: [
        OW(),
        X,
        ...Q,
        T0({
          content: `<bash-stderr>Failed to create background session: ${F}. Try running /login and signing in with a claude.ai account (not Console).</bash-stderr>`,
        }),
      ],
      shouldQuery: !1,
    };
  } finally {
    G(null);
  }
}
async function fT2(A, B, Q, I, G) {
  let Z = D7(A);
  if (!Z.length) return null;
  return hm(
    await YS({
      messages: [...Z, ...D7([T0({ content: vlA() })])],
      systemPrompt: [
        "You are a helpful AI assistant tasked with summarizing conversations.",
      ],
      maxThinkingTokens: 0,
      tools: [t4],
      signal: B,
      options: {
        getToolPermissionContext: Q,
        model: mI(),
        toolChoice: void 0,
        isNonInteractiveSession: I,
        hasAppendSystemPrompt: G,
        maxOutputTokensOverride: BLA,
        querySource: "summarize_for_background_task",
        agents: [],
        mcpTools: [],
      },
    }),
  );
}
var lZ;
var ot1 = T(() => {
  H0();
  iB();
  nA();
  yv1();
  L8();
  lo();
  po();
  PT2();
  rt1();
  C0();
  E7();
  wC();
  zG();
  Ww();
  Y9();
  vC();
  vT2();
  lZ = IA(KA(), 1);
});
import { randomUUID as Ti5 } from "crypto";
function Cb(A) {
  return A.flatMap((B) => {
    switch (B.type) {
      case "assistant":
        return [
          {
            type: "assistant",
            message: B.message,
            uuid: B.uuid,
            requestId: void 0,
            timestamp: new Date().toISOString(),
          },
        ];
      case "user":
        return [
          {
            type: "user",
            message: B.message,
            uuid: B.uuid ?? Ti5(),
            timestamp: new Date().toISOString(),
            isMeta: B.isSynthetic,
          },
        ];
      case "system":
        if (B.subtype === "compact_boundary") {
          let Q = B;
          return [
            {
              type: "system",
              content: "Conversation compacted",
              level: "info",
              subtype: "compact_boundary",
              compactMetadata: {
                trigger: Q.compact_metadata.trigger,
                preTokens: Q.compact_metadata.pre_tokens,
              },
              uuid: B.uuid,
              timestamp: new Date().toISOString(),
            },
          ];
        }
        return [];
      default:
        return [];
    }
  });
}
function hT2(A) {
  return A.flatMap((B) => {
    switch (B.type) {
      case "assistant":
        return [
          {
            type: "assistant",
            message: B.message,
            session_id: L0(),
            parent_tool_use_id: null,
            uuid: B.uuid,
          },
        ];
      case "user":
        return [
          {
            type: "user",
            message: B.message,
            session_id: L0(),
            parent_tool_use_id: null,
            uuid: B.uuid,
            isSynthetic: B.isMeta || B.isVisibleInTranscriptOnly,
          },
        ];
      case "system":
        if (B.subtype === "compact_boundary" && B.compactMetadata)
          return [
            {
              type: "system",
              subtype: "compact_boundary",
              session_id: L0(),
              uuid: B.uuid,
              compact_metadata: {
                trigger: B.compactMetadata.trigger,
                pre_tokens: B.compactMetadata.preTokens,
              },
            },
          ];
        return [];
      case "attachment":
        if (piA(B.attachment))
          return [
            {
              type: "system",
              subtype: "hook_response",
              session_id: L0(),
              uuid: B.uuid,
              hook_name: B.attachment.hookName,
              hook_event: B.attachment.hookEvent,
              stdout: B.attachment.stdout || "",
              stderr: B.attachment.stderr || "",
              exit_code: B.attachment.exitCode,
            },
          ];
        return [];
      default:
        return [];
    }
  });
}
var PwA = T(() => {
  i0();
  uj();
});
function gT2({ tasksSelected: A, showHint: B }) {
  let { columns: Q } = aB(),
    I = Vb.useMemo(() => L1().hasSeenTasksHint, []),
    [{ backgroundTasks: G }] = lB();
  Pi5();
  let Z =
      B && (A || !I)
        ? t3.createElement(
            t3.Fragment,
            null,
            t3.createElement(U, { dimColor: !0 }, " "),
            t3.createElement(
              U,
              { dimColor: !0 },
              A ? "Enter to view tasks" : " to view",
            ),
          )
        : null,
    Y = Object.values(G).filter((J) => J.status === "running");
  if (Y.length === 0) return;
  if (Y.length > 1 || Q < 150)
    return t3.createElement(
      t3.Fragment,
      null,
      t3.createElement(
        U,
        { color: "background", inverse: A },
        Y.length,
        " background",
        " ",
        Y.length === 1 ? "task" : "tasks",
      ),
      Z ? t3.createElement(U, null, " ", Z) : null,
    );
  if (Y.length === 1) {
    let J = Y[0];
    return t3.createElement(
      t3.Fragment,
      null,
      t3.createElement(
        U,
        { color: "background", inverse: A },
        t3.createElement(h11, { task: J }),
      ),
      Z ? t3.createElement(U, null, " ", Z) : null,
    );
  }
  return null;
}
function Pi5() {
  let [{ backgroundTasks: A }, B] = lB(),
    Q = Vb.useMemo(
      () => Object.values(A).filter((Y) => Y.type === "remote_session"),
      [A],
    ),
    [I, G] = Vb.useState([]),
    Z = Vb.useCallback(
      async (Y) => {
        for await (let {
          response: { log: J },
          session: X,
        } of uT2(Y)) {
          let W = J.find((F) => F.type === "result");
          B((F) => ({
            ...F,
            backgroundTasks: {
              ...F.backgroundTasks,
              [X.id]: {
                ...X,
                status: W
                  ? W.subtype === "success"
                    ? "completed"
                    : "failed"
                  : J.length > 0
                    ? "running"
                    : "starting",
                log: J,
              },
            },
          }));
        }
      },
      [B],
    );
  Vb.useEffect(() => {
    if (Q.every((J) => I.includes(J.id))) return;
    G(Q.map((J) => J.id));
    let Y = Q.filter((J) => !I.includes(J.id));
    if (!Y.length) return;
    Z(Y).catch((J) => BA(J, LT));
  }, [Z, I, Q]);
}
async function* uT2(A) {
  return;
}
function ji5(A) {
  let B = A.findLast(
    (G) =>
      G.type === "assistant" &&
      G.message.content.some(
        (Z) => Z.type === "tool_use" && Z.name === oG.name,
      ),
  );
  if (!B) return [];
  let Q = B.message.content.find(
    (G) => G.type === "tool_use" && G.name === oG.name,
  )?.input;
  if (!Q) return [];
  let I = oG.inputSchema.safeParse(Q);
  if (!I.success) return [];
  return I.data.todos;
}
async function Si5(A, B) {
  return null;
}
var t3, Vb;
var mT2 = T(() => {
  nA();
  kB();
  c9();
  lo();
  c1();
  vn();
  nt1();
  N8();
  ot1();
  PwA();
  zG();
  iB();
  ((t3 = IA(KA(), 1)), (Vb = IA(KA(), 1)));
});
function yi5({ value: A, onChange: B, historyFailedMatch: Q }) {
  return no.createElement(
    S,
    { gap: 1 },
    no.createElement(
      U,
      { dimColor: !0 },
      Q ? "no matching prompt:" : "search prompts:",
    ),
    no.createElement(O4, {
      value: A,
      onChange: B,
      cursorOffset: A.length,
      onChangeCursorOffset: () => {},
      columns: A.length + 1,
      focus: !0,
      showCursor: !0,
      multiline: !1,
      dimColor: !0,
    }),
  );
}
var no, dT2;
var cT2 = T(() => {
  nA();
  rG();
  no = IA(KA(), 1);
  dT2 = yi5;
});
function lT2({
  exitMessage: A,
  vimMode: B,
  mode: Q,
  toolPermissionContext: I,
  suppressHint: G,
  tasksSelected: Z,
  isPasting: Y,
  isSearching: J,
  historyQuery: X,
  setHistoryQuery: W,
  historyFailedMatch: F,
}) {
  if (A.show)
    return M3.createElement(
      U,
      { dimColor: !0, key: "exit-message" },
      "Press ",
      A.key,
      " again to exit",
    );
  if (Y)
    return M3.createElement(
      U,
      { dimColor: !0, key: "pasting-message" },
      "Pasting text",
    );
  let C = mIA() && B === "INSERT" && !J;
  return M3.createElement(
    S,
    { justifyContent: "flex-start", gap: 1 },
    J &&
      M3.createElement(dT2, { value: X, onChange: W, historyFailedMatch: F }),
    C
      ? M3.createElement(U, { dimColor: !0, key: "vim-insert" }, "-- INSERT --")
      : null,
    M3.createElement(ki5, {
      mode: Q,
      toolPermissionContext: I,
      showHint: !G && !C,
      tasksSelected: Z,
    }),
  );
}
function ki5({
  mode: A,
  toolPermissionContext: B,
  showHint: Q,
  tasksSelected: I,
}) {
  let [{ backgroundTasks: G }] = lB(),
    Z = pT2.useMemo(
      () =>
        Object.values(G).filter(
          (W) => W.type === "remote_session" || W.status === "running",
        ).length,
      [G],
    );
  if (A === "memory")
    return M3.createElement(U, { color: "remember" }, "# to memorize");
  if (A === "bash")
    return M3.createElement(U, { color: "bashBorder" }, "! for bash mode");
  let Y = B?.mode,
    J = !KT0(Y),
    X = [
      ...(Y && J
        ? [
            M3.createElement(
              U,
              { color: Fi(Y), key: "mode" },
              DT0(Y),
              " ",
              Sk(Y).toLowerCase(),
              " on",
              M3.createElement(
                U,
                { dimColor: !0 },
                " (",
                DH.displayText,
                " to cycle)",
              ),
            ),
          ]
        : []),
      ...(Z > 0
        ? [
            M3.createElement(gT2, {
              key: "tasks",
              tasksSelected: I,
              showHint: Q,
            }),
          ]
        : []),
    ];
  if (X.length)
    return M3.createElement(
      S,
      null,
      wW(X, (W) =>
        M3.createElement(
          U,
          { dimColor: !0, key: `separator-${W}` },
          " ",
          "",
          " ",
        ),
      ),
    );
  if (!Q) return null;
  return M3.createElement(U, { dimColor: !0 }, "? for shortcuts");
}
var M3, pT2;
var iT2 = T(() => {
  nA();
  dzA();
  lh();
  MM();
  mT2();
  c9();
  cT2();
  ((M3 = IA(KA(), 1)), (pT2 = IA(KA(), 1)));
});
function et1() {
  return N0()?.statusLine !== void 0;
}
function _i5(A, B) {
  let Q = H2A({ permissionMode: A, mainLoopModel: mI(), exceeds200kTokens: B }),
    G = N0()?.outputStyle || nF;
  return {
    ...KL(),
    model: { id: Q, display_name: z2A(Q) },
    workspace: { current_dir: G0(), project_dir: GQ() },
    version: {
      ISSUES_EXPLAINER:
        "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.claude.com/s/claude-code",
      VERSION: "2.0.42",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
    }.VERSION,
    output_style: { name: G },
    cost: {
      total_cost_usd: dV(),
      total_duration_ms: jGA(),
      total_api_duration_ms: IM(),
      total_lines_added: ke(),
      total_lines_removed: _e(),
    },
    exceeds_200k_tokens: B,
  };
}
function nT2({ messages: A }) {
  let B = Kb.useRef(),
    [{ toolPermissionContext: Q, statusLineText: I }, G] = lB(),
    Z = Kb.useRef({
      messageId: null,
      exceeds200kTokens: !1,
      permissionMode: Q.mode,
    }),
    Y = Kb.useCallback(
      async (F) => {
        B.current?.abort();
        let C = new AbortController();
        B.current = C;
        try {
          let V = Z.current.exceeds200kTokens;
          if (F !== void 0) {
            let E = F.filter((L) => L.type === "assistant"),
              H = E[E.length - 1],
              w = H?.uuid || H?.message?.id || null;
            if (w !== Z.current.messageId)
              ((V = hlA(F)),
                (Z.current.messageId = w),
                (Z.current.exceeds200kTokens = V));
          }
          let K = _i5(Z.current.permissionMode, V),
            D = await Ae1(K, C.signal);
          if (!C.signal.aborted) G((E) => ({ ...E, statusLineText: D }));
        } catch {}
      },
      [G],
    ),
    J = w2A(() => Y(A), 300);
  if (
    (Kb.useEffect(() => {
      let F = A.filter((K) => K.type === "assistant"),
        C = F[F.length - 1],
        V = C?.uuid || C?.message?.id || null;
      if (V !== Z.current.messageId || Q.mode !== Z.current.permissionMode)
        ((Z.current.messageId = V), (Z.current.permissionMode = Q.mode), J());
    }, [A, Q.mode, J]),
    Kb.useEffect(() => {
      let C = N0()?.statusLine;
      if (C)
        GA("tengu_status_line_mount", {
          command_length: C.command.length,
          padding: C.padding,
        });
    }, []),
    Kb.useEffect(() => {
      return (
        Y(),
        () => {
          B.current?.abort();
        }
      );
    }, []),
    !I)
  )
    return null;
  let W = N0()?.statusLine?.padding ?? 0;
  return jwA.createElement(
    S,
    { paddingX: W },
    jwA.createElement(U, { dimColor: !0 }, I),
  );
}
var jwA, Kb;
var aT2 = T(() => {
  nA();
  mj();
  i0();
  V2();
  OQ();
  Y9();
  vU();
  mj();
  H0();
  c9();
  Gy();
  ux();
  DN();
  ((jwA = IA(KA(), 1)), (Kb = IA(KA(), 1)));
});
function Qe1({ suggestions: A, selectedSuggestion: B }) {
  let { rows: Q } = aB(),
    I = Math.min(10, Math.max(1, Q - 3)),
    G = (W) => {
      return Math.max(...W.map((F) => F.displayText.length)) + 5;
    };
  if (A.length === 0) return null;
  let Z = G(A),
    Y = Math.max(0, Math.min(B - Math.floor(I / 2), A.length - I)),
    J = Math.min(Y + I, A.length),
    X = A.slice(Y, J);
  return CE.createElement(
    S,
    { flexDirection: "column" },
    X.map((W) =>
      CE.createElement(xi5, {
        key: W.id,
        item: W,
        maxColumnWidth: Z,
        isSelected: W.id === A[B]?.id,
      }),
    ),
  );
}
var CE, Be1, xi5, $z7;
var sT2 = T(() => {
  nA();
  N8();
  ((CE = IA(KA(), 1)),
    (Be1 = IA(KA(), 1)),
    (xi5 = Be1.memo(function ({ item: B, maxColumnWidth: Q, isSelected: I }) {
      let G = aB().columns,
        Z = Q ?? B.displayText.length + 5,
        Y = G < 80 || (B.description && Z * 2 > G),
        J = B.color || (I ? "suggestion" : void 0),
        X = !I;
      return CE.createElement(
        S,
        { key: B.id, flexDirection: Y ? "column" : "row" },
        CE.createElement(
          S,
          { width: Y ? void 0 : Z },
          CE.createElement(U, { color: J, dimColor: X }, B.displayText),
        ),
        B.description &&
          CE.createElement(
            S,
            { width: G - (Y ? 4 : Z + 4), paddingLeft: Y ? 4 : 0 },
            CE.createElement(
              U,
              {
                color: I ? "suggestion" : void 0,
                dimColor: !I,
                wrap: "wrap-trim",
              },
              B.description,
            ),
          ),
      );
    })));
  $z7 = Be1.memo(Qe1);
});
function m11(A) {
  let { dimColor: B, fixedWidth: Q, gap: I, paddingX: G } = A;
  return O2.createElement(
    S,
    { paddingX: G, flexDirection: "row", gap: I },
    O2.createElement(
      S,
      { flexDirection: "column", width: Q ? 22 : void 0 },
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "! for bash mode"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "/ for commands"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "@ for file paths"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "# to memorize"),
      ),
      !1,
    ),
    O2.createElement(
      S,
      { flexDirection: "column", width: Q ? 35 : void 0 },
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "double tap esc to clear input"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(
          U,
          { dimColor: B },
          DH.displayText.replace("+", " + "),
          " to auto-accept edits",
        ),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "ctrl + o for verbose output"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "ctrl + t to show todos"),
      ),
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "tab to toggle thinking"),
      ),
      O2.createElement(S, null, O2.createElement(U, { dimColor: B }, gQ2())),
    ),
    O2.createElement(
      S,
      { flexDirection: "column" },
      O2.createElement(
        S,
        null,
        O2.createElement(U, { dimColor: B }, "ctrl + _ to undo"),
      ),
      WT0 &&
        O2.createElement(
          S,
          null,
          O2.createElement(U, { dimColor: B }, "ctrl + z to suspend"),
        ),
      O2.createElement(
        S,
        null,
        O2.createElement(
          U,
          { dimColor: B },
          Oi.displayText.replace("+", " + "),
          " to paste images",
        ),
      ),
    ),
  );
}
var O2;
var Ie1 = T(() => {
  nA();
  lh();
  E5();
  dzA();
  O2 = IA(KA(), 1);
});
function vi5({
  apiKeyStatus: A,
  debug: B,
  exitMessage: Q,
  vimMode: I,
  mode: G,
  autoUpdaterResult: Z,
  isAutoUpdating: Y,
  verbose: J,
  onAutoUpdaterResult: X,
  onChangeIsUpdating: W,
  suggestions: F,
  selectedSuggestion: C,
  toolPermissionContext: V,
  helpOpen: K,
  suppressHint: D,
  tasksSelected: E,
  ideSelection: H,
  mcpClients: w,
  isPasting: L = !1,
  isInputWrapped: N = !1,
  messages: $,
  isSearching: O,
  historyQuery: P,
  setHistoryQuery: k,
  historyFailedMatch: b,
  shouldShowSearchHint: x,
}) {
  let n = D || et1() || O;
  if (F.length)
    return qV.createElement(
      S,
      { paddingX: 2, paddingY: 0 },
      qV.createElement(Qe1, { suggestions: F, selectedSuggestion: C }),
    );
  if (K)
    return qV.createElement(m11, { dimColor: !0, fixedWidth: !0, paddingX: 2 });
  return qV.createElement(
    S,
    { flexDirection: "row", justifyContent: "space-between", paddingX: 2 },
    qV.createElement(
      S,
      { flexDirection: "column" },
      et1() &&
        G === "prompt" &&
        !Q.show &&
        !L &&
        qV.createElement(nT2, { messages: $ }),
      qV.createElement(lT2, {
        exitMessage: Q,
        vimMode: I,
        mode: G,
        toolPermissionContext: V,
        suppressHint: n,
        tasksSelected: E,
        isPasting: L,
        isSearching: O,
        historyQuery: P,
        setHistoryQuery: k,
        historyFailedMatch: b,
      }),
    ),
    qV.createElement(HB2, {
      apiKeyStatus: A,
      autoUpdaterResult: Z,
      debug: B,
      isAutoUpdating: Y,
      verbose: J,
      messages: $,
      onAutoUpdaterResult: X,
      onChangeIsUpdating: W,
      ideSelection: H,
      mcpClients: w,
      isInputWrapped: N,
      shouldShowSearchHint: x,
    }),
  );
}
var qV, rT2, oT2;
var tT2 = T(() => {
  nA();
  iT2();
  Ui1();
  aT2();
  sT2();
  Ie1();
  ((qV = IA(KA(), 1)), (rT2 = IA(KA(), 1)));
  oT2 = rT2.memo(vi5);
});
import { execFileSync as bi5 } from "child_process";
function eT2(A) {
  if (!NA().existsSync(A)) return "";
  return NA().readFileSync(A, { encoding: "utf-8" });
}
function AP2(A) {
  try {
    bi5("git", ["rev-parse", "--is-inside-work-tree"], {
      cwd: A,
      stdio: "ignore",
    });
  } catch (B) {
    return !1;
  }
  return !0;
}
var Ge1 = T(() => {
  m0();
  arA();
});
import { join as BP2 } from "path";
function c11({ onSelect: A, onCancel: B, title: Q, renderDetails: I }) {
  let G = LF(),
    Z = BP2(mB(), "CLAUDE.md"),
    Y = BP2(GQ(), "CLAUDE.md"),
    J = G.some((w) => w.path === Z),
    X = G.some((w) => w.path === Y),
    W = [
      ...G.map((w) => ({ ...w, exists: !0 })),
      ...(J ? [] : [{ path: Z, type: "User", content: "", exists: !1 }]),
      ...(X ? [] : [{ path: Y, type: "Project", content: "", exists: !1 }]),
    ],
    F = new Map(),
    C = W.map((w) => {
      let L = TY(w.path),
        N = w.exists ? "" : " (new)",
        $ = w.parent ? (F.get(w.parent) ?? 0) + 1 : 0;
      F.set(w.path, $);
      let O = $ > 0 ? "  ".repeat($ - 1) : "",
        P;
      if (w.type === "User" && !w.isNested && w.path === Z) P = "User memory";
      else if (w.type === "Project" && !w.isNested && w.path === Y)
        P = "Project memory";
      else if ($ > 0) P = `${O}L ${L}${N}`;
      else P = `${L}`;
      let k,
        b = AP2(GQ());
      if (w.type === "User" && !w.isNested) k = "Saved in ~/.claude/CLAUDE.md";
      else if (w.type === "Project" && !w.isNested && w.path === Y)
        k = `${b ? "Checked in at" : "Saved in"} ./CLAUDE.md`;
      else if ((w.type, w.parent)) k = "@-imported";
      else if (w.isNested) k = "dynamically loaded";
      else k = "";
      return { label: P, value: w.path, description: k };
    }),
    V = d11 && C.some((w) => w.value === d11) ? d11 : C[0]?.value || "",
    [K, D] = QP2.useState(V),
    H = W.find((w) => w.path === K)?.type;
  return (
    IB(),
    h1((w, L) => {
      if (L.escape) B();
    }),
    mw.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: "remember",
        padding: 1,
        width: "100%",
      },
      mw.createElement(
        S,
        {
          marginBottom: 1,
          flexDirection: "row",
          justifyContent: "space-between",
        },
        mw.createElement(
          U,
          { color: "remember", bold: !0 },
          Q || "Select memory file to edit:",
        ),
      ),
      mw.createElement(
        S,
        { flexDirection: "column", paddingX: 1 },
        mw.createElement($0, {
          focusValue: K,
          options: C,
          onFocus: (w) => D(w),
          onChange: (w) => {
            ((d11 = w), A(w));
          },
          onCancel: B,
        }),
      ),
      I &&
        mw.createElement(S, { marginTop: 1, flexDirection: "column" }, I(K, H)),
    )
  );
}
var mw, QP2, d11;
var Ze1 = T(() => {
  nA();
  R5();
  R9();
  lD();
  Z4();
  Ge1();
  i0();
  vB();
  ((mw = IA(KA(), 1)), (QP2 = IA(KA(), 1)));
});
function IP2(A, B) {
  let Q = p11.useRef();
  p11.useEffect(() => {
    let I = Az(A);
    if (Q.current !== I) Q.current = I;
    if (I)
      I.client.setNotificationHandler(hi5, (G) => {
        if (Q.current !== I) return;
        try {
          let Z = G.params,
            Y = Z.lineStart !== void 0 ? Z.lineStart + 1 : void 0,
            J = Z.lineEnd !== void 0 ? Z.lineEnd + 1 : void 0;
          B({ filePath: Z.filePath, lineStart: Y, lineEnd: J });
        } catch (Z) {
          BA(Z, TJ0);
        }
      });
  }, [A, B]);
}
var p11,
  fi5 = "at_mentioned",
  hi5;
var GP2 = T(() => {
  e2();
  zW();
  c1();
  ((p11 = IA(KA(), 1)),
    (hi5 = _.object({
      method: _.literal(fi5),
      params: _.object({
        filePath: _.string(),
        lineStart: _.number().optional(),
        lineEnd: _.number().optional(),
      }),
    })));
});
function ZP2({ maxBufferSize: A, debounceMs: B }) {
  let [Q, I] = Zy.useState([]),
    [G, Z] = Zy.useState(-1),
    Y = Zy.useRef(0),
    J = Zy.useRef(null),
    X = Zy.useCallback(
      (V, K, D = {}) => {
        let E = Date.now();
        if (J.current) (clearTimeout(J.current), (J.current = null));
        if (E - Y.current < B) {
          J.current = setTimeout(() => {
            X(V, K, D);
          }, B);
          return;
        }
        ((Y.current = E),
          I((H) => {
            let w = G >= 0 ? H.slice(0, G + 1) : H,
              L = w[w.length - 1];
            if (L && L.text === V) return w;
            let N = [
              ...w,
              { text: V, cursorOffset: K, pastedContents: D, timestamp: E },
            ];
            if (N.length > A) return N.slice(-A);
            return N;
          }),
          Z((H) => {
            let w = H >= 0 ? H + 1 : Q.length;
            return Math.min(w, A - 1);
          }));
      },
      [B, A, G, Q.length],
    ),
    W = Zy.useCallback(() => {
      if (G < 0 || Q.length === 0) return;
      let V = Math.max(0, G - 1),
        K = Q[V];
      if (K) return (Z(V), K);
      return;
    }, [Q, G]),
    F = Zy.useCallback(() => {
      if ((I([]), Z(-1), (Y.current = 0), J.current))
        (clearTimeout(J.current), (J.current = null));
    }, [Y, J]),
    C = G > 0 && Q.length > 1;
  return { pushToBuffer: X, undo: W, canUndo: C, clearBuffer: F };
}
var Zy;
var YP2 = T(() => {
  Zy = IA(KA(), 1);
});
function JP2({ shell: A, onDone: B, onKillShell: Q }) {
  let [I, G] = SwA.useState(0),
    [Z, Y] = SwA.useState({
      stdout: "",
      stderr: "",
      stdoutLines: 0,
      stderrLines: 0,
    });
  h1((F, C) => {
    if (C.escape || C.return || F === " ")
      B("Shell details dismissed", { display: "system" });
    else if (F === "k" && A.status === "running" && Q) Q();
  });
  let J = IB(),
    X = (F) => {
      let C = Math.floor((Date.now() - F) / 1000),
        V = Math.floor(C / 3600),
        K = Math.floor((C - V * 3600) / 60),
        D = C - V * 3600 - K * 60;
      return `${V > 0 ? `${V}h ` : ""}${K > 0 || V > 0 ? `${K}m ` : ""}${D}s`;
    };
  SwA.useEffect(() => {
    let F = giA(A),
      C = (L, N, $ = 10) => {
        if (!N) return L;
        let O = L.split(`
`),
          P = N.split(`
`);
        return [...O, ...P].slice(-$).join(`
`);
      },
      V = C(Z.stdout, F.stdout),
      K = C(Z.stderr, F.stderr),
      { totalLines: D, truncatedContent: E } = vj(V),
      { totalLines: H, truncatedContent: w } = vj(K);
    if (
      (Y({ stdout: E, stderr: w, stdoutLines: D, stderrLines: H }),
      A.status === "running")
    ) {
      let L = setTimeout(() => {
        G((N) => N + 1);
      }, 1000);
      return () => clearTimeout(L);
    }
  }, [A.id, A.status, I, Z.stdout, Z.stderr, A]);
  let W =
    A.command.length > 70 ? A.command.substring(0, 67) + "..." : A.command;
  return o5.default.createElement(
    S,
    { width: "100%", flexDirection: "column" },
    o5.default.createElement(
      S,
      { width: "100%" },
      o5.default.createElement(
        S,
        {
          borderStyle: "round",
          borderColor: "background",
          flexDirection: "column",
          marginTop: 1,
          paddingLeft: 1,
          paddingRight: 1,
          width: "100%",
        },
        o5.default.createElement(
          S,
          null,
          o5.default.createElement(
            U,
            { color: "background", bold: !0 },
            "Shell details",
          ),
        ),
        o5.default.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          o5.default.createElement(
            U,
            null,
            o5.default.createElement(U, { bold: !0 }, "Status:"),
            " ",
            A.status === "running"
              ? o5.default.createElement(
                  U,
                  { color: "background" },
                  A.status,
                  A.result?.code !== void 0 && ` (exit code: ${A.result.code})`,
                )
              : A.status === "completed"
                ? o5.default.createElement(
                    U,
                    { color: "success" },
                    A.status,
                    A.result?.code !== void 0 &&
                      ` (exit code: ${A.result.code})`,
                  )
                : o5.default.createElement(
                    U,
                    { color: "error" },
                    A.status,
                    A.result?.code !== void 0 &&
                      ` (exit code: ${A.result.code})`,
                  ),
          ),
          o5.default.createElement(
            U,
            null,
            o5.default.createElement(U, { bold: !0 }, "Runtime:"),
            " ",
            X(A.startTime),
          ),
          o5.default.createElement(
            U,
            { wrap: "truncate-end" },
            o5.default.createElement(U, { bold: !0 }, "Command:"),
            " ",
            W,
          ),
        ),
        o5.default.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          o5.default.createElement(U, { bold: !0 }, "Stdout:"),
          Z.stdout
            ? o5.default.createElement(
                o5.default.Fragment,
                null,
                o5.default.createElement(
                  S,
                  {
                    borderStyle: "round",
                    borderDimColor: !0,
                    paddingX: 1,
                    flexDirection: "column",
                    height: 12,
                  },
                  Z.stdout
                    .split(
                      `
`,
                    )
                    .slice(-10)
                    .map((F, C) =>
                      o5.default.createElement(
                        U,
                        { key: C, wrap: "truncate-end" },
                        F,
                      ),
                    ),
                ),
                o5.default.createElement(
                  U,
                  { dimColor: !0, italic: !0 },
                  Z.stdoutLines > 10
                    ? `Showing last 10 lines of ${Z.stdoutLines} total lines`
                    : `Showing ${Z.stdoutLines} lines`,
                ),
              )
            : o5.default.createElement(
                U,
                { dimColor: !0 },
                "No stdout output available",
              ),
        ),
        Z.stderr &&
          o5.default.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            o5.default.createElement(
              U,
              { bold: !0, color: "error" },
              "Stderr:",
            ),
            o5.default.createElement(
              S,
              {
                borderStyle: "round",
                borderColor: "error",
                paddingX: 1,
                flexDirection: "column",
                height: 3,
              },
              Z.stderr
                .split(
                  `
`,
                )
                .slice(-1)
                .map((F, C) =>
                  o5.default.createElement(
                    U,
                    { key: C, color: "error", wrap: "truncate-end" },
                    F,
                  ),
                ),
            ),
            o5.default.createElement(
              U,
              { dimColor: !0, italic: !0, color: "error" },
              Z.stderrLines > 1
                ? `Showing last line of ${Z.stderrLines} total lines`
                : `Showing ${Z.stderrLines} line`,
            ),
          ),
      ),
    ),
    o5.default.createElement(
      S,
      { marginLeft: 2 },
      J.pending
        ? o5.default.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            J.keyName,
            " again to exit",
          )
        : o5.default.createElement(
            U,
            { dimColor: !0 },
            "Press Esc/Enter/Space to close",
            A.status === "running" && Q
              ? o5.default.createElement(U, null, "  k to kill")
              : null,
          ),
    ),
  );
}
var o5, SwA;
var XP2 = T(() => {
  nA();
  R9();
  Rs();
  qm();
  ((o5 = IA(KA(), 1)), (SwA = IA(KA(), 1)));
});
function WP2({ session: A, toolUseContext: B, onDone: Q }) {
  let [I, G] = ywA.useState(!1),
    [Z, Y] = ywA.useState(null);
  h1((V, K) => {
    if (K.escape || K.return || V === " ")
      Q("Remote session details dismissed", { display: "system" });
    else if (V === "t" && !I) X();
  });
  let J = IB();
  async function X() {
    (G(!0), Y(null));
    try {
      await OwA(A.id);
    } catch (V) {
      (Y(V instanceof Error ? V.message : String(V)), G(!1));
    }
  }
  let W = (V) => {
      let K = Math.floor((Date.now() - V) / 1000),
        D = Math.floor(K / 3600),
        E = Math.floor((K - D * 3600) / 60),
        H = K - D * 3600 - E * 60;
      return `${D > 0 ? `${D}h ` : ""}${E > 0 || D > 0 ? `${E}m ` : ""}${H}s`;
    },
    F = ywA.useMemo(() => {
      return bY(Cb(A.log.slice(-3))).filter((V) => V.type !== "progress");
    }, [A]),
    C = A.title.length > 50 ? A.title.substring(0, 47) + "..." : A.title;
  return R6.default.createElement(
    S,
    { width: "100%", flexDirection: "column" },
    R6.default.createElement(
      S,
      { width: "100%" },
      R6.default.createElement(
        S,
        {
          borderStyle: "round",
          borderColor: "background",
          flexDirection: "column",
          marginTop: 1,
          paddingLeft: 1,
          paddingRight: 1,
          width: "100%",
        },
        R6.default.createElement(
          S,
          null,
          R6.default.createElement(
            U,
            { color: "background", bold: !0 },
            "Remote session details",
          ),
        ),
        R6.default.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          R6.default.createElement(
            U,
            null,
            R6.default.createElement(U, { bold: !0 }, "Status"),
            ":",
            " ",
            A.status === "running" || A.status === "starting"
              ? R6.default.createElement(U, { color: "background" }, A.status)
              : A.status === "completed"
                ? R6.default.createElement(U, { color: "success" }, A.status)
                : R6.default.createElement(U, { color: "error" }, A.status),
          ),
          R6.default.createElement(
            U,
            null,
            R6.default.createElement(U, { bold: !0 }, "Runtime"),
            ": ",
            W(A.startTime),
          ),
          R6.default.createElement(
            U,
            { wrap: "truncate-end" },
            R6.default.createElement(U, { bold: !0 }, "Title"),
            ": ",
            C,
          ),
          R6.default.createElement(
            U,
            null,
            R6.default.createElement(U, { bold: !0 }, "Progress"),
            ":",
            " ",
            R6.default.createElement(f11, { session: A }),
          ),
          R6.default.createElement(
            U,
            null,
            R6.default.createElement(U, { bold: !0 }, "Session URL"),
            ":",
            " ",
            R6.default.createElement(
              U,
              { dimColor: !0 },
              "https://claude.ai/code/",
              A.id,
            ),
          ),
        ),
        A.log.length > 0 &&
          R6.default.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            R6.default.createElement(
              U,
              null,
              R6.default.createElement(U, { bold: !0 }, "Recent messages"),
              ":",
            ),
            R6.default.createElement(
              S,
              { flexDirection: "column", height: 10, overflowY: "hidden" },
              F.map((V, K) =>
                R6.default.createElement(ax, {
                  key: K,
                  message: V,
                  messages: F,
                  addMargin: K > 0,
                  tools: B.options.tools,
                  verbose: B.options.verbose,
                  erroredToolUseIDs: new Set(),
                  inProgressToolUseIDs: new Set(),
                  resolvedToolUseIDs: new Set(),
                  progressMessagesForMessage: [],
                  shouldAnimate: !1,
                  shouldShowDot: !1,
                  style: "condensed",
                  isTranscriptMode: !1,
                }),
              ),
            ),
            R6.default.createElement(
              S,
              { marginTop: 1 },
              R6.default.createElement(
                U,
                { dimColor: !0, italic: !0 },
                "Showing last ",
                Math.min(3, A.log.length),
                " of",
                " ",
                A.log.length,
                " messages",
              ),
            ),
          ),
        Z &&
          R6.default.createElement(
            S,
            { marginTop: 1 },
            R6.default.createElement(
              U,
              { color: "error" },
              "Teleport failed: ",
              Z,
            ),
          ),
        I &&
          R6.default.createElement(
            S,
            { marginTop: 1 },
            R6.default.createElement(
              U,
              { color: "background" },
              "Teleporting to session...",
            ),
          ),
      ),
    ),
    R6.default.createElement(
      S,
      { marginLeft: 2 },
      J.pending
        ? R6.default.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            J.keyName,
            " again to exit",
          )
        : R6.default.createElement(
            U,
            { dimColor: !0 },
            "Press Esc/Enter/Space to close",
            !I ? R6.default.createElement(U, null, "  t to teleport") : null,
          ),
    ),
  );
}
var R6, ywA;
var FP2 = T(() => {
  nA();
  R9();
  it1();
  lo();
  YEA();
  PwA();
  iB();
  ((R6 = IA(KA(), 1)), (ywA = IA(KA(), 1)));
});
function CP2({ agent: A, onDone: B, onKillAgent: Q }) {
  h1((Y, J) => {
    if (J.escape || J.return || Y === " ") B();
    else if (Y === "k" && A.status === "running" && Q) Q();
  });
  let I = IB(),
    G = (Y) => {
      let J = Math.floor((Date.now() - Y) / 1000),
        X = Math.floor(J / 3600),
        W = Math.floor((J - X * 3600) / 60),
        F = J - X * 3600 - W * 60;
      return `${X > 0 ? `${X}h ` : ""}${W > 0 || X > 0 ? `${W}m ` : ""}${F}s`;
    },
    Z = A.prompt.length > 200 ? A.prompt.substring(0, 197) + "" : A.prompt;
  return bX.default.createElement(
    S,
    { width: "100%", flexDirection: "column" },
    bX.default.createElement(
      S,
      { width: "100%" },
      bX.default.createElement(
        S,
        {
          borderStyle: "round",
          borderColor: "background",
          flexDirection: "column",
          marginTop: 1,
          paddingLeft: 1,
          paddingRight: 1,
          width: "100%",
        },
        bX.default.createElement(
          S,
          null,
          bX.default.createElement(
            U,
            { color: "background", bold: !0 },
            "Async agent details",
          ),
        ),
        bX.default.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          bX.default.createElement(
            U,
            null,
            bX.default.createElement(U, { bold: !0 }, "Status:"),
            " ",
            A.status === "running"
              ? bX.default.createElement(U, { color: "background" }, A.status)
              : A.status === "completed"
                ? bX.default.createElement(U, { color: "success" }, A.status)
                : bX.default.createElement(
                    U,
                    { color: "error" },
                    A.status,
                    A.error && ` - ${A.error}`,
                  ),
          ),
          bX.default.createElement(
            U,
            null,
            bX.default.createElement(U, { bold: !0 }, "Runtime:"),
            " ",
            G(A.startTime),
          ),
          bX.default.createElement(
            U,
            { wrap: "wrap" },
            bX.default.createElement(U, { bold: !0 }, "Prompt:"),
            " ",
            Z,
          ),
        ),
      ),
    ),
    bX.default.createElement(
      S,
      { marginLeft: 2 },
      I.pending
        ? bX.default.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            I.keyName,
            " again to exit",
          )
        : bX.default.createElement(
            U,
            { dimColor: !0 },
            "Press Esc/Enter/Space to close",
            A.status === "running" && Q
              ? bX.default.createElement(U, null, "  k to kill")
              : null,
          ),
    ),
  );
}
var bX;
var VP2 = T(() => {
  nA();
  R9();
  bX = IA(KA(), 1);
});
function gi5(A, B, Q) {
  B((I) => {
    let G = I.backgroundTasks[A];
    if (!G || G.type !== "async_agent")
      return (
        BA(
          Error(
            "Async Agent not found in AppState.backgroundTasks. This is a bug",
          ),
          LT,
        ),
        I
      );
    let Z = Q(G);
    return { ...I, backgroundTasks: { ...I.backgroundTasks, [A]: Z } };
  });
}
function Ye1(A, B) {
  gi5(A, B, (Q) => {
    if (Q.status !== "running") return Q;
    return (
      Q.abortController?.abort(),
      Q.unregisterCleanup?.(),
      { ...Q, status: "killed" }
    );
  });
}
var l11 = T(() => {
  vG();
  c1();
  BU();
  y7();
});
function i11({ onDone: A, toolUseContext: B }) {
  let [{ backgroundTasks: Q }, I] = lB(),
    [G, Z] = ao.useState(null),
    [Y, J] = ao.useState(0);
  h1((P, k) => {
    if (!G && k.escape)
      A("Background tasks dialog dismissed", { display: "system" });
    if (!G && k.return && H) Z(H.id);
    if (!G && P === "k" && H?.type === "shell") W(H.id);
    if (!G && P === "k" && H?.type === "async_agent") Ye1(H.id, I);
    if (!G && (k.upArrow || k.downArrow)) {
      let b = E.length;
      if (b === 0) return;
      if (k.upArrow) J((x) => Math.max(0, x - 1));
      else J((x) => Math.min(b - 1, x + 1));
    }
  });
  let X = IB();
  function W(P) {
    I((k) => {
      let b = Q[P];
      if (!b) return k;
      if (b.type !== "shell") return k;
      return { ...k, backgroundTasks: { ...k.backgroundTasks, [P]: uiA(b) } };
    });
  }
  let F = Object.values(Q).map(ui5),
    C = F.sort((P, k) => {
      if (P.status === "running" && k.status !== "running") return -1;
      if (P.status !== "running" && k.status === "running") return 1;
      return k.task.startTime - P.task.startTime;
    }),
    V = C.filter((P) => P.type === "shell"),
    K = C.filter((P) => P.type === "remote_session"),
    D = C.filter((P) => P.type === "async_agent"),
    E = ao.useMemo(() => {
      return [...V, ...K, ...D];
    }, [V, K, D]),
    H = E[Y] || null;
  if (
    (ao.useEffect(() => {
      if (
        G &&
        !Object.values(Q).some((k) =>
          k.type === "async_agent" ? k.agentId === G : k.id === G,
        )
      )
        Z(null);
      let P = E.length;
      if (Y >= P && P > 0) J(P - 1);
    }, [G, Q, Y, E]),
    G)
  ) {
    let P = Object.values(Q).find((k) =>
      k.type === "async_agent" ? k.agentId === G : k.id === G,
    );
    if (!P) return null;
    if (P.type === "shell")
      return S5.default.createElement(JP2, {
        shell: P,
        onDone: A,
        onKillShell: () => W(P.id),
        key: `shell-${P.id}`,
      });
    else if (P.type === "async_agent")
      return S5.default.createElement(CP2, {
        agent: P,
        onDone: A,
        onKillAgent: () => Ye1(P.agentId, I),
        key: `agent-${P.agentId}`,
      });
    else
      return S5.default.createElement(WP2, {
        session: P,
        onDone: A,
        toolUseContext: B,
        key: `session-${P.id}`,
      });
  }
  let w = V.filter((P) => P.status === "running").length,
    L = K.filter(
      (P) => P.status === "running" || P.status === "starting",
    ).length,
    N = D.filter((P) => P.status === "running").length,
    $ = wW(
      [
        ...(w > 0
          ? [
              S5.default.createElement(
                U,
                { key: "shells" },
                w,
                " ",
                w !== 1 ? "active shells" : "active shell",
              ),
            ]
          : []),
        ...(L > 0
          ? [
              S5.default.createElement(
                U,
                { key: "sessions" },
                L,
                " ",
                L !== 1 ? "active session" : "active session",
              ),
            ]
          : []),
        ...[],
      ],
      (P) => S5.default.createElement(U, { key: `separator-${P}` }, "  "),
    ),
    O = [
      S5.default.createElement(U, { key: "upDown" }, "/ to select"),
      S5.default.createElement(U, { key: "enter" }, "Enter to view"),
      ...((H?.type === "shell" || H?.type === "async_agent") &&
      H.status === "running"
        ? [S5.default.createElement(U, { key: "kill" }, "k to kill")]
        : []),
      S5.default.createElement(U, { key: "esc" }, "Esc to close"),
    ];
  return S5.default.createElement(
    S,
    { width: "100%", flexDirection: "column" },
    S5.default.createElement(
      S,
      {
        borderStyle: "round",
        borderColor: "background",
        flexDirection: "column",
        marginTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        width: "100%",
      },
      S5.default.createElement(
        U,
        { color: "background", bold: !0 },
        "Background tasks",
      ),
      S5.default.createElement(U, { dimColor: !0 }, $),
      F.length === 0
        ? S5.default.createElement(
            U,
            { dimColor: !0 },
            "No tasks currently running",
          )
        : S5.default.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            V.length > 0 &&
              S5.default.createElement(
                S,
                { flexDirection: "column" },
                (K.length > 0 || D.length > 0) &&
                  S5.default.createElement(
                    U,
                    { dimColor: !0 },
                    S5.default.createElement(U, { bold: !0 }, "  ", "Bashes"),
                    " (",
                    V.length,
                    ")",
                  ),
                S5.default.createElement(
                  S,
                  { flexDirection: "column" },
                  V.map((P, k) =>
                    S5.default.createElement(KP2, {
                      key: P.id,
                      item: P,
                      isSelected: k === Y,
                    }),
                  ),
                ),
              ),
            K.length > 0 &&
              S5.default.createElement(
                S,
                { flexDirection: "column", marginTop: V.length > 0 ? 1 : 0 },
                S5.default.createElement(
                  U,
                  { dimColor: !0 },
                  S5.default.createElement(
                    U,
                    { bold: !0 },
                    "  ",
                    "Remote sessions",
                  ),
                  " (",
                  K.length,
                  ")",
                ),
                S5.default.createElement(
                  S,
                  { flexDirection: "column" },
                  K.map((P, k) =>
                    S5.default.createElement(KP2, {
                      key: P.id,
                      item: P,
                      isSelected: V.length + k === Y,
                    }),
                  ),
                ),
              ),
            !1,
          ),
    ),
    S5.default.createElement(
      S,
      { marginLeft: 2 },
      X.pending
        ? S5.default.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            X.keyName,
            " again to exit",
          )
        : S5.default.createElement(
            U,
            { dimColor: !0 },
            wW(O, (P) =>
              S5.default.createElement(U, { key: `separator-${P}` }, "  "),
            ),
          ),
    ),
  );
}
function ui5(A) {
  switch (A.type) {
    case "shell":
      return {
        id: A.id,
        type: "shell",
        label: A.description,
        status: A.status,
        task: A,
      };
    case "remote_session":
      return {
        id: A.id,
        type: "remote_session",
        label: A.title,
        status: A.status,
        task: A,
      };
    case "async_agent":
      return {
        id: A.agentId,
        type: "async_agent",
        label: A.description,
        status: A.status,
        task: A,
      };
  }
}
function KP2({ item: A, isSelected: B }) {
  return S5.default.createElement(
    S,
    { flexDirection: "row", gap: 1 },
    S5.default.createElement(
      U,
      { color: B ? "suggestion" : void 0 },
      B ? E1.pointer + " " : "  ",
      S5.default.createElement(h11, { task: A.task }),
    ),
  );
}
var S5, ao;
var Je1 = T(() => {
  nA();
  s2();
  R9();
  XP2();
  FP2();
  VP2();
  c9();
  Rs();
  l11();
  nt1();
  ((S5 = IA(KA(), 1)), (ao = IA(KA(), 1)));
});
function di5(A, B) {
  if (A.length <= mi5) return { truncatedText: A, placeholderContent: "" };
  let Q = Math.floor(DP2 / 2),
    I = Math.floor(DP2 / 2),
    G = A.slice(0, Q),
    Z = A.slice(-I),
    Y = A.slice(Q, -I),
    J = MjA(Y),
    W = ci5(B, J);
  return { truncatedText: G + W + Z, placeholderContent: Y };
}
function ci5(A, B) {
  return `[...Truncated text #${A} +${B} lines...]`;
}
function EP2(A, B) {
  let Q = Object.keys(B).map(Number),
    I = Q.length > 0 ? Math.max(...Q) + 1 : 1,
    { truncatedText: G, placeholderContent: Z } = di5(A, I);
  if (!Z) return { newInput: A, newPastedContents: B };
  return {
    newInput: G,
    newPastedContents: { ...B, [I]: { id: I, type: "text", content: Z } },
  };
}
var mi5 = 1e4,
  DP2 = 1000;
var HP2 = T(() => {
  ph();
});
function zP2({
  input: A,
  pastedContents: B,
  onInputChange: Q,
  setCursorOffset: I,
  setPastedContents: G,
}) {
  let [Z, Y] = kwA.useState(!1);
  (kwA.useEffect(() => {
    if (Z) return;
    if (A.length <= 1e4) return;
    let { newInput: J, newPastedContents: X } = EP2(A, B);
    (Q(J), I(J.length), G(X), Y(!0));
  }, [A, Z, B, Q, G, I]),
    kwA.useEffect(() => {
      if (A === "") Y(!1);
    }, [A]));
}
var kwA;
var UP2 = T(() => {
  HP2();
  kwA = IA(KA(), 1);
});
function wP2(A, B = 20) {
  let Q = new Map();
  for (let G of A) Q.set(G, (Q.get(G) || 0) + 1);
  return Array.from(Q.entries())
    .sort((G, Z) => Z[1] - G[1])
    .slice(0, B)
    .map(([G, Z]) => `${Z.toString().padStart(6)} ${G}`).join(`
`);
}
async function pi5() {
  if (O0.platform === "win32") return [];
  if (!(await QO())) return [];
  try {
    let A = "",
      { stdout: B } = await B5("git", ["config", "user.email"], { cwd: G0() }),
      Q = "";
    if (B.trim()) {
      let { stdout: Y } = await B5(
          "git",
          [
            "log",
            "-n",
            "1000",
            "--pretty=format:",
            "--name-only",
            "--diff-filter=M",
            `--author=${B.trim()}`,
          ],
          { cwd: G0() },
        ),
        J = Y.split(
          `
`,
        ).filter((X) => X.trim());
      Q = wP2(J);
    }
    if (
      ((A =
        `Files modified by user:
` + Q),
      Q.split(`
`).length < 10)
    ) {
      let { stdout: Y } = await B5(
          "git",
          [
            "log",
            "-n",
            "1000",
            "--pretty=format:",
            "--name-only",
            "--diff-filter=M",
          ],
          { cwd: G0() },
        ),
        J = Y.split(
          `
`,
        ).filter((W) => W.trim()),
        X = wP2(J);
      A +=
        `

Files modified by other users:
` + X;
    }
    let G = (
      await $X({
        systemPrompt: [
          "You are an expert at analyzing git history. Given a list of files and their modification counts, return exactly five filenames that are frequently modified and represent core application logic (not auto-generated files, dependencies, or configuration). Make sure filenames are diverse, not all in the same folder, and are a mix of user and other users. Return only the filenames' basenames (without the path) separated by newlines with no explanation.",
        ],
        userPrompt: A,
        signal: new AbortController().signal,
        options: {
          querySource: "example_commands_frequently_modified",
          agents: [],
          isNonInteractiveSession: !1,
          hasAppendSystemPrompt: !1,
          mcpTools: [],
        },
      })
    ).message.content[0];
    if (!G || G.type !== "text") return [];
    let Z = G.text.trim().split(`
`);
    if (Z.length < 5) return [];
    return Z;
  } catch (A) {
    return (BA(A, kZ0), []);
  }
}
var li5 = 604800000,
  $P2,
  qP2;
var Xe1 = T(() => {
  kB();
  C6();
  V2();
  zG();
  Q5();
  c1();
  a2();
  P11();
  vC();
  (($P2 = I0(() => {
    let A = v6(),
      B = A.exampleFiles?.length ? uo(A.exampleFiles) : "<filepath>",
      Q = [
        "fix lint errors",
        "fix typecheck errors",
        `how does ${B} work?`,
        `refactor ${B}`,
        "how do I log an error?",
        `edit ${B} to...`,
        `write a test for ${B}`,
        "create a util logging.py that...",
      ];
    return `Try "${uo(Q)}"`;
  })),
    (qP2 = I0(async () => {
      let A = v6(),
        B = Date.now(),
        Q = A.exampleFilesGeneratedAt ?? 0;
      if (B - Q > li5) A.exampleFiles = [];
      if (!A.exampleFiles?.length)
        pi5().then((I) => {
          if (I.length)
            uG({
              ...v6(),
              exampleFiles: I,
              exampleFilesGeneratedAt: Date.now(),
            });
        });
    })));
});
function LP2({ input: A, mode: B, queuedCommands: Q, submitCount: I }) {
  let G = NP2.useMemo(() => {
    if (A !== "") return;
    if (Q.length > 0 && (L1().queuedCommandUpHintCount || 0) < ii5)
      return "Press up to edit queued messages";
    if (I < 1) return $P2();
  }, [A, Q, I]);
  if (B === "memory")
    return 'Add to memory. Try "Always use descriptive variable names"';
  return G;
}
var NP2,
  ii5 = 3;
var MP2 = T(() => {
  kB();
  Xe1();
  NP2 = IA(KA(), 1);
});
function OP2({ mode: A, isLoading: B }) {
  return PR.createElement(
    S,
    {
      alignItems: "flex-start",
      alignSelf: "flex-start",
      flexWrap: "nowrap",
      justifyContent: "flex-start",
      width: 2,
    },
    A === "bash"
      ? PR.createElement(U, { color: "bashBorder", dimColor: B }, "!")
      : A === "memory" || A === "memorySelect"
        ? PR.createElement(U, { color: "remember", dimColor: B }, "#")
        : A === "background"
          ? PR.createElement(U, { color: "background", dimColor: B }, "&")
          : PR.createElement(U, { dimColor: B }, ">"),
  );
}
var PR;
var RP2 = T(() => {
  nA();
  PR = IA(KA(), 1);
});
function TP2({ queuedCommands: A }) {
  let { columns: B } = aB();
  if (A.length === 0) return null;
  return _wA.createElement(
    S,
    { marginTop: 1, paddingLeft: 2, flexDirection: "column", width: B - 4 },
    _wA.createElement(
      U,
      { dimColor: !0, wrap: "wrap" },
      A.map((Q) => Q.value).join(`
`),
    ),
  );
}
var _wA;
var PP2 = T(() => {
  N8();
  nA();
  _wA = IA(KA(), 1);
});
function jP2(A, B, Q, I, G, Z, Y, J, X) {
  let [W, F] = dw.useState(""),
    [C, V] = dw.useState(!1),
    [K, D] = dw.useState(""),
    [E, H] = dw.useState(0),
    [w, L] = dw.useState("prompt"),
    [N, $] = dw.useState(void 0),
    O = dw.useRef(void 0),
    P = dw.useRef(new Set()),
    k = dw.useRef(null);
  function b() {
    if (O.current) (O.current.return(void 0), (O.current = void 0));
  }
  function x() {
    (X(!1),
      F(""),
      V(!1),
      D(""),
      H(0),
      L("prompt"),
      $(void 0),
      b(),
      P.current.clear());
  }
  async function n(m, o) {
    if (!J) return;
    if (W.length === 0) {
      (b(), P.current.clear(), $(void 0), V(!1), Q(K), I(E), Z(w));
      return;
    }
    if (!m) (b(), (O.current = OjA()), P.current.clear());
    if (!O.current) return;
    while (!0) {
      if (o?.aborted) return;
      let l = await O.current.next();
      if (l.done) {
        V(!0);
        return;
      }
      let y = l.value.display,
        c = y.lastIndexOf(W);
      if (c !== -1 && !P.current.has(y)) {
        (P.current.add(y), $(l.value), V(!1));
        let e = uk(y);
        (Z(e), Q(y));
        let WA = Ri(y).lastIndexOf(W);
        I(WA !== -1 ? WA : c);
        return;
      }
    }
  }
  return (
    h1(
      (m, o) => {
        if (J) {
          if (o.ctrl && m === "r") n(!0);
          else if (o.escape || o.tab) {
            if (N) {
              let l = typeof N === "string" ? N : N.display,
                y = uk(l),
                c = Ri(l);
              (Q(c), Z(y));
            }
            x();
          } else if ((o.ctrl && m === "c") || (o.backspace && W === ""))
            (Q(K), I(E), x());
          else if (o.return) {
            if (W.length === 0) A({ display: K, pastedContents: {} });
            else if (N) {
              let l = typeof N === "string" ? N : N.display,
                y = uk(l),
                c = Ri(l);
              (Z(y), A({ display: c, pastedContents: {} }));
            }
            x();
          }
        } else if (o.ctrl && m === "r")
          (X(!0), D(B), H(G), L(Y), (O.current = OjA()), P.current.clear());
      },
      { isActive: !0 },
    ),
    dw.useEffect(() => {
      k.current?.abort();
      let m = new AbortController();
      return (
        (k.current = m),
        n(!1, m.signal),
        () => {
          m.abort();
        }
      );
    }, [W]),
    {
      historyQuery: W,
      setHistoryQuery: F,
      historyMatch: N,
      historyFailedMatch: C,
    }
  );
}
var dw;
var SP2 = T(() => {
  nA();
  ph();
  dw = IA(KA(), 1);
});
import * as yP2 from "path";
function ni5({
  debug: A,
  ideSelection: B,
  toolPermissionContext: Q,
  setToolPermissionContext: I,
  apiKeyStatus: G,
  commands: Z,
  agents: Y,
  isLoading: J,
  verbose: X,
  messages: W,
  onAutoUpdaterResult: F,
  autoUpdaterResult: C,
  input: V,
  onInputChange: K,
  mode: D,
  onModeChange: E,
  queuedCommands: H,
  queueManager: w,
  submitCount: L,
  onShowMessageSelector: N,
  mcpClients: $,
  pastedContents: O,
  setPastedContents: P,
  vimMode: k,
  setVimMode: b,
  showBashesDialog: x,
  setShowBashesDialog: n,
  onExit: m,
  getToolUseContext: o,
  onSubmit: l,
  isSearchingHistory: y,
  setIsSearchingHistory: c,
}) {
  let e = Jc(),
    [QA, WA] = fY.useState(!1),
    [JA, wA] = fY.useState({ show: !1 }),
    [xA, rA] = fY.useState(V.length),
    [qA, SA] = lB(),
    {
      historyQuery: zA,
      setHistoryQuery: kA,
      historyMatch: sA,
      historyFailedMatch: Z1,
    } = jP2(
      (B1) => {
        let yA = typeof B1 === "string" ? B1 : B1.display;
        LB(yA);
      },
      V,
      K,
      rA,
      xA,
      E,
      D,
      y,
      c,
    ),
    XA = fY.useMemo(() => {
      let B1 = Object.keys(O).map(Number);
      if (B1.length === 0) return 1;
      return Math.max(...B1) + 1;
    }, [O]),
    [CA, UA] = fY.useState(!1),
    [HA, LA] = fY.useState(!1),
    [TA, tA] = fY.useState(!1),
    [aA, W1] = fY.useState(!1),
    w1 = fY.useMemo(
      () => (y && sA ? Ri(typeof sA === "string" ? sA : sA.display) : V),
      [y, sA, V],
    ),
    OA = fY.useMemo(() => XbA(w1), [w1]),
    I1 = fY.useMemo(() => {
      let B1 = [];
      if (y && sA && !Z1)
        B1.push({
          start: xA,
          end: xA + zA.length,
          style: { type: "solid", color: "warning" },
          priority: 20,
        });
      if (OA.length > 0) {
        let yA = Rn(w1);
        if (yA.level !== "none") {
          let J1 = YbA[yA.level],
            p1 = UzB[yA.level];
          for (let r1 of OA)
            B1.push({
              start: r1.start,
              end: r1.end,
              style: JbA(r1.word)
                ? { type: "rainbow", useShimmer: !0 }
                : { type: "shimmer", baseColor: J1, shimmerColor: p1 },
              priority: 10,
            });
        }
      }
      return B1;
    }, [y, zA, sA, Z1, xA, OA, w1]),
    { addNotification: i1 } = f7();
  fY.useEffect(() => {
    if (!OA.length) return;
    if (OA.length && !qA.thinkingEnabled)
      i1({
        key: "thinking-toggled-via-keyword",
        jsx: L7.createElement(U, { color: "suggestion" }, "Thinking on"),
        priority: "immediate",
        timeoutMs: 3000,
      });
  }, [i1, qA.thinkingEnabled, SA, OA.length]);
  let {
    pushToBuffer: G1,
    undo: e1,
    canUndo: _0,
    clearBuffer: h0,
  } = ZP2({ maxBufferSize: 50, debounceMs: 1000 });
  zP2({
    input: V,
    pastedContents: O,
    onInputChange: K,
    setCursorOffset: rA,
    setPastedContents: P,
  });
  let a0 = LP2({ input: V, mode: D, queuedCommands: H, submitCount: L }),
    c0 = fY.useCallback(
      (B1) => {
        if (B1 === "?") {
          (GA("tengu_help_toggled", {}), UA((JB) => !JB));
          return;
        }
        UA(!1);
        let yA = B1.length === V.length + 1,
          J1 = xA === 0,
          p1 = uk(B1);
        if (yA && J1 && p1 !== "prompt") {
          E(p1);
          return;
        }
        let r1 = B1.replaceAll("\t", "    ");
        if (V !== r1) G1(V, xA, O);
        K(r1);
      },
      [K, E, V, xA, G1, O],
    ),
    {
      resetHistory: K0,
      onHistoryUp: F1,
      onHistoryDown: q1,
      shouldShowSearchHint: y1,
      dismissSearchHint: g1,
    } = zB2(
      (B1, yA, J1) => {
        (c0(B1), E(yA), P(J1));
      },
      V,
      O,
      rA,
    );
  fY.useEffect(() => {
    if (y) g1();
  }, [y, g1]);
  function E0() {
    if (YQ.length > 1) return;
    if (H.length > 0) {
      OI();
      return;
    }
    if (HA) LA(!1);
    else F1();
  }
  function U0() {
    if (YQ.length > 1) return;
    let B1 = q1(),
      yA = Object.values(qA.backgroundTasks).filter(
        (J1) => J1.status === "running",
      ).length;
    if (B1 && yA > 0) {
      LA(!0);
      let J1 = L1();
      if (!J1.hasSeenTasksHint) n0({ ...J1, hasSeenTasksHint: !0 });
    } else LA(!1);
  }
  let [e0, VB] = fY.useState({
      suggestions: [],
      selectedSuggestion: -1,
      commandArgumentHint: void 0,
    }),
    LB = fY.useCallback(
      async (B1, yA = !1, J1) => {
        if (B1.trim() === "") return;
        let p1 =
          e0.suggestions.length > 0 &&
          e0.suggestions.every((r1) => r1.description === "directory");
        if (e0.suggestions.length > 0 && !yA && !p1) return;
        await l(B1, J1, {
          setCursorOffset: rA,
          clearBuffer: h0,
          resetHistory: K0,
        });
      },
      [e0.suggestions, l, rA, h0, K0],
    ),
    {
      suggestions: YQ,
      selectedSuggestion: R2,
      commandArgumentHint: MB,
    } = xQ2({
      commands: Z,
      onInputChange: K,
      onSubmit: LB,
      setCursorOffset: rA,
      input: V,
      cursorOffset: xA,
      mode: D,
      agents: Y,
      setSuggestionsState: VB,
      suggestionsState: e0,
      suppressSuggestions: y,
    });
  function C4(B1, yA) {
    (GA("tengu_paste_image", {}), E("prompt"));
    let J1 = {
      id: XA,
      type: "image",
      content: B1,
      mediaType: yA || "image/png",
    };
    (P((p1) => ({ ...p1, [XA]: J1 })), m8(rx0(J1.id)));
  }
  function H8(B1) {
    let yA = SZ(B1)
        .replace(
          /\r/g,
          `
`,
        )
        .replaceAll("\t", "    "),
      J1 = MjA(yA),
      p1 = Math.min(F3 - 10, 2);
    if (yA.length > HjA || J1 > p1) {
      let r1 = { id: XA, type: "text", content: yA };
      (P((JB) => ({ ...JB, [XA]: r1 })), m8(sx0(r1.id, J1)));
    } else m8(yA);
  }
  function m8(B1) {
    G1(V, xA, O);
    let yA = V.slice(0, xA) + B1 + V.slice(xA);
    (K(yA), rA(xA + B1.length));
  }
  let j6 = vk(
      () => {},
      () => N(),
    ),
    OI = fY.useCallback(() => {
      let B1 = w.popAllForEditing(V, xA);
      if (!B1) return;
      (K(B1.text), E("prompt"), rA(B1.cursorOffset));
    }, [w, K, E, V, xA]);
  (IP2($, function (B1) {
    GA("tengu_ext_at_mentioned", {});
    let yA,
      J1 = yP2.relative(G0(), B1.filePath);
    if (B1.lineStart && B1.lineEnd)
      yA =
        B1.lineStart === B1.lineEnd
          ? `@${J1}#L${B1.lineStart} `
          : `@${J1}#L${B1.lineStart}-${B1.lineEnd} `;
    else yA = `@${J1} `;
    let p1 = V[xA - 1] ?? " ";
    if (!/\s/.test(p1)) yA = ` ${yA}`;
    m8(yA);
  }),
    h1((B1, yA) => {
      if (yA.ctrl && B1 === "_") {
        if (_0) {
          let J1 = e1();
          if (J1) (K(J1.text), rA(J1.cursorOffset), P(J1.pastedContents));
        }
        return;
      }
      if (yA.ctrl && B1.toLowerCase() === "g") {
        (GA("tengu_external_editor_used", {}), W1(!0));
        let J1 = soA(V);
        if ((W1(!1), J1 !== null && J1 !== V))
          (G1(V, xA, O), K(J1), rA(J1.length));
        return;
      }
      if (yA.return && HA) {
        (n(!0), LA(!1));
        return;
      }
      if (xA === 0 && (yA.escape || yA.backspace || yA.delete))
        (E("prompt"), UA(!1));
      if (CA && V === "" && (yA.backspace || yA.delete)) UA(!1);
      if (DH.check(B1, yA)) {
        let J1 = mQ2(Q);
        if ((GA("tengu_mode_cycle", { to: J1 }), J1 === "plan")) {
          let r1 = L1();
          n0({ ...r1, lastPlanModeUse: Date.now() });
        }
        let p1 = aF(Q, { type: "setMode", mode: J1, destination: "session" });
        if ((I(p1), CA)) UA(!1);
        return;
      }
      if (yA.escape) {
        if (HA) {
          LA(!1);
          return;
        }
        if (H.length > 0) {
          OI();
          return;
        }
        if (W.length > 0 && !V && !J) j6();
      }
      if (yA.return && CA) UA(!1);
    }));
  let { columns: BG, rows: F3 } = aB(),
    j4 = BG - 3,
    Q6 = fY.useMemo(() => {
      let B1 = V.split(`
`);
      for (let yA of B1) if (yA.length > j4) return !0;
      return B1.length > 1;
    }, [V, j4]);
  if (x)
    return L7.createElement(i11, {
      onDone: () => {
        n(!1);
      },
      toolUseContext: o(W, [], new AbortController(), [], void 0, e),
    });
  let BI = {
      multiline: !0,
      onSubmit: LB,
      onChange: c0,
      value: sA ? Ri(typeof sA === "string" ? sA : sA.display) : V,
      onHistoryUp: E0,
      onHistoryDown: U0,
      onHistoryReset: K0,
      placeholder: a0,
      onExit: m,
      onExitMessage: (B1, yA) => wA({ show: B1, key: yA }),
      onImagePaste: C4,
      columns: j4,
      disableCursorMovementForUpDownKeys: YQ.length > 0,
      cursorOffset: xA,
      onChangeCursorOffset: rA,
      onPaste: H8,
      onIsPastingChange: tA,
      focus: D !== "memorySelect" && !y,
      showCursor: D !== "memorySelect" && !HA && !y,
      argumentHint: MB,
      onUndo: _0
        ? () => {
            let B1 = e1();
            if (B1) (K(B1.text), rA(B1.cursorOffset), P(B1.pastedContents));
          }
        : void 0,
      highlights: I1,
    },
    R7 = () => {
      let B1 = {
        bash: "bashBorder",
        memory: "remember",
        memorySelect: "remember",
        background: "background",
      };
      if (B1[D]) return B1[D];
      return qA.thinkingEnabled ? "suggestion" : "promptBorder";
    };
  if (aA)
    return L7.createElement(
      S,
      {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "center",
        borderColor: R7(),
        borderDimColor: D !== "memory",
        borderStyle: "round",
        borderLeft: !1,
        borderRight: !1,
        borderBottom: !0,
        width: "100%",
      },
      L7.createElement(
        U,
        { dimColor: !0, italic: !0 },
        "Save and close editor to continue...",
      ),
    );
  return L7.createElement(
    S,
    { flexDirection: "column", marginTop: 1 },
    L7.createElement(TP2, { queuedCommands: H }),
    L7.createElement(
      S,
      {
        flexDirection: "row",
        alignItems: "flex-start",
        justifyContent: "flex-start",
        borderColor: R7(),
        borderDimColor: D !== "memory",
        borderStyle: "round",
        borderLeft: !1,
        borderRight: !1,
        borderBottom: !0,
        width: "100%",
      },
      L7.createElement(OP2, { mode: D, isLoading: J }),
      L7.createElement(
        S,
        { flexGrow: 1, flexShrink: 1 },
        mIA()
          ? L7.createElement(ii1, {
              ...BI,
              initialMode: k,
              onModeChange: b,
              isLoading: J,
            })
          : L7.createElement(O4, { ...BI }),
      ),
    ),
    D === "memorySelect" &&
      L7.createElement(c11, {
        onSelect: (B1) => {
          LB(V, !1, B1);
        },
        onCancel: () => {
          E("memory");
        },
      }),
    L7.createElement(oT2, {
      apiKeyStatus: G,
      debug: A,
      exitMessage: JA,
      vimMode: k,
      mode: D,
      autoUpdaterResult: C,
      isAutoUpdating: QA,
      verbose: X,
      onAutoUpdaterResult: F,
      onChangeIsUpdating: WA,
      suggestions: YQ,
      selectedSuggestion: R2,
      toolPermissionContext: Q,
      helpOpen: CA,
      suppressHint: V.length > 0,
      tasksSelected: HA,
      ideSelection: B,
      mcpClients: $,
      isPasting: TA,
      isInputWrapped: Q6,
      messages: W,
      isSearching: y,
      historyQuery: zA,
      setHistoryQuery: kA,
      historyFailedMatch: Z1,
      shouldShowSearchHint: y1,
    }),
  );
}
var L7, fY, kP2;
var _P2 = T(() => {
  nA();
  PM();
  UB2();
  vQ2();
  kB();
  ph();
  rG();
  hQ2();
  dzA();
  N8();
  czA();
  aC();
  tT2();
  Ze1();
  xPA();
  H0();
  UjA();
  lh();
  GP2();
  V2();
  YP2();
  kH();
  Je1();
  ol1();
  kH();
  c9();
  UP2();
  MP2();
  RP2();
  PP2();
  SP2();
  _H();
  ((L7 = IA(KA(), 1)), (fY = IA(KA(), 1)));
  kP2 = ni5;
});
function vP2() {
  xP2.useEffect(() => {
    let A = Math.round(process.uptime() * 1000);
    GA("tengu_timer", { event: "startup", durationMs: A });
  }, []);
}
var xP2;
var bP2 = T(() => {
  H0();
  xP2 = IA(KA(), 1);
});
function fP2() {
  let [A, B] = xwA.useState(() => {
      let Z = kU();
      if (!Sz() || nB()) return "valid";
      if (Z) return "loading";
      return "missing";
    }),
    [Q, I] = xwA.useState(null),
    G = xwA.useCallback(async () => {
      if (!Sz() || nB()) {
        B("valid");
        return;
      }
      let Z = kU();
      if (!Z) {
        B("missing");
        return;
      }
      try {
        let J = (await gP2(Z, !1)) ? "valid" : "invalid";
        B(J);
        return;
      } catch (Y) {
        (I(Y), B("error"));
        return;
      }
    }, []);
  return { status: A, reverify: G, error: Q };
}
var xwA;
var hP2 = T(() => {
  zG();
  F2();
  xwA = IA(KA(), 1);
});
function uP2(A) {
  let [B, Q] = lB();
  h1((I, G) => {
    if (G.ctrl && I === "t")
      (GA("tengu_toggle_todos", {
        is_expanded: B.showExpandedTodos,
        has_todos: A && A.length > 0,
      }),
        Q((Z) => ({ ...Z, showExpandedTodos: !Z.showExpandedTodos })));
  });
}
var mP2 = T(() => {
  nA();
  c9();
  H0();
});
function dP2(A, B, Q, I, G, Z, Y, J, X, W) {
  h1((F, C) => {
    if (!C.escape) return;
    if (G === "transcript") return;
    if (W) return;
    if (Z?.aborted) return;
    if (!Z) return;
    if (Q) return;
    if (mIA() && J === "INSERT") return;
    if (I.length > 0) {
      if (Y) Y();
    }
    (GA("tengu_cancel", {}), A(() => []), B());
  });
}
var cP2 = T(() => {
  nA();
  H0();
  dzA();
});
function vwA(A) {
  return ai5.includes(A);
}
function bwA(A, B, Q, I) {
  if (!A.toolDecisions) A.toolDecisions = new Map();
  A.toolDecisions.set(B, { source: I, decision: Q, timestamp: Date.now() });
}
function fwA(A, B, Q, I) {
  let G;
  if (A.getPath && B) {
    let Z = A.inputSchema.safeParse(B);
    if (Z.success) {
      let Y = A.getPath(Z.data);
      if (Y) G = YIA(Y);
    }
  }
  return {
    decision: Q,
    source: I,
    tool_name: A.name,
    ...(G && { language: G }),
  };
}
async function hwA(A, B, Q) {
  await _N("tool_decision", { decision: B, source: Q, tool_name: A });
}
function pP2(A, B, Q, I, G) {
  if (
    (GA("tengu_tool_use_granted_in_config", {
      messageID: I,
      toolName: A.name,
      sandboxEnabled: VQ.isSandboxingEnabled(),
    }),
    vwA(A.name))
  ) {
    let Z = fwA(A, B, "accept", "config");
    xe()?.add(1, Z);
  }
  (bwA(Q, G, "accept", "config"), hwA(A.name, "accept", "config"));
}
function si5(A, B) {
  return lP2.useCallback(
    async (Q, I, G, Z, Y, J) => {
      return new Promise((X) => {
        function W() {
          GA("tengu_tool_use_cancelled", {
            messageID: Z.message.id,
            toolName: Q.name,
          });
        }
        function F(V) {
          let K = V ? `${MKA}${V}` : NDA;
          if ((X({ behavior: "ask", message: K }), !V))
            G.abortController.abort("tool-rejection");
        }
        if (G.abortController.signal.aborted) {
          (W(), F());
          return;
        }
        return (J !== void 0 ? Promise.resolve(J) : DL(Q, I, G, Z, Y))
          .then(async (V) => {
            if (V.behavior === "allow") {
              (pP2(Q, I, G, Z.message.id, Y),
                X({ ...V, updatedInput: I, userModified: !1 }));
              return;
            }
            let K = await G.getAppState(),
              D = await Q.description(I, {
                isNonInteractiveSession: G.options.isNonInteractiveSession,
                toolPermissionContext: K.toolPermissionContext,
                tools: G.options.tools,
              });
            if (G.abortController.signal.aborted) {
              (W(), F());
              return;
            }
            switch (V.behavior) {
              case "deny": {
                if (
                  (GA("tengu_tool_use_denied_in_config", {
                    messageID: Z.message.id,
                    toolName: Q.name,
                    sandboxEnabled: VQ.isSandboxingEnabled(),
                  }),
                  vwA(Q.name))
                ) {
                  let E = fwA(Q, I, "reject", "config");
                  xe()?.add(1, E);
                }
                (bwA(G, Y, "reject", "config"),
                  hwA(Q.name, "reject", "config"),
                  X(V));
                return;
              }
              case "ask": {
                A((E) => [
                  ...E,
                  {
                    assistantMessage: Z,
                    tool: Q,
                    description: D,
                    input: I,
                    toolUseContext: G,
                    toolUseID: Y,
                    permissionResult: V,
                    onAbort() {
                      if (
                        (W(),
                        GA("tengu_tool_use_rejected_in_prompt", {
                          messageID: Z.message.id,
                          toolName: Q.name,
                          sandboxEnabled: VQ.isSandboxingEnabled(),
                          hasFeedback: !1,
                        }),
                        vwA(Q.name))
                      ) {
                        let H = fwA(Q, I, "reject", "user_abort");
                        xe()?.add(1, H);
                      }
                      (bwA(G, Y, "reject", "user_abort"),
                        hwA(Q.name, "reject", "user_abort"),
                        F());
                    },
                    async onAllow(H, w) {
                      n11(w);
                      let L = await G.getAppState(),
                        N = so(L.toolPermissionContext, w);
                      B(N);
                      let $ = w.some((k) => We1(k.destination));
                      GA(
                        $
                          ? "tengu_tool_use_granted_in_prompt_permanent"
                          : "tengu_tool_use_granted_in_prompt_temporary",
                        {
                          messageID: Z.message.id,
                          toolName: Q.name,
                          sandboxEnabled: VQ.isSandboxingEnabled(),
                        },
                      );
                      let O = $ ? "user_permanent" : "user_temporary";
                      if (vwA(Q.name)) {
                        let k = fwA(Q, H, "accept", O);
                        xe()?.add(1, k);
                      }
                      (bwA(G, Y, "accept", O), hwA(Q.name, "accept", O));
                      let P = Q.inputsEquivalent
                        ? !Q.inputsEquivalent(I, H)
                        : !1;
                      X({
                        behavior: "allow",
                        updatedInput: H,
                        userModified: P,
                      });
                    },
                    onReject(H) {
                      if (
                        (GA("tengu_tool_use_rejected_in_prompt", {
                          messageID: Z.message.id,
                          toolName: Q.name,
                          sandboxEnabled: VQ.isSandboxingEnabled(),
                          hasFeedback: !!H,
                        }),
                        vwA(Q.name))
                      ) {
                        let w = fwA(Q, I, "reject", "user_reject");
                        xe()?.add(1, w);
                      }
                      (bwA(G, Y, "reject", "user_reject"),
                        hwA(Q.name, "reject", "user_reject"),
                        F(H));
                    },
                    async recheckPermission() {
                      let H = await DL(Q, I, G, Z, Y);
                      if (H.behavior === "allow")
                        (A((w) => w.filter((L) => L.toolUseID !== Y)),
                          pP2(Q, I, G, Z.message.id, Y),
                          X({
                            behavior: "allow",
                            updatedInput: H.updatedInput || I,
                            userModified: !1,
                          }));
                    },
                  },
                ]);
                return;
              }
            }
          })
          .catch((V) => {
            if (V instanceof IX) (W(), F());
            else BA(V, Ml);
          });
      });
    },
    [A, B],
  );
}
var lP2, ai5, iP2;
var nP2 = T(() => {
  f3();
  H0();
  iB();
  y7();
  c1();
  i0();
  I5A();
  Z4();
  aC();
  VW();
  ((lP2 = IA(KA(), 1)), (ai5 = ["Edit", "Write", "NotebookEdit"]));
  iP2 = si5;
});
function sP2(A) {
  return aP2.useMemo(() => {
    let B = Rn(A);
    return { level: B.level, tokens: B.tokens };
  }, [A]);
}
var aP2;
var rP2 = T(() => {
  kH();
  aP2 = IA(KA(), 1);
});
function a11({
  output: A,
  fullOutput: B,
  elapsedTimeSeconds: Q,
  totalLines: I,
  verbose: G,
}) {
  let Z = SZ(B.trim()),
    J = SZ(A.trim())
      .split(
        `
`,
      )
      .filter((C) => C),
    X = G
      ? Z
      : J.slice(-5).join(`
`),
    W = G ? 0 : I ? Math.max(0, I - 5) : 0,
    F = Q !== void 0 ? `(${KU(Q * 1000)})` : void 0;
  if (!J.length)
    return Yy.default.createElement(
      j0,
      null,
      Yy.default.createElement(U, { dimColor: !0 }, "Running ", F),
    );
  return Yy.default.createElement(
    j0,
    null,
    Yy.default.createElement(
      S,
      { flexDirection: "column" },
      Yy.default.createElement(
        S,
        {
          height: G ? void 0 : Math.min(5, J.length),
          flexDirection: "column",
          overflow: "hidden",
        },
        Yy.default.createElement(U, { dimColor: !0 }, X),
      ),
      Yy.default.createElement(
        S,
        { flexDirection: "row", gap: 1 },
        !G &&
          W > 0 &&
          Yy.default.createElement(
            U,
            { dimColor: !0 },
            W > 0 && `+${W} more line${W === 1 ? "" : "s"}`,
          ),
        F && Yy.default.createElement(U, { dimColor: !0 }, F),
      ),
    ),
  );
}
var Yy;
var Fe1 = T(() => {
  nA();
  PM();
  L8();
  Yy = IA(KA(), 1);
});
function Ce1({ input: A, progress: B, verbose: Q }) {
  return s11.default.createElement(
    S,
    { flexDirection: "column", marginTop: 1 },
    s11.default.createElement(niA, {
      addMargin: !1,
      param: { text: `<bash-input>${A}</bash-input>`, type: "text" },
    }),
    B
      ? s11.default.createElement(a11, {
          fullOutput: B.fullOutput,
          output: B.output,
          elapsedTimeSeconds: B.elapsedTimeSeconds,
          totalLines: B.totalLines,
          verbose: Q,
        })
      : r2.renderToolUseProgressMessage([], {
          verbose: Q,
          tools: [],
          terminalSize: void 0,
        }),
  );
}
var s11;
var oP2 = T(() => {
  nA();
  Tv1();
  Fe1();
  EF();
  s11 = IA(KA(), 1);
});
async function tP2(A, B, Q, I, G, Z, Y) {
  (GA("tengu_input_bash", {}), Z(!0));
  let J = T0({
      content: Nz({
        inputString: `<bash-input>${A}</bash-input>`,
        precedingInputBlocks: B,
      }),
      autocheckpoint: Y,
    }),
    X;
  G({
    jsx: Jy.createElement(Ce1, {
      input: A,
      progress: null,
      verbose: I.options.verbose,
    }),
    shouldHidePromptInput: !1,
  });
  try {
    let W = {
        ...I,
        setToolJSX: (D) => {
          X = D?.jsx;
        },
      },
      C = (
        await r2.call(
          { command: A, dangerouslyDisableSandbox: !0 },
          W,
          void 0,
          void 0,
          (D) => {
            G({
              jsx: Jy.createElement(
                Jy.Fragment,
                null,
                Jy.createElement(Ce1, {
                  input: A,
                  progress: D.data,
                  verbose: I.options.verbose,
                }),
                X,
              ),
              shouldHidePromptInput: !1,
              showSpinner: !1,
            });
          },
        )
      ).data;
    if (!C) throw Error("No result received from bash command");
    let V = C.stderr,
      K = await I.getAppState();
    if (plA(K.toolPermissionContext)) V = clA(V);
    return {
      messages: [
        OW(),
        J,
        ...Q,
        T0({
          content: `<bash-stdout>${C.stdout}</bash-stdout><bash-stderr>${V}</bash-stderr>`,
        }),
      ],
      shouldQuery: !1,
    };
  } catch (W) {
    if (W instanceof hT) {
      if (W.interrupted)
        return {
          messages: [OW(), J, T0({ content: W6A }), ...Q],
          shouldQuery: !1,
        };
      return {
        messages: [
          OW(),
          J,
          ...Q,
          T0({
            content: `<bash-stdout>${W.stdout}</bash-stdout><bash-stderr>${W.stderr}</bash-stderr>`,
          }),
        ],
        shouldQuery: !1,
      };
    }
    return {
      messages: [
        OW(),
        J,
        ...Q,
        T0({
          content: `<bash-stderr>Command failed: ${W instanceof Error ? W.message : String(W)}</bash-stderr>`,
        }),
      ],
      shouldQuery: !1,
    };
  } finally {
    G(null);
  }
}
var Jy;
var eP2 = T(() => {
  H0();
  iB();
  iB();
  oP2();
  EF();
  qm();
  qm();
  y7();
  Jy = IA(KA(), 1);
});
import { homedir as ri5 } from "os";
import { relative as oi5 } from "path";
function Ke1(A) {
  let B = ri5(),
    Q = G0(),
    I = A.startsWith(B) ? "~" + A.slice(B.length) : null,
    G = A.startsWith(Q) ? "./" + oi5(Q, A) : null;
  if (I && G) return I.length <= G.length ? I : G;
  return I || G || A;
}
function Aj2({ memoryPath: A }) {
  let B = Ke1(A);
  return Ve1.default.createElement(
    S,
    { flexDirection: "column", flexGrow: 1 },
    Ve1.default.createElement(
      U,
      { color: "text" },
      "Memory updated in ",
      B,
      "  /memory to edit",
    ),
  );
}
var Ve1;
var De1 = T(() => {
  nA();
  V2();
  Ve1 = IA(KA(), 1);
});
import { dirname as Bj2 } from "path";
function ti5(A) {
  let B = A.trim();
  if (!B) return "";
  if (B.startsWith("- ")) return B;
  if (B.startsWith("-")) return `- ${B.slice(1).trim()}`;
  return `- ${B}`;
}
function ei5() {
  let A = L1(),
    B = (A.memoryUsageCount || 0) + 1;
  n0({ ...A, memoryUsageCount: B });
}
var Ee1, Qj2;
var Ij2 = T(() => {
  De1();
  H0();
  kB();
  Ge1();
  m0();
  Z4();
  c1();
  Ee1 = IA(KA(), 1);
  Qj2 = vP(async function (A, B, Q) {
    (GA("tengu_add_memory_start", {}), ei5());
    let I = eT2(Q);
    if (!NA().existsSync(Bj2(Q)))
      try {
        NA().mkdirSync(Bj2(Q));
      } catch (G) {
        BA(G instanceof Error ? G : Error(String(G)), zY0);
      }
    try {
      let G = ti5(A),
        Z = I.replace(/\n+$/, ""),
        Y = Z
          ? `${Z}
${G}`
          : G;
      (NA().writeFileSync(Q, Y, { encoding: "utf8", flush: !0 }),
        B.readFileState.set(Q, {
          content: Y,
          timestamp: BV(Q),
          offset: void 0,
          limit: void 0,
        }),
        GA("tengu_add_memory_success", {}),
        B.addNotification?.({
          key: "memory-update-success",
          priority: "immediate",
          jsx: Ee1.createElement(Aj2, { memoryPath: Q }),
        }));
    } catch (G) {
      (BA(G, dJ0),
        GA("tengu_add_memory_failure", {}),
        B.addNotification?.({
          key: "memory-update-error",
          priority: "high",
          text: "Failed to save memory",
          color: "error",
        }));
    }
  });
});
function Gj2(A, B, Q, I, G) {
  GA("tengu_input_memory", {});
  let Z = T0({
    content: Nz({
      inputString: `<user-memory-input>${A}</user-memory-input>`,
      precedingInputBlocks: B,
    }),
  });
  return (Qj2(A, I, G), { messages: [OW(), ...Q, Z], shouldQuery: !1 });
}
var Zj2 = T(() => {
  H0();
  iB();
  Ij2();
});
function Yj2(A, B, Q, I, G, Z, Y, J) {
  I(!0);
  let X =
    typeof A === "string" ? A : A.find((V) => V.type === "text")?.text || "";
  ofQ(X);
  let W = {};
  if (typeof A === "string") {
    let V = jdQ(A),
      K = SdQ(A);
    ((W = { is_negative: V, is_keep_going: K }),
      _N("user_prompt", { prompt_length: String(A.length), prompt: VaA(A) }));
  }
  if ((GA("tengu_input_prompt", W), B.length > 0)) {
    let V = T0({
        content: [
          ...B,
          ...(typeof A === "string" ? [{ type: "text", text: A }] : A),
        ],
        autocheckpoint: G,
        uuid: Z,
        thinkingMetadata: Y,
      }),
      K = $_([V], J ?? void 0);
    return {
      messages: [V, ...Q],
      shouldQuery: !0,
      maxThinkingTokens: K > 0 ? K : void 0,
    };
  }
  let F = T0({ content: A, autocheckpoint: G, uuid: Z, thinkingMetadata: Y }),
    C = $_([F], J ?? void 0);
  return {
    messages: [F, ...Q],
    shouldQuery: !0,
    maxThinkingTokens: C > 0 ? C : void 0,
  };
}
var Jj2 = T(() => {
  H0();
  I5A();
  ss();
  iB();
  kH();
});
function we1() {
  if (!He1) He1 = EA("perf_hooks").performance;
  return He1;
}
function Fj2() {
  if (!gwA) return;
  (we1().clearMarks(),
    Ue1.clear(),
    (ze1 = null),
    Wj2++,
    LI("query_user_input_received"));
}
function LI(A) {
  if (!gwA) return;
  let B = we1();
  if (
    (B.mark(A),
    Ue1.set(A, process.memoryUsage()),
    A === "query_first_chunk_received" && ze1 === null)
  ) {
    let Q = B.getEntriesByType("mark");
    if (Q.length > 0) ze1 = Q[Q.length - 1]?.startTime ?? 0;
  }
}
function Cj2() {
  if (!gwA) return;
  LI("query_profile_end");
}
function e3A(A) {
  return A.toFixed(3);
}
function Xj2(A) {
  return (A / 1024 / 1024).toFixed(2);
}
function An5(A, B) {
  if (B === "query_user_input_received") return "";
  if (A > 1000) return "   VERY SLOW";
  if (A > 100) return "   SLOW";
  if (B.includes("git_status") && A > 50) return "   git status";
  if (B.includes("tool_schema") && A > 50) return "   tool schemas";
  if (B.includes("client_creation") && A > 50) return "   client creation";
  return "";
}
function Bn5() {
  if (!gwA)
    return "Query profiling not enabled (set CLAUDE_CODE_PROFILE_QUERY=1)";
  let B = we1().getEntriesByType("mark");
  if (B.length === 0) return "No query profiling checkpoints recorded";
  let Q = [];
  (Q.push("=".repeat(80)),
    Q.push(`QUERY PROFILING REPORT - Query #${Wj2}`),
    Q.push("=".repeat(80)),
    Q.push(""));
  let I = B[0]?.startTime ?? 0,
    G = I,
    Z = 0,
    Y = 0;
  for (let W of B) {
    let F = W.startTime - I,
      C = e3A(F),
      V = W.startTime - G,
      K = e3A(V),
      D = Ue1.get(W.name),
      E = An5(V, W.name),
      H = D ? ` | RSS: ${Xj2(D.rss)}MB, Heap: ${Xj2(D.heapUsed)}MB` : "";
    if (
      (Q.push(`[+${C.padStart(10)}ms] (+${K.padStart(9)}ms) ${W.name}${E}${H}`),
      W.name === "query_api_request_sent")
    )
      Z = F;
    if (W.name === "query_first_chunk_received") Y = F;
    G = W.startTime;
  }
  let J = B[B.length - 1],
    X = J ? J.startTime - I : 0;
  if ((Q.push(""), Q.push("-".repeat(80)), Y > 0)) {
    let W = Z,
      F = Y - Z,
      C = ((W / Y) * 100).toFixed(1),
      V = ((F / Y) * 100).toFixed(1);
    (Q.push(`Total TTFT: ${e3A(Y)}ms`),
      Q.push(`  - Pre-request overhead: ${e3A(W)}ms (${C}%)`),
      Q.push(`  - Network latency: ${e3A(F)}ms (${V}%)`));
  } else Q.push(`Total time: ${e3A(X)}ms`);
  return (
    Q.push("=".repeat(80)),
    Q.join(`
`)
  );
}
function Vj2() {
  if (!gwA) return;
  g(Bn5());
}
var gwA,
  Ue1,
  Wj2 = 0,
  ze1 = null,
  He1 = null;
var uwA = T(() => {
  C0();
  ((gwA = process.env.CLAUDE_CODE_PROFILE_QUERY === "1"), (Ue1 = new Map()));
});
import { randomUUID as Qn5 } from "node:crypto";
async function Db({
  input: A,
  mode: B,
  setIsLoading: Q,
  setToolJSX: I,
  context: G,
  pastedContents: Z,
  ideSelection: Y,
  memoryPath: J,
  autocheckpoint: X,
  messages: W,
  setUserInputOnProcessing: F,
  uuid: C,
  isAlreadyProcessing: V,
  thinkingMetadata: K,
  manualThinkingTokens: D,
  querySource: E,
}) {
  let H = typeof A === "string" ? A : null;
  if (B === "prompt" && H !== null) F?.(H);
  LI("query_process_user_input_base_start");
  let w = await In5(A, B, Q, I, G, Z, Y, J, X, W, C, V, K, D, E);
  if ((LI("query_process_user_input_base_end"), !w.shouldQuery))
    return (F?.(void 0), w);
  LI("query_hooks_start");
  let L = C6A(A) || "",
    N = await G.getAppState();
  for await (let $ of Ne1(L, N.toolPermissionContext.mode, G)) {
    if ($.message?.type === "progress") continue;
    if ($.blockingError) {
      let O = qe1($.blockingError);
      return (
        F?.(void 0),
        {
          messages: [
            bN(
              `${O}

Original prompt: ${A}`,
              "warning",
            ),
          ],
          shouldQuery: !1,
          allowedTools: w.allowedTools,
          skipHistory: w.skipHistory,
          maxThinkingTokens: w.maxThinkingTokens,
        }
      );
    }
    if ($.preventContinuation) {
      let O = $.stopReason
        ? `Operation stopped by hook: ${$.stopReason}`
        : "Operation stopped by hook";
      return (
        w.messages.push(T0({ content: O })),
        (w.shouldQuery = !1),
        F?.(void 0),
        w
      );
    }
    if ($.additionalContexts && $.additionalContexts.length > 0)
      w.messages.push(
        f8({
          type: "hook_additional_context",
          content: $.additionalContexts.map(Kj2),
          hookName: "UserPromptSubmit",
          toolUseID: `hook-${Qn5()}`,
          hookEvent: "UserPromptSubmit",
        }),
      );
    if ($.message)
      switch ($.message.attachment.type) {
        case "hook_success":
          if (!$.message.attachment.content) break;
          w.messages.push({
            ...$.message,
            attachment: {
              ...$.message.attachment,
              content: Kj2($.message.attachment.content),
            },
          });
          break;
        default:
          w.messages.push($.message);
          break;
      }
  }
  return (LI("query_hooks_end"), F?.(void 0), w);
}
function Kj2(A) {
  if (A.length > $e1)
    return `${A.substring(0, $e1)} [output truncated - exceeded ${$e1} characters]`;
  return A;
}
async function In5(A, B, Q, I, G, Z, Y, J, X, W, F, C, V, K, D) {
  let E = null,
    H = [];
  if (typeof A === "string") E = A;
  else if (A.length > 0) {
    LI("query_image_processing_start");
    for (let O = 0; O < A.length; O++) {
      let P = A[O];
      if (P.type === "image") A[O] = await Lx0(P);
    }
    LI("query_image_processing_end");
    let $ = A[A.length - 1];
    if ($?.type === "text") ((E = $.text), (H = [...A.slice(0, -1)]));
    else H = A;
  }
  if (E === null && B !== "prompt")
    throw Error(`Mode: ${B} requires a string input.`);
  let w = Z
      ? Object.values(Z)
          .filter(($) => $.type === "image")
          .map(($) => ({
            type: "image",
            source: {
              type: "base64",
              media_type: $.mediaType || "image/png",
              data: $.content,
            },
          }))
      : [],
    L = E !== null && (B !== "prompt" || !E.startsWith("/"));
  LI("query_attachment_loading_start");
  let N = L ? await GsA(Y6A(E, G, Y ?? null, [], W, D)) : [];
  if ((LI("query_attachment_loading_end"), E !== null && B === "bash"))
    return await tP2(E, H, N, G, I, Q, X);
  if (E !== null && B === "background") return await bT2(E, H, N, G, I, Q, X);
  if (E !== null && B === "memorySelect" && J) return Gj2(E, H, N, G, J);
  if (E !== null && E.startsWith("/"))
    return await t12(E, H, w, N, G, Q, I, X, F, C);
  if (E !== null && B === "prompt") {
    let $ = E.trim(),
      O = N.find((P) => P.attachment.type === "agent_mention");
    if (O) {
      let P = `@agent-${O.attachment.agentType}`,
        k = $ === P,
        b = $.startsWith(P) && !k;
      GA("tengu_subagent_at_mention", { is_subagent_only: k, is_prefix: b });
    }
  }
  return Yj2(A, w, N, Q, X, F, V, K);
}
var $e1 = 1e4;
var mwA = T(() => {
  iB();
  Gr();
  uj();
  iB();
  mj();
  ot1();
  eP2();
  toA();
  Zj2();
  Jj2();
  DjA();
  H0();
  uwA();
});
function Gn5() {
  (sP1(""), D8(0));
}
async function Le1(A) {
  let {
      input: B,
      memoryPath: Q,
      helpers: I,
      isLoading: G,
      mode: Z,
      commands: Y,
      onInputChange: J,
      onModeChange: X,
      setPastedContents: W,
      onSubmitCountChange: F,
      setIDESelection: C,
      setIsLoading: V,
      setToolJSX: K,
      getToolUseContext: D,
      messages: E,
      mainLoopModel: H,
      pastedContents: w,
      ideSelection: L,
      setUserInputOnProcessing: N,
      queueManager: $,
      setAbortController: O,
      onQuery: P,
      resetLoadingState: k,
      thinkingTokens: b,
      checkpointing: x,
      thinkingEnabled: n,
      setAppState: m,
      onBeforeQuery: o,
    } = A,
    { setCursorOffset: l, clearBuffer: y, resetHistory: c } = I;
  if (B.trim() === "") return;
  if (["exit", "quit", ":q", ":q!", ":wq", ":wq!"].includes(B.trim())) {
    if (Y.find((wA) => wA.name === "exit")) Le1({ ...A, input: "/exit" });
    else Gn5();
    return;
  }
  let e = B,
    QA = ox0(B),
    WA = 0;
  for (let JA of QA) {
    let wA = w[JA.id];
    if (wA && wA.type === "text") ((e = e.replace(JA.match, wA.content)), WA++);
  }
  if ((GA("tengu_paste_text", { pastedTextCount: WA }), Z === "memory")) {
    X("memorySelect");
    return;
  }
  if (G) {
    if (Z !== "prompt" && Z !== "memorySelect") return;
    if (Z === "memorySelect" && Q) {
      let JA = a9(),
        wA = D(E, [], JA, [], void 0, H);
      (Db({
        input: e,
        mode: "memorySelect",
        setIsLoading: V,
        setToolJSX: K,
        context: wA,
        memoryPath: Q,
        messages: E,
      }),
        X("prompt"));
    }
    ($.enqueue({ value: e, mode: "prompt" }), J(""), l(0), W({}), c(), y());
    return;
  }
  (J(""),
    l(0),
    X("prompt"),
    W({}),
    C(void 0),
    F((JA) => JA + 1),
    y(),
    Fj2(),
    await Dj2({
      input: e,
      mode: Z,
      messages: E,
      mainLoopModel: H,
      pastedContents: w,
      ideSelection: L,
      memoryPath: Q,
      thinkingTokens: b,
      thinkingEnabled: n,
      checkpointing: x,
      queueManager: $,
      querySource: A.querySource,
      commands: Y,
      isLoading: G,
      setIsLoading: V,
      setToolJSX: K,
      getToolUseContext: D,
      setUserInputOnProcessing: N,
      setAbortController: O,
      onQuery: P,
      resetLoadingState: k,
      setAppState: m,
      onBeforeQuery: o,
      resetHistory: c,
    }));
}
async function Dj2(A) {
  let {
    input: B,
    mode: Q,
    messages: I,
    mainLoopModel: G,
    pastedContents: Z,
    ideSelection: Y,
    memoryPath: J,
    thinkingTokens: X,
    thinkingEnabled: W,
    checkpointing: F,
    queueManager: C,
    querySource: V,
    isLoading: K,
    setIsLoading: D,
    setToolJSX: E,
    getToolUseContext: H,
    setUserInputOnProcessing: w,
    setAbortController: L,
    onQuery: N,
    resetLoadingState: $,
    setAppState: O,
    onBeforeQuery: P,
    resetHistory: k,
  } = A;
  LI("query_autocheckpoint_start");
  let b = await srA(B, Q, F, (WA) => {
    O((JA) => ({ ...JA, checkpointing: WA }));
  });
  LI("query_autocheckpoint_end");
  let x = !K,
    n = a9();
  if (x) L(n);
  let m = Zn5(Q, X, B, W);
  LI("query_process_user_input_start");
  let {
    messages: o,
    shouldQuery: l,
    allowedTools: y,
    skipHistory: c,
    maxThinkingTokens: e,
    model: QA,
  } = await Db({
    input: B,
    mode: Q,
    setIsLoading: D,
    setToolJSX: E,
    context: H(I, [], n, [], void 0, G),
    pastedContents: Z,
    ideSelection: Y,
    memoryPath: J,
    autocheckpoint: b,
    messages: I,
    setUserInputOnProcessing: w,
    isAlreadyProcessing: K,
    thinkingMetadata: m,
    querySource: V,
  });
  if ((LI("query_process_user_input_end"), UG()))
    (LI("query_file_history_snapshot_start"),
      o.filter(GIA).forEach((WA) => {
        MdA((JA) => {
          O((wA) => ({ ...wA, fileHistory: JA(wA.fileHistory) }));
        }, WA.uuid);
      }),
      LI("query_file_history_snapshot_end"));
  if ((E(null), o.length)) {
    let JA = await N(
      o,
      n,
      l,
      y ?? [],
      QA ?? G,
      e,
      C,
      Q === "prompt" ? P : void 0,
      B,
    );
    if (!C.isEmpty() && JA.status === "completed") {
      let wA = [],
        xA;
      while ((xA = C.dequeue())) wA.push(xA.value);
      if (wA.length > 0)
        await Dj2({
          ...A,
          input: wA.join(`
`),
          mode: "prompt",
        });
    }
  } else {
    if (!c) gk({ display: B, pastedContents: Z });
    if ((k(), !K)) (L(null), $(void 0));
    return;
  }
  for (let WA of o)
    if (WA.type === "user")
      (gk({ display: Yb0(B, Q), pastedContents: Z }), k());
}
function Zn5(A, B, Q, I) {
  if (A !== "prompt") return;
  let G = B > 0,
    Z = G ? XbA(Q) : [],
    Y = !I && !G;
  return {
    level: Y ? "none" : "high",
    disabled: Y,
    triggers: Z.map((X) => ({
      start: X.start,
      end: X.end,
      text: Q.slice(X.start, X.end),
    })),
  };
}
var Ej2 = T(() => {
  ph();
  H0();
  BzA();
  vG();
  kH();
  mwA();
  tq();
  orA();
  Xx();
  xY();
  uwA();
});
function Yn5(A, B, Q, I) {
  var G = A.length,
    Z = Q + (I ? 1 : -1);
  while (I ? Z-- : ++Z < G) if (B(A[Z], Z, A)) return Z;
  return -1;
}
var Hj2;
var zj2 = T(() => {
  Hj2 = Yn5;
});
function Jn5(A) {
  return A !== A;
}
var Uj2;
var wj2 = T(() => {
  Uj2 = Jn5;
});
function Xn5(A, B, Q) {
  var I = Q - 1,
    G = A.length;
  while (++I < G) if (A[I] === B) return I;
  return -1;
}
var $j2;
var qj2 = T(() => {
  $j2 = Xn5;
});
function Wn5(A, B, Q) {
  return B === B ? $j2(A, B, Q) : Hj2(A, Uj2, Q);
}
var Nj2;
var Lj2 = T(() => {
  zj2();
  wj2();
  qj2();
  Nj2 = Wn5;
});
function Fn5(A, B) {
  var Q = A == null ? 0 : A.length;
  return !!Q && Nj2(A, B, 0) > -1;
}
var Mj2;
var Oj2 = T(() => {
  Lj2();
  Mj2 = Fn5;
});
function Cn5(A, B, Q) {
  var I = -1,
    G = A == null ? 0 : A.length;
  while (++I < G) if (Q(B, A[I])) return !0;
  return !1;
}
var Rj2;
var Tj2 = T(() => {
  Rj2 = Cn5;
});
var Vn5 = 1 / 0,
  Kn5,
  Pj2;
var jj2 = T(() => {
  O91();
  bY1();
  NNA();
  ((Kn5 = !(Mf && 1 / De(new Mf([, -0]))[1] == Vn5)
    ? JJA
    : function (A) {
        return new Mf(A);
      }),
    (Pj2 = Kn5));
});
function En5(A, B, Q) {
  var I = -1,
    G = Mj2,
    Z = A.length,
    Y = !0,
    J = [],
    X = J;
  if (Q) ((Y = !1), (G = Rj2));
  else if (Z >= Dn5) {
    var W = B ? null : Pj2(A);
    if (W) return De(W);
    ((Y = !1), (G = $NA), (X = new wNA()));
  } else X = B ? [] : J;
  A: while (++I < Z) {
    var F = A[I],
      C = B ? B(F) : F;
    if (((F = Q || F !== 0 ? F : 0), Y && C === C)) {
      var V = X.length;
      while (V--) if (X[V] === C) continue A;
      if (B) X.push(C);
      J.push(F);
    } else if (!G(X, C, Q)) {
      if (X !== J) X.push(C);
      J.push(F);
    }
  }
  return J;
}
var Dn5 = 200,
  Sj2;
var yj2 = T(() => {
  V91();
  Oj2();
  Tj2();
  K91();
  jj2();
  NNA();
  Sj2 = En5;
});
function Hn5(A, B) {
  return A && A.length ? Sj2(A, DT(B, 2)) : [];
}
var A7A;
var r11 = T(() => {
  Se();
  yj2();
  A7A = Hn5;
});
function _j2(A, B) {
  return kj2.useMemo(() => {
    if (A && B && B.length > 0) return A7A([...A, ...B], "name");
    return A || [];
  }, [A, B]);
}
var kj2;
var xj2 = T(() => {
  r11();
  kj2 = IA(KA(), 1);
});
function vj2(A, B) {
  if (B) return A ? `agent:builtin:${A}` : "agent:default";
  else return "agent:custom";
}
function dwA() {
  let B = N0()?.outputStyle ?? nF;
  if (B === nF) return "repl_main_thread";
  return B in ro
    ? `repl_main_thread:outputStyle:${B}`
    : "repl_main_thread:outputStyle:custom";
}
var Me1 = T(() => {
  OQ();
  Gy();
});
function o11(A, B) {
  return bj2.useMemo(() => {
    if (eJ()) return A;
    return A7A([...A, ...B], "name");
  }, [A, B]);
}
var bj2;
var Oe1 = T(() => {
  r11();
  ez();
  bj2 = IA(KA(), 1);
});
function Re1(A, B) {
  return fj2.useMemo(() => {
    if (B.length > 0) return A7A([...A, ...B], "name");
    return A;
  }, [A, B]);
}
var fj2;
var hj2 = T(() => {
  r11();
  fj2 = IA(KA(), 1);
});
async function cc(A, B, Q) {
  let I = A;
  return (
    await Promise.all(
      [...A.matchAll(zn5), ...A.matchAll(Un5)].map(async (G) => {
        let Z = G[1]?.trim();
        if (Z)
          try {
            let Y = await DL(r2, { command: Z }, B, CV({ content: [] }), "");
            if (Y.behavior !== "allow")
              throw (
                g(
                  `Bash command permission check failed for command in ${Q}: ${Z}. Error: ${Y.message}`,
                ),
                new fT(
                  `Bash command permission check failed for pattern "${G[0]}": ${Y.message || "Permission denied"}`,
                )
              );
            let { data: J } = await r2.call({ command: Z }, B),
              X = gj2(J.stdout, J.stderr);
            I = I.replace(G[0], X);
          } catch (Y) {
            if (Y instanceof fT) throw Y;
            wn5(Y, G[0]);
          }
      }),
    ),
    I
  );
}
function gj2(A, B, Q = !1) {
  let I = [];
  if (A.trim()) I.push(A.trim());
  if (B.trim())
    if (Q) I.push(`[stderr: ${B.trim()}]`);
    else
      I.push(`[stderr]
${B.trim()}`);
  return I.join(
    Q
      ? " "
      : `
`,
  );
}
function wn5(A, B, Q = !1) {
  if (A instanceof hT) {
    if (A.interrupted)
      throw new fT(
        `Bash command interrupted for pattern "${B}": [Command interrupted]`,
      );
    let Z = gj2(A.stdout, A.stderr, Q);
    throw new fT(`Bash command failed for pattern "${B}": ${Z}`);
  }
  let I = A instanceof Error ? A.message : String(A),
    G = Q
      ? `[Error: ${I}]`
      : `[Error]
${I}`;
  throw new fT(G);
}
var zn5, Un5;
var cwA = T(() => {
  EF();
  y7();
  C0();
  f3();
  iB();
  ((zn5 = /```!\s*\n?([\s\S]*?)\n?```/g), (Un5 = /(?<!\w)!`([^`]+)`/g));
});
import { join as B7A, basename as Q7A, dirname as pc } from "path";
function t11(A) {
  return /^skill\.md$/i.test(Q7A(A));
}
function Nn5(A, B, Q) {
  if (t11(A)) {
    let G = pc(A),
      Z = pc(G),
      Y = Q7A(G),
      J = Z.startsWith(B) ? Z.slice(B.length).replace(/^\//, "") : "",
      X = J ? J.split("/").join(":") : "";
    return X ? `${Q}:${X}:${Y}` : `${Q}:${Y}`;
  } else {
    let G = pc(A),
      Z = Q7A(A).replace(/\.md$/, ""),
      Y = G.startsWith(B) ? G.slice(B.length).replace(/^\//, "") : "",
      J = Y ? Y.split("/").join(":") : "";
    return J ? `${Q}:${J}:${Z}` : `${Q}:${Z}`;
  }
}
function Ln5(A, B) {
  let Q = [],
    I = NA();
  function G(Z) {
    try {
      let Y = I.readdirSync(Z);
      if (Y.some((X) => X.isFile() && t11(X.name))) {
        for (let X of Y)
          if (X.isFile() && X.name.toLowerCase().endsWith(".md")) {
            let W = B7A(Z, X.name),
              F = I.readFileSync(W, { encoding: "utf-8" }),
              { frontmatter: C, content: V } = GW(F);
            Q.push({ filePath: W, baseDir: B, frontmatter: C, content: V });
          }
        return;
      }
      for (let X of Y) {
        let W = B7A(Z, X.name);
        if (X.isDirectory()) G(W);
        else if (X.isFile() && X.name.toLowerCase().endsWith(".md")) {
          let F = I.readFileSync(W, { encoding: "utf-8" }),
            { frontmatter: C, content: V } = GW(F);
          Q.push({ filePath: W, baseDir: B, frontmatter: C, content: V });
        }
      }
    } catch (Y) {
      g(`Failed to scan directory ${Z}: ${Y}`, { level: "error" });
    }
  }
  return (G(A), Q);
}
function Mn5(A) {
  let B = new Map();
  for (let I of A) {
    let G = pc(I.filePath),
      Z = B.get(G) ?? [];
    (Z.push(I), B.set(G, Z));
  }
  let Q = [];
  for (let [I, G] of B) {
    let Z = G.filter((Y) => t11(Y.filePath));
    if (Z.length > 0) {
      let Y = Z[0];
      if (Z.length > 1)
        g(`Multiple skill files found in ${I}, using ${Q7A(Y.filePath)}`);
      Q.push(Y);
    } else Q.push(...G);
  }
  return Q;
}
async function uj2(A, B, Q, I, G, Z = { isSkillMode: !1 }) {
  let Y = Ln5(A, A),
    J = Mn5(Y),
    X = [];
  for (let W of J) {
    let F = Nn5(W.filePath, W.baseDir, B),
      C = pwA(F, W, Q, I, G, t11(W.filePath), Z);
    if (C) X.push(C);
  }
  return X;
}
function pwA(A, B, Q, I, G, Z, Y = { isSkillMode: !1 }) {
  try {
    let { frontmatter: J, content: X } = B,
      W = J.description ?? Xy(X, Z ? "Plugin skill" : "Plugin command"),
      F = lc(J["allowed-tools"]),
      C = J["argument-hint"],
      V = J.when_to_use,
      K = J.version,
      D = J.name,
      E = J.model === "inherit" ? void 0 : J.model,
      H = J["disable-model-invocation"],
      w;
    if (Y.isSkillMode) w = H === void 0 ? !1 : V0(H);
    else w = V0(H);
    let L = Y.isSkillMode ? qn5 : $n5,
      N = `${W} (${L}:${Q})`,
      $ = Y.isSkillMode ? !0 : !1;
    return {
      type: "prompt",
      name: A,
      description: N,
      hasUserSpecifiedDescription: !!J.description,
      allowedTools: F,
      argumentHint: C,
      whenToUse: V,
      version: K,
      model: E,
      isSkill: Z || Y.isSkillMode,
      disableModelInvocation: w,
      source: "plugin",
      pluginInfo: { pluginManifest: I, repository: Q },
      isEnabled: () => !0,
      isHidden: $,
      progressMessage: Z || Y.isSkillMode ? "loading" : "running",
      userFacingName() {
        return D || A;
      },
      async getPromptForCommand(O, P) {
        let k = Y.isSkillMode
          ? `Base directory for this skill: ${pc(B.filePath)}

${X}`
          : X;
        if (O)
          if (k.includes("$ARGUMENTS")) k = k.replaceAll("$ARGUMENTS", O);
          else
            k =
              k +
              `

ARGUMENTS: ${O}`;
        return (
          (k = Mc1(k, G)),
          (k = await cc(
            k,
            {
              ...P,
              async getAppState() {
                let b = await P.getAppState();
                return {
                  ...b,
                  toolPermissionContext: {
                    ...b.toolPermissionContext,
                    alwaysAllowRules: {
                      ...b.toolPermissionContext.alwaysAllowRules,
                      command: F,
                    },
                  },
                };
              },
            },
            `/${A}`,
          )),
          [{ type: "text", text: k }]
        );
      },
    };
  } catch (J) {
    return (
      g(`Failed to create command from ${B.filePath}: ${J}`, {
        level: "error",
      }),
      null
    );
  }
}
function e11() {
  oo.cache?.clear?.();
}
async function mj2(A, B, Q, I, G) {
  let Z = NA(),
    Y = [];
  try {
    if (!Z.existsSync(A)) return [];
    let J = B7A(A, "SKILL.md");
    if (Z.existsSync(J)) {
      try {
        let W = Z.readFileSync(J, { encoding: "utf-8" }),
          { frontmatter: F, content: C } = GW(W),
          V = `${B}:${Q7A(A)}`,
          K = { filePath: J, baseDir: pc(J), frontmatter: F, content: C },
          D = pwA(V, K, Q, I, G, !0, { isSkillMode: !0 });
        if (D) Y.push(D);
      } catch (W) {
        g(`Failed to load skill from ${J}: ${W}`, { level: "error" });
      }
      return Y;
    }
    let X = Z.readdirSync(A);
    for (let W of X) {
      if (!W.isDirectory() && !W.isSymbolicLink()) continue;
      let F = B7A(A, W.name),
        C = B7A(F, "SKILL.md");
      if (Z.existsSync(C))
        try {
          let V = Z.readFileSync(C, { encoding: "utf-8" }),
            { frontmatter: K, content: D } = GW(V),
            E = `${B}:${W.name}`,
            H = { filePath: C, baseDir: pc(C), frontmatter: K, content: D },
            w = pwA(E, H, Q, I, G, !0, { isSkillMode: !0 });
          if (w) Y.push(w);
        } catch (V) {
          g(`Failed to load skill from ${C}: ${V}`, { level: "error" });
        }
    }
  } catch (J) {
    g(`Failed to load skills from directory ${A}: ${J}`, { level: "error" });
  }
  return Y;
}
function dj2() {
  Te1.cache?.clear?.();
}
var $n5 = "plugin",
  qn5 = "plugin",
  oo,
  Te1;
var lwA = T(() => {
  a2();
  m0();
  NF();
  C0();
  cwA();
  xS();
  vB();
  Oc1();
  oo = I0(async () => {
    let { enabled: A, errors: B } = await Z3(),
      Q = [];
    if (B.length > 0)
      g(`Plugin loading errors: ${B.map((I) => nN(I)).join(", ")}`);
    for (let I of A) {
      if (I.commandsPath)
        try {
          let G = await uj2(
            I.commandsPath,
            I.name,
            I.source,
            I.manifest,
            I.path,
          );
          if ((Q.push(...G), G.length > 0))
            g(
              `Loaded ${G.length} commands from plugin ${I.name} default directory`,
            );
        } catch (G) {
          g(
            `Failed to load commands from plugin ${I.name} default directory: ${G}`,
            { level: "error" },
          );
        }
      if (I.commandsPaths) {
        g(`Plugin ${I.name} has commandsPaths: ${I.commandsPaths.join(", ")}`);
        for (let G of I.commandsPaths)
          try {
            let Z = NA(),
              Y = Z.statSync(G);
            if (
              (g(
                `Checking commandPath ${G} - isDirectory: ${Y.isDirectory()}, isFile: ${Y.isFile()}`,
              ),
              Y.isDirectory())
            ) {
              let J = await uj2(G, I.name, I.source, I.manifest, I.path);
              if ((Q.push(...J), J.length > 0))
                g(
                  `Loaded ${J.length} commands from plugin ${I.name} custom path: ${G}`,
                );
              else
                g(
                  `Warning: No commands found in plugin ${I.name} custom directory: ${G}. Expected .md files or SKILL.md in subdirectories.`,
                  { level: "warn" },
                );
            } else if (Y.isFile() && G.endsWith(".md")) {
              let J = Z.readFileSync(G, { encoding: "utf-8" }),
                { frontmatter: X, content: W } = GW(J),
                F,
                C;
              if (I.commandsMetadata) {
                for (let [E, H] of Object.entries(I.commandsMetadata))
                  if (H.source) {
                    let w = B7A(I.path, H.source);
                    if (G === w) {
                      ((F = `${I.name}:${E}`), (C = H));
                      break;
                    }
                  }
              }
              if (!F) F = `${I.name}:${Q7A(G).replace(/\.md$/, "")}`;
              let V = C
                  ? {
                      ...X,
                      ...(C.description && { description: C.description }),
                      ...(C.argumentHint && {
                        "argument-hint": C.argumentHint,
                      }),
                      ...(C.model && { model: C.model }),
                      ...(C.allowedTools && {
                        "allowed-tools": C.allowedTools.join(","),
                      }),
                    }
                  : X,
                K = { filePath: G, baseDir: pc(G), frontmatter: V, content: W },
                D = pwA(F, K, I.source, I.manifest, I.path, !1);
              if (D)
                (Q.push(D),
                  g(
                    `Loaded command from plugin ${I.name} custom file: ${G}${C ? " (with metadata override)" : ""}`,
                  ));
            }
          } catch (Z) {
            g(
              `Failed to load commands from plugin ${I.name} custom path ${G}: ${Z}`,
              { level: "error" },
            );
          }
      }
      if (I.commandsMetadata) {
        for (let [G, Z] of Object.entries(I.commandsMetadata))
          if (Z.content && !Z.source)
            try {
              let { frontmatter: Y, content: J } = GW(Z.content),
                X = {
                  ...Y,
                  ...(Z.description && { description: Z.description }),
                  ...(Z.argumentHint && { "argument-hint": Z.argumentHint }),
                  ...(Z.model && { model: Z.model }),
                  ...(Z.allowedTools && {
                    "allowed-tools": Z.allowedTools.join(","),
                  }),
                },
                W = `${I.name}:${G}`,
                F = {
                  filePath: `<inline:${W}>`,
                  baseDir: I.path,
                  frontmatter: X,
                  content: J,
                },
                C = pwA(W, F, I.source, I.manifest, I.path, !1);
              if (C)
                (Q.push(C),
                  g(
                    `Loaded inline content command from plugin ${I.name}: ${W}`,
                  ));
            } catch (Y) {
              g(
                `Failed to load inline content command ${G} from plugin ${I.name}: ${Y}`,
                { level: "error" },
              );
            }
      }
    }
    return (g(`Total plugin commands loaded: ${Q.length}`), Q);
  });
  Te1 = I0(async () => {
    g(">>>>> getPluginSkills CALLED <<<<<");
    let { enabled: A, errors: B } = await Z3(),
      Q = [];
    if (B.length > 0)
      g(`Plugin loading errors: ${B.map((I) => nN(I)).join(", ")}`);
    g(`getPluginSkills: Processing ${A.length} enabled plugins`);
    for (let I of A) {
      if (
        (g(
          `Checking plugin ${I.name}: skillsPath=${I.skillsPath ? "exists" : "none"}, skillsPaths=${I.skillsPaths ? I.skillsPaths.length : 0} paths`,
        ),
        I.skillsPath)
      ) {
        g(
          `Attempting to load skills from plugin ${I.name} default skillsPath: ${I.skillsPath}`,
        );
        try {
          let G = await mj2(I.skillsPath, I.name, I.source, I.manifest, I.path);
          (Q.push(...G),
            g(
              `Loaded ${G.length} skills from plugin ${I.name} default directory`,
            ));
        } catch (G) {
          g(
            `Failed to load skills from plugin ${I.name} default directory: ${G}`,
            { level: "error" },
          );
        }
      }
      if (I.skillsPaths) {
        g(
          `Attempting to load skills from plugin ${I.name} skillsPaths: ${I.skillsPaths.join(", ")}`,
        );
        for (let G of I.skillsPaths)
          try {
            g(`Loading from skillPath: ${G} for plugin ${I.name}`);
            let Z = await mj2(G, I.name, I.source, I.manifest, I.path);
            (Q.push(...Z),
              g(
                `Loaded ${Z.length} skills from plugin ${I.name} custom path: ${G}`,
              ));
          } catch (Z) {
            g(
              `Failed to load skills from plugin ${I.name} custom path ${G}: ${Z}`,
              { level: "error" },
            );
          }
      }
    }
    return (g(`Total plugin skills loaded: ${Q.length}`), Q);
  });
});
import { join as On5, basename as Rn5 } from "path";
function cj2(A, B, Q) {
  let I = [],
    G = NA();
  function Z(Y, J = []) {
    try {
      let X = G.readdirSync(Y);
      for (let W of X) {
        let F = On5(Y, W.name);
        if (W.isDirectory()) Z(F, [...J, W.name]);
        else if (W.isFile() && W.name.endsWith(".md")) {
          let C = pj2(F, B, J, Q);
          if (C) I.push(C);
        }
      }
    } catch (X) {
      g(`Failed to scan agents directory ${Y}: ${X}`, { level: "error" });
    }
  }
  return (Z(A), I);
}
function pj2(A, B, Q, I) {
  let G = NA();
  try {
    let Z = G.readFileSync(A, { encoding: "utf-8" }),
      { frontmatter: Y, content: J } = GW(Z),
      X = Y.name || Rn5(A).replace(/\.md$/, ""),
      F = [B, ...Q, X].join(":"),
      C = Y.description || Y["when-to-use"] || `Agent from ${B} plugin`,
      V = eo(Y.tools),
      K = Y.color,
      D = Y.model,
      E = Y.forkContext;
    return {
      agentType: F,
      whenToUse: C,
      tools: V,
      systemPrompt: J.trim(),
      source: "plugin",
      color: K,
      model: D,
      filename: X,
      plugin: I,
      ...{},
    };
  } catch (Z) {
    return (
      g(`Failed to load agent from ${A}: ${Z}`, { level: "error" }),
      null
    );
  }
}
function lj2() {
  to.cache?.clear?.();
}
var to;
var iwA = T(() => {
  a2();
  m0();
  NF();
  C0();
  xS();
  to = I0(async () => {
    let { enabled: A, errors: B } = await Z3(),
      Q = [];
    if (B.length > 0)
      g(`Plugin loading errors: ${B.map((I) => nN(I)).join(", ")}`);
    for (let I of A) {
      if (I.agentsPath)
        try {
          let G = cj2(I.agentsPath, I.name, I.source);
          if ((Q.push(...G), G.length > 0))
            g(
              `Loaded ${G.length} agents from plugin ${I.name} default directory`,
            );
        } catch (G) {
          g(
            `Failed to load agents from plugin ${I.name} default directory: ${G}`,
            { level: "error" },
          );
        }
      if (I.agentsPaths)
        for (let G of I.agentsPaths)
          try {
            let Y = NA().statSync(G);
            if (Y.isDirectory()) {
              let J = cj2(G, I.name, I.source);
              if ((Q.push(...J), J.length > 0))
                g(
                  `Loaded ${J.length} agents from plugin ${I.name} custom path: ${G}`,
                );
            } else if (Y.isFile() && G.endsWith(".md")) {
              let J = pj2(G, I.name, [], I.source);
              if (J)
                (Q.push(J),
                  g(`Loaded agent from plugin ${I.name} custom file: ${G}`));
            }
          } catch (Z) {
            g(
              `Failed to load agents from plugin ${I.name} custom path ${G}: ${Z}`,
              { level: "error" },
            );
          }
    }
    return (g(`Total plugin agents loaded: ${Q.length}`), Q);
  });
});
function B01() {
  let [, A] = lB(),
    B = A01.useCallback(async () => {
      try {
        let { enabled: Q, disabled: I, errors: G } = await Z3(),
          Z = [],
          Y = [];
        try {
          Z = await oo();
        } catch (J) {
          let X = J instanceof Error ? J.message : String(J);
          G.push({
            type: "generic-error",
            source: "plugin-commands",
            error: `Failed to load plugin commands: ${X}`,
          });
        }
        try {
          Y = await to();
        } catch (J) {
          let X = J instanceof Error ? J.message : String(J);
          G.push({
            type: "generic-error",
            source: "plugin-agents",
            error: `Failed to load plugin agents: ${X}`,
          });
        }
        try {
          await Ts();
        } catch (J) {
          let X = J instanceof Error ? J.message : String(J);
          G.push({
            type: "generic-error",
            source: "plugin-hooks",
            error: `Failed to load plugin hooks: ${X}`,
          });
        }
        (A((J) => ({
          ...J,
          plugins: {
            ...J.plugins,
            enabled: Q,
            disabled: I,
            commands: Z,
            agents: Y,
            errors: G,
          },
        })),
          g(
            `Loaded plugins - Enabled: ${Q.length}, Disabled: ${I.length}, Commands: ${Z.length}, Agents: ${Y.length}, Errors: ${G.length}`,
          ));
      } catch (Q) {
        let I = Q instanceof Error ? Q : Error(String(Q));
        (BA(I, lV),
          g(`Error loading plugins: ${Q}`),
          A((G) => ({
            ...G,
            plugins: {
              ...G.plugins,
              enabled: [],
              disabled: [],
              commands: [],
              agents: [],
              errors: [
                {
                  type: "generic-error",
                  source: "plugin-system",
                  error: I.message,
                },
              ],
            },
          })));
      }
    }, [A]);
  return (
    A01.useEffect(() => {
      B();
    }, [B]),
    { refreshPlugins: B }
  );
}
var A01;
var Pe1 = T(() => {
  c9();
  NF();
  lwA();
  iwA();
  tDA();
  C0();
  c1();
  A01 = IA(KA(), 1);
});
function nwA(A) {
  if (!A) return 0;
  return A.activeAgents
    .filter((B) => B.source !== "built-in")
    .reduce((B, Q) => {
      let I = `${Q.agentType}: ${Q.whenToUse}`;
      return B + i7(I);
    }, 0);
}
var At = 15000;
var je1 = T(() => {
  HN();
});
import { relative as Tn5 } from "path";
function ij2(A) {
  return vn5.filter((B) => B.isActive(A));
}
var $2, Pn5, jn5, Sn5, yn5, kn5, _n5, xn5, vn5;
var nj2 = T(() => {
  nA();
  lD();
  s2();
  V2();
  F2();
  i0();
  je1();
  (($2 = IA(KA(), 1)),
    (Pn5 = {
      id: "large-memory-files",
      type: "warning",
      isActive: () => {
        return qs().length > 0;
      },
      render: () => {
        let A = qs();
        return $2.createElement(
          $2.Fragment,
          null,
          A.map((B) => {
            let Q = B.path.startsWith(G0()) ? Tn5(G0(), B.path) : B.path;
            return $2.createElement(
              S,
              { key: B.path, flexDirection: "row" },
              $2.createElement(U, { color: "warning" }, E1.warning),
              $2.createElement(
                U,
                { color: "warning" },
                "Large ",
                $2.createElement(U, { bold: !0 }, Q),
                " will impact performance (",
                yZ(B.content.length),
                " chars >",
                " ",
                yZ(fx),
                ")",
                $2.createElement(U, { dimColor: !0 }, "  /memory to edit"),
              ),
            );
          }),
        );
      },
    }),
    (jn5 = {
      id: "ultra-claude-md",
      type: "warning",
      isActive: () => {
        let A = Ns();
        return A !== null && A.content.length > Q6A;
      },
      render: () => {
        let A = Ns();
        if (!A) return null;
        let B = A.content.length;
        return $2.createElement(
          S,
          { flexDirection: "row", gap: 1 },
          $2.createElement(U, { color: "warning" }, E1.warning),
          $2.createElement(
            U,
            { color: "warning" },
            "CLAUDE.md entries marked as IMPORTANT exceed",
            " ",
            Q6A,
            " chars (",
            B,
            " chars)",
            $2.createElement(U, { dimColor: !0 }, "  /memory to edit"),
          ),
        );
      },
    }),
    (Sn5 = {
      id: "claude-ai-external-token",
      type: "warning",
      isActive: () => {
        let A = ic();
        return (
          nB() &&
          (A.source === "ANTHROPIC_AUTH_TOKEN" || A.source === "apiKeyHelper")
        );
      },
      render: () => {
        let A = ic();
        return $2.createElement(
          S,
          { flexDirection: "row", marginTop: 1 },
          $2.createElement(U, { color: "warning" }, E1.warning),
          $2.createElement(
            U,
            { color: "warning" },
            "Auth conflict: Using ",
            A.source,
            " instead of Claude account subscription token. Either unset ",
            A.source,
            ", or run `claude /logout`.",
          ),
        );
      },
    }),
    (yn5 = {
      id: "api-key-conflict",
      type: "warning",
      isActive: () => {
        let { source: A } = Bw({ skipRetrievingKeyFromApiKeyHelper: K5() });
        return !!awA() && (A === "ANTHROPIC_API_KEY" || A === "apiKeyHelper");
      },
      render: () => {
        let { source: A } = Bw({ skipRetrievingKeyFromApiKeyHelper: K5() });
        return $2.createElement(
          S,
          { flexDirection: "row", marginTop: 1 },
          $2.createElement(U, { color: "warning" }, E1.warning),
          $2.createElement(
            U,
            { color: "warning" },
            "Auth conflict: Using ",
            A,
            " instead of Anthropic Console key. Either unset ",
            A,
            ", or run `claude /logout`.",
          ),
        );
      },
    }),
    (kn5 = {
      id: "both-auth-methods",
      type: "warning",
      isActive: () => {
        let { source: A } = Bw({ skipRetrievingKeyFromApiKeyHelper: K5() }),
          B = ic();
        return (
          A !== "none" &&
          B.source !== "none" &&
          !(A === "apiKeyHelper" && B.source === "apiKeyHelper")
        );
      },
      render: () => {
        let { source: A } = Bw({ skipRetrievingKeyFromApiKeyHelper: K5() }),
          B = ic();
        return $2.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          $2.createElement(
            S,
            { flexDirection: "row" },
            $2.createElement(U, { color: "warning" }, E1.warning),
            $2.createElement(
              U,
              { color: "warning" },
              "Auth conflict: Both a token (",
              B.source,
              ") and an API key (",
              A,
              ") are set. This may lead to unexpected behavior.",
            ),
          ),
          $2.createElement(
            S,
            { flexDirection: "column", marginLeft: 3 },
            $2.createElement(
              U,
              { color: "warning" },
              " Trying to use",
              " ",
              B.source === "claude.ai" ? "claude.ai" : B.source,
              "?",
              " ",
              A === "ANTHROPIC_API_KEY"
                ? 'Unset the ANTHROPIC_API_KEY environment variable, or claude /logout then say "No" to the API key approval before login.'
                : A === "apiKeyHelper"
                  ? "Unset the apiKeyHelper setting."
                  : "claude /logout",
            ),
            $2.createElement(
              U,
              { color: "warning" },
              " Trying to use ",
              A,
              "?",
              " ",
              B.source === "claude.ai"
                ? "claude /logout to sign out of claude.ai."
                : `Unset the ${B.source} environment variable.`,
            ),
          ),
        );
      },
    }),
    (_n5 = {
      id: "sonnet-1m-welcome",
      type: "info",
      isActive: (A) => A.showSonnet1MNotice === !0,
      render: () => {
        return $2.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          $2.createElement(
            U,
            { bold: !0 },
            "You now have access to Sonnet 4 with 1M context (uses more rate limits than Sonnet on long requests)  Update in /model",
          ),
        );
      },
    }),
    (xn5 = {
      id: "large-agent-descriptions",
      type: "warning",
      isActive: (A) => {
        return nwA(A.agentDefinitions) > At;
      },
      render: (A) => {
        let B = nwA(A.agentDefinitions);
        return $2.createElement(
          S,
          { flexDirection: "row" },
          $2.createElement(U, { color: "warning" }, E1.warning),
          $2.createElement(
            U,
            { color: "warning" },
            "Large cumulative agent descriptions will impact performance (~",
            yZ(B),
            " tokens >",
            " ",
            yZ(At),
            ")",
            $2.createElement(U, { dimColor: !0 }, "  /agents to manage"),
          ),
        );
      },
    }),
    (vn5 = [Pn5, jn5, xn5, Sn5, yn5, kn5, _n5]));
});
function aj2({ agentDefinitions: A } = {}) {
  let B = L1(),
    Q = HG()?.organizationUuid,
    G = (Q ? B.s1mAccessCache?.[Q] : void 0)?.hasAccessNotAsDefault,
    Z = Q && B.hasShownS1MWelcomeV2?.[Q],
    Y = nB() && G && !Z,
    J = { config: B, showSonnet1MNotice: Y, agentDefinitions: A },
    X = ij2(J);
  if (
    (Eb.useEffect(() => {
      if (!Q) return;
      let W = X.some((F) => F.id === "sonnet-1m-welcome");
      if (W) GA("tengu_sonnet_1m_notice_shown", {});
      if (W)
        n0({
          ...B,
          ...(W && {
            hasShownS1MWelcomeV2: { ...B.hasShownS1MWelcomeV2, [Q]: !0 },
          }),
        });
    }, [X, B, Q]),
    X.length === 0)
  )
    return null;
  return Eb.createElement(
    S,
    { flexDirection: "column", paddingLeft: 1 },
    X.map((W) => Eb.createElement(Eb.Fragment, { key: W.id }, W.render(J))),
  );
}
var Eb;
var sj2 = T(() => {
  nA();
  kB();
  nj2();
  H0();
  F2();
  Eb = IA(KA(), 1);
});
function rj2(A, B) {
  let Q = new Set();
  for (let I of A) if (!B.has(I)) Q.add(I);
  return Q;
}
function oj2(A, B) {
  for (let Q of A) if (!B.has(Q)) return !1;
  return !0;
}
function tj2({ message: A, isTranscriptMode: B }) {
  if (
    !(
      B &&
      A.timestamp &&
      A.type === "assistant" &&
      A.message.content.some((G) => G.type === "text")
    )
  )
    return null;
  let I = new Date(A.timestamp).toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !0,
  });
  return Se1.default.createElement(
    S,
    { marginTop: 1, minWidth: I.length },
    Se1.default.createElement(U, { dimColor: !0 }, I),
  );
}
var Se1;
var ej2 = T(() => {
  nA();
  Se1 = IA(KA(), 1);
});
function AS2({ message: A, isTranscriptMode: B }) {
  if (
    !(
      B &&
      A.type === "assistant" &&
      A.message.model &&
      A.message.content.some((I) => I.type === "text")
    )
  )
    return null;
  return ye1.default.createElement(
    S,
    { marginTop: 1, marginLeft: 1, minWidth: A.message.model.length + 8 },
    ye1.default.createElement(U, { dimColor: !0 }, A.message.model),
  );
}
var ye1;
var BS2 = T(() => {
  nA();
  ye1 = IA(KA(), 1);
});
function QS2(A) {
  let [B, Q] = I7A.useState(1),
    [I, G] = I7A.useState(-1);
  return (
    h1(
      (Z, Y) => {
        if (Y.escape && I === -1) G(0);
      },
      { isActive: A },
    ),
    I7A.useEffect(() => {
      if (!A) {
        (G(-1), Q(0));
        return;
      }
    }, [A]),
    I7A.useEffect(() => {
      if (I === -1) return;
      let Z = [1, 0, 1, 2, 2, 1, 0, 0, 0, 1, 2, 2, 1];
      if (I >= Z.length) {
        (G(-1), Q(1));
        return;
      }
      Q(Z[I]);
      let Y = setTimeout(() => {
        G((J) => J + 1);
      }, 60);
      return () => clearTimeout(Y);
    }, [I]),
    B
  );
}
var I7A;
var IS2 = T(() => {
  nA();
  I7A = IA(KA(), 1);
});
async function ke1() {
  if (K5()) return;
  if (process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
  let A = await DB.get(fn5);
  if (A.status === 200) {
    let B = L1();
    n0({ ...B, cachedChangelog: A.data, changelogLastFetched: Date.now() });
  }
}
function Bt() {
  return L1().cachedChangelog ?? "";
}
function Q01(A) {
  try {
    if (!A) return {};
    let B = {},
      Q = A.split(/^## /gm).slice(1);
    for (let I of Q) {
      let G = I.trim().split(`
`);
      if (G.length === 0) continue;
      let Z = G[0];
      if (!Z) continue;
      let Y = Z.split(" - ")[0]?.trim() || "";
      if (!Y) continue;
      let J = G.slice(1)
        .filter((X) => X.trim().startsWith("- "))
        .map((X) => X.trim().substring(2).trim())
        .filter(Boolean);
      if (J.length > 0) B[Y] = J;
    }
    return B;
  } catch (B) {
    return (
      BA(B instanceof Error ? B : Error("Failed to parse changelog"), pY0),
      {}
    );
  }
}
function hn5(A, B, Q = Bt()) {
  try {
    let I = Q01(Q),
      G = nc.coerce(A),
      Z = B ? nc.coerce(B) : null;
    if (!Z || (G && nc.gt(G, Z, { loose: !0 })))
      return Object.entries(I)
        .filter(([Y]) => !Z || nc.gt(Y, Z, { loose: !0 }))
        .sort(([Y], [J]) => (nc.gt(Y, J, { loose: !0 }) ? -1 : 1))
        .flatMap(([Y, J]) => J)
        .filter(Boolean)
        .slice(0, bn5);
  } catch (I) {
    return (
      BA(I instanceof Error ? I : Error("Failed to get release notes"), I61),
      []
    );
  }
  return [];
}
function _e1(A = Bt()) {
  try {
    let B = Q01(A);
    return Object.keys(B)
      .sort((I, G) => (nc.gt(I, G, { loose: !0 }) ? 1 : -1))
      .map((I) => {
        let G = B[I];
        if (!G || G.length === 0) return null;
        let Z = G.filter(Boolean);
        if (Z.length === 0) return null;
        return [I, Z];
      })
      .filter((I) => I !== null);
  } catch (B) {
    return (
      BA(B instanceof Error ? B : Error("Failed to get release notes"), I61),
      []
    );
  }
}
function swA(
  A,
  B = {
    ISSUES_EXPLAINER:
      "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://docs.claude.com/s/claude-code",
    VERSION: "2.0.42",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
  }.VERSION,
) {
  if (A !== B || !Bt())
    ke1().catch((G) =>
      BA(G instanceof Error ? G : Error("Failed to fetch changelog"), lY0),
    );
  let Q = hn5(B, A);
  return { hasReleaseNotes: Q.length > 0, releaseNotes: Q };
}
var nc,
  bn5 = 5,
  GS2 = "https://github.com/anthropics/claude-code/blob/main/CHANGELOG.md",
  fn5 =
    "https://raw.githubusercontent.com/anthropics/claude-code/refs/heads/main/CHANGELOG.md";
var G7A = T(() => {
  c1();
  _I();
  kB();
  i0();
  nc = IA(yM(), 1);
});
function JS2(A) {
  if (A >= 70) return "horizontal";
  return "compact";
}
function XS2(A, B, Q) {
  if (B === "horizontal") {
    let G = Q,
      Z = xe1 + G01 + I01 + G,
      Y = A - Z,
      J = Math.max(30, Y),
      X = Math.min(G + J + I01 + G01, A - xe1);
    if (X < G + J + I01 + G01) J = X - G - I01 - G01;
    return { leftWidth: G, rightWidth: J, totalWidth: X };
  }
  let I = Math.min(A - xe1, YS2 + 20);
  return { leftWidth: I, rightWidth: I, totalWidth: I };
}
function WS2(A, B, Q) {
  let I = Math.max(A.length, B.length, Q.length, 20);
  return Math.min(I + 4, YS2);
}
function Y01(A) {
  if (!A || A.length > gn5) return "Welcome back!";
  return `Welcome back ${A}!`;
}
function owA(A, B) {
  if (A.length <= B) return A;
  let Q = "/",
    I = "",
    G = A.split(Q),
    Z = G[0] || "",
    Y = G[G.length - 1] || "";
  if (G.length === 1) return A.substring(0, B - I.length) + I;
  if (Z === "" && I.length + Q.length + Y.length >= B)
    return `${Q}${Y.substring(0, B - I.length - Q.length)}${I}`;
  if (Z !== "" && I.length * 2 + Q.length + Y.length >= B)
    return `${I}${Q}${Y.substring(0, B - I.length * 2 - Q.length)}${I}`;
  if (G.length === 2)
    return `${Z.substring(0, B - I.length - Q.length - Y.length)}${I}${Q}${Y}`;
  let J = B - Z.length - Y.length - I.length - 2 * Q.length;
  if (J <= 0)
    return `${Z.substring(0, Math.max(0, B - Y.length - I.length - 2 * Q.length))}${Q}${I}${Q}${Y}`;
  let X = [];
  for (let W = G.length - 2; W > 0; W--) {
    let F = G[W];
    if (F && F.length + Q.length <= J)
      (X.unshift(F), (J -= F.length + Q.length));
    else break;
  }
  if (X.length === 0) return `${Z}${Q}${I}${Q}${Y}`;
  return `${Z}${Q}${I}${Q}${X.join(Q)}${Q}${Y}`;
}
async function FS2() {
  if (Z01) return Z01;
  let A = L0();
  return (
    (Z01 = Wy(10)
      .then((B) => {
        return (
          (rwA = B.filter((Q) => {
            if (Q.isSidechain) return !1;
            if (Q.leafUuid === A) return !1;
            if (Q.summary?.includes("I apologize")) return !1;
            let I = Q.summary && Q.summary !== "No prompt",
              G = Q.firstPrompt && Q.firstPrompt !== "No prompt";
            return I || G;
          }).slice(0, 3)),
          rwA
        );
      })
      .catch(() => {
        return ((rwA = []), rwA);
      })),
    Z01
  );
}
function CS2() {
  return rwA;
}
function J01() {
  let A = {
      ISSUES_EXPLAINER:
        "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.claude.com/s/claude-code",
      VERSION: "2.0.42",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
    }.VERSION,
    B = G0(),
    Q = mI(),
    I = DzB(Q),
    G = nB() ? twA() : "API Usage Billing";
  return { version: A, cwd: B, modelDisplayName: I, billingType: G };
}
function VS2(A, B, Q) {
  if (A.length + 3 + B.length > Q)
    return {
      shouldSplit: !0,
      truncatedModel: CG(A, Q),
      truncatedBilling: CG(B, Q),
    };
  return {
    shouldSplit: !1,
    truncatedModel: CG(A, Math.max(Q - B.length - 3, 10)),
    truncatedBilling: B,
  };
}
function KS2(A) {
  let B = Bt();
  if (!B) return [];
  let Q = Q01(B),
    I = [],
    G = Object.keys(Q)
      .sort((Z, Y) => (ZS2.gt(Z, Y, { loose: !0 }) ? -1 : 1))
      .slice(0, 3);
  for (let Z of G) {
    let Y = Q[Z];
    if (Y) I.push(...Y);
  }
  return I.slice(0, A);
}
var ZS2,
  YS2 = 50,
  gn5 = 20,
  xe1 = 4,
  I01 = 1,
  G01 = 2,
  rwA,
  Z01 = null;
var X01 = T(() => {
  G7A();
  E7();
  i0();
  V2();
  F2();
  Y9();
  ZS2 = IA(yM(), 1);
  rwA = [];
});
function ve1() {
  if (O0.terminal === "Apple_Terminal") return T6.createElement(un5, null);
  return T6.createElement(
    S,
    { flexDirection: "column" },
    T6.createElement(
      U,
      null,
      T6.createElement(U, { color: "clawd_body" }, " "),
      T6.createElement(
        U,
        { color: "clawd_body", backgroundColor: "clawd_background" },
        "",
      ),
      T6.createElement(U, { color: "clawd_body" }, ""),
    ),
    T6.createElement(
      U,
      null,
      T6.createElement(U, { color: "clawd_body" }, ""),
      T6.createElement(
        U,
        { color: "clawd_body", backgroundColor: "clawd_background" },
        "",
      ),
      T6.createElement(U, { color: "clawd_body" }, ""),
    ),
    T6.createElement(U, { color: "clawd_body" }, "  ", " ", "  "),
  );
}
function un5() {
  return T6.createElement(
    S,
    { flexDirection: "column", alignItems: "center" },
    T6.createElement(
      U,
      null,
      T6.createElement(U, { color: "clawd_body" }, ""),
      T6.createElement(
        U,
        { color: "clawd_background", backgroundColor: "clawd_body" },
        " ",
        "",
        "   ",
        "",
        " ",
      ),
      T6.createElement(U, { color: "clawd_body" }, ""),
    ),
    T6.createElement(U, { backgroundColor: "clawd_body" }, " ".repeat(7)),
    T6.createElement(U, { color: "clawd_body" }, " "),
  );
}
var T6;
var DS2 = T(() => {
  nA();
  C6();
  T6 = IA(KA(), 1);
});
function ES2(A) {
  let { title: B, lines: Q, footer: I, emptyMessage: G } = A,
    Z = B.length;
  if (Q.length === 0 && G) Z = Math.max(Z, G.length);
  else {
    let J = Math.max(
      0,
      ...Q.map((X) => (X.timestamp ? X.timestamp.length : 0)),
    );
    for (let X of Q) {
      let W = J > 0 ? J : 0,
        F = X.text.length + (W > 0 ? W + 2 : 0);
      Z = Math.max(Z, F);
    }
  }
  if (I) Z = Math.max(Z, I.length);
  return Z;
}
function HS2({ config: A, actualWidth: B }) {
  let { title: Q, lines: I, footer: G, emptyMessage: Z } = A,
    Y = "  ",
    J = Math.max(0, ...I.map((X) => (X.timestamp ? X.timestamp.length : 0)));
  return FZ.createElement(
    S,
    { flexDirection: "column", width: B },
    FZ.createElement(U, { bold: !0, color: "claude" }, Q),
    I.length === 0 && Z
      ? FZ.createElement(U, { dimColor: !0 }, CG(Z, B))
      : FZ.createElement(
          FZ.Fragment,
          null,
          I.map((X, W) => {
            let F = Math.max(10, B - (J > 0 ? J + 2 : 0));
            return FZ.createElement(
              U,
              { key: W },
              J > 0 &&
                FZ.createElement(
                  FZ.Fragment,
                  null,
                  FZ.createElement(
                    U,
                    { dimColor: !0 },
                    (X.timestamp || "").padEnd(J),
                  ),
                  "  ",
                ),
              FZ.createElement(U, null, CG(X.text, F)),
            );
          }),
          G && FZ.createElement(U, { dimColor: !0, italic: !0 }, CG(G, B)),
        ),
  );
}
var FZ;
var zS2 = T(() => {
  nA();
  FZ = IA(KA(), 1);
});
function US2({ feeds: A, maxWidth: B }) {
  let Q = A.map((Z) => ES2(Z)),
    I = Math.max(...Q),
    G = Math.min(I, B);
  return jR.createElement(
    S,
    { flexDirection: "column" },
    A.map((Z, Y) =>
      jR.createElement(
        jR.Fragment,
        { key: Y },
        jR.createElement(HS2, { config: Z, actualWidth: G }),
        Y < A.length - 1 && jR.createElement(p5, { dividerColor: "claude" }),
      ),
    ),
  );
}
var jR;
var wS2 = T(() => {
  nA();
  zS2();
  iC();
  jR = IA(KA(), 1);
});
import { homedir as mn5 } from "os";
function be1(A) {
  let B = A.map((Q) => {
    let I = vh(Q.modified);
    return {
      text:
        (Q.summary && Q.summary !== "No prompt" ? Q.summary : Q.firstPrompt) ||
        "",
      timestamp: I,
    };
  });
  return {
    title: "Recent activity",
    lines: B,
    footer: B.length > 0 ? "/resume for more" : void 0,
    emptyMessage: "No recent activity",
  };
}
function $S2(A) {
  let B = A.map((I) => {
      return { text: I };
    }),
    Q = "Check the Claude Code changelog for updates";
  return {
    title: "What's new",
    lines: B,
    footer: B.length > 0 ? "/release-notes for more" : void 0,
    emptyMessage: "Check the Claude Code changelog for updates",
  };
}
function qS2(A) {
  let Q = A.filter(({ isEnabled: G }) => G)
      .sort((G, Z) => Number(G.isComplete) - Number(Z.isComplete))
      .map(({ text: G, isComplete: Z }) => {
        return { text: `${Z ? `${E1.tick} ` : ""}${G}` };
      }),
    I =
      G0() === mn5()
        ? "Note: You have launched claude in your home directory. For the best experience, launch it in a project directory instead."
        : void 0;
  if (I) Q.push({ text: I });
  return { title: "Tips for getting started", lines: Q };
}
var NS2 = T(() => {
  s2();
  V2();
});
function dn5() {
  if (O0.terminal === "Apple_Terminal")
    return y2.createElement(
      S,
      { flexDirection: "column", alignItems: "center" },
      y2.createElement(
        U,
        null,
        y2.createElement(U, { color: "clawd_body" }, ""),
        y2.createElement(
          U,
          { color: "clawd_background", backgroundColor: "clawd_body" },
          " ",
          "",
          "   ",
          "",
          " ",
        ),
        y2.createElement(U, { color: "clawd_body" }, ""),
      ),
      y2.createElement(U, { backgroundColor: "clawd_body" }, " ".repeat(7)),
      y2.createElement(U, { color: "clawd_body" }, " "),
    );
  return y2.createElement(
    S,
    { flexDirection: "column" },
    y2.createElement(
      U,
      null,
      y2.createElement(U, { color: "clawd_body" }, " "),
      y2.createElement(
        U,
        { color: "clawd_body", backgroundColor: "clawd_background" },
        "",
      ),
      y2.createElement(U, { color: "clawd_body" }, ""),
    ),
    y2.createElement(
      U,
      null,
      y2.createElement(U, { color: "clawd_body" }, ""),
      y2.createElement(
        U,
        { color: "clawd_body", backgroundColor: "clawd_background" },
        "",
      ),
      y2.createElement(U, { color: "clawd_body" }, ""),
    ),
    y2.createElement(U, { color: "clawd_body" }, "  ", " ", "  "),
  );
}
function LS2() {
  let { columns: A } = aB(),
    { version: B, cwd: Q, modelDisplayName: I, billingType: G } = J01(),
    Z = Math.max(A - 15, 20),
    Y = "Claude Code v",
    J = CG(B, Math.max(Z - 13, 6)),
    { shouldSplit: X, truncatedModel: W, truncatedBilling: F } = VS2(I, G, Z),
    C = owA(Q, Z);
  return y2.createElement(
    S,
    { flexDirection: "row", gap: 2, alignItems: "center" },
    y2.createElement(dn5, null),
    y2.createElement(
      S,
      { flexDirection: "column" },
      y2.createElement(
        U,
        null,
        y2.createElement(U, { bold: !0 }, "Claude Code"),
        " ",
        y2.createElement(U, { dimColor: !0 }, "v", J),
      ),
      X
        ? y2.createElement(
            y2.Fragment,
            null,
            y2.createElement(U, { dimColor: !0 }, W),
            y2.createElement(U, { dimColor: !0 }, F),
          )
        : y2.createElement(U, { dimColor: !0 }, W, "  ", F),
      y2.createElement(U, { dimColor: !0 }, C),
    ),
  );
}
var y2;
var MS2 = T(() => {
  nA();
  C6();
  N8();
  X01();
  y2 = IA(KA(), 1);
});
function fe1() {
  let A = W01.useMemo(pn5, []);
  if (
    (W01.useEffect(() => {
      TS2(OS2);
    }, [A.tip]),
    !A.tip)
  )
    return null;
  return ewA.createElement(
    S,
    { paddingLeft: 2, flexDirection: "column" },
    ewA.createElement(
      U,
      {
        ...(A.color === "warning"
          ? { color: "warning" }
          : A.color === "error"
            ? { color: "error" }
            : { dimColor: !0 }),
      },
      A.tip,
    ),
  );
}
function pn5() {
  return T2A(OS2, cn5);
}
var ewA,
  W01,
  OS2 = "tengu-top-of-feed-tip",
  cn5;
var RS2 = T(() => {
  nA();
  f4();
  ((ewA = IA(KA(), 1)), (W01 = IA(KA(), 1)));
  cn5 = { tip: "", color: "dim" };
});
function jS2({ isBeforeFirstMessage: A }) {
  let B = QS2(A),
    Q = CS2(),
    I = L1().oauthAccount?.displayName ?? "",
    G = KS2(3),
    { columns: Z } = aB(),
    Y = vx0(),
    J = VQ.isSandboxingEnabled(),
    X = L1(),
    W = N0().companyAnnouncements,
    [F] = F01.useState(() =>
      W && W.length > 0
        ? X.numStartups === 1
          ? W[0]
          : W[Math.floor(Math.random() * W.length)]
        : void 0,
    ),
    { hasReleaseNotes: C } = swA(X.lastReleaseNotesSeen);
  F01.useEffect(() => {
    let m = L1();
    if (
      m.lastReleaseNotesSeen ===
      {
        ISSUES_EXPLAINER:
          "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.claude.com/s/claude-code",
        VERSION: "2.0.42",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
      }.VERSION
    )
      return;
    if (
      (n0({
        ...m,
        lastReleaseNotesSeen: {
          ISSUES_EXPLAINER:
            "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://docs.claude.com/s/claude-code",
          VERSION: "2.0.42",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
        }.VERSION,
      }),
      Y)
    )
      bx0();
  }, [X, Y]);
  let { version: V, cwd: K, modelDisplayName: D, billingType: E } = J01(),
    H = CG(D, PS2 - 20);
  if (!C && !Y && !V0(process.env.CLAUDE_CODE_FORCE_FULL_LOGO))
    return HB.createElement(
      HB.Fragment,
      null,
      HB.createElement(S, null),
      HB.createElement(LS2, null),
      kGA() &&
        HB.createElement(
          S,
          { paddingLeft: 2, flexDirection: "column" },
          HB.createElement(U, { color: "warning" }, "Debug mode enabled"),
          HB.createElement(
            U,
            { dimColor: !0 },
            "Logging to: ",
            Wk() ? "stderr" : Wl(),
          ),
        ),
      HB.createElement(fe1, null),
      F &&
        HB.createElement(
          S,
          { paddingLeft: 2, flexDirection: "column" },
          HB.createElement(U, null, F),
        ),
      !1,
      !1,
    );
  let w = JS2(Z),
    L = L1().theme,
    N = ` ${OB("claude", L)("Claude Code")} ${OB("inactive", L)(`v${V}`)} `,
    $ = OB("claude", L)(" Claude Code ");
  if (w === "compact") {
    let o = Y01(I);
    if (o.length > Z - 4) o = Y01(null);
    let l = owA(K, Z - 4);
    return HB.createElement(
      HB.Fragment,
      null,
      HB.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: "claude",
          borderText: {
            content: $,
            position: "top",
            align: "start",
            offset: 1,
          },
          paddingX: 1,
          paddingY: 1,
          alignItems: "center",
          width: Z,
        },
        HB.createElement(U, { bold: !0 }, o),
        HB.createElement(
          S,
          { marginY: 1 },
          HB.createElement(
            S,
            { height: 5, flexDirection: "column", justifyContent: "flex-end" },
            HB.createElement(
              S,
              { marginBottom: B },
              HB.createElement(ve1, null),
            ),
          ),
        ),
        HB.createElement(U, { dimColor: !0 }, H),
        HB.createElement(U, { dimColor: !0 }, E),
        HB.createElement(U, { dimColor: !0 }, l),
      ),
      J &&
        HB.createElement(
          S,
          { marginTop: 1, flexDirection: "column" },
          HB.createElement(
            U,
            { color: "warning" },
            "Your bash commands will be sandboxed. Disable with /sandbox.",
          ),
        ),
    );
  }
  let O = Y01(I),
    P = `${H}  ${E}`,
    k = owA(K, PS2),
    b = WS2(O, k, P),
    { leftWidth: x, rightWidth: n } = XS2(Z, w, b);
  return HB.createElement(
    HB.Fragment,
    null,
    HB.createElement(S, null),
    HB.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: "claude",
        borderText: { content: N, position: "top", align: "start", offset: 3 },
      },
      HB.createElement(
        S,
        {
          flexDirection: w === "horizontal" ? "row" : "column",
          paddingX: 1,
          gap: 1,
        },
        HB.createElement(
          S,
          {
            flexDirection: "column",
            width: x,
            justifyContent: "space-between",
            alignItems: "center",
            minHeight: 9,
          },
          HB.createElement(
            S,
            { marginTop: 1 },
            HB.createElement(U, { bold: !0 }, O),
          ),
          HB.createElement(
            S,
            { height: 5, flexDirection: "column", justifyContent: "flex-end" },
            HB.createElement(
              S,
              { marginBottom: B },
              HB.createElement(ve1, null),
            ),
          ),
          HB.createElement(
            S,
            { flexDirection: "column", alignItems: "center" },
            HB.createElement(U, { dimColor: !0 }, P),
            HB.createElement(U, { dimColor: !0 }, k),
          ),
        ),
        w === "horizontal" &&
          HB.createElement(p5, {
            orientation: "vertical",
            dividerColor: "claude",
          }),
        w === "horizontal" &&
          HB.createElement(US2, {
            feeds: Y ? [qS2(TJ1()), be1(Q)] : [be1(Q), $S2(G)],
            maxWidth: n,
          }),
      ),
    ),
    kGA() &&
      HB.createElement(
        S,
        { paddingLeft: 2, flexDirection: "column" },
        HB.createElement(U, { color: "warning" }, "Debug mode enabled"),
        HB.createElement(
          U,
          { dimColor: !0 },
          "Logging to: ",
          Wk() ? "stderr" : Wl(),
        ),
      ),
    HB.createElement(fe1, null),
    F &&
      HB.createElement(
        S,
        { paddingLeft: 2, flexDirection: "column" },
        HB.createElement(U, null, F),
      ),
    J &&
      HB.createElement(
        S,
        { paddingLeft: 2, flexDirection: "column" },
        HB.createElement(
          U,
          { color: "warning" },
          "Your bash commands will be sandboxed. Disable with /sandbox.",
        ),
      ),
    !1,
    !1,
  );
}
var HB,
  F01,
  PS2 = 50;
var SS2 = T(() => {
  nA();
  N8();
  IS2();
  X01();
  DS2();
  wS2();
  NS2();
  iC();
  kB();
  OQ();
  C0();
  NJA();
  MS2();
  G7A();
  ym1();
  vB();
  RS2();
  VW();
  ((HB = IA(KA(), 1)), (F01 = IA(KA(), 1)));
});
function in5(A, B, Q, I, G, Z, Y) {
  if (Y === "transcript") return !0;
  switch (A.type) {
    case "attachment":
    case "user":
    case "assistant": {
      let J = Q$A(A);
      if (!J) return !0;
      if (Q.has(J)) return !1;
      if (G.has(J)) return !1;
      if (kS2(B, J, "PostToolUse")) return !1;
      return oj2(Z, I);
    }
    case "system":
      return A.subtype !== "api_error";
  }
}
var e3,
  Hb,
  A$A = 10,
  ln5 = ({
    messages: A,
    normalizedMessageHistory: B,
    tools: Q,
    verbose: I,
    toolJSX: G,
    toolUseConfirmQueue: Z,
    inProgressToolUseIDs: Y,
    isMessageSelectorVisible: J,
    conversationId: X,
    screen: W,
    screenToggleId: F,
    streamingToolUses: C,
    showAllInTranscript: V = !1,
    agentDefinitions: K,
  }) => {
    let { columns: D } = aB(),
      E = Hb.useMemo(() => [...B, ...bY(A).filter(B$A)], [A, B]),
      H = Hb.useMemo(() => new Set(Object.keys(V01(E))), [E]),
      w = Hb.useMemo(() => xS2(E), [E]),
      L = Hb.useMemo(
        () =>
          C.filter((k) => {
            if (Y.has(k.contentBlock.id)) return !1;
            if (
              E.some(
                (b) =>
                  b.type === "assistant" &&
                  b.message.content[0].type === "tool_use" &&
                  b.message.content[0].id === k.contentBlock.id,
              )
            )
              return !1;
            return !0;
          }),
        [C, Y, E],
      ),
      N = Hb.useMemo(
        () => L.flatMap((k) => bY([CV({ content: [k.contentBlock] })])),
        [L],
      ),
      $ = Hb.useMemo(() => {
        let k = W === "transcript",
          b = k && !V,
          x = I ? E : dj(E),
          n = yS2(
            x.filter((y) => y.type !== "progress").filter((y) => bS2(y, k)),
            N,
          ),
          m = b ? n.slice(-A$A) : n,
          o = b && n.length > A$A;
        return [
          {
            type: "static",
            jsx: e3.createElement(
              S,
              { flexDirection: "column", gap: 1, key: `logo-${X}-${F}` },
              e3.createElement(jS2, { isBeforeFirstMessage: !1 }),
              e3.createElement(aj2, { agentDefinitions: K }),
            ),
          },
          ...(o
            ? [
                {
                  type: "static",
                  jsx: e3.createElement(p5, {
                    key: `truncation-indicator-${X}-${F}`,
                    dividerChar: "",
                    title: `Ctrl+E to show ${iA.bold(E.length - A$A)} previous messages`,
                    width: D,
                  }),
                },
              ]
            : []),
          ...(k && V && E.length > A$A
            ? [
                {
                  type: "static",
                  jsx: e3.createElement(p5, {
                    key: `hide-indicator-${X}-${F}`,
                    dividerChar: "",
                    title: `Ctrl+E to hide ${iA.bold(E.length - A$A)} previous messages`,
                    width: D,
                  }),
                },
              ]
            : []),
          ...m.flatMap((y) => {
            let c = Q$A(y),
              e = vS2(y, E);
            return {
              type: in5(
                y,
                E,
                new Set(C.map((WA) => WA.contentBlock.id)),
                H,
                Y,
                _S2(y, m),
                W,
              )
                ? "static"
                : "transient",
              jsx: e3.createElement(
                S,
                {
                  key: `${y.uuid}-${X}-${F}`,
                  width: D,
                  flexDirection: "row",
                  flexWrap: "nowrap",
                  alignItems: "flex-start",
                  justifyContent: "space-between",
                  gap: 1,
                },
                e3.createElement(ax, {
                  message: y,
                  messages: E,
                  addMargin: !0,
                  tools: Q,
                  verbose: I,
                  erroredToolUseIDs: w,
                  inProgressToolUseIDs: Y,
                  progressMessagesForMessage: e,
                  shouldAnimate:
                    (!G || !!G.shouldContinueAnimation) &&
                    !Z.length &&
                    !J &&
                    (!c || Y.has(c)),
                  shouldShowDot: !0,
                  resolvedToolUseIDs: H,
                  isTranscriptMode: k,
                }),
                e3.createElement(tj2, { message: y, isTranscriptMode: k }),
                e3.createElement(AS2, { message: y, isTranscriptMode: k }),
              ),
            };
          }),
        ];
      }, [W, V, I, E, N, X, F, K, D, C, H, Q, w, Y, G, Z.length, J]),
      O = Hb.useMemo(() => $.filter((k) => k.type === "static"), [$]),
      P = Hb.useMemo(() => $.filter((k) => k.type === "transient"), [$]);
    return e3.createElement(
      e3.Fragment,
      null,
      e3.createElement(
        kh,
        { key: `static-messages-${X}-${F}`, items: O },
        (k) => k.jsx,
      ),
      P.map((k) => k.jsx),
    );
  },
  Z7A;
var C01 = T(() => {
  nA();
  nA();
  iB();
  sj2();
  YEA();
  N8();
  iC();
  f2();
  ej2();
  BS2();
  SS2();
  ((e3 = IA(KA(), 1)), (Hb = IA(KA(), 1)), (Z7A = e3.memo(ln5)));
});
function fS2(A, B, Q, I, G) {
  h1(async (Z, Y) => {
    if (Y.ctrl && Z === "o")
      (B((J) => (J === "transcript" ? "prompt" : "transcript")),
        Q((J) => J + 1),
        I(!1),
        await G());
    if (Y.ctrl && Z === "e" && A === "transcript")
      (I((J) => !J), Q((J) => J + 1), await G());
    if (
      (Y.ctrl && Z === "c" && A === "transcript") ||
      (Y.escape && A === "transcript")
    )
      (B("prompt"), Q((J) => J + 1), I(!1), await G());
  });
}
var hS2 = T(() => {
  nA();
});
function gS2(A, B) {
  let Q = I$A.useRef(!1),
    I = I$A.useRef(null);
  I$A.useEffect(() => {
    let G = Az(A);
    if (I.current !== G)
      ((Q.current = !1),
        (I.current = G || null),
        B({ lineCount: 0, lineStart: void 0, text: void 0, filePath: void 0 }));
    if (Q.current || !G) return;
    let Z = (Y) => {
      if (Y.selection?.start && Y.selection?.end) {
        let { start: J, end: X } = Y.selection,
          W = X.line - J.line + 1;
        if (X.character === 0) W--;
        let F = {
          lineCount: W,
          lineStart: J.line,
          text: Y.text,
          filePath: Y.filePath,
        };
        B(F);
      }
    };
    (G.client.setNotificationHandler(nn5, (Y) => {
      if (I.current !== G) return;
      try {
        let J = Y.params;
        if (J.selection && J.selection.start && J.selection.end) Z(J);
        else if (J.text !== void 0)
          Z({ selection: null, text: J.text, filePath: J.filePath });
      } catch (J) {
        BA(J, PJ0);
      }
    }),
      (Q.current = !0));
  }, [A, B]);
}
var I$A, nn5;
var uS2 = T(() => {
  e2();
  zW();
  c1();
  ((I$A = IA(KA(), 1)),
    (nn5 = _.object({
      method: _.literal("selection_changed"),
      params: _.object({
        selection: _.object({
          start: _.object({ line: _.number(), character: _.number() }),
          end: _.object({ line: _.number(), character: _.number() }),
        })
          .nullable()
          .optional(),
        text: _.string().optional(),
        filePath: _.string().optional(),
      }),
    })));
});
function an5() {
  return _7("cache_warming", "config", {
    enabled: !1,
    idleThresholdMs: 240000,
    subsequentWarmupIntervalMs: 300000,
    maxRequests: 1,
  });
}
function mS2(A, B) {
  let Q = K01.useRef(null);
  K01.useEffect(() => {
    let I = an5();
    if (!I.enabled) return;
    if (A || B === 0) {
      if (Q.current) (Q.current.abort(), (Q.current = null));
      return;
    }
    let G = 0,
      Z = null,
      Y = async () => {
        let X = JLA();
        if (!X) {
          g("Cache warming: No previous API request to replay");
          return;
        }
        if (Q.current) Q.current.abort();
        Q.current = a9();
        try {
          g(`Cache warming: Sending request ${G + 1}/${I.maxRequests}`);
          let W = {
              ...X,
              messages: [
                ...X.messages,
                { role: "user", content: 'Reply with just "OK"' },
              ],
              max_tokens: 10,
            },
            C = (
              await tU({ maxRetries: 0, model: X.model })
            ).beta.messages.stream(W, { signal: Q.current.signal });
          for await (let D of C) if (Q.current?.signal.aborted) break;
          let K = (await C.finalMessage()).usage;
          if (
            (g("Cache warming: Request completed"),
            GA("tengu_cache_warming_request", {
              warmup_number: G + 1,
              cache_read_tokens: K.cache_read_input_tokens ?? 0,
              cache_creation_tokens: K.cache_creation_input_tokens ?? 0,
              input_tokens: K.input_tokens,
              output_tokens: K.output_tokens,
            }),
            G++,
            G < I.maxRequests)
          )
            J(I.subsequentWarmupIntervalMs);
        } catch (W) {
          if (W instanceof Error) BA(W, bJ0);
        } finally {
          Q.current = null;
        }
      },
      J = (X) => {
        Z = setTimeout(() => {
          Y();
        }, X);
      };
    return (
      J(I.idleThresholdMs),
      () => {
        if (Z) clearTimeout(Z);
        if (Q.current) (Q.current.abort(), (Q.current = null));
      }
    );
  }, [A, B]);
}
var K01;
var dS2 = T(() => {
  P4A();
  i0();
  C0();
  vG();
  f4();
  H0();
  c1();
  K01 = IA(KA(), 1);
});
function pS2({
  autoConnectIdeFlag: A,
  ideToInstallExtension: B,
  setDynamicMcpConfig: Q,
  setShowIdeOnboarding: I,
  setIDEInstallationState: G,
}) {
  cS2.useEffect(() => {
    function Z(Y) {
      if (!Y) return;
      if (
        !(
          (L1().autoConnectIde ||
            A ||
            UW() ||
            B ||
            V0(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE)) &&
          !Nf(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE)
        )
      )
        return;
      Q((W) => {
        if (W?.ide) return W;
        return {
          ...W,
          ide: {
            type: Y.url.startsWith("ws:") ? "ws-ide" : "sse-ide",
            url: Y.url,
            ideName: Y.name,
            authToken: Y.authToken,
            ideRunningInWindows: Y.ideRunningInWindows,
            scope: "dynamic",
          },
        };
      });
    }
    FNQ(
      Z,
      B,
      () => I(!0),
      (Y) => G(Y),
    );
  }, [A, B, Q, I, G]);
}
var cS2;
var lS2 = T(() => {
  kB();
  zW();
  vB();
  cS2 = IA(KA(), 1);
});
var he1;
var iS2 = T(() => {
  nA();
  Z5();
  c4A();
  xX();
  xj();
  Q5();
  m0();
  H0();
  he1 = IA(KA(), 1);
});
var $O7;
var nS2 = T(() => {
  iS2();
  xY();
  $O7 = IA(KA(), 1);
});
function on5() {
  return uo(rn5) ?? "Goodbye!";
}
var sn5, rn5, tn5, D01;
var ge1 = T(() => {
  P11();
  xY();
  c4A();
  nS2();
  ((sn5 = IA(KA(), 1)),
    (rn5 = ["Goodbye!", "See ya!", "Bye!", "Catch you later!"]));
  ((tn5 = {
    type: "local-jsx",
    name: "exit",
    aliases: ["quit"],
    description: "Exit the REPL",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      return (A(on5()), await P6(0, "prompt_input_exit"), null);
    },
    userFacingName() {
      return "exit";
    },
  }),
    (D01 = tn5));
});
function aS2() {
  let A = Y7A.useRef();
  if (!A.current) A.current = AR();
  let B = A.current,
    [Q, I] = Y7A.useState(() => B.get());
  return (
    Y7A.useEffect(() => {
      function G() {
        I(B.get());
      }
      return (G(), B.setUpdateCallback(G), () => B.setUpdateCallback(null));
    }, [B]),
    { queuedCommands: Q, queueManager: B }
  );
}
var Y7A;
var sS2 = T(() => {
  c5A();
  Y7A = IA(KA(), 1);
});
function rS2({ onDone: A, onRunInit: B }) {
  let Q = IB();
  return (
    en5(),
    hY.default.createElement(
      hY.default.Fragment,
      null,
      hY.default.createElement(
        S,
        { flexDirection: "column" },
        hY.default.createElement(
          S,
          {
            flexDirection: "column",
            borderStyle: "round",
            borderColor: "suggestion",
            paddingLeft: 1,
            paddingRight: 1,
            gap: 1,
          },
          hY.default.createElement(
            S,
            null,
            hY.default.createElement(U, { color: "claude" }, " "),
            hY.default.createElement(
              S,
              { flexDirection: "column" },
              hY.default.createElement(
                U,
                { bold: !0 },
                "Set up CLAUDE.md for this project?",
              ),
            ),
          ),
          hY.default.createElement(
            S,
            { flexDirection: "column", paddingLeft: 1, gap: 1 },
            hY.default.createElement(
              U,
              { wrap: "wrap" },
              "CLAUDE.md helps Claude understand your project structure,",
              hY.default.createElement(
                U,
                { dimColor: !0 },
                `
`,
              ),
              "common commands, and coding conventions.",
            ),
            hY.default.createElement(
              U,
              { wrap: "wrap", dimColor: !0 },
              "Running ",
              hY.default.createElement(U, { bold: !0 }, "/init"),
              " will analyze your codebase and create this file.",
            ),
          ),
          hY.default.createElement(
            S,
            { paddingLeft: 1 },
            hY.default.createElement($0, {
              options: [
                { label: "Yes, run /init", value: "yes" },
                { label: "No, maybe later", value: "no" },
              ],
              onChange: (I) => {
                if (I === "yes") B();
                else A();
              },
              onCancel: A,
            }),
          ),
        ),
        hY.default.createElement(
          S,
          { marginLeft: 3 },
          hY.default.createElement(
            U,
            { dimColor: !0 },
            Q.pending
              ? hY.default.createElement(
                  hY.default.Fragment,
                  null,
                  "Press ",
                  Q.keyName,
                  " again to exit",
                )
              : hY.default.createElement(
                  hY.default.Fragment,
                  null,
                  "Enter to confirm  Esc to skip",
                ),
          ),
        ),
      ),
    )
  );
}
function oS2() {
  return L1().hasInitOnboardingBeenShown === !0;
}
function tS2() {
  let A = L1(),
    B = _7("cc_onboarding_init_modal", "show_init_modal_on_first_session", !1),
    Q = oS2();
  return B && A.numStartups === 1 && !Q;
}
function en5() {
  if (oS2()) return;
  let A = L1();
  n0({ ...A, hasInitOnboardingBeenShown: !0 });
}
var hY;
var eS2 = T(() => {
  nA();
  R9();
  kB();
  Z5();
  f4();
  hY = IA(KA(), 1);
});
class nK {
  static instance = null;
  status = { isAuthenticating: !1, output: [] };
  listeners = new Set();
  static getInstance() {
    if (!nK.instance) nK.instance = new nK();
    return nK.instance;
  }
  getStatus() {
    return { ...this.status, output: [...this.status.output] };
  }
  startAuthentication() {
    ((this.status = { isAuthenticating: !0, output: [] }),
      this.notifyListeners());
  }
  addOutput(A) {
    (this.status.output.push(A), this.notifyListeners());
  }
  setError(A) {
    ((this.status.error = A), this.notifyListeners());
  }
  endAuthentication(A) {
    if (A) this.status = { isAuthenticating: !1, output: [] };
    else this.status.isAuthenticating = !1;
    this.notifyListeners();
  }
  subscribe(A) {
    return (
      this.listeners.add(A),
      () => {
        this.listeners.delete(A);
      }
    );
  }
  notifyListeners() {
    this.listeners.forEach((A) => A(this.getStatus()));
  }
  static reset() {
    if (nK.instance) (nK.instance.listeners.clear(), (nK.instance = null));
  }
}
function Ay2() {
  let [A, B] = SR.useState(nK.getInstance().getStatus());
  if (
    (SR.useEffect(() => {
      return nK.getInstance().subscribe(B);
    }, []),
    !A.isAuthenticating && !A.error && A.output.length === 0)
  )
    return null;
  if (!A.isAuthenticating && !A.error) return null;
  return SR.default.createElement(
    S,
    {
      flexDirection: "column",
      borderStyle: "round",
      borderColor: "permission",
      paddingX: 1,
      marginY: 1,
    },
    SR.default.createElement(
      U,
      { bold: !0, color: "permission" },
      "AWS Authentication",
    ),
    A.output.length > 0 &&
      SR.default.createElement(
        S,
        { flexDirection: "column", marginTop: 1 },
        A.output
          .slice(-5)
          .map((Q, I) =>
            SR.default.createElement(U, { key: I, dimColor: !0 }, Q),
          ),
      ),
    A.error &&
      SR.default.createElement(
        S,
        { marginTop: 1 },
        SR.default.createElement(U, { color: "error" }, A.error),
      ),
  );
}
var SR;
var By2 = T(() => {
  nA();
  SR = IA(KA(), 1);
});
function NV() {
  return (
    V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
    V0(process.env.CLAUDE_CODE_USE_VERTEX) ||
    !!process.env.DISABLE_TELEMETRY ||
    !!process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC
  );
}
var J7A = T(() => {
  vB();
});
import { randomUUID as Qy2 } from "crypto";
function Iy2(A, B, Q) {
  let I = k4A(A)?.message?.id || "unknown",
    [G, Z] = aK.useState("closed"),
    [Y, J] = lB(),
    X = y11("tengu_feedback_survey_config", Aa5),
    W = aK.useRef(Qy2()),
    F = aK.useRef(Date.now()),
    C = aK.useRef(Q),
    V = aK.useCallback(
      (N, $) => {
        J((O) => ({
          ...O,
          feedbackSurvey: { timeLastShown: N, submitCountAtLastAppearance: $ },
        }));
      },
      [J],
    ),
    K = aK.useCallback(() => {
      if (G !== "closed") return;
      (Z("open"),
        V(Date.now(), Q),
        (W.current = Qy2()),
        GA("tengu_feedback_survey_event", {
          event_type: "appeared",
          appearance_id: W.current,
          last_assistant_message_id: I,
        }));
    }, [G, I, Q, V]),
    D = aK.useCallback(() => {
      (Z("thanks"), setTimeout(() => Z("closed"), X.hideThanksAfterMs));
    }, [X.hideThanksAfterMs]),
    E = mI(),
    H = aK.useMemo(() => {
      if (X.onForModels.length === 0) return !1;
      if (X.onForModels.includes("*")) return !0;
      return X.onForModels.includes(E);
    }, [X.onForModels, E]),
    w = aK.useMemo(() => {
      if (G !== "closed") return !1;
      if (B) return !1;
      if (
        process.env.CLAUDE_FORCE_DISPLAY_SURVEY &&
        !Y.feedbackSurvey.timeLastShown
      )
        return !0;
      if (!H) return !1;
      if (V0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY)) return !1;
      if (NV()) return !1;
      if (Y.feedbackSurvey.timeLastShown) {
        if (
          Y.feedbackSurvey.submitCountAtLastAppearance !== null &&
          Q <
            Y.feedbackSurvey.submitCountAtLastAppearance +
              X.minUserTurnsBetweenFeedback
        )
          return !1;
      } else {
        if (Date.now() - F.current < X.minTimeBeforeFeedbackMs) return !1;
        if (Q < C.current + X.minUserTurnsBeforeFeedback) return !1;
      }
      if (Math.random() > X.probability) return !1;
      let N = L1().feedbackSurveyState;
      if (N?.lastShownTime) {
        if (Date.now() - N.lastShownTime < X.minTimeBetweenGlobalFeedbackMs)
          return !1;
      }
      return !0;
    }, [
      G,
      B,
      H,
      Y.feedbackSurvey.timeLastShown,
      Y.feedbackSurvey.submitCountAtLastAppearance,
      Q,
      X.minTimeBetweenGlobalFeedbackMs,
      X.minUserTurnsBetweenFeedback,
      X.minTimeBeforeFeedbackMs,
      X.minUserTurnsBeforeFeedback,
      X.probability,
    ]);
  aK.useEffect(() => {
    if (w) K();
  }, [w, K]);
  let L = aK.useCallback(
    (N) => {
      if ((V(Date.now(), Q), N === "dismissed")) Z("closed");
      else D();
      GA("tengu_feedback_survey_event", {
        event_type: "responded",
        appearance_id: W.current,
        response: N,
        last_assistant_message_id: I,
      });
    },
    [I, D, V, Q],
  );
  return { state: G, handleSelect: L };
}
var aK, Aa5;
var Gy2 = T(() => {
  f4();
  H0();
  J7A();
  kB();
  Y9();
  vB();
  c9();
  iB();
  ((aK = IA(KA(), 1)),
    (Aa5 = {
      minTimeBeforeFeedbackMs: 600000,
      minTimeBetweenGlobalFeedbackMs: 1e8,
      minUserTurnsBeforeFeedback: 5,
      minUserTurnsBetweenFeedback: 10,
      hideThanksAfterMs: 3000,
      onForModels: ["*"],
      probability: 0.005,
    }));
});
function Zy2({ onSelect: A, inputValue: B, setInputValue: Q }) {
  let I = sF.useRef(B);
  return (
    sF.useEffect(() => {
      if (B !== I.current) {
        let G = B.slice(-1);
        if (ue1(G)) (Q(B.slice(0, -1)), A(Qa5[G]));
      }
    }, [B, A, Q]),
    sF.default.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      sF.default.createElement(
        S,
        null,
        sF.default.createElement(U, null, iA.cyan(" ")),
        sF.default.createElement(
          U,
          { bold: !0 },
          "How is Claude doing this session? (optional)",
        ),
      ),
      sF.default.createElement(
        S,
        { marginLeft: 2 },
        sF.default.createElement(
          S,
          { width: 10 },
          sF.default.createElement(U, null, iA.cyan("1"), ": Bad"),
        ),
        sF.default.createElement(
          S,
          { width: 10 },
          sF.default.createElement(U, null, iA.cyan("2"), ": Fine"),
        ),
        sF.default.createElement(
          S,
          { width: 10 },
          sF.default.createElement(U, null, iA.cyan("3"), ": Good"),
        ),
        sF.default.createElement(
          S,
          null,
          sF.default.createElement(U, null, iA.cyan("0"), ": Dismiss"),
        ),
      ),
    )
  );
}
var sF,
  Ba5,
  Qa5,
  ue1 = (A) => Ba5.includes(A);
var Yy2 = T(() => {
  f2();
  nA();
  ((sF = IA(KA(), 1)),
    (Ba5 = ["0", "1", "2", "3"]),
    (Qa5 = { 0: "dismissed", 1: "bad", 2: "fine", 3: "good" }));
});
function Jy2({ state: A, handleSelect: B, inputValue: Q, setInputValue: I }) {
  if (A === "closed") return null;
  if (A === "thanks")
    return G$A.default.createElement(
      S,
      { marginTop: 1, flexDirection: "column" },
      G$A.default.createElement(
        U,
        { color: "success" },
        " Thanks for helping make Claude better!",
      ),
      G$A.default.createElement(
        U,
        { dimColor: !0 },
        "Use /feedback to share detailed feedback or file a bug.",
      ),
    );
  if (Q && !ue1(Q)) return null;
  return G$A.default.createElement(Zy2, {
    onSelect: B,
    inputValue: Q,
    setInputValue: I,
  });
}
var G$A;
var Xy2 = T(() => {
  nA();
  Yy2();
  G$A = IA(KA(), 1);
});
function Fy2() {
  let { addNotification: A } = f7();
  Wy2.useEffect(() => {
    kS().then((B) => {
      B.forEach((Q, I) => {
        let G = "low";
        if (Q.type === "error" || Q.userActionRequired) G = "high";
        else if (Q.type === "path" || Q.type === "alias") G = "medium";
        A({
          key: `install-message-${I}-${Q.type}`,
          text: Q.message,
          priority: G,
          color: Q.type === "error" ? "error" : "warning",
        });
      });
    });
  }, [A]);
}
var Wy2;
var Cy2 = T(() => {
  _H();
  FR();
  Wy2 = IA(KA(), 1);
});
function Vy2() {
  return L1().tipsHistory || {};
}
function Ia5(A) {
  let B = L1();
  n0({ ...B, tipsHistory: A });
}
function Ky2(A) {
  let B = Vy2(),
    Q = L1().numStartups;
  ((B[A] = Q), Ia5(B));
}
function Ga5(A) {
  return Vy2()[A] || 0;
}
function E01(A) {
  let B = Ga5(A);
  if (B === 0) return 1 / 0;
  return L1().numStartups - B;
}
var me1 = T(() => {
  kB();
});
function ac() {
  return !1;
}
function Dy2() {
  if (process.env.CLAUDE_CODE_PLAN_V2_AGENT_COUNT) {
    let A = parseInt(process.env.CLAUDE_CODE_PLAN_V2_AGENT_COUNT, 10);
    if (!isNaN(A) && A > 0 && A <= 10) return A;
  }
  return 4;
}
var Ey2, Ya5, Ja5, H01;
var de1 = T(() => {
  kB();
  vC();
  Y9();
  y0A();
  C6();
  zW();
  E5();
  lh();
  OQ();
  me1();
  tq();
  C0();
  ((Ey2 = IA(jv1(), 1)),
    (Ya5 = [
      {
        id: "new-user-warmup",
        content:
          "Start with small features or bug fixes, tell Claude to propose a plan, and verify its suggested edits",
        cooldownSessions: 3,
        async isRelevant() {
          return L1().numStartups < 10;
        },
      },
      {
        id: "plan-mode-for-complex-tasks",
        content: `Use Plan Mode to prepare for a complex request before making changes. Press ${DH.displayText} twice to enable.`,
        cooldownSessions: 5,
        isRelevant: async () => {
          let A = L1();
          return (
            (A.lastPlanModeUse
              ? (Date.now() - A.lastPlanModeUse) / 86400000
              : 1 / 0) > 7
          );
        },
      },
      {
        id: "default-permission-mode-config",
        content:
          "Use /config to change your default permission mode (including Plan Mode)",
        cooldownSessions: 10,
        isRelevant: async () => {
          try {
            if (!ac()) return !1;
            let A = L1(),
              B = N0(),
              Q = Boolean(A.lastPlanModeUse),
              I = Boolean(B?.permissions?.defaultMode);
            return Q && !I;
          } catch (A) {
            return (
              g(
                `Failed to check default-permission-mode-config tip relevance: ${A}`,
                { level: "warn" },
              ),
              !1
            );
          }
        },
      },
      {
        id: "git-worktrees",
        content:
          "Use git worktrees to run multiple Claude sessions in parallel.",
        cooldownSessions: 10,
        isRelevant: async () => {
          try {
            let A = L1();
            return (await gFA()) <= 1 && A.numStartups > 50;
          } catch (A) {
            return !1;
          }
        },
      },
      {
        id: "terminal-setup",
        content:
          O0.terminal === "Apple_Terminal"
            ? "Run /terminal-setup to enable convenient terminal integration like Option + Enter for new line and more"
            : "Run /terminal-setup to enable convenient terminal integration like Shift + Enter for new line and more",
        cooldownSessions: 10,
        async isRelevant() {
          let A = L1();
          if (O0.terminal === "Apple_Terminal")
            return ch.isEnabled() && !A.optionAsMetaKeyInstalled;
          return ch.isEnabled() && !A.shiftEnterKeyBindingInstalled;
        },
      },
      {
        id: "shift-enter",
        content:
          O0.terminal === "Apple_Terminal"
            ? "Press Option+Enter to send a multi-line message"
            : "Press Shift+Enter to send a multi-line message",
        cooldownSessions: 10,
        async isRelevant() {
          let A = L1();
          return Boolean(
            (O0.terminal === "Apple_Terminal"
              ? A.optionAsMetaKeyInstalled
              : A.shiftEnterKeyBindingInstalled) && A.numStartups > 3,
          );
        },
      },
      {
        id: "shift-enter-setup",
        content:
          O0.terminal === "Apple_Terminal"
            ? "Run /terminal-setup to enable Option+Enter for new lines"
            : "Run /terminal-setup to enable Shift+Enter for new lines",
        cooldownSessions: 10,
        async isRelevant() {
          if (!MJA()) return !1;
          let A = L1();
          return !(O0.terminal === "Apple_Terminal"
            ? A.optionAsMetaKeyInstalled
            : A.shiftEnterKeyBindingInstalled);
        },
      },
      {
        id: "memory-command",
        content: "Use /memory to view and manage Claude memory",
        cooldownSessions: 15,
        async isRelevant() {
          return L1().memoryUsageCount <= 0;
        },
      },
      {
        id: "theme-command",
        content: "Use /theme to change the color theme",
        cooldownSessions: 20,
        isRelevant: async () => !0,
      },
      {
        id: "status-line",
        content:
          "Use /statusline to set up a custom status line that will display beneath the input box",
        cooldownSessions: 25,
        isRelevant: async () => N0().statusLine === void 0,
      },
      {
        id: "stickers-command",
        content: "Use /stickers to order Claude Code swag",
        cooldownSessions: 20,
        isRelevant: async () => !0,
      },
      {
        id: "prompt-queue",
        content:
          "Hit Enter to queue up additional messages while Claude is working.",
        cooldownSessions: 5,
        async isRelevant() {
          return L1().promptQueueUseCount <= 3;
        },
      },
      {
        id: "enter-to-steer-in-relatime",
        content:
          "Send messages to Claude while it works to steer Claude in real-time",
        cooldownSessions: 20,
        isRelevant: async () => !0,
      },
      {
        id: "todo-list",
        content:
          "Ask Claude to create a todo list when working on complex tasks to track progress and remain on track",
        cooldownSessions: 20,
        isRelevant: async () => !0,
      },
      {
        id: "vscode-command-install",
        content: `Open the Command Palette (Cmd+Shift+P) and run "Shell Command: Install '${O0.terminal === "vscode" ? "code" : O0.terminal}' command in PATH" to enable IDE integration`,
        cooldownSessions: 0,
        async isRelevant() {
          if (!pDA()) return !1;
          if (EB() !== "macos") return !1;
          switch (O0.terminal) {
            case "vscode":
              return !XNQ();
            case "cursor":
              return !YNQ();
            case "windsurf":
              return !JNQ();
            default:
              return !1;
          }
        },
      },
      {
        id: "ide-upsell-external-terminal",
        content: "Connect Claude to your IDE  /ide",
        cooldownSessions: 4,
        async isRelevant() {
          if (UW()) return !1;
          if (TiA().length !== 0) return !1;
          return jiA().length > 0;
        },
      },
      {
        id: "# for memory",
        content:
          "Want Claude to remember something? Hit # to add preferences, tools, and instructions to Claude's memory",
        cooldownSessions: 10,
        isRelevant: async () => L1().memoryUsageCount <= 10,
      },
      {
        id: "install-github-app",
        content:
          "Run /install-github-app to tag @claude right from your Github issues and PRs",
        cooldownSessions: 10,
        isRelevant: async () => !L1().githubActionSetupCount,
      },
      {
        id: "permissions",
        content:
          "Use /permissions to pre-approve and pre-deny bash, edit, and MCP tools",
        cooldownSessions: 10,
        async isRelevant() {
          return L1().numStartups > 10;
        },
      },
      {
        id: "drag-and-drop-images",
        content:
          "Did you know you can drag and drop image files into your terminal?",
        cooldownSessions: 10,
        isRelevant: async () => !0,
      },
      {
        id: "paste-images-mac",
        content: "Paste images into Claude Code using control+v (not cmd+v!)",
        cooldownSessions: 10,
        isRelevant: async () => EB() === "macos",
      },
      {
        id: "double-esc",
        content:
          "Press Esc twice to rewind the conversation to a previous point in time",
        cooldownSessions: 10,
        isRelevant: async () => !UG(),
      },
      {
        id: "double-esc-code-restore",
        content:
          "Press Esc twice to rewind the code and/or conversation to a previous point in time",
        cooldownSessions: 10,
        isRelevant: async () => UG(),
      },
      {
        id: "continue",
        content:
          "Run claude --continue or claude --resume to resume a conversation",
        cooldownSessions: 10,
        isRelevant: async () => !0,
      },
      {
        id: "custom-commands",
        content:
          "Create custom slash commands by adding .md files to .claude/commands/ in your project or ~/.claude/commands/ for commands that work in any project",
        cooldownSessions: 15,
        async isRelevant() {
          return L1().numStartups > 10;
        },
      },
      {
        id: "shift-tab",
        content: `Hit ${DH.displayText} to cycle between default mode, auto-accept edit mode, and plan mode`,
        cooldownSessions: 10,
        isRelevant: async () => !0,
      },
      {
        id: "image-paste",
        content: `Use ${Oi.displayText} to paste images from your clipboard`,
        cooldownSessions: 20,
        isRelevant: async () => !0,
      },
      {
        id: "tab-toggle-thinking",
        content: "Hit tab to toggle thinking mode on and off",
        cooldownSessions: 10,
        isRelevant: async () => !0,
      },
      {
        id: "ultrathink-keyword",
        content:
          "Type 'ultrathink' in your message to enable thinking for just that turn",
        cooldownSessions: 10,
        isRelevant: async () => !0,
      },
      {
        id: "custom-agents",
        content:
          "Use /agents to optimize specific tasks. Eg. Software Architect, Code Writer, Code Reviewer",
        cooldownSessions: 15,
        async isRelevant() {
          return L1().numStartups > 5;
        },
      },
      {
        id: "opusplan-mode-reminder",
        content: `Your default model setting is Opus Plan Mode. Press ${DH.displayText} twice to activate Plan Mode and plan with Claude Opus.`,
        cooldownSessions: 2,
        async isRelevant() {
          let A = L1(),
            Q = Ln() === "opusplan",
            I = A.lastPlanModeUse
              ? (Date.now() - A.lastPlanModeUse) / 86400000
              : 1 / 0;
          return Q && I > 3;
        },
      },
    ]),
    (Ja5 = []),
    (H01 = Ey2.memoize(async () => {
      let A = [...Ya5, ...Ja5],
        B = await Promise.all(A.map((Q) => Q.isRelevant()));
      return A.filter((Q, I) => B[I]).filter(
        (Q) => E01(Q.id) >= Q.cooldownSessions,
      );
    })));
});
function Xa5(A) {
  if (A.length === 0) return;
  if (A.length === 1) return A[0];
  let B = A.map((Q) => ({ tip: Q, sessions: E01(Q.id) }));
  return (B.sort((Q, I) => I.sessions - Q.sessions), B[0]?.tip);
}
async function Hy2() {
  if (N0().spinnerTipsEnabled === !1) return;
  let A = await H01();
  if (A.length === 0) return;
  return Xa5(A);
}
function zy2(A) {
  (Ky2(A.id),
    GA("tengu_tip_shown", {
      tipIdLength: A.id,
      cooldownSessions: A.cooldownSessions,
    }));
}
var Uy2 = T(() => {
  me1();
  H0();
  kB();
  OQ();
  G7A();
  de1();
});
function $y2() {
  let [A, B] = lB(),
    { toolPermissionContext: Q } = A;
  wy2.useEffect(() => {
    ce1(Q, B);
  }, []);
}
var wy2, ce1;
var qy2 = T(() => {
  a2();
  c9();
  OIA();
  ((wy2 = IA(KA(), 1)),
    (ce1 = I0(async (A, B) => {
      if (!A.isBypassPermissionsModeAvailable) return;
      if (!(await pe1())) return;
      B((I) => {
        return { ...I, toolPermissionContext: Ny2(I.toolPermissionContext) };
      });
    })));
});
function Ly2(A, B, Q) {
  let I = z01.useRef(!1);
  z01.useEffect(() => {
    if (!UG() || I.current) return;
    if (((I.current = !0), A)) OdA(A, Q);
  }, [B, A, Q]);
}
var z01;
var My2 = T(() => {
  tq();
  z01 = IA(KA(), 1);
});
function Oy2({ hostPattern: { host: A }, onUserResponse: B }) {
  function Q(G) {
    switch (G) {
      case "yes":
        B({ allow: !0, persistToSettings: !1 });
        break;
      case "yes-dont-ask-again":
        B({ allow: !0, persistToSettings: !0 });
        break;
      case "no":
        B({ allow: !1, persistToSettings: !1 });
        break;
    }
  }
  let I = [
    { label: "Yes", value: "yes" },
    {
      label: `Yes, and don't ask again for ${iA.bold(A)}`,
      value: "yes-dont-ask-again",
    },
    {
      label: `No, and tell Claude what to do differently ${iA.bold.dim("(esc)")}`,
      value: "no",
    },
  ];
  return PW.createElement(
    yX,
    { title: "Network request outside of sandbox" },
    PW.createElement(
      S,
      { flexDirection: "column", paddingX: 2, paddingY: 1 },
      PW.createElement(
        S,
        null,
        PW.createElement(U, { dimColor: !0 }, "Host:"),
        PW.createElement(U, null, " ", A),
      ),
      PW.createElement(
        S,
        { marginTop: 1 },
        PW.createElement(U, null, "Do you want to allow this connection?"),
      ),
      PW.createElement(
        S,
        null,
        PW.createElement($0, {
          options: I,
          onChange: Q,
          onCancel: () => {
            B({ allow: !1, persistToSettings: !1 });
          },
        }),
      ),
    ),
  );
}
var PW;
var Ry2 = T(() => {
  nA();
  Z5();
  QR();
  f2();
  H0();
  PW = IA(KA(), 1);
});
var Wa5,
  aR7,
  U01 = 604800000,
  Ty2 = 86400000,
  le1;
var Z$A = T(() => {
  ((Wa5 = Math.pow(10, 8) * 24 * 60 * 60 * 1000),
    (aR7 = -Wa5),
    (le1 = Symbol.for("constructDateFrom")));
});
function yz(A, B) {
  if (typeof A === "function") return A(B);
  if (A && typeof A === "object" && le1 in A) return A[le1](B);
  if (A instanceof Date) return new A.constructor(B);
  return new Date(B);
}
var sc = T(() => {
  Z$A();
});
function gY(A, B) {
  return yz(B || A, A);
}
var cw = T(() => {
  sc();
});
var Py2 = () => {};
var jy2 = () => {};
var Sy2 = () => {};
var yy2 = () => {};
var ky2 = () => {};
var _y2 = () => {};
var xy2 = () => {};
var vy2 = () => {};
var by2 = () => {};
function rc() {
  return Fa5;
}
var Fa5;
var Y$A = T(() => {
  Fa5 = {};
});
function zb(A, B) {
  let Q = rc(),
    I =
      B?.weekStartsOn ??
      B?.locale?.options?.weekStartsOn ??
      Q.weekStartsOn ??
      Q.locale?.options?.weekStartsOn ??
      0,
    G = gY(A, B?.in),
    Z = G.getDay(),
    Y = (Z < I ? 7 : 0) + Z - I;
  return (G.setDate(G.getDate() - Y), G.setHours(0, 0, 0, 0), G);
}
var X7A = T(() => {
  Y$A();
  cw();
});
function Qt(A, B) {
  return zb(A, { ...B, weekStartsOn: 1 });
}
var J$A = T(() => {
  X7A();
});
function w01(A, B) {
  let Q = gY(A, B?.in),
    I = Q.getFullYear(),
    G = yz(Q, 0);
  (G.setFullYear(I + 1, 0, 4), G.setHours(0, 0, 0, 0));
  let Z = Qt(G),
    Y = yz(Q, 0);
  (Y.setFullYear(I, 0, 4), Y.setHours(0, 0, 0, 0));
  let J = Qt(Y);
  if (Q.getTime() >= Z.getTime()) return I + 1;
  else if (Q.getTime() >= J.getTime()) return I;
  else return I - 1;
}
var $01 = T(() => {
  sc();
  J$A();
  cw();
});
function ie1(A) {
  let B = gY(A),
    Q = new Date(
      Date.UTC(
        B.getFullYear(),
        B.getMonth(),
        B.getDate(),
        B.getHours(),
        B.getMinutes(),
        B.getSeconds(),
        B.getMilliseconds(),
      ),
    );
  return (Q.setUTCFullYear(B.getFullYear()), +A - +Q);
}
var fy2 = T(() => {
  cw();
});
function hy2(A, ...B) {
  let Q = yz.bind(null, A || B.find((I) => typeof I === "object"));
  return B.map(Q);
}
var gy2 = T(() => {
  sc();
});
function ne1(A, B) {
  let Q = gY(A, B?.in);
  return (Q.setHours(0, 0, 0, 0), Q);
}
var ae1 = T(() => {
  cw();
});
function uy2(A, B, Q) {
  let [I, G] = hy2(Q?.in, A, B),
    Z = ne1(I),
    Y = ne1(G),
    J = +Z - ie1(Z),
    X = +Y - ie1(Y);
  return Math.round((J - X) / Ty2);
}
var se1 = T(() => {
  fy2();
  gy2();
  Z$A();
  ae1();
});
function my2(A, B) {
  let Q = w01(A, B),
    I = yz(B?.in || A, 0);
  return (I.setFullYear(Q, 0, 4), I.setHours(0, 0, 0, 0), Qt(I));
}
var re1 = T(() => {
  sc();
  $01();
  J$A();
});
var dy2 = () => {};
var cy2 = () => {};
var py2 = () => {};
var ly2 = () => {};
var iy2 = () => {};
var ny2 = () => {};
var ay2 = () => {};
var sy2 = () => {};
var ry2 = () => {};
var oy2 = () => {};
var ty2 = () => {};
var ey2 = () => {};
var Ak2 = () => {};
var Bk2 = () => {};
var Qk2 = () => {};
var Ik2 = () => {};
var Gk2 = () => {};
var Zk2 = () => {};
function Yk2(A) {
  return (
    A instanceof Date ||
    (typeof A === "object" &&
      Object.prototype.toString.call(A) === "[object Date]")
  );
}
var oe1 = () => {};
function Jk2(A) {
  return !((!Yk2(A) && typeof A !== "number") || isNaN(+gY(A)));
}
var te1 = T(() => {
  oe1();
  cw();
});
var Xk2 = () => {};
var Wk2 = () => {};
var Fk2 = () => {};
var Ck2 = () => {};
var Vk2 = () => {};
var Kk2 = () => {};
var Dk2 = () => {};
var Ek2 = () => {};
var Hk2 = () => {};
var zk2 = () => {};
var Uk2 = () => {};
var wk2 = () => {};
var $k2 = () => {};
var qk2 = () => {};
var Nk2 = () => {};
var Lk2 = () => {};
var Mk2 = () => {};
var Ok2 = () => {};
var Rk2 = () => {};
var Tk2 = () => {};
var Pk2 = () => {};
var jk2 = () => {};
var Sk2 = () => {};
var yk2 = () => {};
var kk2 = () => {};
var _k2 = () => {};
var xk2 = () => {};
var vk2 = () => {};
var bk2 = () => {};
var fk2 = () => {};
var hk2 = () => {};
var gk2 = () => {};
var uk2 = () => {};
function mk2(A, B) {
  let Q = gY(A, B?.in);
  return (Q.setFullYear(Q.getFullYear(), 0, 1), Q.setHours(0, 0, 0, 0), Q);
}
var ee1 = T(() => {
  cw();
});
var dk2 = () => {};
var ck2 = () => {};
var pk2 = () => {};
var lk2 = () => {};
var ik2 = () => {};
var nk2 = () => {};
var ak2 = () => {};
var sk2 = () => {};
var rk2 = () => {};
var ok2 = () => {};
var tk2 = () => {};
var ek2 = () => {};
var A_2 = () => {};
var Ca5,
  B_2 = (A, B, Q) => {
    let I,
      G = Ca5[A];
    if (typeof G === "string") I = G;
    else if (B === 1) I = G.one;
    else I = G.other.replace("{{count}}", B.toString());
    if (Q?.addSuffix)
      if (Q.comparison && Q.comparison > 0) return "in " + I;
      else return I + " ago";
    return I;
  };
var Q_2 = T(() => {
  Ca5 = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds",
    },
    xSeconds: { one: "1 second", other: "{{count}} seconds" },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes",
    },
    xMinutes: { one: "1 minute", other: "{{count}} minutes" },
    aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" },
    xHours: { one: "1 hour", other: "{{count}} hours" },
    xDays: { one: "1 day", other: "{{count}} days" },
    aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" },
    xWeeks: { one: "1 week", other: "{{count}} weeks" },
    aboutXMonths: { one: "about 1 month", other: "about {{count}} months" },
    xMonths: { one: "1 month", other: "{{count}} months" },
    aboutXYears: { one: "about 1 year", other: "about {{count}} years" },
    xYears: { one: "1 year", other: "{{count}} years" },
    overXYears: { one: "over 1 year", other: "over {{count}} years" },
    almostXYears: { one: "almost 1 year", other: "almost {{count}} years" },
  };
});
function q01(A) {
  return (B = {}) => {
    let Q = B.width ? String(B.width) : A.defaultWidth;
    return A.formats[Q] || A.formats[A.defaultWidth];
  };
}
var Va5, Ka5, Da5, I_2;
var G_2 = T(() => {
  ((Va5 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy",
  }),
    (Ka5 = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a",
    }),
    (Da5 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}",
    }),
    (I_2 = {
      date: q01({ formats: Va5, defaultWidth: "full" }),
      time: q01({ formats: Ka5, defaultWidth: "full" }),
      dateTime: q01({ formats: Da5, defaultWidth: "full" }),
    }));
});
var Ea5,
  Z_2 = (A, B, Q, I) => Ea5[A];
var Y_2 = T(() => {
  Ea5 = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P",
  };
});
function W7A(A) {
  return (B, Q) => {
    let I = Q?.context ? String(Q.context) : "standalone",
      G;
    if (I === "formatting" && A.formattingValues) {
      let Y = A.defaultFormattingWidth || A.defaultWidth,
        J = Q?.width ? String(Q.width) : Y;
      G = A.formattingValues[J] || A.formattingValues[Y];
    } else {
      let Y = A.defaultWidth,
        J = Q?.width ? String(Q.width) : A.defaultWidth;
      G = A.values[J] || A.values[Y];
    }
    let Z = A.argumentCallback ? A.argumentCallback(B) : B;
    return G[Z];
  };
}
var Ha5,
  za5,
  Ua5,
  wa5,
  $a5,
  qa5,
  Na5 = (A, B) => {
    let Q = Number(A),
      I = Q % 100;
    if (I > 20 || I < 10)
      switch (I % 10) {
        case 1:
          return Q + "st";
        case 2:
          return Q + "nd";
        case 3:
          return Q + "rd";
      }
    return Q + "th";
  },
  J_2;
var X_2 = T(() => {
  ((Ha5 = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"],
  }),
    (za5 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
    }),
    (Ua5 = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
    }),
    (wa5 = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ],
    }),
    ($a5 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night",
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night",
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night",
      },
    }),
    (qa5 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night",
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night",
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night",
      },
    }),
    (J_2 = {
      ordinalNumber: Na5,
      era: W7A({ values: Ha5, defaultWidth: "wide" }),
      quarter: W7A({
        values: za5,
        defaultWidth: "wide",
        argumentCallback: (A) => A - 1,
      }),
      month: W7A({ values: Ua5, defaultWidth: "wide" }),
      day: W7A({ values: wa5, defaultWidth: "wide" }),
      dayPeriod: W7A({
        values: $a5,
        defaultWidth: "wide",
        formattingValues: qa5,
        defaultFormattingWidth: "wide",
      }),
    }));
});
function F7A(A) {
  return (B, Q = {}) => {
    let I = Q.width,
      G = (I && A.matchPatterns[I]) || A.matchPatterns[A.defaultMatchWidth],
      Z = B.match(G);
    if (!Z) return null;
    let Y = Z[0],
      J = (I && A.parsePatterns[I]) || A.parsePatterns[A.defaultParseWidth],
      X = Array.isArray(J)
        ? Ma5(J, (C) => C.test(Y))
        : La5(J, (C) => C.test(Y)),
      W;
    ((W = A.valueCallback ? A.valueCallback(X) : X),
      (W = Q.valueCallback ? Q.valueCallback(W) : W));
    let F = B.slice(Y.length);
    return { value: W, rest: F };
  };
}
function La5(A, B) {
  for (let Q in A)
    if (Object.prototype.hasOwnProperty.call(A, Q) && B(A[Q])) return Q;
  return;
}
function Ma5(A, B) {
  for (let Q = 0; Q < A.length; Q++) if (B(A[Q])) return Q;
  return;
}
function W_2(A) {
  return (B, Q = {}) => {
    let I = B.match(A.matchPattern);
    if (!I) return null;
    let G = I[0],
      Z = B.match(A.parsePattern);
    if (!Z) return null;
    let Y = A.valueCallback ? A.valueCallback(Z[0]) : Z[0];
    Y = Q.valueCallback ? Q.valueCallback(Y) : Y;
    let J = B.slice(G.length);
    return { value: Y, rest: J };
  };
}
var Oa5, Ra5, Ta5, Pa5, ja5, Sa5, ya5, ka5, _a5, xa5, va5, ba5, F_2;
var C_2 = T(() => {
  ((Oa5 = /^(\d+)(th|st|nd|rd)?/i),
    (Ra5 = /\d+/i),
    (Ta5 = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i,
    }),
    (Pa5 = { any: [/^b/i, /^(a|c)/i] }),
    (ja5 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i,
    }),
    (Sa5 = { any: [/1/i, /2/i, /3/i, /4/i] }),
    (ya5 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
    }),
    (ka5 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i,
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i,
      ],
    }),
    (_a5 = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
    }),
    (xa5 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
    }),
    (va5 = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
    }),
    (ba5 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i,
      },
    }),
    (F_2 = {
      ordinalNumber: W_2({
        matchPattern: Oa5,
        parsePattern: Ra5,
        valueCallback: (A) => parseInt(A, 10),
      }),
      era: F7A({
        matchPatterns: Ta5,
        defaultMatchWidth: "wide",
        parsePatterns: Pa5,
        defaultParseWidth: "any",
      }),
      quarter: F7A({
        matchPatterns: ja5,
        defaultMatchWidth: "wide",
        parsePatterns: Sa5,
        defaultParseWidth: "any",
        valueCallback: (A) => A + 1,
      }),
      month: F7A({
        matchPatterns: ya5,
        defaultMatchWidth: "wide",
        parsePatterns: ka5,
        defaultParseWidth: "any",
      }),
      day: F7A({
        matchPatterns: _a5,
        defaultMatchWidth: "wide",
        parsePatterns: xa5,
        defaultParseWidth: "any",
      }),
      dayPeriod: F7A({
        matchPatterns: va5,
        defaultMatchWidth: "any",
        parsePatterns: ba5,
        defaultParseWidth: "any",
      }),
    }));
});
var AA0;
var V_2 = T(() => {
  Q_2();
  G_2();
  Y_2();
  X_2();
  C_2();
  AA0 = {
    code: "en-US",
    formatDistance: B_2,
    formatLong: I_2,
    formatRelative: Z_2,
    localize: J_2,
    match: F_2,
    options: { weekStartsOn: 0, firstWeekContainsDate: 1 },
  };
});
var K_2 = T(() => {
  V_2();
});
function D_2(A, B) {
  let Q = gY(A, B?.in);
  return uy2(Q, mk2(Q)) + 1;
}
var BA0 = T(() => {
  se1();
  ee1();
  cw();
});
function E_2(A, B) {
  let Q = gY(A, B?.in),
    I = +Qt(Q) - +my2(Q);
  return Math.round(I / U01) + 1;
}
var QA0 = T(() => {
  Z$A();
  J$A();
  re1();
  cw();
});
function N01(A, B) {
  let Q = gY(A, B?.in),
    I = Q.getFullYear(),
    G = rc(),
    Z =
      B?.firstWeekContainsDate ??
      B?.locale?.options?.firstWeekContainsDate ??
      G.firstWeekContainsDate ??
      G.locale?.options?.firstWeekContainsDate ??
      1,
    Y = yz(B?.in || A, 0);
  (Y.setFullYear(I + 1, 0, Z), Y.setHours(0, 0, 0, 0));
  let J = zb(Y, B),
    X = yz(B?.in || A, 0);
  (X.setFullYear(I, 0, Z), X.setHours(0, 0, 0, 0));
  let W = zb(X, B);
  if (+Q >= +J) return I + 1;
  else if (+Q >= +W) return I;
  else return I - 1;
}
var L01 = T(() => {
  Y$A();
  sc();
  X7A();
  cw();
});
function H_2(A, B) {
  let Q = rc(),
    I =
      B?.firstWeekContainsDate ??
      B?.locale?.options?.firstWeekContainsDate ??
      Q.firstWeekContainsDate ??
      Q.locale?.options?.firstWeekContainsDate ??
      1,
    G = N01(A, B),
    Z = yz(B?.in || A, 0);
  return (Z.setFullYear(G, 0, I), Z.setHours(0, 0, 0, 0), zb(Z, B));
}
var IA0 = T(() => {
  Y$A();
  sc();
  L01();
  X7A();
});
function z_2(A, B) {
  let Q = gY(A, B?.in),
    I = +zb(Q, B) - +H_2(Q, B);
  return Math.round(I / U01) + 1;
}
var GA0 = T(() => {
  Z$A();
  X7A();
  IA0();
  cw();
});
function sI(A, B) {
  let Q = A < 0 ? "-" : "",
    I = Math.abs(A).toString().padStart(B, "0");
  return Q + I;
}
var Ub;
var U_2 = T(() => {
  Ub = {
    y(A, B) {
      let Q = A.getFullYear(),
        I = Q > 0 ? Q : 1 - Q;
      return sI(B === "yy" ? I % 100 : I, B.length);
    },
    M(A, B) {
      let Q = A.getMonth();
      return B === "M" ? String(Q + 1) : sI(Q + 1, 2);
    },
    d(A, B) {
      return sI(A.getDate(), B.length);
    },
    a(A, B) {
      let Q = A.getHours() / 12 >= 1 ? "pm" : "am";
      switch (B) {
        case "a":
        case "aa":
          return Q.toUpperCase();
        case "aaa":
          return Q;
        case "aaaaa":
          return Q[0];
        case "aaaa":
        default:
          return Q === "am" ? "a.m." : "p.m.";
      }
    },
    h(A, B) {
      return sI(A.getHours() % 12 || 12, B.length);
    },
    H(A, B) {
      return sI(A.getHours(), B.length);
    },
    m(A, B) {
      return sI(A.getMinutes(), B.length);
    },
    s(A, B) {
      return sI(A.getSeconds(), B.length);
    },
    S(A, B) {
      let Q = B.length,
        I = A.getMilliseconds(),
        G = Math.trunc(I * Math.pow(10, Q - 3));
      return sI(G, B.length);
    },
  };
});
function w_2(A, B = "") {
  let Q = A > 0 ? "-" : "+",
    I = Math.abs(A),
    G = Math.trunc(I / 60),
    Z = I % 60;
  if (Z === 0) return Q + String(G);
  return Q + String(G) + B + sI(Z, 2);
}
function $_2(A, B) {
  if (A % 60 === 0) return (A > 0 ? "-" : "+") + sI(Math.abs(A) / 60, 2);
  return It(A, B);
}
function It(A, B = "") {
  let Q = A > 0 ? "-" : "+",
    I = Math.abs(A),
    G = sI(Math.trunc(I / 60), 2),
    Z = sI(I % 60, 2);
  return Q + G + B + Z;
}
var C7A, ZA0;
var q_2 = T(() => {
  BA0();
  QA0();
  $01();
  GA0();
  L01();
  U_2();
  ((C7A = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  }),
    (ZA0 = {
      G: function (A, B, Q) {
        let I = A.getFullYear() > 0 ? 1 : 0;
        switch (B) {
          case "G":
          case "GG":
          case "GGG":
            return Q.era(I, { width: "abbreviated" });
          case "GGGGG":
            return Q.era(I, { width: "narrow" });
          case "GGGG":
          default:
            return Q.era(I, { width: "wide" });
        }
      },
      y: function (A, B, Q) {
        if (B === "yo") {
          let I = A.getFullYear(),
            G = I > 0 ? I : 1 - I;
          return Q.ordinalNumber(G, { unit: "year" });
        }
        return Ub.y(A, B);
      },
      Y: function (A, B, Q, I) {
        let G = N01(A, I),
          Z = G > 0 ? G : 1 - G;
        if (B === "YY") {
          let Y = Z % 100;
          return sI(Y, 2);
        }
        if (B === "Yo") return Q.ordinalNumber(Z, { unit: "year" });
        return sI(Z, B.length);
      },
      R: function (A, B) {
        let Q = w01(A);
        return sI(Q, B.length);
      },
      u: function (A, B) {
        let Q = A.getFullYear();
        return sI(Q, B.length);
      },
      Q: function (A, B, Q) {
        let I = Math.ceil((A.getMonth() + 1) / 3);
        switch (B) {
          case "Q":
            return String(I);
          case "QQ":
            return sI(I, 2);
          case "Qo":
            return Q.ordinalNumber(I, { unit: "quarter" });
          case "QQQ":
            return Q.quarter(I, {
              width: "abbreviated",
              context: "formatting",
            });
          case "QQQQQ":
            return Q.quarter(I, { width: "narrow", context: "formatting" });
          case "QQQQ":
          default:
            return Q.quarter(I, { width: "wide", context: "formatting" });
        }
      },
      q: function (A, B, Q) {
        let I = Math.ceil((A.getMonth() + 1) / 3);
        switch (B) {
          case "q":
            return String(I);
          case "qq":
            return sI(I, 2);
          case "qo":
            return Q.ordinalNumber(I, { unit: "quarter" });
          case "qqq":
            return Q.quarter(I, {
              width: "abbreviated",
              context: "standalone",
            });
          case "qqqqq":
            return Q.quarter(I, { width: "narrow", context: "standalone" });
          case "qqqq":
          default:
            return Q.quarter(I, { width: "wide", context: "standalone" });
        }
      },
      M: function (A, B, Q) {
        let I = A.getMonth();
        switch (B) {
          case "M":
          case "MM":
            return Ub.M(A, B);
          case "Mo":
            return Q.ordinalNumber(I + 1, { unit: "month" });
          case "MMM":
            return Q.month(I, { width: "abbreviated", context: "formatting" });
          case "MMMMM":
            return Q.month(I, { width: "narrow", context: "formatting" });
          case "MMMM":
          default:
            return Q.month(I, { width: "wide", context: "formatting" });
        }
      },
      L: function (A, B, Q) {
        let I = A.getMonth();
        switch (B) {
          case "L":
            return String(I + 1);
          case "LL":
            return sI(I + 1, 2);
          case "Lo":
            return Q.ordinalNumber(I + 1, { unit: "month" });
          case "LLL":
            return Q.month(I, { width: "abbreviated", context: "standalone" });
          case "LLLLL":
            return Q.month(I, { width: "narrow", context: "standalone" });
          case "LLLL":
          default:
            return Q.month(I, { width: "wide", context: "standalone" });
        }
      },
      w: function (A, B, Q, I) {
        let G = z_2(A, I);
        if (B === "wo") return Q.ordinalNumber(G, { unit: "week" });
        return sI(G, B.length);
      },
      I: function (A, B, Q) {
        let I = E_2(A);
        if (B === "Io") return Q.ordinalNumber(I, { unit: "week" });
        return sI(I, B.length);
      },
      d: function (A, B, Q) {
        if (B === "do") return Q.ordinalNumber(A.getDate(), { unit: "date" });
        return Ub.d(A, B);
      },
      D: function (A, B, Q) {
        let I = D_2(A);
        if (B === "Do") return Q.ordinalNumber(I, { unit: "dayOfYear" });
        return sI(I, B.length);
      },
      E: function (A, B, Q) {
        let I = A.getDay();
        switch (B) {
          case "E":
          case "EE":
          case "EEE":
            return Q.day(I, { width: "abbreviated", context: "formatting" });
          case "EEEEE":
            return Q.day(I, { width: "narrow", context: "formatting" });
          case "EEEEEE":
            return Q.day(I, { width: "short", context: "formatting" });
          case "EEEE":
          default:
            return Q.day(I, { width: "wide", context: "formatting" });
        }
      },
      e: function (A, B, Q, I) {
        let G = A.getDay(),
          Z = (G - I.weekStartsOn + 8) % 7 || 7;
        switch (B) {
          case "e":
            return String(Z);
          case "ee":
            return sI(Z, 2);
          case "eo":
            return Q.ordinalNumber(Z, { unit: "day" });
          case "eee":
            return Q.day(G, { width: "abbreviated", context: "formatting" });
          case "eeeee":
            return Q.day(G, { width: "narrow", context: "formatting" });
          case "eeeeee":
            return Q.day(G, { width: "short", context: "formatting" });
          case "eeee":
          default:
            return Q.day(G, { width: "wide", context: "formatting" });
        }
      },
      c: function (A, B, Q, I) {
        let G = A.getDay(),
          Z = (G - I.weekStartsOn + 8) % 7 || 7;
        switch (B) {
          case "c":
            return String(Z);
          case "cc":
            return sI(Z, B.length);
          case "co":
            return Q.ordinalNumber(Z, { unit: "day" });
          case "ccc":
            return Q.day(G, { width: "abbreviated", context: "standalone" });
          case "ccccc":
            return Q.day(G, { width: "narrow", context: "standalone" });
          case "cccccc":
            return Q.day(G, { width: "short", context: "standalone" });
          case "cccc":
          default:
            return Q.day(G, { width: "wide", context: "standalone" });
        }
      },
      i: function (A, B, Q) {
        let I = A.getDay(),
          G = I === 0 ? 7 : I;
        switch (B) {
          case "i":
            return String(G);
          case "ii":
            return sI(G, B.length);
          case "io":
            return Q.ordinalNumber(G, { unit: "day" });
          case "iii":
            return Q.day(I, { width: "abbreviated", context: "formatting" });
          case "iiiii":
            return Q.day(I, { width: "narrow", context: "formatting" });
          case "iiiiii":
            return Q.day(I, { width: "short", context: "formatting" });
          case "iiii":
          default:
            return Q.day(I, { width: "wide", context: "formatting" });
        }
      },
      a: function (A, B, Q) {
        let G = A.getHours() / 12 >= 1 ? "pm" : "am";
        switch (B) {
          case "a":
          case "aa":
            return Q.dayPeriod(G, {
              width: "abbreviated",
              context: "formatting",
            });
          case "aaa":
            return Q.dayPeriod(G, {
              width: "abbreviated",
              context: "formatting",
            }).toLowerCase();
          case "aaaaa":
            return Q.dayPeriod(G, { width: "narrow", context: "formatting" });
          case "aaaa":
          default:
            return Q.dayPeriod(G, { width: "wide", context: "formatting" });
        }
      },
      b: function (A, B, Q) {
        let I = A.getHours(),
          G;
        if (I === 12) G = C7A.noon;
        else if (I === 0) G = C7A.midnight;
        else G = I / 12 >= 1 ? "pm" : "am";
        switch (B) {
          case "b":
          case "bb":
            return Q.dayPeriod(G, {
              width: "abbreviated",
              context: "formatting",
            });
          case "bbb":
            return Q.dayPeriod(G, {
              width: "abbreviated",
              context: "formatting",
            }).toLowerCase();
          case "bbbbb":
            return Q.dayPeriod(G, { width: "narrow", context: "formatting" });
          case "bbbb":
          default:
            return Q.dayPeriod(G, { width: "wide", context: "formatting" });
        }
      },
      B: function (A, B, Q) {
        let I = A.getHours(),
          G;
        if (I >= 17) G = C7A.evening;
        else if (I >= 12) G = C7A.afternoon;
        else if (I >= 4) G = C7A.morning;
        else G = C7A.night;
        switch (B) {
          case "B":
          case "BB":
          case "BBB":
            return Q.dayPeriod(G, {
              width: "abbreviated",
              context: "formatting",
            });
          case "BBBBB":
            return Q.dayPeriod(G, { width: "narrow", context: "formatting" });
          case "BBBB":
          default:
            return Q.dayPeriod(G, { width: "wide", context: "formatting" });
        }
      },
      h: function (A, B, Q) {
        if (B === "ho") {
          let I = A.getHours() % 12;
          if (I === 0) I = 12;
          return Q.ordinalNumber(I, { unit: "hour" });
        }
        return Ub.h(A, B);
      },
      H: function (A, B, Q) {
        if (B === "Ho") return Q.ordinalNumber(A.getHours(), { unit: "hour" });
        return Ub.H(A, B);
      },
      K: function (A, B, Q) {
        let I = A.getHours() % 12;
        if (B === "Ko") return Q.ordinalNumber(I, { unit: "hour" });
        return sI(I, B.length);
      },
      k: function (A, B, Q) {
        let I = A.getHours();
        if (I === 0) I = 24;
        if (B === "ko") return Q.ordinalNumber(I, { unit: "hour" });
        return sI(I, B.length);
      },
      m: function (A, B, Q) {
        if (B === "mo")
          return Q.ordinalNumber(A.getMinutes(), { unit: "minute" });
        return Ub.m(A, B);
      },
      s: function (A, B, Q) {
        if (B === "so")
          return Q.ordinalNumber(A.getSeconds(), { unit: "second" });
        return Ub.s(A, B);
      },
      S: function (A, B) {
        return Ub.S(A, B);
      },
      X: function (A, B, Q) {
        let I = A.getTimezoneOffset();
        if (I === 0) return "Z";
        switch (B) {
          case "X":
            return $_2(I);
          case "XXXX":
          case "XX":
            return It(I);
          case "XXXXX":
          case "XXX":
          default:
            return It(I, ":");
        }
      },
      x: function (A, B, Q) {
        let I = A.getTimezoneOffset();
        switch (B) {
          case "x":
            return $_2(I);
          case "xxxx":
          case "xx":
            return It(I);
          case "xxxxx":
          case "xxx":
          default:
            return It(I, ":");
        }
      },
      O: function (A, B, Q) {
        let I = A.getTimezoneOffset();
        switch (B) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + w_2(I, ":");
          case "OOOO":
          default:
            return "GMT" + It(I, ":");
        }
      },
      z: function (A, B, Q) {
        let I = A.getTimezoneOffset();
        switch (B) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + w_2(I, ":");
          case "zzzz":
          default:
            return "GMT" + It(I, ":");
        }
      },
      t: function (A, B, Q) {
        let I = Math.trunc(+A / 1000);
        return sI(I, B.length);
      },
      T: function (A, B, Q) {
        return sI(+A, B.length);
      },
    }));
});
var N_2 = (A, B) => {
    switch (A) {
      case "P":
        return B.date({ width: "short" });
      case "PP":
        return B.date({ width: "medium" });
      case "PPP":
        return B.date({ width: "long" });
      case "PPPP":
      default:
        return B.date({ width: "full" });
    }
  },
  L_2 = (A, B) => {
    switch (A) {
      case "p":
        return B.time({ width: "short" });
      case "pp":
        return B.time({ width: "medium" });
      case "ppp":
        return B.time({ width: "long" });
      case "pppp":
      default:
        return B.time({ width: "full" });
    }
  },
  fa5 = (A, B) => {
    let Q = A.match(/(P+)(p+)?/) || [],
      I = Q[1],
      G = Q[2];
    if (!G) return N_2(A, B);
    let Z;
    switch (I) {
      case "P":
        Z = B.dateTime({ width: "short" });
        break;
      case "PP":
        Z = B.dateTime({ width: "medium" });
        break;
      case "PPP":
        Z = B.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        Z = B.dateTime({ width: "full" });
        break;
    }
    return Z.replace("{{date}}", N_2(I, B)).replace("{{time}}", L_2(G, B));
  },
  M_2;
var O_2 = T(() => {
  M_2 = { p: L_2, P: fa5 };
});
function R_2(A) {
  return ha5.test(A);
}
function T_2(A) {
  return ga5.test(A);
}
function P_2(A, B, Q) {
  let I = ma5(A, B, Q);
  if ((console.warn(I), ua5.includes(A))) throw RangeError(I);
}
function ma5(A, B, Q) {
  let I = A[0] === "Y" ? "years" : "days of the month";
  return `Use \`${A.toLowerCase()}\` instead of \`${A}\` (in \`${B}\`) for formatting ${I} to the input \`${Q}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
var ha5, ga5, ua5;
var j_2 = T(() => {
  ((ha5 = /^D+$/), (ga5 = /^Y+$/), (ua5 = ["D", "DD", "YY", "YYYY"]));
});
function S_2(A, B, Q) {
  let I = rc(),
    G = Q?.locale ?? I.locale ?? AA0,
    Z =
      Q?.firstWeekContainsDate ??
      Q?.locale?.options?.firstWeekContainsDate ??
      I.firstWeekContainsDate ??
      I.locale?.options?.firstWeekContainsDate ??
      1,
    Y =
      Q?.weekStartsOn ??
      Q?.locale?.options?.weekStartsOn ??
      I.weekStartsOn ??
      I.locale?.options?.weekStartsOn ??
      0,
    J = gY(A, Q?.in);
  if (!Jk2(J)) throw RangeError("Invalid time value");
  let X = B.match(ca5)
    .map((F) => {
      let C = F[0];
      if (C === "p" || C === "P") {
        let V = M_2[C];
        return V(F, G.formatLong);
      }
      return F;
    })
    .join("")
    .match(da5)
    .map((F) => {
      if (F === "''") return { isToken: !1, value: "'" };
      let C = F[0];
      if (C === "'") return { isToken: !1, value: na5(F) };
      if (ZA0[C]) return { isToken: !0, value: F };
      if (C.match(ia5))
        throw RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            C +
            "`",
        );
      return { isToken: !1, value: F };
    });
  if (G.localize.preprocessor) X = G.localize.preprocessor(J, X);
  let W = { firstWeekContainsDate: Z, weekStartsOn: Y, locale: G };
  return X.map((F) => {
    if (!F.isToken) return F.value;
    let C = F.value;
    if (
      (!Q?.useAdditionalWeekYearTokens && T_2(C)) ||
      (!Q?.useAdditionalDayOfYearTokens && R_2(C))
    )
      P_2(C, B, String(A));
    let V = ZA0[C[0]];
    return V(J, C, G.localize, W);
  }).join("");
}
function na5(A) {
  let B = A.match(pa5);
  if (!B) return A;
  return B[1].replace(la5, "'");
}
var da5, ca5, pa5, la5, ia5;
var y_2 = T(() => {
  K_2();
  Y$A();
  q_2();
  O_2();
  j_2();
  te1();
  cw();
  ((da5 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g),
    (ca5 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g),
    (pa5 = /^'([^]*?)'?$/),
    (la5 = /''/g),
    (ia5 = /[a-zA-Z]/));
});
var k_2 = () => {};
var __2 = () => {};
var x_2 = () => {};
var v_2 = () => {};
var b_2 = () => {};
var f_2 = () => {};
var h_2 = () => {};
var g_2 = () => {};
var u_2 = () => {};
var m_2 = () => {};
var d_2 = () => {};
var c_2 = () => {};
var p_2 = () => {};
var l_2 = () => {};
var i_2 = () => {};
var n_2 = () => {};
var a_2 = () => {};
var s_2 = () => {};
var r_2 = () => {};
var o_2 = () => {};
var t_2 = () => {};
var e_2 = () => {};
var Ax2 = () => {};
var Bx2 = () => {};
var Qx2 = () => {};
var Ix2 = () => {};
var Gx2 = () => {};
var Zx2 = () => {};
var Yx2 = () => {};
var Jx2 = () => {};
var Xx2 = () => {};
var Wx2 = () => {};
var Fx2 = () => {};
var Cx2 = () => {};
var Vx2 = () => {};
var Kx2 = () => {};
var Dx2 = () => {};
var Ex2 = () => {};
var Hx2 = () => {};
var zx2 = () => {};
var Ux2 = () => {};
var wx2 = () => {};
var $x2 = () => {};
var qx2 = () => {};
var Nx2 = () => {};
var Lx2 = () => {};
var Mx2 = () => {};
var Ox2 = () => {};
var Rx2 = () => {};
var Tx2 = () => {};
var Px2 = () => {};
var jx2 = () => {};
var Sx2 = () => {};
var yx2 = () => {};
var kx2 = () => {};
var _x2 = () => {};
var xx2 = () => {};
var vx2 = () => {};
var bx2 = () => {};
var fx2 = () => {};
var hx2 = () => {};
var gx2 = () => {};
var ux2 = () => {};
var mx2 = () => {};
var dx2 = () => {};
var cx2 = () => {};
var px2 = () => {};
var lx2 = () => {};
var ix2 = () => {};
var nx2 = () => {};
var ax2 = () => {};
var sx2 = () => {};
var rx2 = () => {};
var ox2 = () => {};
var tx2 = () => {};
var ex2 = () => {};
var Av2 = () => {};
var Bv2 = () => {};
var Qv2 = () => {};
var Iv2 = () => {};
var Gv2 = () => {};
var Zv2 = () => {};
var Yv2 = () => {};
var Jv2 = () => {};
var Xv2 = () => {};
var Wv2 = () => {};
var Fv2 = () => {};
var Cv2 = () => {};
var Vv2 = () => {};
var Kv2 = () => {};
var Dv2 = () => {};
var Ev2 = () => {};
var Hv2 = () => {};
var zv2 = () => {};
var Uv2 = () => {};
var wv2 = () => {};
var $v2 = () => {};
var qv2 = () => {};
var Nv2 = () => {};
var Lv2 = () => {};
var Mv2 = () => {};
var Ov2 = () => {};
var Rv2 = () => {};
var Tv2 = () => {};
var Pv2 = () => {};
var jv2 = () => {};
var Sv2 = () => {};
var yv2 = () => {};
var kv2 = () => {};
var _v2 = () => {};
var xv2 = () => {};
var vv2 = () => {};
var bv2 = () => {};
var fv2 = () => {};
var hv2 = () => {};
var gv2 = () => {};
var uv2 = () => {};
var mv2 = () => {};
var dv2 = () => {};
var cv2 = () => {};
var pv2 = () => {};
var lv2 = () => {};
var iv2 = () => {};
var nv2 = () => {};
var av2 = () => {};
var sv2 = () => {};
var rv2 = () => {};
var ov2 = () => {};
var tv2 = () => {};
var ev2 = () => {};
var Ab2 = () => {};
var Bb2 = () => {};
var Qb2 = () => {};
var Ib2 = () => {};
var Gb2 = () => {};
var Zb2 = () => {};
var Yb2 = () => {};
var Jb2 = () => {};
var Xb2 = () => {};
var Wb2 = () => {};
var Fb2 = () => {};
var Cb2 = () => {};
var Vb2 = () => {};
var Kb2 = () => {};
var Db2 = () => {};
var Eb2 = () => {};
var Hb2 = () => {};
var zb2 = () => {};
var Ub2 = () => {};
var wb2 = () => {};
var $b2 = () => {};
var qb2 = () => {};
var Nb2 = () => {};
var Lb2 = () => {};
var Mb2 = () => {};
var Ob2 = T(() => {
  Sy2();
  xy2();
  Py2();
  by2();
  cy2();
  vy2();
  py2();
  jy2();
  ly2();
  iy2();
  ny2();
  ay2();
  sy2();
  ty2();
  ey2();
  Ak2();
  Bk2();
  Qk2();
  sc();
  Ik2();
  Gk2();
  Xk2();
  se1();
  Wk2();
  Fk2();
  Ck2();
  Kk2();
  Dk2();
  Ek2();
  Hk2();
  zk2();
  wk2();
  $k2();
  qk2();
  Ok2();
  Rk2();
  Tk2();
  Pk2();
  jk2();
  Sk2();
  yk2();
  kk2();
  _k2();
  vk2();
  bk2();
  fk2();
  gk2();
  dk2();
  ck2();
  Nk2();
  pk2();
  lk2();
  nk2();
  ak2();
  sk2();
  Lk2();
  rk2();
  ok2();
  tk2();
  ek2();
  ik2();
  uk2();
  A_2();
  y_2();
  k_2();
  __2();
  x_2();
  v_2();
  b_2();
  f_2();
  h_2();
  g_2();
  u_2();
  m_2();
  d_2();
  c_2();
  p_2();
  l_2();
  BA0();
  i_2();
  a_2();
  s_2();
  r_2();
  o_2();
  t_2();
  QA0();
  $01();
  e_2();
  Ax2();
  Bx2();
  Qx2();
  Ix2();
  Vk2();
  Gx2();
  Zx2();
  Yx2();
  GA0();
  Jx2();
  L01();
  Wx2();
  Fx2();
  Cx2();
  Vx2();
  Kx2();
  Dx2();
  Ex2();
  Hx2();
  zx2();
  Ux2();
  wx2();
  oe1();
  $x2();
  qx2();
  Nx2();
  Lx2();
  Mx2();
  Mk2();
  n_2();
  yx2();
  kx2();
  _x2();
  Zk2();
  vx2();
  fx2();
  hx2();
  ux2();
  mx2();
  dx2();
  px2();
  bx2();
  lx2();
  yy2();
  ky2();
  ix2();
  nx2();
  ax2();
  sx2();
  rx2();
  ox2();
  tx2();
  ex2();
  Av2();
  Bv2();
  Qv2();
  Iv2();
  te1();
  Gv2();
  _y2();
  Zv2();
  Jv2();
  Xv2();
  Fv2();
  Cv2();
  Xx2();
  Vv2();
  Wv2();
  Kv2();
  Dv2();
  ry2();
  Ev2();
  Hv2();
  zv2();
  Uv2();
  oy2();
  wv2();
  $v2();
  qv2();
  Nv2();
  Lv2();
  Mv2();
  Ov2();
  Rv2();
  Tv2();
  Pv2();
  jv2();
  Sv2();
  yv2();
  Sx2();
  kv2();
  _v2();
  xv2();
  vv2();
  bv2();
  fv2();
  hv2();
  gv2();
  uv2();
  mv2();
  dv2();
  cv2();
  pv2();
  lv2();
  iv2();
  nv2();
  av2();
  rv2();
  ov2();
  Px2();
  tv2();
  ev2();
  Ab2();
  jx2();
  Tx2();
  dy2();
  Bb2();
  Qb2();
  sv2();
  Ib2();
  Gb2();
  Rx2();
  Zb2();
  Yb2();
  ae1();
  Jb2();
  xx2();
  J$A();
  re1();
  gx2();
  hk2();
  xk2();
  cx2();
  Xb2();
  Wb2();
  X7A();
  IA0();
  ee1();
  Fb2();
  Vb2();
  Kb2();
  Yv2();
  Db2();
  Uk2();
  Eb2();
  Hb2();
  Cb2();
  zb2();
  Ub2();
  wb2();
  $b2();
  cw();
  Ox2();
  qb2();
  Nb2();
  Lb2();
  Mb2();
});
function Rb2() {
  let [A, B] = X$A.useState([]),
    [Q, I] = X$A.useState(0);
  if (
    (X$A.useEffect(() => {
      let G = VQ.getSandboxViolationStore();
      return G.subscribe((Y) => {
        (B(Y.slice(-10)), I(G.getTotalCount()));
      });
    }, []),
    !VQ.isSandboxingEnabled() || EB() === "linux")
  )
    return null;
  if (Q === 0) return null;
  return VE.createElement(
    S,
    { flexDirection: "column", marginTop: 1 },
    VE.createElement(
      S,
      { marginLeft: 0 },
      VE.createElement(
        U,
        { color: "permission" },
        " Sandbox blocked ",
        Q,
        " total",
        " ",
        Q === 1 ? "operation" : "operations",
      ),
    ),
    A.map((G, Z) =>
      VE.createElement(
        S,
        { key: `${G.timestamp.getTime()}-${Z}`, paddingLeft: 2 },
        VE.createElement(
          U,
          { dimColor: !0 },
          S_2(G.timestamp, "h:mm:ssa"),
          G.command ? ` ${G.command}:` : "",
          " ",
          G.line,
        ),
      ),
    ),
    VE.createElement(
      S,
      { paddingLeft: 2 },
      VE.createElement(
        U,
        { dimColor: !0 },
        " showing last ",
        Math.min(10, A.length),
        " of ",
        Q,
      ),
    ),
  );
}
var VE, X$A;
var Tb2 = T(() => {
  nA();
  VW();
  Ob2();
  E5();
  ((VE = IA(KA(), 1)), (X$A = IA(KA(), 1)));
});
function M01() {
  let { addNotification: A } = f7(),
    [B, Q] = V7A.useState(() => {
      let { errors: G } = oc();
      return G;
    }),
    I = V7A.useCallback(() => {
      let { errors: G } = oc();
      Q(G);
    }, []);
  return (
    b0A(I),
    V7A.useEffect(() => {
      if (B.length > 0)
        A({
          key: "settings-errors",
          jsx: YA0.createElement(
            U,
            { dimColor: !0 },
            "Found ",
            B.length,
            " invalid settings",
            " ",
            B.length === 1 ? "file" : "files",
            "  /doctor for details",
          ),
          priority: "high",
        });
    }, [B, A]),
    B
  );
}
var V7A, YA0;
var JA0 = T(() => {
  OQ();
  fjA();
  _H();
  nA();
  ((V7A = IA(KA(), 1)), (YA0 = IA(KA(), 1)));
});
function jb2({ mcpClients: A = [] }) {
  let { addNotification: B } = f7();
  Pb2.useEffect(() => {
    let Q = A.filter(
        (G) =>
          G.type === "failed" &&
          G.config.type !== "sse-ide" &&
          G.config.type !== "ws-ide",
      ),
      I = A.filter((G) => G.type === "needs-auth");
    if (Q.length === 0 && I.length === 0) return;
    if (Q.length > 0)
      B({
        key: "mcp-failed",
        jsx: rF.createElement(
          rF.Fragment,
          null,
          rF.createElement(
            U,
            { color: "error" },
            Q.length,
            " MCP",
            " ",
            Q.length === 1 ? "server" : "servers",
            " failed",
          ),
          rF.createElement(U, { dimColor: !0 }, "  /mcp for info"),
        ),
        priority: "medium",
      });
    if (I.length)
      B({
        key: "mcp-needs-auth",
        jsx: rF.createElement(
          rF.Fragment,
          null,
          rF.createElement(
            U,
            { color: "warning" },
            I.length,
            " MCP",
            " ",
            I.length === 1 ? "server needs" : "servers need",
            " ",
            "auth",
          ),
          rF.createElement(U, { dimColor: !0 }, "  /mcp for info"),
        ),
        priority: "medium",
      });
  }, [B, A]);
}
var rF, Pb2;
var Sb2 = T(() => {
  nA();
  _H();
  ((rF = IA(KA(), 1)), (Pb2 = IA(KA(), 1)));
});
function yb2() {
  let { addNotification: A } = f7(),
    [B] = lB(),
    { installationStatus: Q } = B.plugins,
    {
      totalFailed: I,
      failedMarketplacesCount: G,
      failedPluginsCount: Z,
    } = O01.useMemo(() => {
      if (!Q)
        return {
          totalFailed: 0,
          failedMarketplacesCount: 0,
          failedPluginsCount: 0,
        };
      let Y = Q.marketplaces.filter((X) => X.status === "failed"),
        J = Q.plugins.filter((X) => X.status === "failed");
      return {
        totalFailed: Y.length + J.length,
        failedMarketplacesCount: Y.length,
        failedPluginsCount: J.length,
      };
    }, [Q]);
  O01.useEffect(() => {
    if (!Q) {
      g("No installation status to monitor");
      return;
    }
    if (I === 0) return;
    if (
      (g(
        `Plugin installation status: ${G} failed marketplaces, ${Z} failed plugins`,
      ),
      I === 0)
    )
      return;
    (g(`Adding notification for ${I} failed installations`),
      A({
        key: "plugin-install-failed",
        jsx: Fy.createElement(
          Fy.Fragment,
          null,
          Fy.createElement(
            U,
            { color: "error" },
            I,
            " plugin",
            I === 1 ? "" : "s",
            " failed to install",
          ),
          Fy.createElement(U, { dimColor: !0 }, "  /plugin for details"),
        ),
        priority: "medium",
      }));
  }, [A, I, G, Z]);
}
var Fy, O01;
var kb2 = T(() => {
  nA();
  _H();
  c9();
  C0();
  ((Fy = IA(KA(), 1)), (O01 = IA(KA(), 1)));
});
function xb2() {
  let [{ checkpointing: A }] = lB(),
    B =
      A?.status === "error"
        ? "Checkpointing disabled"
        : A?.status === "initialized" && A?.saveError
          ? "Checkpointing failed"
          : void 0,
    { addNotification: Q } = f7();
  _b2.useEffect(() => {
    return;
  }, [Q, B]);
}
var Gt, _b2;
var vb2 = T(() => {
  _H();
  nA();
  s2();
  c9();
  ((Gt = IA(KA(), 1)), (_b2 = IA(KA(), 1)));
});
async function bb2() {
  let A = N0(),
    B = new Map();
  if (A.extraKnownMarketplaces)
    for (let [Q, I] of Object.entries(A.extraKnownMarketplaces)) B.set(Q, I);
  return B;
}
async function fb2(A) {
  try {
    let B = await PY(),
      Q = [];
    for (let [I] of A) if (!B[I]) Q.push(I);
    return Q;
  } catch (B) {
    return (BA(B instanceof Error ? B : Error(String(B)), IH), []);
  }
}
var hb2 = T(() => {
  OQ();
  pD();
  c1();
});
import { join as W$A } from "path";
function ub2() {
  return W$A(mB(), "plugins", aa5);
}
function K7A() {
  if (Cy !== null) return Cy.plugins;
  let A = NA(),
    B = ub2();
  try {
    if (!A.existsSync(B))
      return (
        g(
          `installed_plugins.json doesn't exist yet at ${B}, returning empty object`,
        ),
        (Cy = { version: EL, plugins: {} }),
        Cy.plugins
      );
    let Q = A.readFileSync(B, { encoding: "utf-8" }),
      I = JSON.parse(Q),
      G = d$Q.parse(I);
    if (G.version !== EL)
      g(
        `installed_plugins.json schema version ${G.version} doesn't match current version ${EL}, will update on next sync`,
      );
    return (
      (Cy = G),
      g(
        `Loaded ${Object.keys(G.plugins).length} installed plugins from ${B} (schema version ${G.version})`,
      ),
      G.plugins
    );
  } catch (Q) {
    let I = Q instanceof Error ? Q.message : String(Q);
    return (
      g(
        `Failed to load installed_plugins.json: ${I}. Starting with empty state.`,
        { level: "error" },
      ),
      BA(
        Q instanceof Error
          ? Q
          : Error(`Failed to load installed_plugins.json: ${I}`),
        lV,
      ),
      (Cy = { version: EL, plugins: {} }),
      Cy.plugins
    );
  }
}
function XA0(A) {
  let B = NA(),
    Q = ub2();
  try {
    let I = W$A(mB(), "plugins");
    if (!B.existsSync(I)) B.mkdirSync(I);
    let G = { version: EL, plugins: A },
      Z = JSON.stringify(G, null, 2);
    (B.writeFileSync(Q, Z, { encoding: "utf-8", flush: !0 }),
      (Cy = G),
      g(
        `Saved ${Object.keys(A).length} installed plugins to ${Q} (schema version ${EL})`,
      ));
  } catch (I) {
    let G = I instanceof Error ? I.message : String(I);
    throw (
      BA(
        I instanceof Error
          ? I
          : Error(`Failed to save installed_plugins.json: ${G}`),
        lV,
      ),
      I
    );
  }
}
function sa5(A) {
  return K7A()[A];
}
function Zt(A) {
  return sa5(A) !== void 0;
}
function mb2(A, B) {
  let Q = K7A(),
    I = A in Q;
  ((Q[A] = B), XA0(Q), g(`${I ? "Updated" : "Added"} installed plugin: ${A}`));
}
function db2(A) {
  let B = K7A(),
    Q = B[A];
  if (Q) (delete B[A], XA0(B), g(`Removed installed plugin: ${A}`));
  return Q;
}
function cb2(A) {
  let B = NA();
  try {
    if (B.existsSync(A))
      (B.rmSync(A, { recursive: !0, force: !0 }),
        g(`Deleted plugin cache at ${A}`));
    else g(`Plugin cache at ${A} doesn't exist, skipping deletion`);
  } catch (Q) {
    let I = Q instanceof Error ? Q.message : String(Q);
    throw (
      BA(
        Q instanceof Error ? Q : Error(`Failed to delete plugin cache: ${I}`),
        Tl,
      ),
      Error(`Failed to delete plugin cache at ${A}: ${I}`)
    );
  }
}
function ra5(A, B) {
  if (Object.keys(A).length === 0) return !0;
  if (B === EL && Cy !== null) return !0;
  return !1;
}
function oa5(A, B) {
  if (!A.includes("@")) return !1;
  if (A in B)
    return (g(`Plugin ${A} already in installed_plugins.json, skipping`), !1);
  return !0;
}
async function R01(A) {
  try {
    let B = await r0("git", ["-C", A, "rev-parse", "HEAD"]);
    if (B.code === 0 && B.stdout) return B.stdout.trim();
    return;
  } catch (B) {
    g(`Failed to get git commit SHA from ${A}: ${B}`);
    return;
  }
}
function gb2(A, B) {
  let Q = NA(),
    I = W$A(A, ".claude-plugin", "plugin.json");
  if (!Q.existsSync(I)) return "unknown";
  try {
    let G = Q.readFileSync(I, { encoding: "utf-8" });
    return JSON.parse(G).version || "unknown";
  } catch {
    return (g(`Could not read version from manifest for ${B}`), "unknown");
  }
}
async function pb2() {
  let B = N0().enabledPlugins || {},
    Q = Cy || { version: 0, plugins: {} };
  if (ra5(B, Q.version)) return;
  if (Q.version !== EL)
    g(
      `Schema version mismatch (current: ${Q.version}, expected: ${EL}), syncing installed_plugins.json`,
    );
  else g("Syncing installed_plugins.json with enabledPlugins from settings");
  let I = NA(),
    G = K7A(),
    Z = new Date().toISOString(),
    Y = 0,
    J = 0;
  for (let [X] of Object.entries(B)) {
    if (!oa5(X, G)) {
      J++;
      continue;
    }
    let W = X.split("@"),
      F = W[0];
    if (!F || W.length !== 2) {
      (g(`Invalid plugin ID format: ${X}, skipping migration`), J++);
      continue;
    }
    try {
      let C,
        V = "unknown",
        K = void 0,
        D = !1;
      try {
        let E = await Om(X);
        if (!E) {
          (g(`Plugin ${X} not found in any marketplace, skipping`), J++);
          continue;
        }
        let { entry: H, marketplaceInstallLocation: w } = E;
        if (typeof H.source === "string")
          ((D = !0),
            (C = W$A(w, H.source)),
            (V = gb2(C, X)),
            (K = await R01(C)));
        else {
          let L = fDA(),
            N = F.replace(/[^a-zA-Z0-9-_]/g, "-"),
            $ = W$A(L, N);
          if (!I.existsSync($)) {
            (g(`External plugin ${X} not in cache, skipping`), J++);
            continue;
          }
          ((C = $), (V = gb2($, X)), (K = await R01($)));
        }
      } catch (E) {
        (g(`Failed to get plugin info for ${X}: ${E}, skipping`), J++);
        continue;
      }
      ((G[X] = {
        version: V,
        installedAt: Z,
        lastUpdated: Z,
        installPath: C,
        gitCommitSha: K,
        isLocal: D,
      }),
        Y++,
        g(`Added ${X} to installed_plugins.json`));
    } catch (C) {
      let V = C instanceof Error ? C.message : String(C);
      (g(`Failed to migrate plugin ${X}: ${V}`, { level: "warn" }), J++);
    }
  }
  if (Y > 0 || Q.version !== EL)
    if ((XA0(G), Q.version !== EL))
      g(
        `Updated installed_plugins.json to schema version ${EL} (${Y} plugins added, ${J} skipped)`,
      );
    else
      g(
        `Sync completed: ${Y} plugins added to installed_plugins.json, ${J} skipped`,
      );
  else if (J > 0)
    g(`Sync completed: All ${J} plugins already in installed_plugins.json`);
}
var aa5 = "installed_plugins.json",
  EL = 1,
  Cy = null;
var F$A = T(() => {
  m0();
  C0();
  c1();
  vB();
  Ks();
  OQ();
  NF();
  Q5();
  pD();
});
function ta5() {
  return new Date().toISOString();
}
async function yR(A, B) {
  if (typeof B.source === "string")
    throw Error(
      "cacheAndRegisterPlugin should only be used for external plugins",
    );
  let Q = await hDA(B.source, { manifest: B }),
    I = await R01(Q.path),
    G = ta5();
  return (
    mb2(A, {
      version: Q.manifest.version || B.version || "unknown",
      installedAt: G,
      lastUpdated: G,
      installPath: Q.path,
      gitCommitSha: I,
      isLocal: !1,
    }),
    Q.path
  );
}
var C$A = T(() => {
  F$A();
  NF();
});
async function WA0() {
  let A = N0(),
    B = [];
  if (A.enabledPlugins) {
    for (let [Q, I] of Object.entries(A.enabledPlugins))
      if (Q.includes("@") && I) B.push(Q);
  }
  return B;
}
async function FA0() {
  pb2().catch((Q) => {
    BA(Q instanceof Error ? Q : Error(String(Q)), lV);
  });
  let A = K7A(),
    B = Object.keys(A);
  return (g(`Found ${B.length} installed plugins`), B);
}
async function lb2(A) {
  try {
    let B = await FA0(),
      Q = [];
    for (let I of A)
      if (!B.includes(I))
        try {
          if (await Om(I)) Q.push(I);
        } catch (G) {
          g(`Failed to check plugin ${I} in marketplace: ${G}`);
        }
    return Q;
  } catch (B) {
    return (BA(B instanceof Error ? B : Error(String(B)), lV), []);
  }
}
var ib2 = T(() => {
  OQ();
  pD();
  c1();
  C0();
  NF();
  OQ();
  m0();
  C$A();
  F$A();
});
function CA0(A, B, Q, I) {
  A((G) => ({
    ...G,
    plugins: {
      ...G.plugins,
      installationStatus: {
        ...G.plugins.installationStatus,
        marketplaces: G.plugins.installationStatus.marketplaces.map((Z) =>
          Z.name === B ? { ...Z, status: Q, error: I } : Z,
        ),
      },
    },
  }));
}
function VA0(A, B, Q, I) {
  A((G) => ({
    ...G,
    plugins: {
      ...G.plugins,
      installationStatus: {
        ...G.plugins.installationStatus,
        plugins: G.plugins.installationStatus.plugins.map((Z) =>
          Z.id === B ? { ...Z, status: Q, error: I } : Z,
        ),
      },
    },
  }));
}
async function ea5(A, B, Q) {
  let I = [],
    G = [];
  for (let Z of A) {
    let Y = B.get(Z);
    if (!Y) continue;
    CA0(Q, Z, "installing");
    try {
      (await Ds(Y.source),
        I.push(Z),
        CA0(Q, Z, "installed"),
        n$Q(),
        XiA(),
        await As5(Z, Q));
    } catch (J) {
      let X = J instanceof Error ? J.message : String(J);
      (G.push({ name: Z, error: X }),
        CA0(Q, Z, "failed", X),
        BA(J instanceof Error ? J : Error(String(J)), IH));
    }
  }
  return { installed: I, failed: G };
}
async function As5(A, B) {
  try {
    let I = (await WA0()).filter((G) => G.endsWith(`@${A}`));
    if (I.length > 0) {
      let G = await lb2(I);
      if (G.length > 0)
        (g(
          `Installing ${G.length} plugins from newly installed marketplace ${A}`,
        ),
          await nb2(G, B));
    }
  } catch (Q) {
    BA(Q instanceof Error ? Q : Error(String(Q)), lV);
  }
}
async function nb2(A, B) {
  let I = { ...cQ("userSettings")?.enabledPlugins },
    G = [],
    Z = [];
  for (let Y of A) {
    VA0(B, Y, "installing");
    try {
      let J = await Om(Y);
      if (!J) throw Error("Plugin not found in any marketplace");
      let { entry: X } = J;
      if (typeof X.source !== "string" || !X.source.startsWith("./"))
        await yR(Y, X);
      if (N0().enabledPlugins?.[Y] !== !0) I[Y] = !0;
      (G.push(Y), VA0(B, Y, "installed"));
    } catch (J) {
      let X = J instanceof Error ? J.message : String(J);
      (Z.push({ name: Y, error: X }),
        VA0(B, Y, "failed", X),
        BA(J instanceof Error ? J : Error(String(J)), lV));
    }
  }
  if (Object.keys(I).length > 0) {
    let Y = cQ("userSettings");
    B2("userSettings", { ...Y, enabledPlugins: I });
  }
  return { installed: G, failed: Z };
}
async function T01(A) {
  g("performBackgroundPluginInstallations called");
  try {
    let B = [],
      Q = [],
      I = await PY(),
      G = await bb2();
    if (G.size > 0) {
      g(`Found ${G.size} extra marketplaces in settings`);
      let J = await fb2(G);
      if (J.length > 0) {
        g(`Installing ${J.length} marketplaces automatically`);
        for (let X of J) {
          let W = G.get(X);
          if (W) B.push({ name: X, marketplace: W });
        }
      }
    }
    let Z = await WA0(),
      Y = [];
    if (Z.length > 0) {
      g(`Found ${Z.length} enabled plugins`);
      let J = await FA0(),
        X = Z.filter((F) => !J.includes(F));
      g(`Found ${X.length} missing plugins (not installed): ${X.join(", ")}`);
      let W = [];
      for (let F of X) {
        let [, C] = F.split("@");
        if (!C) W.push(F);
        else if (C in I || G.has(C) || B.some((V) => V.name === C)) W.push(F);
        else Y.push(F);
      }
      if (Y.length > 0) {
        let F = [...new Set(Y.map((C) => C.split("@")[1]))];
        (g(
          `Cannot install ${Y.length} plugins because their marketplaces are not installed or configured: ${F.join(", ")}`,
        ),
          g(`Uninstallable plugins: ${Y.join(", ")}`));
      }
      if (W.length > 0)
        (g(`Installing ${W.length} plugins automatically`), Q.push(...W));
    }
    if (
      (g(
        `Setting installation status: ${B.length} marketplaces, ${Q.length} installable plugins, ${Y.length} uninstallable plugins`,
      ),
      A((J) => ({
        ...J,
        plugins: {
          ...J.plugins,
          installationStatus: {
            marketplaces: B.map(({ name: X }) => ({
              name: X,
              status: "pending",
            })),
            plugins: [
              ...Q.map((X) => {
                let [W] = X.split("@");
                return { id: X, name: W || X, status: "pending" };
              }),
              ...Y.map((X) => {
                let [W, F] = X.split("@");
                return {
                  id: X,
                  name: W || X,
                  status: "failed",
                  error: `Marketplace '${F}' is not installed or configured`,
                };
              }),
            ],
          },
        },
      })),
      B.length > 0)
    )
      ea5(
        B.map((J) => J.name),
        G,
        A,
      ).catch((J) => {
        BA(J instanceof Error ? J : Error(String(J)), IH);
      });
    if (Q.length > 0) {
      let J = Q.filter((X) => {
        let [, W] = X.split("@");
        return !B.some((F) => F.name === W);
      });
      if (J.length > 0)
        nb2(J, A).catch((X) => {
          BA(X instanceof Error ? X : Error(String(X)), lV);
        });
    }
  } catch (B) {
    BA(B instanceof Error ? B : Error(String(B)), lV);
  }
}
var KA0 = T(() => {
  C0();
  c1();
  hb2();
  ib2();
  pD();
  pD();
  NF();
  C$A();
  OQ();
});
async function ab2(A) {
  if ((g("performStartupChecks called"), !fX(!0))) {
    g(
      "Trust not accepted for current directory - skipping plugin installations",
    );
    return;
  }
  try {
    (g("Starting background plugin installations"), await T01(A));
  } catch (B) {
    g(`Error initiating background plugin installations: ${B}`);
  }
}
var sb2 = T(() => {
  C0();
  KA0();
  kB();
});
function ob2() {
  let { addNotification: A } = f7(),
    [{ thinkingEnabled: B }] = lB();
  rb2.useEffect(() => {
    A({
      key: "toggled-thinking-initial",
      jsx: B
        ? V$A.createElement(
            U,
            { color: "suggestion" },
            "Thinking on (tab to toggle)",
          )
        : V$A.createElement(
            U,
            { dimColor: !0 },
            "Thinking off (tab to toggle)",
          ),
      priority: "low",
      timeoutMs: 60000,
    });
  }, [A]);
}
var V$A, rb2;
var tb2 = T(() => {
  _H();
  nA();
  c9();
  ((V$A = IA(KA(), 1)), (rb2 = IA(KA(), 1)));
});
function Af2({ ideSelection: A, mcpClients: B, ideInstallationStatus: Q }) {
  let { addNotification: I } = f7(),
    G = _IA(B),
    Z = Q ? UN(Q?.ideType) : !1,
    Y = Q?.error || Z,
    J = G === "connected" && (A?.filePath || (A?.text && A.lineCount > 0)),
    X = G === "connected" && !J,
    W = Y && !Z && !X && !J,
    F = Y && Z && !X && !J;
  eb2.useEffect(() => {
    if (UW() || G !== null) return;
    lDA(!0).then((C) => {
      if (C.length > 0) {
        let V = C[0]?.name;
        if (V && !F)
          I({
            key: "ide-status-hint",
            jsx: kR.createElement(
              U,
              { dimColor: !0 },
              E1.circle,
              " /ide for ",
              Bs5(V),
            ),
            priority: "low",
          });
        else if (!W && G === "disconnected")
          I({
            key: "ide-status-disconnected",
            jsx: kR.createElement(
              U,
              { color: "error", key: "ide-status" },
              E1.circle,
              " IDE disconnected",
            ),
            priority: "medium",
          });
        else if (F)
          I({
            key: "ide-status-jetbrains-disconnected",
            jsx: kR.createElement(
              U,
              { dimColor: !0 },
              "IDE plugin not connected  /status for info",
            ),
            priority: "medium",
          });
        else if (X)
          I({
            key: "ide-status-connected",
            jsx: kR.createElement(
              U,
              { color: "ide", key: "ide-status" },
              E1.circle,
              "IDE connected",
            ),
            priority: "low",
          });
        else if (W)
          I({
            key: "ide-status-install-error",
            jsx: kR.createElement(
              U,
              { color: "error" },
              "IDE extension install failed (see /status for info)",
            ),
            priority: "medium",
          });
      }
    });
  }, [I, G, X, W, F]);
}
function Bs5(A) {
  if (A === "Visual Studio Code") return "VS Code";
  return A;
}
var eb2, kR;
var Bf2 = T(() => {
  _H();
  zW();
  RtA();
  nA();
  s2();
  ((eb2 = IA(KA(), 1)), (kR = IA(KA(), 1)));
});
function If2() {
  let { addNotification: A } = f7();
  Qf2.useEffect(() => {
    let Q = L1().sonnet45MigrationTimestamp;
    if (Q) {
      if (Date.now() - Q < 3000)
        A({
          key: "sonnet-4.5-update",
          text: "Model updated to Sonnet 4.5",
          color: "suggestion",
          priority: "high",
          timeoutMs: 3000,
        });
    }
  }, [A]);
}
var Qf2;
var Gf2 = T(() => {
  _H();
  kB();
  Qf2 = IA(KA(), 1);
});
function Yf2() {
  let { addNotification: A } = f7();
  Zf2.useEffect(() => {
    if (L1().subscriptionNoticeCount ?? 0 >= Qs5) return;
    Is5().then((B) => {
      if (B === null) return;
      let Q = L1();
      (n0({
        ...Q,
        subscriptionNoticeCount: (Q.subscriptionNoticeCount ?? 0) + 1,
      }),
        GA("tengu_switch_to_subscription_notice_shown", {}),
        A({
          key: "switch-to-subscription",
          jsx: K$A.createElement(
            U,
            { color: "suggestion" },
            "Use your existing Claude ",
            B,
            " plan with Claude Code",
            K$A.createElement(
              U,
              { color: "text", dimColor: !0 },
              " ",
              " /login to activate",
            ),
          ),
          priority: "low",
        }));
    });
  }, [A]);
}
async function Is5() {
  if (nB()) return null;
  let A = await svA();
  if (!A) return null;
  if (A.account.has_claude_max) return "Max";
  if (A.account.has_claude_pro) return "Pro";
  return null;
}
var K$A,
  Zf2,
  Qs5 = 3;
var Jf2 = T(() => {
  nA();
  zFA();
  kB();
  H0();
  F2();
  _H();
  ((K$A = IA(KA(), 1)), (Zf2 = IA(KA(), 1)));
});
function Xf2({ onRun: A, onCancel: B, reason: Q }) {
  let I = D7A.useRef(!1);
  return (
    h1(
      D7A.useCallback(
        (G, Z) => {
          if (Z.escape) B();
        },
        [B],
      ),
    ),
    D7A.useEffect(() => {
      if (!I.current) ((I.current = !0), A());
    }, [A]),
    KE.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      KE.createElement(
        S,
        null,
        KE.createElement(
          U,
          { bold: !0 },
          "Running /issue to capture feedback...",
        ),
      ),
      KE.createElement(
        S,
        null,
        KE.createElement(U, { dimColor: !0 }, "Press Esc anytime to cancel"),
      ),
      KE.createElement(
        S,
        null,
        KE.createElement(U, { dimColor: !0 }, "Reason: ", Q),
      ),
    )
  );
}
function D$A(A) {
  return !1;
  switch (A) {
    case "feedback_survey_bad":
    case "400_tool_use_error":
      return !0;
    case "feedback_survey_good":
    default:
      return !1;
  }
}
function Wf2(A) {
  switch (A) {
    case "feedback_survey_bad":
      return 'You responded "Bad" to the feedback survey';
    case "feedback_survey_good":
      return 'You responded "Good" to the feedback survey';
    case "400_tool_use_error":
      return "A 400 tool use error occurred";
    default:
      return "Unknown reason";
  }
}
var KE, D7A;
var Ff2 = T(() => {
  nA();
  ((KE = IA(KA(), 1)), (D7A = IA(KA(), 1)));
});
import { randomUUID as DA0 } from "crypto";
function E7A({
  commands: A,
  debug: B,
  initialPrompt: Q,
  initialTools: I,
  initialMessages: G,
  initialCheckpoints: Z,
  initialFileHistorySnapshots: Y,
  mcpClients: J,
  dynamicMcpConfig: X,
  autoConnectIdeFlag: W,
  strictMcpConfig: F = !1,
  systemPrompt: C,
  appendSystemPrompt: V,
  onBeforeQuery: K,
  onTurnComplete: D,
  disabled: E = !1,
}) {
  let [H, w] = lB(),
    {
      toolPermissionContext: L,
      verbose: N,
      mcp: $,
      plugins: O,
      agentDefinitions: P,
    } = H,
    k = Jc(),
    b = VdA(),
    x = hB.useRef(H);
  x.current = H;
  let n = hB.useMemo(() => Yz(L), [L]);
  $y2();
  let [m, o] = hB.useState(X),
    l = hB.useCallback(
      (u0) => {
        o(u0);
      },
      [o],
    ),
    [y, c] = hB.useState("prompt"),
    [e, QA] = hB.useState(1),
    [WA, JA] = hB.useState(!1),
    { addNotification: wA } = f7(),
    xA = _j2(J, $.clients),
    [rA, qA] = hB.useState(void 0),
    [SA, zA] = hB.useState(null),
    [kA, sA] = hB.useState(null),
    [Z1, XA] = hB.useState(!1),
    [CA, UA] = hB.useState(!1);
  (If2(),
    Yf2(),
    xb2(),
    Af2({ ideSelection: rA, mcpClients: xA, ideInstallationStatus: kA }),
    jb2({ mcpClients: xA }),
    yb2(),
    M01(),
    ob2(),
    Fy2());
  let HA = hB.useMemo(() => {
    return [...n, ...I];
  }, [n, I]);
  (B01(),
    hB.useEffect(() => {
      ab2(w);
    }, [w]));
  let LA = o11(HA, $.tools),
    TA = Re1(A, O.commands),
    tA = Re1(TA, $.commands);
  (HoQ($.clients), gS2($.clients, qA));
  let [aA, W1] = hB.useState("responding"),
    [w1, OA] = hB.useState([]),
    [I1, i1] = hB.useState(null),
    [G1, e1] = hB.useState(!1),
    [_0, h0] = hB.useState(0),
    [a0, c0] = hB.useState(void 0),
    K0 = hB.useCallback(
      (u0) => {
        if ((e1(u0), u0)) h0(Date.now());
      },
      [h0],
    ),
    [F1, q1] = hB.useState(null);
  hB.useEffect(() => {
    if (F1?.notifications)
      F1.notifications.forEach((u0) => {
        wA({ key: "auto-updater-notification", text: u0, priority: "low" });
      });
  }, [F1, wA]);
  let [y1, g1] = hB.useState(null),
    [E0, U0] = hB.useState([]),
    [e0, VB] = hB.useState([]),
    [LB, YQ] = hB.useState(G ?? []),
    [R2, MB] = hB.useState([]),
    [C4, H8] = hB.useState(!1),
    [m8, j6] = hB.useState(""),
    [OI, AI] = hB.useState("prompt"),
    { queuedCommands: BG, queueManager: F3 } = aS2(),
    [j4, Q6] = hB.useState({}),
    [BI, R7] = hB.useState(0),
    [B1, yA] = hB.useState(0),
    [J1, p1] = hB.useState(0),
    [r1, JB] = hB.useState(null),
    [mQ, z9] = hB.useState(null),
    [V4, d8] = hB.useState(null),
    [U9, A8] = hB.useState(!1),
    [c8, g4] = hB.useState(!1),
    [P9, B8] = hB.useState(DA0()),
    [B4, rI] = hB.useState(L1().hasAcknowledgedCostThreshold),
    [P8, s6] = hB.useState(new Set()),
    [x9, S4] = hB.useState("INSERT"),
    [_5, u4] = hB.useState(!1),
    [S6, v9] = hB.useState(!1),
    i9 = hB.useRef(!1),
    QI = hB.useRef(null),
    N9 = hB.useCallback(() => {
      Hy2().then((u0) => {
        if ((w((_Q) => ({ ..._Q, spinnerTip: u0?.content })), u0)) zy2(u0);
      });
    }, [w]),
    T2 = hB.useCallback(() => {
      if (
        (K0(!1),
        c0(void 0),
        yA(0),
        OA([]),
        JB(null),
        z9(null),
        d8(null),
        N9(),
        $aA(),
        D)
      )
        D();
    }, [N9, D]),
    mA = sP2(m8),
    ZA = (!y1 || y1.showSpinner === !0) && E0.length === 0 && G1,
    AA = Iy2(LB, G1, BI),
    RA = hB.useMemo(
      () => ({
        ...AA,
        handleSelect: (u0) => {
          if (
            (AA.handleSelect(u0),
            (u0 === "bad" && D$A("feedback_survey_bad")) ||
              (u0 === "good" && D$A("feedback_survey_good")))
          )
            TB(u0 === "bad" ? "feedback_survey_bad" : "feedback_survey_good");
        },
      }),
      [AA],
    );
  (pS2({
    autoConnectIdeFlag: W,
    ideToInstallExtension: SA,
    setDynamicMcpConfig: o,
    setShowIdeOnboarding: XA,
    setIDEInstallationState: sA,
  }),
    hB.useEffect(() => {
      if (tS2() && !Z1) UA(!0);
    }, [Z1]),
    WoQ(Z, H.checkpointing, (u0) => w((_Q) => ({ ..._Q, checkpointing: u0 }))),
    Ly2(Y, H.fileHistory, (u0) => w((_Q) => ({ ..._Q, fileHistory: u0 }))));
  let [_A, uA] = hB.useState(!1);
  hB.useEffect(() => {
    if (b.isUsingOverage && !_A) {
      let u0 = i3(),
        _Q = u0 === "team" || u0 === "enterprise",
        dQ = "Now using extra usage",
        uB = b.resetsAt ? pT(b.resetsAt, !0) : void 0;
      if (b.rateLimitType === "five_hour")
        dQ = _Q
          ? `5-hour limit ${uB ? `resets ${uB}` : "reached"}  continuing with extra usage`
          : "5-hour limit reached, now using extra usage";
      else if (b.rateLimitType === "seven_day")
        dQ = _Q
          ? `Weekly limit ${uB ? `resets ${uB}` : "reached"}  continuing with extra usage`
          : "Weekly limit reached, now using extra usage";
      else if (b.rateLimitType === "seven_day_opus")
        dQ = _Q
          ? `Opus limit ${uB ? `resets ${uB}` : "reached"}  continuing with extra usage`
          : "Opus weekly limit reached, now using extra usage";
      (wA({ key: "limit-reached", text: dQ, priority: "immediate" }), uA(!0));
    } else if (!b.isUsingOverage && _A) uA(!1);
  }, [b, _A, wA]);
  let D1 = hB.useCallback(
      async (u0, _Q) => {
        let dQ = pzA(_Q.messages),
          uB = await Cw("resume", u0);
        if ((dQ.push(...uB), UiA(_Q), _Q.fileHistorySnapshots))
          (OdA(_Q.fileHistorySnapshots, (m4) => {
            w((L9) => ({ ...L9, fileHistory: m4 }));
          }),
            RdA(_Q));
        (T2(),
          i1(null),
          await NY(),
          B8(u0),
          QM(u0),
          await Vy(),
          YQ(() => dQ),
          g1(null),
          j6(""),
          MB([]));
      },
      [T2, w],
    ),
    O1 = L0(),
    R1 = hB.useMemo(() => km(L0()), []),
    v1 = hB.useRef(
      (() => {
        let u0 = _x(EA0);
        return (
          u0.set(R1, {
            content: JSON.stringify(H.todos[O1] || []),
            timestamp: 0,
            offset: void 0,
            limit: void 0,
          }),
          u0
        );
      })(),
    ),
    { status: u1, reverify: Q0 } = fP2(),
    [d0, TB] = hB.useState(null),
    [LQ, JQ] = hB.useState(null),
    [k2, Q8] = hB.useState(!1),
    RI = !G1 && c8;
  function r6() {
    if (k2 || LQ) return;
    if (U9) return "message-selector";
    if (e0[0]) return "sandbox-permission";
    let u0 = !y1 || y1.shouldContinueAnimation;
    if (u0 && E0[0]) return "tool-permission";
    if (u0 && H.elicitation.queue[0]) return "elicitation";
    if (u0 && RI) return "cost";
    if (CA && !y1?.shouldHidePromptInput) return "init-onboarding";
    if (u0 && Z1) return "ide-onboarding";
    return;
  }
  let oI = r6();
  function TI() {
    if (oI === "elicitation") return;
    if ((T2(), oI === "tool-permission")) (E0[0]?.onAbort(), U0([]));
    else I1?.abort();
  }
  let aZ = hB.useCallback(() => {
    let u0 = F3.popAllForEditing(m8, 0);
    if (!u0) return;
    (j6(u0.text), AI("prompt"));
  }, [F3, j6, AI, m8]);
  (dP2(U0, TI, U9 || _5, BG, y, I1?.signal, aZ, x9, y1?.isLocalJSXCommand, S6),
    hB.useEffect(() => {
      if (dV() >= 5 && !c8 && !B4) {
        if ((GA("tengu_cost_threshold_reached", {}), fiA())) g4(!0);
      }
    }, [LB, c8, B4]));
  let sZ = hB.useCallback(async (u0) => {
    return new Promise((_Q) => {
      VB((dQ) => [
        ...dQ,
        {
          hostPattern: u0,
          shouldAllowHost: (uB) => {
            (VB((m4) => m4.slice(1)), _Q(uB));
          },
          recheckPermission: async () => {
            let uB = x.current.toolPermissionContext,
              m4 = `domain:${u0.host}`;
            if (UK(uB, RJ, "allow").get(m4))
              (g(`[Sandbox] Auto-approving ${u0.host} due to permission rule`),
                VB((z8) => z8.filter((U8) => U8.hostPattern.host !== u0.host)),
                _Q(!0));
          },
        },
      ]);
    });
  }, []);
  if (VQ.isSandboxingEnabled())
    VQ.initialize(sZ).catch((u0) => {
      (process.stderr.write(`
 Sandbox Error: ${u0 instanceof Error ? u0.message : String(u0)}
`),
        D8(1, "other"));
    });
  let b9 = hB.useCallback(
      (u0) => {
        (w((_Q) => ({ ..._Q, toolPermissionContext: u0 })),
          setImmediate(() => {
            U0((_Q) => {
              return (
                _Q.forEach((dQ) => {
                  dQ.recheckPermission();
                }),
                _Q
              );
            });
          }));
      },
      [w, U0],
    ),
    cX = iP2(U0, b9),
    [R3] = HQ(),
    HZ = hB.useCallback(
      (u0, _Q, dQ, uB, m4, L9) => {
        return {
          abortController: dQ,
          options: {
            commands: tA,
            tools: LA,
            debug: B,
            verbose: N,
            mainLoopModel: L9,
            maxThinkingTokens: m4 ?? (H.thinkingEnabled ? $_(_Q, void 0) : 0),
            mcpClients: xA,
            mcpResources: $.resources,
            ideInstallationStatus: kA,
            isNonInteractiveSession: !1,
            hasAppendSystemPrompt: !1,
            dynamicMcpConfig: m,
            theme: R3,
            agentDefinitions: P,
          },
          messageQueueManager: F3,
          getAppState() {
            return new Promise((z8) => {
              w((U8) => {
                return (
                  z8(U8),
                  {
                    ...U8,
                    toolPermissionContext: {
                      ...U8.toolPermissionContext,
                      alwaysAllowRules: {
                        ...U8.toolPermissionContext.alwaysAllowRules,
                        command: uB,
                      },
                    },
                  }
                );
              });
            });
          },
          setAppState: w,
          messages: u0,
          setMessages: YQ,
          updateFileHistoryState(z8) {
            w((U8) => ({ ...U8, fileHistory: z8(U8.fileHistory) }));
          },
          openMessageSelector: () => {
            if (!E) A8(!0);
          },
          onChangeAPIKey: Q0,
          readFileState: v1.current,
          setToolJSX: g1,
          addNotification: wA,
          onChangeDynamicMcpConfig: l,
          onInstallIDEExtension: zA,
          nestedMemoryAttachmentTriggers: new Set(),
          setResponseLength: yA,
          setStreamMode: W1,
          setSpinnerMessage: JB,
          setSpinnerColor: z9,
          setSpinnerShimmerColor: d8,
          setInProgressToolUseIDs: s6,
          agentId: O1,
          resume: D1,
        };
      },
      [
        tA,
        LA,
        B,
        N,
        xA,
        $.resources,
        kA,
        m,
        R3,
        P,
        w,
        Q0,
        wA,
        l,
        O1,
        D1,
        F3,
        H.thinkingEnabled,
        E,
      ],
    ),
    zZ = hB.useCallback(
      async (u0, _Q, dQ) => {
        await Le1({
          input: u0,
          memoryPath: _Q,
          helpers: dQ,
          isLoading: G1,
          mode: OI,
          commands: tA,
          onInputChange: j6,
          onModeChange: AI,
          setPastedContents: Q6,
          onSubmitCountChange: R7,
          setIDESelection: qA,
          setIsLoading: K0,
          setToolJSX: g1,
          getToolUseContext: HZ,
          messages: LB,
          mainLoopModel: k,
          pastedContents: j4,
          ideSelection: rA,
          setUserInputOnProcessing: c0,
          queueManager: F3,
          setAbortController: i1,
          onQuery: fz,
          resetLoadingState: T2,
          thinkingTokens: mA.tokens,
          checkpointing: H.checkpointing,
          thinkingEnabled: H.thinkingEnabled,
          setAppState: w,
          querySource: dwA(),
          onBeforeQuery: K,
        });
      },
      [
        G1,
        OI,
        tA,
        j6,
        AI,
        Q6,
        R7,
        qA,
        K0,
        g1,
        HZ,
        LB,
        k,
        j4,
        rA,
        c0,
        F3,
        i1,
        fz,
        T2,
        mA.tokens,
        H.checkpointing,
        H.thinkingEnabled,
        w,
        K,
      ],
    ),
    xW = hB.useCallback(() => {
      (UA(!1),
        zZ("/init", void 0, {
          setCursorOffset: () => {},
          clearBuffer: () => {},
          resetHistory: () => {},
        }));
    }, [zZ]),
    II = hB.useCallback(() => {
      (TB(null),
        zZ("/issue", void 0, {
          setCursorOffset: () => {},
          clearBuffer: () => {},
          resetHistory: () => {},
        }));
    }, [zZ]),
    vW = hB.useCallback(() => {
      TB(null);
    }, []);
  async function dY() {
    Q0();
    let u0 = LF();
    for (let z8 of u0)
      v1.current.set(z8.path, {
        content: z8.content,
        timestamp: Date.now(),
        offset: void 0,
        limit: void 0,
      });
    if (!Q) return;
    (K0(!0), yA(0), OA([]));
    let _Q = await srA(Q, "prompt", H.checkpointing, (z8) => {
        w((U8) => ({ ...U8, checkpointing: z8 }));
      }),
      dQ = VX0();
    i1(dQ);
    let {
      messages: uB,
      shouldQuery: m4,
      allowedTools: L9,
    } = await Db({
      input: Q,
      mode: "prompt",
      setIsLoading: K0,
      setToolJSX: g1,
      context: HZ(LB, LB, dQ, [], void 0, k),
      ideSelection: rA,
      autocheckpoint: _Q,
      messages: LB,
      setUserInputOnProcessing: c0,
      querySource: dwA(),
    });
    if (UG())
      uB.filter(GIA).forEach((z8) => {
        MdA((U8) => {
          w((x2) => ({ ...x2, fileHistory: U8(x2.fileHistory) }));
        }, z8.uuid);
      });
    if (uB.length) {
      for (let T3 of uB) if (T3.type === "user") gk(Q);
      if ((YQ((T3) => [...T3, ...uB]), !m4)) {
        (T2(), i1(null));
        return;
      }
      let [z8, U8, x2] = await Promise.all([
          Dd(LA, k, Array.from(L.additionalWorkingDirectories.keys()), xA, L),
          FV(),
          WV(),
        ]),
        y4 = [...(C ? [C] : z8), ...(V ? [V] : [])],
        I7 = HZ([...LB, ...uB], uB, dQ, [], void 0, k),
        G7 = L9
          ? {
              ...I7,
              async getAppState() {
                return {
                  ...H,
                  toolPermissionContext: {
                    ...H.toolPermissionContext,
                    alwaysAllowRules: {
                      ...H.toolPermissionContext.alwaysAllowRules,
                      command: L9,
                    },
                  },
                };
              },
            }
          : I7;
      try {
        for await (let T3 of wS({
          messages: [...LB, ...uB],
          systemPrompt: y4,
          userContext: U8,
          systemContext: x2,
          canUseTool: cX,
          toolUseContext: G7,
          querySource: dwA(),
        }))
          E$A(
            T3,
            (v2) => {
              if (
                (YQ((P3) => [...P3, v2]),
                v2.type === "assistant" &&
                  "message" in v2 &&
                  Array.isArray(v2.message.content))
              ) {
                let P3 = v2.message.content.find((y6) => y6.type === "text");
                if (
                  P3 &&
                  "text" in P3 &&
                  P3.text.includes("API Error: 400") &&
                  D$A("400_tool_use_error")
                )
                  TB("400_tool_use_error");
              }
            },
            (v2) => yA((P3) => P3 + v2.length),
            W1,
            OA,
          );
      } finally {
        T2();
      }
    } else (gk(Q), T2());
    rI(L1().hasAcknowledgedCostThreshold || !1);
  }
  async function A$(u0, _Q, dQ, uB, m4, L9, z8) {
    let U8 = _Q
      .filter((v2) => v2.type === "user" || v2.type === "assistant")
      .pop();
    if (uB) {
      gx.handleQueryStart(xA);
      let v2 = Az(xA);
      if (v2) WNQ(v2);
    }
    if ((P0A(), U8?.type === "user" && typeof U8.message.content === "string"))
      kBQ(U8.message.content);
    if (!uB) {
      (T2(), i1(null));
      return;
    }
    let x2 = HZ(u0, _Q, dQ, m4, z8, L9);
    LI("query_context_loading_start");
    let [, y4, I7, G7] = await Promise.all([
      ce1(L, w),
      Dd(LA, L9, Array.from(L.additionalWorkingDirectories.keys()), xA, L),
      FV(),
      WV(),
    ]);
    LI("query_context_loading_end");
    let T3 = [...(C ? [C] : y4), ...(V ? [V] : [])];
    LI("query_query_start");
    for await (let v2 of wS({
      messages: u0,
      systemPrompt: T3,
      userContext: I7,
      systemContext: G7,
      canUseTool: cX,
      toolUseContext: x2,
      querySource: dwA(),
    }))
      E$A(
        v2,
        (P3) => {
          if (
            (YQ((y6) => [...y6, P3]),
            P3.type === "assistant" &&
              "message" in P3 &&
              Array.isArray(P3.message.content))
          ) {
            let y6 = P3.message.content.find((eQ) => eQ.type === "text");
            if (
              y6 &&
              "text" in y6 &&
              y6.text.includes("API Error: 400") &&
              D$A("400_tool_use_error")
            )
              TB("400_tool_use_error");
          }
        },
        (P3) => yA((y6) => y6 + P3.length),
        W1,
        OA,
      );
    if ((LI("query_end"), T2(), Vj2(), !C4))
      YQ((v2) => {
        let P3 = qF(v2);
        if (ET(L9) === 1e6) return v2;
        let { percentLeft: eQ } = px(P3);
        if (eQ > 10) return v2;
        let { hasAccess: j8 } = w_();
        if (!j8) return v2;
        let PI = QbA.value,
          rZ =
            `${eQ}% context left` +
            (cx() ? " until auto-compact" : "") +
            `  try /model ${PI}`,
          QG = bN(rZ, "suggestion");
        return (H8(!0), [...v2, QG]);
      });
    T2();
  }
  async function fz(u0, _Q, dQ, uB, m4, L9, z8, U8, x2) {
    if (i9.current) {
      GA("tengu_concurrent_onquery_detected", {});
      for (let y4 of u0)
        if (y4.type === "user") {
          let I7 = C6A(y4.message.content);
          if (I7)
            (z8.enqueue({ value: I7, mode: "prompt" }),
              GA("tengu_concurrent_onquery_enqueued", {}));
        }
      return (K0(!1), { status: "skipped", reason: "already_running" });
    }
    if ((K0(!0), YQ((y4) => [...y4, ...u0]), yA(0), OA([]), U8 && x2)) {
      let y4 = [...LB, ...u0];
      if (!(await U8(x2, y4)))
        return (K0(!1), { status: "skipped", reason: "blocked_by_callback" });
    }
    ((i9.current = !0), (QI.current = u0));
    try {
      let y4 = await new Promise((I7) => {
        YQ((G7) => {
          return (I7(G7), G7);
        });
      });
      await A$(y4, u0, _Q, dQ, uB, m4, L9);
    } finally {
      ((i9.current = !1), p1(Date.now()));
    }
    return { status: "completed" };
  }
  (kNQ(),
    AoQ(LB, LB.length === G?.length),
    vP2(),
    hB.useEffect(() => {
      if (BG.length < 1) return;
      let u0 = L1();
      n0({ ...u0, promptQueueUseCount: (u0.promptQueueUseCount ?? 0) + 1 });
    }, [BG.length]),
    hB.useEffect(() => {
      (zwA.recordUserActivity(), SGA());
    }, [m8, BI]));
  let I6 = hB.useRef(new Set());
  (hB.useEffect(() => {
    let u0 = new Set(LB.filter((dQ) => pr(dQ)).map((dQ) => dQ.uuid));
    if (Array.from(u0).some((dQ) => !I6.current.has(dQ)))
      ((I6.current = u0), NY(), B8(DA0()));
  }, [LB]),
    hB.useEffect(() => {
      if (G1) return;
      if (BI === 0) return;
      if (J1 === 0) return;
      let u0 = setTimeout(() => {
        if (QLA() > J1) return;
        let dQ = Date.now() - J1;
        if (
          !G1 &&
          !y1 &&
          oI === void 0 &&
          dQ >= L1().messageIdleNotifThresholdMs
        )
          Tr({
            message: "Claude is waiting for your input",
            notificationType: "idle_prompt",
          });
      }, L1().messageIdleNotifThresholdMs);
      return () => clearTimeout(u0);
    }, [G1, y1, BI, oI, J1]),
    mS2(G1, J1),
    hB.useEffect(() => {
      return (
        dY(),
        () => {
          gx.shutdown();
        }
      );
    }, []));
  let { internal_eventEmitter: f9 } = _h(),
    [B$, kL] = hB.useState(0);
  hB.useEffect(() => {
    let u0 = () => {
        process.stdout.write(`
Claude Code has been suspended. Run \`fg\` to bring Claude Code back.
Note: ctrl + z now suspends Claude Code, ctrl + _ undoes input.
`);
      },
      _Q = () => {
        kL((dQ) => dQ + 1);
      };
    return (
      f9?.on("suspend", u0),
      f9?.on("resume", _Q),
      () => {
        (f9?.off("suspend", u0), f9?.off("resume", _Q));
      }
    );
  }, [f9]);
  let Q7 = hB.useMemo(() => bY(R2).filter(B$A), [R2]),
    pX = hB.useMemo(() => {
      if (!G1) return null;
      let u0 = LB.filter(
        (x2) =>
          x2.type === "progress" &&
          x2.data.type === "hook_progress" &&
          (x2.data.hookEvent === "Stop" ||
            x2.data.hookEvent === "SubagentStop"),
      );
      if (u0.length === 0) return null;
      let _Q = [...new Set(u0.map((x2) => x2.toolUseID))],
        dQ = _Q[_Q.length - 1];
      if (!dQ) return null;
      if (
        LB.some(
          (x2) =>
            x2.type === "system" &&
            x2.subtype === "stop_hook_summary" &&
            x2.toolUseID === dQ,
        )
      )
        return null;
      let m4 = u0.filter((x2) => x2.toolUseID === dQ),
        L9 = m4.length,
        z8 = LB.filter((x2) => {
          if (x2.type !== "attachment") return !1;
          let y4 = x2.attachment;
          return (
            "hookEvent" in y4 &&
            (y4.hookEvent === "Stop" || y4.hookEvent === "SubagentStop") &&
            "toolUseID" in y4 &&
            y4.toolUseID === dQ
          );
        }).length,
        U8 =
          m4[0]?.data.hookEvent === "SubagentStop" ? "subagent stop" : "stop";
      return L9 === 1
        ? `running ${U8} hook`
        : `running stop hooks: ${z8}/${L9}`;
    }, [LB, G1]);
  fS2(y, c, QA, JA, NY);
  let TE = H.todos[O1];
  if ((uP2(TE), y === "transcript"))
    return d2.createElement(
      d2.Fragment,
      null,
      d2.createElement(Z7A, {
        messages: LB,
        normalizedMessageHistory: Q7,
        tools: LA,
        verbose: !0,
        toolJSX: null,
        toolUseConfirmQueue: [],
        inProgressToolUseIDs: P8,
        isMessageSelectorVisible: !1,
        conversationId: P9,
        screen: y,
        agentDefinitions: P,
        screenToggleId: e,
        streamingToolUses: w1,
        showAllInTranscript: WA,
      }),
      y1 &&
        d2.createElement(S, { flexDirection: "column", width: "100%" }, y1.jsx),
      d2.createElement(Rb2, null),
      d2.createElement(
        S,
        {
          alignItems: "center",
          alignSelf: "center",
          borderTopDimColor: !0,
          borderBottom: !1,
          borderLeft: !1,
          borderRight: !1,
          borderStyle: "single",
          marginTop: 1,
          paddingLeft: 2,
          width: "100%",
        },
        d2.createElement(
          U,
          { dimColor: !0 },
          "Showing detailed transcript  ctrl+o to toggle",
        ),
      ),
    );
  return d2.createElement(
    ftA,
    { key: B$, dynamicMcpConfig: m, isStrictMcpConfig: F },
    d2.createElement(Z7A, {
      messages: LB,
      normalizedMessageHistory: Q7,
      tools: LA,
      verbose: N,
      toolJSX: y1,
      toolUseConfirmQueue: E0,
      inProgressToolUseIDs: P8,
      isMessageSelectorVisible: U9,
      conversationId: P9,
      screen: y,
      screenToggleId: e,
      streamingToolUses: w1,
      showAllInTranscript: WA,
      agentDefinitions: P,
    }),
    d2.createElement(Ay2, null),
    a0 &&
      d2.createElement(Ss, {
        param: { text: a0, type: "text" },
        addMargin: !0,
        verbose: N,
      }),
    y1 &&
      d2.createElement(S, { flexDirection: "column", width: "100%" }, y1.jsx),
    d2.createElement(
      S,
      { flexDirection: "column", width: "100%" },
      ZA &&
        d2.createElement(BT2, {
          mode: aA,
          spinnerTip: H.spinnerTip,
          currentResponseLength: B1,
          overrideMessage: r1,
          spinnerSuffix: pX,
          verbose: N,
          loadingStartTime: _0,
          todos: TE,
          overrideColor: mQ,
          overrideShimmerColor: V4,
          hasActiveTools: P8.size > 0,
        }),
      !ZA &&
        H.showExpandedTodos &&
        d2.createElement(
          S,
          { width: "100%", flexDirection: "column" },
          d2.createElement(s3A, { todos: TE || [], isStandalone: !0 }),
        ),
      oI === "sandbox-permission" &&
        d2.createElement(Oy2, {
          hostPattern: e0[0].hostPattern,
          onUserResponse: (u0) => {
            let { allow: _Q, persistToSettings: dQ } = u0,
              uB = e0[0];
            if (!uB) return;
            if (dQ) {
              let m4 = {
                type: "addRules",
                rules: [
                  {
                    toolName: _C,
                    ruleContent: `domain:${uB.hostPattern.host}`,
                  },
                ],
                behavior: _Q ? "allow" : "deny",
                destination: "localSettings",
              };
              (w((L9) => ({
                ...L9,
                toolPermissionContext: aF(L9.toolPermissionContext, m4),
              })),
                wb(m4),
                setImmediate(() => {
                  VB((L9) => {
                    return (
                      L9.forEach((z8) => {
                        z8.recheckPermission();
                      }),
                      L9
                    );
                  });
                }));
            }
            uB.shouldAllowHost(_Q);
          },
        }),
      oI === "tool-permission" &&
        d2.createElement(D02, {
          key: E0[0]?.toolUseID,
          onDone: () => U0(([u0, ..._Q]) => _Q),
          onReject: aZ,
          toolUseConfirm: E0[0],
          toolUseContext: HZ(LB, LB, I1 ?? a9(), [], void 0, k),
          verbose: N,
        }),
      oI === "elicitation" &&
        d2.createElement(w02, {
          serverName: H.elicitation.queue[0].serverName,
          request: H.elicitation.queue[0].request,
          onResponse: (u0, _Q) => {
            let dQ = H.elicitation.queue[0];
            if (dQ)
              (w((uB) => ({
                ...uB,
                elicitation: { queue: uB.elicitation.queue.slice(1) },
              })),
                dQ.respond({ action: u0, content: _Q }));
          },
          signal: H.elicitation.queue[0].signal,
        }),
      oI === "cost" &&
        d2.createElement(PaQ, {
          onDone: () => {
            (g4(!1), rI(!0));
            let u0 = L1();
            (n0({ ...u0, hasAcknowledgedCostThreshold: !0 }),
              GA("tengu_cost_threshold_acknowledged", {}));
          },
        }),
      oI === "ide-onboarding" &&
        d2.createElement(rqQ, { onDone: () => XA(!1), installationStatus: kA }),
      oI === "init-onboarding" &&
        d2.createElement(rS2, { onDone: () => UA(!1), onRunInit: xW }),
      LQ,
      !y1?.shouldHidePromptInput &&
        !oI &&
        !k2 &&
        !E &&
        d2.createElement(
          d2.Fragment,
          null,
          d0 &&
            d2.createElement(Xf2, { onRun: II, onCancel: vW, reason: Wf2(d0) }),
          d2.createElement(Jy2, {
            state: RA.state,
            handleSelect: RA.handleSelect,
            inputValue: m8,
            setInputValue: j6,
          }),
          d2.createElement(kP2, {
            debug: B,
            ideSelection: rA,
            getToolUseContext: HZ,
            toolPermissionContext: L,
            setToolPermissionContext: b9,
            apiKeyStatus: u1,
            commands: tA,
            agents: P.activeAgents,
            isLoading: G1,
            onExit: async () => {
              Q8(!0);
              let u0 = await D01.call(() => {});
              JQ(u0);
            },
            verbose: N,
            messages: LB,
            onAutoUpdaterResult: q1,
            autoUpdaterResult: F1,
            input: m8,
            onInputChange: j6,
            mode: OI,
            onModeChange: AI,
            queuedCommands: BG,
            queueManager: F3,
            submitCount: BI,
            onShowMessageSelector: () => A8((u0) => !u0),
            mcpClients: xA,
            pastedContents: j4,
            setPastedContents: Q6,
            vimMode: x9,
            setVimMode: S4,
            showBashesDialog: _5,
            setShowBashesDialog: u4,
            onSubmit: zZ,
            isSearchingHistory: S6,
            setIsSearchingHistory: v9,
          }),
        ),
    ),
    oI === "message-selector" &&
      d2.createElement(VoQ, {
        messages: LB,
        onPreRestore: TI,
        onRestoreCode: async (u0) => {
          await iP1((_Q) => {
            w((dQ) => ({ ...dQ, fileHistory: _Q(dQ.fileHistory) }));
          }, u0.uuid);
        },
        onRestoreMessage: async (u0) => {
          let _Q = LB.indexOf(u0),
            dQ = LB.slice(0, _Q);
          setImmediate(async () => {
            if (
              (await NY(),
              YQ([...dQ]),
              B8(DA0()),
              typeof u0.message.content === "string")
            ) {
              let uB = u0.message.content,
                m4 = g2(uB, "bash-input"),
                L9 = g2(uB, "command-name");
              if (m4) (j6(m4), AI("bash"));
              else if (L9) {
                let z8 = g2(uB, "command-args") || "";
                (j6(`${L9} ${z8}`), AI("prompt"));
              } else (j6(uB), AI("prompt"));
            } else if (
              Array.isArray(u0.message.content) &&
              u0.message.content.length >= 2 &&
              u0.message.content.some((uB) => uB.type === "image") &&
              u0.message.content.some((uB) => uB.type === "text")
            ) {
              let uB = u0.message.content.find((L9) => L9.type === "text");
              if (uB && uB.type === "text") (j6(uB.text), AI("prompt"));
              let m4 = u0.message.content.filter((L9) => L9.type === "image");
              if (m4.length > 0) {
                let L9 = {};
                (m4.forEach((z8, U8) => {
                  if (z8.source.type === "base64")
                    L9[U8 + 1] = {
                      id: U8 + 1,
                      type: "image",
                      content: z8.source.data,
                      mediaType: z8.source.media_type,
                    };
                }),
                  Q6(L9));
              }
            }
          });
        },
        onClose: () => A8(!1),
      }),
  );
}
var d2,
  hB,
  EA0 = 100;
var P01 = T(() => {
  nA();
  jaQ();
  _H();
  nrA();
  zN();
  i0();
  ss();
  BoQ();
  FoQ();
  orA();
  zoQ();
  E02();
  $02();
  _P2();
  xX();
  Qr();
  ZS();
  lD();
  ux();
  bP2();
  ph();
  hP2();
  mP2();
  cP2();
  nP2();
  rP2();
  aC();
  f3();
  gr();
  C0();
  kB();
  F2();
  H0();
  iB();
  DN();
  bm();
  Xx();
  kH();
  xY();
  Ej2();
  uwA();
  U5A();
  xj2();
  Me1();
  Oe1();
  hj2();
  Pe1();
  C01();
  S11();
  NJA();
  hS2();
  Ps();
  uS2();
  nO();
  czA();
  Y9();
  UFA();
  c9();
  mwA();
  _m();
  E7();
  dIA();
  tq();
  dS2();
  zW();
  lS2();
  ge1();
  sS2();
  Ls();
  La();
  sx1();
  eS2();
  yt1();
  vG();
  Io();
  By2();
  Gy2();
  Xy2();
  BzA();
  Cy2();
  Uy2();
  qy2();
  VW();
  My2();
  Ry2();
  Tb2();
  JA0();
  Sb2();
  kb2();
  vb2();
  sb2();
  siA();
  tb2();
  Bf2();
  Gf2();
  Jf2();
  Ff2();
  ((d2 = IA(KA(), 1)), (hB = IA(KA(), 1)));
});
async function* H7A({
  agentDefinition: A,
  promptMessages: B,
  toolUseContext: Q,
  canUseTool: I,
  isAsync: G,
  forkContextMessages: Z,
  querySource: Y,
  override: J,
  model: X,
}) {
  let W = GbA(A.model, Q.options.mainLoopModel, X),
    F = J?.agentId ? J.agentId : $rA(),
    V = [...(Z ? Gs5(Z) : []), ...B],
    K = Z !== void 0 ? zs(Q.readFileState) : _x(EA0),
    [D, E, H] = await Promise.all([
      Q.getAppState(),
      J?.userContext ?? FV(),
      J?.systemContext ?? WV(),
    ]),
    L = p5A(A, Q.options.tools, G).resolvedTools,
    N = Array.from(D.toolPermissionContext.additionalWorkingDirectories.keys()),
    $ = A.systemPrompt ? [A.systemPrompt] : [Cf2],
    O = J?.systemPrompt ? J.systemPrompt : await Vf2($, W, N),
    P = [],
    k,
    b = J?.abortController
      ? J.abortController
      : G
        ? new AbortController()
        : Q.abortController,
    x = G ? !0 : (Q.options.isNonInteractiveSession ?? !1),
    n = G ? () => {} : Q.setAppState;
  for await (let m of wS({
    messages: V,
    systemPrompt: O,
    userContext: E,
    systemContext: H,
    canUseTool: I,
    toolUseContext: {
      abortController: b,
      options: {
        isNonInteractiveSession: x,
        hasAppendSystemPrompt: Q.options.hasAppendSystemPrompt,
        tools: L,
        commands: [],
        debug: Q.options.debug,
        verbose: Q.options.verbose,
        mainLoopModel: W,
        maxThinkingTokens: $_(V),
        mcpClients: Q.options.mcpClients,
        mcpResources: Q.options.mcpResources,
        agentDefinitions: Q.options.agentDefinitions,
      },
      getAppState: Q.getAppState,
      setAppState: n,
      messages: V,
      setMessages: () => {},
      readFileState: K,
      nestedMemoryAttachmentTriggers: new Set(),
      messageQueueManager: AR(),
      setInProgressToolUseIDs: () => {},
      setResponseLength: Q.setResponseLength,
      updateFileHistoryState: () => {},
      agentId: F,
      isSubAgent: !0,
      queryTracking: Q.queryTracking,
    },
    querySource: Y,
  }))
    if (
      m.type === "assistant" ||
      m.type === "user" ||
      m.type === "progress" ||
      (m.type === "system" && m.subtype === "compact_boundary")
    )
      (P.push(m),
        (k = Kf2(P, F).catch((o) =>
          g(`Failed to record sidechain transcript: ${o}`),
        )),
        yield m);
  if ((await k, b.signal.aborted)) throw new IX();
  if (A.callback) A.callback();
}
function Gs5(A) {
  let B = new Set();
  for (let Q of A)
    if (Q?.type === "user") {
      let G = Q.message.content;
      if (Array.isArray(G)) {
        for (let Z of G)
          if (Z.type === "tool_result" && Z.tool_use_id) B.add(Z.tool_use_id);
      }
    }
  return A.filter((Q) => {
    if (Q?.type === "assistant") {
      let G = Q.message.content;
      if (Array.isArray(G))
        return !G.some((Y) => Y.type === "tool_use" && Y.id && !B.has(Y.id));
    }
    return !0;
  });
}
var j01 = T(() => {
  U5A();
  y7();
  Tv();
  c5A();
  ZS();
  Qr();
  Y9();
  kH();
  l5A();
  zN();
  P01();
  E7();
  C0();
});
var S01;
var HA0 = T(() => {
  S01 = {
    agentType: "general-purpose",
    whenToUse:
      "General-purpose agent for researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries use this agent to perform the search for you.",
    tools: ["*"],
    systemPrompt: `You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup.

Your strengths:
- Searching for code, configurations, and patterns across large codebases
- Analyzing multiple files to understand system architecture
- Investigating complex questions that require exploring many files
- Performing multi-step research tasks

Guidelines:
- For file searches: Use Grep or Glob when you need to search broadly. Use Read when you know the specific file path.
- For analysis: Start broad and narrow down. Use multiple search strategies if the first doesn't yield results.
- Be thorough: Check multiple locations, consider different naming conventions, look for related files.
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication, avoid using emojis.`,
    source: "built-in",
    baseDir: "built-in",
    model: "sonnet",
  };
});
function y01({ prompt: A, theme: B, dim: Q = !1 }) {
  return gB.createElement(
    S,
    { flexDirection: "column" },
    gB.createElement(U, { color: "success", bold: !0 }, "Prompt:"),
    gB.createElement(
      S,
      { paddingLeft: 2 },
      gB.createElement(U, { dimColor: Q }, B ? tC(A, B) : A),
    ),
  );
}
function Df2({ content: A, theme: B }) {
  return gB.createElement(
    S,
    { flexDirection: "column" },
    gB.createElement(U, { color: "success", bold: !0 }, "Response:"),
    A.map((Q, I) =>
      gB.createElement(
        S,
        { key: I, paddingLeft: 2, marginTop: I === 0 ? 0 : 1 },
        gB.createElement(U, null, B ? tC(Q.text, B) : Q.text),
      ),
    ),
  );
}
function Ef2(A, B, { tools: Q, verbose: I, theme: G }) {
  if (A.status === "async_launched") {
    let { prompt: D } = A;
    return gB.createElement(
      S,
      { flexDirection: "column" },
      gB.createElement(
        j0,
        { height: 1 },
        gB.createElement(
          U,
          null,
          "Launched in background",
          !I &&
            iA.dim(
              D
                ? " (down arrow  to manage  ctrl+o to expand)"
                : " (down arrow  to manage)",
            ),
        ),
      ),
      I &&
        D &&
        gB.createElement(
          j0,
          null,
          gB.createElement(y01, { prompt: D, theme: G }),
        ),
    );
  }
  if (A.status !== "completed") return null;
  let {
      totalDurationMs: Z,
      totalToolUseCount: Y,
      totalTokens: J,
      usage: X,
      content: W,
      prompt: F,
    } = A,
    V = `Done (${[Y === 1 ? "1 tool use" : `${Y} tool uses`, yZ(J) + " tokens", KU(Z)].join("  ")})`,
    K = CV({ content: V, usage: X });
  return gB.createElement(
    S,
    { flexDirection: "column" },
    I &&
      F &&
      gB.createElement(
        j0,
        null,
        gB.createElement(y01, { prompt: F, theme: G }),
      ),
    I
      ? B.map((D) =>
          gB.createElement(
            j0,
            { key: D.uuid },
            gB.createElement(ax, {
              message: D.data.message,
              messages: D.data.normalizedMessages,
              addMargin: !1,
              tools: Q,
              verbose: I,
              erroredToolUseIDs: new Set(),
              inProgressToolUseIDs: new Set(),
              resolvedToolUseIDs: new Set(),
              progressMessagesForMessage: B,
              shouldAnimate: !1,
              shouldShowDot: !1,
              isTranscriptMode: !1,
            }),
          ),
        )
      : null,
    I &&
      W &&
      W.length > 0 &&
      gB.createElement(
        j0,
        null,
        gB.createElement(Df2, { content: W, theme: G }),
      ),
    gB.createElement(
      j0,
      { height: 1 },
      gB.createElement(ax, {
        message: K,
        messages: bY([K]),
        addMargin: !1,
        tools: Q,
        verbose: I,
        erroredToolUseIDs: new Set(),
        inProgressToolUseIDs: new Set(),
        resolvedToolUseIDs: new Set(),
        progressMessagesForMessage: [],
        shouldAnimate: !1,
        shouldShowDot: !1,
        isTranscriptMode: !1,
      }),
    ),
  );
}
function Hf2({ description: A, prompt: B }) {
  if (!A || !B) return null;
  return A;
}
function k01(
  A,
  { tools: B, verbose: Q, terminalSize: I, inProgressToolCallCount: G },
) {
  if (!A.length)
    return gB.createElement(
      j0,
      { height: 1 },
      gB.createElement(U, { dimColor: !0 }, Js5),
    );
  let Z = (G ?? 1) * Zs5 + Ys5,
    Y = !Q && I && I.rows && I.rows < Z,
    J = () => {
      let K = A.filter((H) => {
          return H.data.message.message.content.some(
            (L) => L.type === "tool_use",
          );
        }).length,
        D = [...A].reverse().find((H) => H.data.message.type === "assistant"),
        E = null;
      if (D?.data.message.type === "assistant") {
        let H = D.data.message.message.usage;
        E =
          (H.cache_creation_input_tokens ?? 0) +
          (H.cache_read_input_tokens ?? 0) +
          H.input_tokens +
          H.output_tokens;
      }
      return { toolUseCount: K, tokens: E };
    };
  if (Y) {
    let { toolUseCount: K, tokens: D } = J();
    return gB.createElement(
      j0,
      { height: 1 },
      gB.createElement(
        U,
        { dimColor: !0 },
        "In progress  ",
        gB.createElement(U, { bold: !0 }, K),
        " tool",
        " ",
        K === 1 ? "use" : "uses",
        D && `  ${yZ(D)} tokens`,
        "  (ctrl+o to expand)",
      ),
    );
  }
  let X = A.filter((K) => {
      return K.data.message.message.content.some((E) => E.type === "tool_use");
    }).length,
    W = Q ? A : A.slice(-zA0),
    F = W.filter((K) => {
      return K.data.message.message.content.some((E) => E.type === "tool_use");
    }).length,
    C = X - F;
  if (!Q && A.length > zA0) W = A.slice(-zA0 + 1);
  let V = A[0]?.data.prompt;
  return gB.createElement(
    j0,
    null,
    gB.createElement(
      S,
      { flexDirection: "column" },
      Q &&
        V &&
        gB.createElement(
          S,
          { marginBottom: 1 },
          gB.createElement(y01, { prompt: V }),
        ),
      W.map((K) =>
        gB.createElement(
          S,
          { key: K.uuid, height: 1, overflow: "hidden" },
          gB.createElement(ax, {
            message: K.data.message,
            messages: K.data.normalizedMessages,
            addMargin: !1,
            tools: B,
            verbose: Q,
            erroredToolUseIDs: new Set(),
            inProgressToolUseIDs: new Set(),
            resolvedToolUseIDs: wA0(A),
            progressMessagesForMessage: A,
            shouldAnimate: !1,
            shouldShowDot: !1,
            style: "condensed",
            isTranscriptMode: !1,
          }),
        ),
      ),
      C > 0 &&
        gB.createElement(
          U,
          { dimColor: !0 },
          "+",
          C,
          " more tool ",
          C === 1 ? "use" : "uses",
          " ",
          gB.createElement(su, null),
        ),
    ),
  );
}
function zf2(A, { progressMessagesForMessage: B, tools: Q, verbose: I }) {
  return gB.createElement(
    gB.Fragment,
    null,
    k01(B, { tools: Q, verbose: I }),
    gB.createElement(l5, null),
  );
}
function Uf2(A, { progressMessagesForMessage: B, tools: Q, verbose: I }) {
  return gB.createElement(
    gB.Fragment,
    null,
    k01(B, { tools: Q, verbose: I }),
    gB.createElement(H6, { result: A, verbose: I }),
  );
}
function wf2(A) {
  if (A?.subagent_type && A.subagent_type !== S01.agentType)
    return A.subagent_type;
  return "Task";
}
function $f2(A) {
  if (!A?.subagent_type) return;
  return U6A(A.subagent_type);
}
var gB,
  zA0 = 3,
  Zs5 = 9,
  Ys5 = 7,
  Js5 = "Initializing";
var UA0 = T(() => {
  f2();
  nA();
  UF();
  qX();
  Kx();
  L8();
  YEA();
  iB();
  iB();
  HA0();
  cm();
  f4A();
  gB = IA(KA(), 1);
});
var Xs5,
  H$A = "AgentOutputTool",
  lm7;
var $A0 = T(() => {
  e2();
  nA();
  l11();
  y7();
  UF();
  UA0();
  ((Xs5 = IA(KA(), 1)),
    (lm7 = _.strictObject({
      agentIds: _.array(_.string()).describe(
        "Array of agent IDs to retrieve results for",
      ),
      block: _.boolean()
        .default(!0)
        .describe("Whether to block until results are ready"),
      wait_up_to: _.number()
        .min(0)
        .max(300)
        .default(150)
        .describe("Maximum time to wait in seconds"),
    })));
});
function Nf2({ onBackground: A }) {
  h1((Q, I) => {
    if (Q === "b" && I.ctrl) A();
  });
  let B =
    O0.terminal === "tmux"
      ? "ctrl+b ctrl+b to run in background"
      : "ctrl+b to run in background";
  return iZ.createElement(
    S,
    { paddingLeft: 5 },
    iZ.createElement(U, { dimColor: !0 }, B),
  );
}
function Lf2(A, { verbose: B, theme: Q }) {
  let { command: I } = A;
  if (!I) return null;
  let G = I;
  if (I.includes(`"$(cat <<'EOF'`)) {
    let Z = I.match(/^(.*?)"?\$\(cat <<'EOF'\n([\s\S]*?)\n\s*EOF\n\s*\)"(.*)$/);
    if (Z && Z[1] && Z[2]) {
      let Y = Z[1],
        J = Z[2],
        X = Z[3] || "";
      G = `${Y.trim()} "${J.trim()}"${X.trim()}`;
    }
  }
  if (!B) {
    let Z = G.split(`
`),
      Y = Z.length > qf2,
      J = G.length > qA0;
    if (Y || J) {
      let X = G;
      if (Y)
        X = Z.slice(0, qf2).join(`
`);
      if (X.length > qA0) X = X.slice(0, qA0);
      return iZ.createElement(U, null, X.trim(), "");
    }
  }
  return G;
}
function Mf2() {
  return iZ.createElement(l5, null);
}
function Of2(
  A,
  { verbose: B, tools: Q, terminalSize: I, inProgressToolCallCount: G },
) {
  let Z = A.at(-1);
  if (!Z || !Z.data || !Z.data.output)
    return iZ.createElement(
      j0,
      { height: 1 },
      iZ.createElement(U, { dimColor: !0 }, "Running"),
    );
  let Y = Z.data;
  return iZ.createElement(a11, {
    fullOutput: Y.fullOutput,
    output: Y.output,
    elapsedTimeSeconds: Y.elapsedTimeSeconds,
    totalLines: Y.totalLines,
    verbose: B,
  });
}
function Rf2() {
  return iZ.createElement(
    j0,
    { height: 1 },
    iZ.createElement(U, { dimColor: !0 }, "Waiting"),
  );
}
function Tf2(A, B, { verbose: Q, theme: I, tools: G, style: Z }) {
  return iZ.createElement(js, { content: A, verbose: Q });
}
function Pf2(A, { verbose: B, progressMessagesForMessage: Q, tools: I }) {
  return iZ.createElement(H6, { result: A, verbose: B });
}
var iZ,
  qf2 = 2,
  qA0 = 160;
var NA0 = T(() => {
  nA();
  UF();
  qX();
  L8();
  aiA();
  Fe1();
  C6();
  iZ = IA(KA(), 1);
});
function Es5(A) {
  let B = 0,
    Q = bY(A);
  for (let I of Q)
    if (I.type === "assistant") {
      for (let G of I.message.content) if (G.type === "tool_use") B++;
    }
  return B;
}
function Hs5(A, B, Q) {
  let { prompt: I, resolvedAgentModel: G, isBuiltInAgent: Z, startTime: Y } = Q,
    J = k4A(A);
  if (J === void 0) throw Error("No assistant messages found");
  let X = J.message.content.filter((C) => C.type === "text"),
    W = flA(J.message.usage),
    F = Es5(A);
  return (
    GA("tengu_agent_tool_completed", {
      model: G,
      prompt_char_count: I.length,
      response_char_count: X.length,
      assistant_message_count: A.length,
      total_tool_uses: F,
      duration_ms: Date.now() - Y,
      total_tokens: W,
      is_built_in_agent: Z,
    }),
    {
      agentId: B,
      content: X,
      totalDurationMs: Date.now() - Y,
      totalTokens: W,
      totalToolUseCount: F,
      usage: J.message.usage,
    }
  );
}
var Ws5, jf2, Rd7, Fs5, Cs5, Vs5, Ks5, Ds5, dm;
var BnA = T(() => {
  Q0A();
  e2();
  iB();
  SMQ();
  cm();
  Y9();
  y7();
  H0();
  j01();
  DN();
  iB();
  UA0();
  l11();
  l5A();
  $A0();
  Me1();
  Tv();
  E7();
  NA0();
  ((Ws5 = IA(KA(), 1)),
    (jf2 = _.object({
      description: _.string().describe(
        "A short (3-5 word) description of the task",
      ),
      prompt: _.string().describe("The task for the agent to perform"),
      subagent_type: _.string().describe(
        "The type of specialized agent to use for this task",
      ),
      model: _.enum(["sonnet", "opus", "haiku"])
        .optional()
        .describe(
          "Optional model to use for this agent. If not specified, inherits from parent. Prefer haiku for quick, straightforward tasks to minimize cost and latency.",
        ),
      resume: _.string()
        .optional()
        .describe(
          "Optional agent ID to resume from. If provided, the agent will continue from the previous execution transcript.",
        ),
    })),
    (Rd7 = jf2.extend({
      run_in_background: _.boolean()
        .optional()
        .describe(
          "Set to true to run this agent in the background. Use AgentOutputTool to read the output later.",
        ),
    })),
    (Fs5 = jf2),
    (Cs5 = _.object({
      agentId: _.string(),
      content: _.array(_.object({ type: _.literal("text"), text: _.string() })),
      totalToolUseCount: _.number(),
      totalDurationMs: _.number(),
      totalTokens: _.number(),
      usage: _.object({
        input_tokens: _.number(),
        output_tokens: _.number(),
        cache_creation_input_tokens: _.number().nullable(),
        cache_read_input_tokens: _.number().nullable(),
        server_tool_use: _.object({
          web_search_requests: _.number(),
          web_fetch_requests: _.number(),
        }).nullable(),
        service_tier: _.enum(["standard", "priority", "batch"]).nullable(),
        cache_creation: _.object({
          ephemeral_1h_input_tokens: _.number(),
          ephemeral_5m_input_tokens: _.number(),
        }).nullable(),
      }),
    })),
    (Vs5 = Cs5.extend({ status: _.literal("completed"), prompt: _.string() })),
    (Ks5 = _.object({
      status: _.literal("async_launched"),
      agentId: _.string().describe("The ID of the async agent"),
      description: _.string().describe("The description of the task"),
      prompt: _.string().describe("The prompt for the agent"),
    })),
    (Ds5 = _.union([Vs5, Ks5, FaQ])));
  dm = {
    async prompt({ agents: A }) {
      return await jMQ(A);
    },
    name: x8,
    async description() {
      return "Launch a new task";
    },
    inputSchema: Fs5,
    outputSchema: Ds5,
    async call(
      {
        prompt: A,
        subagent_type: B,
        description: Q,
        model: I,
        resume: G,
        run_in_background: Z,
      },
      Y,
      J,
      X,
      W,
    ) {
      let F = Date.now(),
        C = Y.options.agentDefinitions.activeAgents,
        V = C.find(($) => $.agentType === B);
      if (!V)
        throw Error(
          `Agent type '${B}' not found. Available agents: ${C.map(($) => $.agentType).join(", ")}`,
        );
      if (V.color) w6A(B, V.color);
      let K = V?.source === "built-in",
        D = GbA(V.model, Y.options.mainLoopModel, I);
      GA("tengu_agent_tool_selected", {
        agent_type: V.agentType,
        model: D,
        source: V.source,
        color: V.color,
        is_built_in_agent: K,
      });
      let E;
      if (G) {
        let $ = await Sf2(G);
        if (!$) throw Error(`No transcript found for agent ID: ${G}`);
        E = $;
      }
      let H = V?.forkContext ? Y.messages : void 0,
        w = V?.forkContext ? CaQ(A, X) : [T0({ content: A })],
        L = {
          prompt: A,
          resolvedAgentModel: D,
          isBuiltInAgent: K,
          startTime: F,
        },
        N = {
          agentDefinition: V,
          promptMessages: E ? [...E, ...w] : w,
          toolUseContext: Y,
          canUseTool: J,
          forkContextMessages: H,
          isAsync: Z === !0,
          querySource: vj2(V.agentType, K),
          model: I,
        };
      {
        let $ = G || $rA(),
          O = [],
          P = !1,
          k = Date.now();
        if (w[0] && w[0].type === "user") {
          let y = bY(w),
            c = y.find((e) => e.type === "user");
          if (c && c.type === "user" && W)
            W({
              toolUseID: `agent_${X.message.id}`,
              data: {
                message: c,
                normalizedMessages: y,
                type: "agent_progress",
                prompt: A,
                resume: G,
              },
            });
        }
        let b = () => {
            P = !0;
          },
          x = !1,
          m = setInterval(() => {
            let y = Date.now() - k;
          }, 100);
        try {
          for await (let y of H7A({ ...N, override: { agentId: $ } })) {
            if ((O.push(y), y.type !== "assistant" && y.type !== "user"))
              continue;
            E$A(
              y,
              () => {},
              (e) => Y.setResponseLength((QA) => QA + e.length),
              () => {},
              () => {},
            );
            let c = bY(O);
            for (let e of bY([y]))
              for (let QA of e.message.content) {
                if (QA.type !== "tool_use" && QA.type !== "tool_result")
                  continue;
                if (W)
                  W({
                    toolUseID: `agent_${X.message.id}`,
                    data: {
                      message: e,
                      normalizedMessages: c,
                      type: "agent_progress",
                      prompt: A,
                      resume: G,
                    },
                  });
              }
          }
        } finally {
          if (m) clearInterval(m);
          if (Y.setToolJSX) Y.setToolJSX(null);
        }
        let o = nV(
          O.filter((y) => y.type !== "system" && y.type !== "progress"),
        );
        if (o && trA(o)) throw new IX();
        let l = Hs5(O, $, L);
        return { data: { status: "completed", prompt: A, ...l } };
      }
    },
    isReadOnly() {
      return !0;
    },
    isConcurrencySafe() {
      return !0;
    },
    isEnabled() {
      return !0;
    },
    userFacingName: wf2,
    userFacingNameBackgroundColor: $f2,
    async checkPermissions(A) {
      return { behavior: "allow", updatedInput: A };
    },
    mapToolResultToToolResultBlockParam(A, B) {
      if (A.status === "async_launched")
        return {
          tool_use_id: B,
          type: "tool_result",
          content: [
            {
              type: "text",
              text: `Async agent launched successfully.
agentId: ${A.agentId} (This is an internal ID for your use, do not mention it to the user. Use this ID to retrieve results with ${H$A} when the agent finishes). 
The agent is currently working in the background. If you have other tasks you you should continue working on them now. Wait to call ${H$A} until either:
- If you want to check on the agent's progress - call ${H$A} with block=false to get an immediate update on the agent's status
- If you run out of things to do and the agent is still running - call ${H$A} with block=true to idle and wait for the agent's result (do not use block=true unless you completely run out of things to do as it will waste time).`,
            },
          ],
        };
      if (A.status === "completed")
        return { tool_use_id: B, type: "tool_result", content: A.content };
      throw Error(`Unexpected agent tool result status: ${A.status}`);
    },
    renderToolResultMessage: Ef2,
    renderToolUseMessage: Hf2,
    renderToolUseProgressMessage: k01,
    renderToolUseRejectedMessage: zf2,
    renderToolUseErrorMessage: Uf2,
  };
});
var yf2 = `
- Kills a running background bash shell by its ID
- Takes a shell_id parameter identifying the shell to kill
- Returns a success or failure status 
- Use this tool when you need to terminate a long-running shell
- Shell IDs can be found using the /bashes command
`;
function kf2({ shell_id: A }) {
  if (!A) return null;
  return `Kill shell: ${A}`;
}
function _f2() {
  return null;
}
function xf2() {
  return z7A.default.createElement(l5, null);
}
function vf2(A, { verbose: B }) {
  return z7A.default.createElement(H6, { result: A, verbose: B });
}
function bf2(A) {
  return z7A.default.createElement(
    S,
    null,
    z7A.default.createElement(U, null, " "),
    z7A.default.createElement(U, null, "Shell ", A.shell_id, " killed"),
  );
}
var z7A;
var ff2 = T(() => {
  nA();
  UF();
  qX();
  z7A = IA(KA(), 1);
});
var zs5, Us5, _01;
var LA0 = T(() => {
  e2();
  Rs();
  ff2();
  ((zs5 = _.strictObject({
    shell_id: _.string().describe("The ID of the background shell to kill"),
  })),
    (Us5 = _.object({
      message: _.string().describe("Status message about the operation"),
      shell_id: _.string().describe("The ID of the shell that was killed"),
    })),
    (_01 = {
      name: "KillShell",
      userFacingName: () => "Kill Shell",
      inputSchema: zs5,
      outputSchema: Us5,
      isEnabled() {
        return !0;
      },
      isConcurrencySafe() {
        return !0;
      },
      isReadOnly() {
        return !1;
      },
      async checkPermissions(A) {
        return { behavior: "allow", updatedInput: A };
      },
      async validateInput({ shell_id: A }, { getAppState: B }) {
        let I = (await B()).backgroundTasks[A];
        if (!I)
          return {
            result: !1,
            message: `No shell found with ID: ${A}`,
            errorCode: 1,
          };
        if (I.type !== "shell")
          return {
            result: !1,
            message: `Shell ${A} is not a shell`,
            errorCode: 2,
          };
        return { result: !0 };
      },
      async description() {
        return "Kill a background bash shell by ID";
      },
      async prompt() {
        return yf2;
      },
      mapToolResultToToolResultBlockParam(A, B) {
        return {
          tool_use_id: B,
          type: "tool_result",
          content: JSON.stringify(A),
        };
      },
      renderToolUseMessage: kf2,
      renderToolUseProgressMessage: _f2,
      renderToolUseRejectedMessage: xf2,
      renderToolUseErrorMessage: vf2,
      renderToolResultMessage: bf2,
      async call({ shell_id: A }, { getAppState: B, setAppState: Q }) {
        let G = (await B()).backgroundTasks[A];
        if (!G) throw Error(`No shell found with ID: ${A}`);
        if (G.type !== "shell") throw Error(`Shell ${A} is not a shell`);
        if (G.status !== "running")
          throw Error(
            `Shell ${A} is not running, so cannot be killed (status: ${G.status})`,
          );
        let Z = uiA(G);
        return (
          Q((Y) => ({
            ...Y,
            backgroundTasks: { ...Y.backgroundTasks, [A]: Z },
          })),
          {
            data: {
              message: `Successfully killed shell: ${A} (${G.command})`,
              shell_id: A,
            },
          }
        );
      },
    }));
});
function hf2() {
  return `
- Retrieves output from a running or completed background bash shell
- Takes a shell_id parameter identifying the shell
- Always returns only new output since the last check
- Returns stdout and stderr output along with shell status
- Supports optional regex filtering to show only lines matching a pattern
- Use this tool when you need to monitor or check the output of a long-running shell
- Shell IDs can be found using the /bashes command
`;
}
function MA0(A) {
  let B = Fs();
  if (A.length <= B)
    return {
      totalLines: A.split(`
`).length,
      truncatedContent: A,
    };
  let Q = A.slice(0, B),
    I = A.slice(B).split(`
`).length,
    G = `${Q}

... [${I} lines truncated] ...`;
  return {
    totalLines: A.split(`
`).length,
    truncatedContent: G,
  };
}
var gf2 = T(() => {
  f8A();
  qm();
});
function uf2(A, B, Q) {
  let I = {
    stdout: A.stdout,
    stderr: A.stderr,
    isImage: !1,
    dangerouslyDisableSandbox: !0,
    returnCodeInterpretation: A.error || void 0,
  };
  return Yt.createElement(js, { content: I, verbose: Q.verbose });
}
function mf2(A) {
  if (A?.filter) return `Reading shell output (filtered: ${A.filter})`;
  return "Reading shell output";
}
function df2() {
  return null;
}
function cf2() {
  return Yt.createElement(l5, null);
}
function pf2(A, { verbose: B }) {
  return Yt.createElement(H6, { result: A, verbose: B });
}
var Yt;
var lf2 = T(() => {
  UF();
  qX();
  aiA();
  Yt = IA(KA(), 1);
});
function if2(A, B) {
  if (!B || !A.trim()) return A;
  let Q = new RegExp(B, "i");
  return A.split(
    `
`,
  ).filter((Z) => Q.test(Z)).join(`
`);
}
var ws5, $s5, x01;
var OA0 = T(() => {
  e2();
  Rs();
  gf2();
  lf2();
  ((ws5 = _.object({
    shellId: _.string().describe("The ID of the background shell"),
    command: _.string().describe("The command that was run in the shell"),
    status: _.enum(["running", "completed", "failed", "killed"]).describe(
      "The current status of the shell command",
    ),
    exitCode: _.number()
      .nullable()
      .describe("The exit code of the command, if available"),
    stdout: _.string().describe("The standard output of the command"),
    stderr: _.string().describe("The standard error output of the command"),
    stdoutLines: _.number().describe(
      "Total number of lines in original stdout, even if truncated or filtered",
    ),
    stderrLines: _.number().describe(
      "Total number of lines in original stderr, even if truncated or filtered",
    ),
    error: _.string()
      .optional()
      .describe("Error message if the shell command failed"),
    filterPattern: _.string()
      .optional()
      .describe(
        "The regex pattern used for filtering (only present when filter is applied)",
      ),
    timestamp: _.string().describe(
      "The current timestamp when the output was retrieved",
    ),
  })),
    ($s5 = _.strictObject({
      bash_id: _.string().describe(
        "The ID of the background shell to retrieve output from",
      ),
      filter: _.string()
        .optional()
        .describe(
          "Optional regular expression to filter the output lines. Only lines matching this regex will be included in the result. Any lines that do not match will no longer be available to read.",
        ),
    })),
    (x01 = {
      name: "BashOutput",
      async description() {
        return "Retrieves output from a background bash shell";
      },
      async prompt() {
        return hf2();
      },
      userFacingName() {
        return "BashOutput";
      },
      isEnabled() {
        return !0;
      },
      inputSchema: $s5,
      outputSchema: ws5,
      isConcurrencySafe() {
        return !0;
      },
      isReadOnly() {
        return !0;
      },
      async checkPermissions(A) {
        return { behavior: "allow", updatedInput: A };
      },
      async validateInput({ bash_id: A, filter: B }, { getAppState: Q }) {
        if (B)
          try {
            new RegExp(B, "i");
          } catch (Z) {
            return {
              result: !1,
              message: `Invalid regex pattern "${B}": ${Z instanceof Error ? Z.message : String(Z)}`,
              errorCode: 1,
            };
          }
        let G = (await Q()).backgroundTasks[A];
        if (!G)
          return {
            result: !1,
            message: `No shell found with ID: ${A}`,
            errorCode: 2,
          };
        if (G.type !== "shell")
          return {
            result: !1,
            message: `Shell ${A} is not a shell`,
            errorCode: 3,
          };
        return { result: !0 };
      },
      async call({ bash_id: A, filter: B }, { getAppState: Q }) {
        let Z = (await Q()).backgroundTasks[A];
        if (!Z) throw Error(`No shell found with ID: ${A}`);
        if (Z.type !== "shell") throw Error(`Shell ${A} is not a shell`);
        let Y = giA(Z),
          J = if2(Y.stdout, B),
          X = if2(Y.stderr, B),
          { truncatedContent: W } = MA0(Sx(J)),
          { truncatedContent: F } = MA0(Sx(X)),
          C = Y.stdout.split(`
`).length,
          V = Y.stderr.split(`
`).length;
        return {
          data: {
            shellId: Z.id,
            command: Z.command,
            status: Z.status,
            exitCode: Z.result?.code ?? null,
            stdout: W,
            stderr: F,
            stdoutLines: C,
            stderrLines: V,
            timestamp: new Date().toISOString(),
            ...(B && { filterPattern: B }),
          },
        };
      },
      mapToolResultToToolResultBlockParam(A, B) {
        let Q = [];
        if (
          (Q.push(`<status>${A.status}</status>`),
          A.exitCode !== null && A.exitCode !== void 0)
        )
          Q.push(`<exit_code>${A.exitCode}</exit_code>`);
        if (A.stdout.trim())
          Q.push(`<stdout>
${A.stdout.trimEnd()}
</stdout>`);
        if (A.stderr.trim())
          Q.push(`<stderr>
${A.stderr.trim()}
</stderr>`);
        return (
          Q.push(`<timestamp>${A.timestamp}</timestamp>`),
          {
            tool_use_id: B,
            type: "tool_result",
            content: Q.join(`

`),
          }
        );
      },
      renderToolUseProgressMessage: df2,
      renderToolResultMessage: uf2,
      renderToolUseMessage: mf2,
      renderToolUseRejectedMessage: cf2,
      renderToolUseErrorMessage: pf2,
    }));
});
function qs5(A) {
  let B = 0,
    Q = 0;
  for (let I of A) if (typeof I !== "string") (B++, (Q += I.content.length));
  return { searchCount: B, totalResultCount: Q };
}
function nf2(
  { query: A, allowed_domains: B, blocked_domains: Q },
  { verbose: I },
) {
  if (!A) return null;
  let G = "";
  if (A) G += `"${A}"`;
  if (I) {
    if (B && B.length > 0) G += `, only allowing domains: ${B.join(", ")}`;
    if (Q && Q.length > 0) G += `, blocking domains: ${Q.join(", ")}`;
  }
  return G;
}
function af2() {
  return Ky.default.createElement(l5, null);
}
function sf2(A, { verbose: B }) {
  return Ky.default.createElement(H6, { result: A, verbose: B });
}
function rf2(A) {
  if (A.length === 0) return null;
  let B = A[A.length - 1];
  if (!B?.data) return null;
  let Q = B.data;
  switch (Q.type) {
    case "query_update":
      return Ky.default.createElement(
        j0,
        null,
        Ky.default.createElement(U, { dimColor: !0 }, "Searching: ", Q.query),
      );
    case "search_results_received":
      return Ky.default.createElement(
        j0,
        null,
        Ky.default.createElement(
          U,
          { dimColor: !0 },
          "Found ",
          Q.resultCount,
          ' results for "',
          Q.query,
          '"',
        ),
      );
    default:
      return null;
  }
}
function of2(A) {
  let { searchCount: B } = qs5(A.results),
    Q =
      A.durationSeconds >= 1
        ? `${Math.round(A.durationSeconds)}s`
        : `${Math.round(A.durationSeconds * 1000)}ms`;
  return Ky.default.createElement(
    S,
    { justifyContent: "space-between", width: "100%" },
    Ky.default.createElement(
      j0,
      { height: 1 },
      Ky.default.createElement(
        U,
        null,
        "Did ",
        B,
        " search",
        B !== 1 ? "es" : "",
        " in ",
        Q,
      ),
    ),
  );
}
var Ky;
var tf2 = T(() => {
  nA();
  L8();
  UF();
  qX();
  Ky = IA(KA(), 1);
});
function Ts5(A, B, Q) {
  let I = [],
    G = "",
    Z = !0;
  for (let Y of A) {
    if (Y.type === "server_tool_use") {
      if (Z) {
        if (((Z = !1), G.trim().length > 0)) I.push(G.trim());
        G = "";
      }
      continue;
    }
    if (Y.type === "web_search_tool_result") {
      if (!Array.isArray(Y.content)) {
        let X = `Web search error: ${Y.content.error_code}`;
        (BA(Error(X), kJ0), I.push(X));
        continue;
      }
      let J = Y.content.map((X) => ({ title: X.title, url: X.url }));
      I.push({ tool_use_id: Y.tool_use_id, content: J });
    }
    if (Y.type === "text")
      if (Z) G += Y.text;
      else ((Z = !0), (G = Y.text));
  }
  if (G.length) I.push(G.trim());
  return { query: B, results: I, durationSeconds: Q };
}
var Ns5,
  Ls5,
  Ms5,
  Os5,
  Rs5 = (A) => {
    return {
      type: "web_search_20250305",
      name: "web_search",
      allowed_domains: A.allowed_domains,
      blocked_domains: A.blocked_domains,
      max_uses: 8,
    };
  },
  z$A;
var RA0 = T(() => {
  e2();
  zG();
  iB();
  Y9();
  EH();
  c1();
  tf2();
  ((Ns5 = _.strictObject({
    query: _.string().min(2).describe("The search query to use"),
    allowed_domains: _.array(_.string())
      .optional()
      .describe("Only include search results from these domains"),
    blocked_domains: _.array(_.string())
      .optional()
      .describe("Never include search results from these domains"),
  })),
    (Ls5 = _.object({
      title: _.string().describe("The title of the search result"),
      url: _.string().describe("The URL of the search result"),
    })),
    (Ms5 = _.object({
      tool_use_id: _.string().describe("ID of the tool use"),
      content: _.array(Ls5).describe("Array of search hits"),
    })),
    (Os5 = _.object({
      query: _.string().describe("The search query that was executed"),
      results: _.array(_.union([Ms5, _.string()])).describe(
        "Search results and/or text commentary from the model",
      ),
      durationSeconds: _.number().describe(
        "Time taken to complete the search operation",
      ),
    })));
  z$A = {
    name: xn,
    async description(A) {
      return `Claude wants to search the web for: ${A.query}`;
    },
    userFacingName() {
      return "Web Search";
    },
    isEnabled() {
      let A = g3(),
        B = mI();
      if (A === "firstParty") return !0;
      if (A === "vertex")
        return (
          B.includes("claude-opus-4") ||
          B.includes("claude-sonnet-4") ||
          B.includes("claude-haiku-4")
        );
      return !1;
    },
    inputSchema: Ns5,
    outputSchema: Os5,
    isConcurrencySafe() {
      return !0;
    },
    isReadOnly() {
      return !0;
    },
    async checkPermissions(A) {
      return {
        behavior: "passthrough",
        message: "WebSearchTool requires permission.",
      };
    },
    async prompt() {
      return FUB;
    },
    renderToolUseMessage: nf2,
    renderToolUseRejectedMessage: af2,
    renderToolUseErrorMessage: sf2,
    renderToolUseProgressMessage: rf2,
    renderToolResultMessage: of2,
    async validateInput(A) {
      let { query: B, allowed_domains: Q, blocked_domains: I } = A;
      if (!B.length)
        return { result: !1, message: "Error: Missing query", errorCode: 1 };
      if (Q && I)
        return {
          result: !1,
          message:
            "Error: Cannot specify both allowed_domains and blocked_domains in the same request",
          errorCode: 2,
        };
      return { result: !0 };
    },
    async call(A, B, Q, I, G) {
      let Z = performance.now(),
        { query: Y } = A,
        J = T0({ content: "Perform a web search for the query: " + Y }),
        X = Rs5(A),
        W = J6A({
          messages: [J],
          systemPrompt: [
            "You are an assistant for performing a web search tool use",
          ],
          maxThinkingTokens: B.options.maxThinkingTokens,
          tools: [],
          signal: B.abortController.signal,
          options: {
            getToolPermissionContext: async () => {
              return (await B.getAppState()).toolPermissionContext;
            },
            model: mI(),
            toolChoice: void 0,
            isNonInteractiveSession: B.options.isNonInteractiveSession,
            hasAppendSystemPrompt: B.options.hasAppendSystemPrompt,
            extraToolSchemas: [X],
            querySource: "web_search_tool",
            agents: B.options.agentDefinitions.activeAgents,
            mcpTools: [],
          },
        }),
        F = [],
        C = null,
        V = "",
        K = 0,
        D = new Map();
      for await (let $ of W) {
        if (
          (F.push($),
          $.type === "stream_event" && $.event?.type === "content_block_start")
        ) {
          let O = $.event.content_block;
          if (O && O.type === "server_tool_use") {
            ((C = O.id), (V = ""));
            continue;
          }
        }
        if (
          C &&
          $.type === "stream_event" &&
          $.event?.type === "content_block_delta"
        ) {
          let O = $.event.delta;
          if (O?.type === "input_json_delta" && O.partial_json) {
            V += O.partial_json;
            try {
              let P = V.match(/"query"\s*:\s*"((?:[^"\\]|\\.)*)"/);
              if (P && P[1]) {
                let k = JSON.parse('"' + P[1] + '"');
                if (!D.has(C) || D.get(C) !== k) {
                  if ((D.set(C, k), K++, G))
                    G({
                      toolUseID: `search-progress-${K}`,
                      data: { type: "query_update", query: k },
                    });
                }
              }
            } catch {}
          }
        }
        if (
          $.type === "stream_event" &&
          $.event?.type === "content_block_start"
        ) {
          let O = $.event.content_block;
          if (O && O.type === "web_search_tool_result") {
            let P = O.tool_use_id,
              k = D.get(P) || Y,
              b = O.content;
            if ((K++, G))
              G({
                toolUseID: P || `search-progress-${K}`,
                data: {
                  type: "search_results_received",
                  resultCount: Array.isArray(b) ? b.length : 0,
                  query: k,
                },
              });
          }
        }
      }
      let H = F.filter(($) => $.type === "assistant").flatMap(
          ($) => $.message.content,
        ),
        L = (performance.now() - Z) / 1000;
      return { data: Ts5(H, Y, L) };
    },
    mapToolResultToToolResultBlockParam(A, B) {
      let { query: Q, results: I } = A,
        G = `Web search results for query: "${Q}"

`;
      return (
        I.forEach((Z) => {
          if (typeof Z === "string")
            G +=
              Z +
              `

`;
          else if (Z.content.length > 0)
            G += `Links: ${JSON.stringify(Z.content)}

`;
          else
            G += `No links found.

`;
        }),
        { tool_use_id: B, type: "tool_result", content: G.trim() }
      );
    },
  };
});
var Dc7;
var ef2 = T(() => {
  e2();
  Dc7 = _.strictObject({});
});
var Ps5, js5, Ss5, ys5, ks5, Ah2;
var Bh2 = T(() => {
  e2();
  ((Ps5 = _.strictObject({
    operation: _.literal("goToDefinition"),
    filePath: _.string().describe("The absolute or relative path to the file"),
    line: _.number()
      .int()
      .nonnegative()
      .describe("The line number (0-indexed) in the file"),
    character: _.number()
      .int()
      .nonnegative()
      .describe("The character offset (0-indexed) on the line"),
  })),
    (js5 = _.strictObject({
      operation: _.literal("findReferences"),
      filePath: _.string().describe(
        "The absolute or relative path to the file",
      ),
      line: _.number()
        .int()
        .nonnegative()
        .describe("The line number (0-indexed) in the file"),
      character: _.number()
        .int()
        .nonnegative()
        .describe("The character offset (0-indexed) on the line"),
    })),
    (Ss5 = _.strictObject({
      operation: _.literal("hover"),
      filePath: _.string().describe(
        "The absolute or relative path to the file",
      ),
      line: _.number()
        .int()
        .nonnegative()
        .describe("The line number (0-indexed) in the file"),
      character: _.number()
        .int()
        .nonnegative()
        .describe("The character offset (0-indexed) on the line"),
    })),
    (ys5 = _.strictObject({
      operation: _.literal("documentSymbol"),
      filePath: _.string().describe(
        "The absolute or relative path to the file",
      ),
      line: _.number()
        .int()
        .nonnegative()
        .describe("The line number (0-indexed) in the file"),
      character: _.number()
        .int()
        .nonnegative()
        .describe("The character offset (0-indexed) on the line"),
    })),
    (ks5 = _.strictObject({
      operation: _.literal("workspaceSymbol"),
      filePath: _.string().describe(
        "The absolute or relative path to the file",
      ),
      line: _.number()
        .int()
        .nonnegative()
        .describe("The line number (0-indexed) in the file"),
      character: _.number()
        .int()
        .nonnegative()
        .describe("The character offset (0-indexed) on the line"),
    })),
    (Ah2 = _.discriminatedUnion("operation", [Ps5, js5, Ss5, ys5, ks5])));
});
import { relative as _s5 } from "path";
function Gh2(A, B) {
  if (!A)
    return (
      g(
        "formatUri called with undefined URI - indicates malformed LSP server response",
        { level: "warn" },
      ),
      "<unknown location>"
    );
  let Q = A.replace(/^file:\/\//, "");
  try {
    Q = decodeURIComponent(Q);
  } catch (I) {
    let G = I instanceof Error ? I.message : String(I);
    g(`Failed to decode LSP URI '${A}': ${G}. Using un-decoded path: ${Q}`, {
      level: "warn",
    });
  }
  if (B) {
    let I = _s5(B, Q);
    if (I.length < Q.length && !I.startsWith("../../")) return I;
  }
  return Q;
}
function Zh2(A, B) {
  let Q = new Map();
  for (let I of A) {
    let G = "uri" in I ? I.uri : I.location.uri,
      Z = Gh2(G, B),
      Y = Q.get(Z);
    if (Y) Y.push(I);
    else Q.set(Z, [I]);
  }
  return Q;
}
function v01(A, B) {
  let Q = Gh2(A.uri, B),
    I = A.range.start.line + 1,
    G = A.range.start.character + 1;
  return `${Q}:${I}:${G}`;
}
function Qh2(A) {
  return { uri: A.targetUri, range: A.targetSelectionRange || A.targetRange };
}
function Ih2(A) {
  return "targetUri" in A;
}
function Yh2(A, B) {
  if (!A) return "No definition found";
  if (Array.isArray(A)) {
    let I = A.map((J) => (Ih2(J) ? Qh2(J) : J)),
      G = I.filter((J) => !J || !J.uri);
    if (G.length > 0)
      g(
        `formatGoToDefinitionResult: Filtering out ${G.length} invalid location(s) - this should have been caught earlier`,
        { level: "warn" },
      );
    let Z = I.filter((J) => J && J.uri);
    if (Z.length === 0) return "No definition found";
    if (Z.length === 1) return `Defined in ${v01(Z[0], B)}`;
    let Y = Z.map((J) => `  ${v01(J, B)}`).join(`
`);
    return `Found ${Z.length} definitions:
${Y}`;
  }
  let Q = Ih2(A) ? Qh2(A) : A;
  return `Defined in ${v01(Q, B)}`;
}
function Jh2(A, B) {
  if (!A || A.length === 0) return "No references found";
  let Q = A.filter((Y) => !Y || !Y.uri);
  if (Q.length > 0)
    g(
      `formatFindReferencesResult: Filtering out ${Q.length} invalid location(s) - this should have been caught earlier`,
      { level: "warn" },
    );
  let I = A.filter((Y) => Y && Y.uri);
  if (I.length === 0) return "No references found";
  if (I.length === 1)
    return `Found 1 reference:
  ${v01(I[0], B)}`;
  let G = Zh2(I, B),
    Z = [`Found ${I.length} references across ${G.size} files:`];
  for (let [Y, J] of G) {
    Z.push(`
${Y}:`);
    for (let X of J) {
      let W = X.range.start.line + 1,
        F = X.range.start.character + 1;
      Z.push(`  Line ${W}:${F}`);
    }
  }
  return Z.join(`
`);
}
function xs5(A) {
  if (Array.isArray(A))
    return A.map((B) => {
      if (typeof B === "string") return B;
      return B.value;
    }).join(`

`);
  if (typeof A === "string") return A;
  if ("kind" in A) return A.value;
  return A.value;
}
function Xh2(A, B) {
  if (!A) return "No hover information available";
  let Q = xs5(A.contents);
  if (A.range) {
    let I = A.range.start.line + 1,
      G = A.range.start.character + 1;
    return `Hover info at ${I}:${G}:

${Q}`;
  }
  return Q;
}
function Wh2(A) {
  return (
    {
      [1]: "File",
      [2]: "Module",
      [3]: "Namespace",
      [4]: "Package",
      [5]: "Class",
      [6]: "Method",
      [7]: "Property",
      [8]: "Field",
      [9]: "Constructor",
      [10]: "Enum",
      [11]: "Interface",
      [12]: "Function",
      [13]: "Variable",
      [14]: "Constant",
      [15]: "String",
      [16]: "Number",
      [17]: "Boolean",
      [18]: "Array",
      [19]: "Object",
      [20]: "Key",
      [21]: "Null",
      [22]: "EnumMember",
      [23]: "Struct",
      [24]: "Event",
      [25]: "Operator",
      [26]: "TypeParameter",
    }[A] || "Unknown"
  );
}
function Fh2(A, B = 0) {
  let Q = [],
    I = "  ".repeat(B),
    G = Wh2(A.kind),
    Z = `${I}${A.name} (${G})`;
  if (A.detail) Z += ` ${A.detail}`;
  let Y = A.range.start.line + 1;
  if (((Z += ` - Line ${Y}`), Q.push(Z), A.children && A.children.length > 0))
    for (let J of A.children) Q.push(...Fh2(J, B + 1));
  return Q;
}
function Ch2(A, B) {
  if (!A || A.length === 0) return "No symbols found in document";
  let Q = ["Document symbols:"];
  for (let I of A) Q.push(...Fh2(I));
  return Q.join(`
`);
}
function Vh2(A, B) {
  if (!A || A.length === 0) return "No symbols found in workspace";
  let Q = A.filter((Y) => !Y || !Y.location || !Y.location.uri);
  if (Q.length > 0)
    g(
      `formatWorkspaceSymbolResult: Filtering out ${Q.length} invalid symbol(s) - this should have been caught earlier`,
      { level: "warn" },
    );
  let I = A.filter((Y) => Y && Y.location && Y.location.uri);
  if (I.length === 0) return "No symbols found in workspace";
  let G = [
      `Found ${I.length} symbol${I.length === 1 ? "" : "s"} in workspace:`,
    ],
    Z = Zh2(I, B);
  for (let [Y, J] of Z) {
    G.push(`
${Y}:`);
    for (let X of J) {
      let W = Wh2(X.kind),
        F = X.location.range.start.line + 1,
        C = `  ${X.name} (${W}) - Line ${F}`;
      if (X.containerName) C += ` in ${X.containerName}`;
      G.push(C);
    }
  }
  return G.join(`
`);
}
var Kh2 = T(() => {
  C0();
});
var Dh2 = "LSP",
  TA0 = `Interact with Language Server Protocol (LSP) servers to get code intelligence features.

Supported operations:
- goToDefinition: Find where a symbol is defined
- findReferences: Find all references to a symbol
- hover: Get hover information (documentation, type info) for a symbol
- documentSymbol: Get all symbols (functions, classes, variables) in a document
- workspaceSymbol: Search for symbols across the entire workspace

All operations require:
- filePath: The file to operate on
- line: The line number (0-indexed)
- character: The character offset (0-indexed) on the line

Note: LSP servers must be configured for the file type. If no server is available, an error will be returned.`;
function Eh2(A, B, Q) {
  try {
    let I = NA(),
      G = M9(A);
    if (!I.existsSync(G)) return null;
    let Y = I.readFileSync(G, { encoding: "utf-8" }).split(`
`);
    if (B < 0 || B >= Y.length) return null;
    let J = Y[B];
    if (!J || Q < 0 || Q >= J.length) return null;
    let X = /[\w$'!]+|[+\-*/%&|^~<>=]+/g,
      W;
    while ((W = X.exec(J)) !== null) {
      let F = W.index,
        C = F + W[0].length;
      if (Q >= F && Q < C) {
        let V = W[0];
        return V.length > 30 ? V.slice(0, 27) + "..." : V;
      }
    }
    return null;
  } catch (I) {
    if (I instanceof Error)
      g(`Symbol extraction failed for ${A}:${B}:${Q}: ${I.message}`, {
        level: "warn",
      });
    return null;
  }
}
var Hh2 = T(() => {
  m0();
  hG();
  C0();
});
function bs5({
  operation: A,
  resultCount: B,
  fileCount: Q,
  content: I,
  verbose: G,
}) {
  let Z = vs5[A] || { singular: "result", plural: "results" },
    Y = B === 1 ? Z.singular : Z.plural,
    J =
      A === "hover" && B > 0 && Z.special
        ? CZ.default.createElement(
            CZ.default.Fragment,
            null,
            "Hover info ",
            Z.special,
          )
        : CZ.default.createElement(
            CZ.default.Fragment,
            null,
            "Found ",
            CZ.default.createElement(U, { bold: !0 }, B, " "),
            Y,
          ),
    X =
      Q > 1
        ? CZ.default.createElement(
            CZ.default.Fragment,
            null,
            " ",
            "across ",
            CZ.default.createElement(U, { bold: !0 }, Q, " "),
            "files",
          )
        : null;
  if (G)
    return CZ.default.createElement(
      S,
      { flexDirection: "column" },
      CZ.default.createElement(
        S,
        { flexDirection: "row" },
        CZ.default.createElement(U, null, " ", J, X),
      ),
      CZ.default.createElement(
        S,
        { marginLeft: 5 },
        CZ.default.createElement(U, null, I),
      ),
    );
  return CZ.default.createElement(
    j0,
    { height: 1 },
    CZ.default.createElement(
      U,
      null,
      J,
      X,
      " ",
      B > 0 && CZ.default.createElement(su, null),
    ),
  );
}
function zh2() {
  return "LSP";
}
function Uh2(A, { verbose: B }) {
  if (!A.operation) return null;
  let Q = [];
  if (
    (A.operation === "goToDefinition" ||
      A.operation === "findReferences" ||
      A.operation === "hover") &&
    A.filePath &&
    A.line !== void 0 &&
    A.character !== void 0
  ) {
    let I = Eh2(A.filePath, A.line, A.character),
      G = B ? A.filePath : TY(A.filePath);
    if (I)
      (Q.push(`operation: "${A.operation}"`),
        Q.push(`symbol: "${I}"`),
        Q.push(`in: "${G}"`));
    else
      (Q.push(`operation: "${A.operation}"`),
        Q.push(`file: "${G}"`),
        Q.push(`position: ${A.line}:${A.character}`));
    return Q.join(", ");
  }
  if ((Q.push(`operation: "${A.operation}"`), A.filePath)) {
    let I = B ? A.filePath : TY(A.filePath);
    Q.push(`file: "${I}"`);
  }
  return Q.join(", ");
}
function wh2() {
  return CZ.default.createElement(l5, null);
}
function $h2(A, { verbose: B }) {
  if (!B && typeof A === "string" && g2(A, "tool_use_error"))
    return CZ.default.createElement(
      j0,
      null,
      CZ.default.createElement(U, { color: "error" }, "LSP operation failed"),
    );
  return CZ.default.createElement(H6, { result: A, verbose: B });
}
function qh2() {
  return null;
}
function Nh2(A, B, { verbose: Q }) {
  if (A.resultCount !== void 0 && A.fileCount !== void 0)
    return CZ.default.createElement(bs5, {
      operation: A.operation,
      resultCount: A.resultCount,
      fileCount: A.fileCount,
      content: A.result,
      verbose: Q,
    });
  return CZ.default.createElement(
    j0,
    null,
    CZ.default.createElement(U, null, A.result),
  );
}
var CZ, vs5;
var Lh2 = T(() => {
  nA();
  UF();
  qX();
  L8();
  f4A();
  iB();
  Z4();
  Hh2();
  ((CZ = IA(KA(), 1)),
    (vs5 = {
      goToDefinition: { singular: "definition", plural: "definitions" },
      findReferences: { singular: "reference", plural: "references" },
      documentSymbol: { singular: "symbol", plural: "symbols" },
      workspaceSymbol: { singular: "symbol", plural: "symbols" },
      hover: {
        singular: "hover info",
        plural: "hover info",
        special: "available",
      },
    }));
});
import { pathToFileURL as fs5 } from "url";
import * as jA0 from "path";
function us5(A, B) {
  let Q = fs5(B).href,
    I = { line: A.line, character: A.character };
  switch (A.operation) {
    case "goToDefinition":
      return {
        method: "textDocument/definition",
        params: { textDocument: { uri: Q }, position: I },
      };
    case "findReferences":
      return {
        method: "textDocument/references",
        params: {
          textDocument: { uri: Q },
          position: I,
          context: { includeDeclaration: !0 },
        },
      };
    case "hover":
      return {
        method: "textDocument/hover",
        params: { textDocument: { uri: Q }, position: I },
      };
    case "documentSymbol":
      return {
        method: "textDocument/documentSymbol",
        params: { textDocument: { uri: Q } },
      };
    case "workspaceSymbol":
      return { method: "workspace/symbol", params: { query: "" } };
  }
}
function Mh2(A) {
  let B = A.length;
  for (let Q of A)
    if (Q.children && Q.children.length > 0) B += Mh2(Q.children);
  return B;
}
function PA0(A) {
  return new Set(A.map((B) => B.uri)).size;
}
function ms5(A) {
  return "targetUri" in A;
}
function ds5(A) {
  if (ms5(A))
    return { uri: A.targetUri, range: A.targetSelectionRange || A.targetRange };
  return A;
}
function cs5(A, B, Q) {
  switch (A) {
    case "goToDefinition": {
      let G = (Array.isArray(B) ? B : B ? [B] : []).map(ds5),
        Z = G.filter((J) => !J || !J.uri);
      if (Z.length > 0)
        BA(
          Error(
            `LSP server returned ${Z.length} location(s) with undefined URI for goToDefinition on ${Q}. This indicates malformed data from the LSP server.`,
          ),
          yl,
        );
      let Y = G.filter((J) => J && J.uri);
      return { formatted: Yh2(B, Q), resultCount: Y.length, fileCount: PA0(Y) };
    }
    case "findReferences": {
      let I = B || [],
        G = I.filter((Y) => !Y || !Y.uri);
      if (G.length > 0)
        BA(
          Error(
            `LSP server returned ${G.length} location(s) with undefined URI for findReferences on ${Q}. This indicates malformed data from the LSP server.`,
          ),
          yl,
        );
      let Z = I.filter((Y) => Y && Y.uri);
      return { formatted: Jh2(B, Q), resultCount: Z.length, fileCount: PA0(Z) };
    }
    case "hover":
      return {
        formatted: Xh2(B, Q),
        resultCount: B ? 1 : 0,
        fileCount: B ? 1 : 0,
      };
    case "documentSymbol": {
      let I = B || [],
        G = I.length > 0 ? Mh2(I) : 0;
      return {
        formatted: Ch2(B, Q),
        resultCount: G,
        fileCount: I.length > 0 ? 1 : 0,
      };
    }
    case "workspaceSymbol": {
      let I = B || [],
        G = I.filter((J) => !J || !J.location || !J.location.uri);
      if (G.length > 0)
        BA(
          Error(
            `LSP server returned ${G.length} symbol(s) with undefined location URI for workspaceSymbol on ${Q}. This indicates malformed data from the LSP server.`,
          ),
          yl,
        );
      let Z = I.filter((J) => J && J.location && J.location.uri),
        Y = Z.map((J) => J.location);
      return { formatted: Vh2(B, Q), resultCount: Z.length, fileCount: PA0(Y) };
    }
  }
}
var hs5, gs5, SA0;
var Oh2 = T(() => {
  e2();
  Bh2();
  Kh2();
  o8A();
  hG();
  V2();
  m0();
  KJ();
  c1();
  C0();
  Lh2();
  ((hs5 = _.strictObject({
    operation: _.enum([
      "goToDefinition",
      "findReferences",
      "hover",
      "documentSymbol",
      "workspaceSymbol",
    ]).describe("The LSP operation to perform"),
    filePath: _.string().describe("The absolute or relative path to the file"),
    line: _.number()
      .int()
      .nonnegative()
      .describe("The line number (0-indexed) in the file"),
    character: _.number()
      .int()
      .nonnegative()
      .describe("The character offset (0-indexed) on the line"),
  })),
    (gs5 = _.object({
      operation: _.enum([
        "goToDefinition",
        "findReferences",
        "hover",
        "documentSymbol",
        "workspaceSymbol",
      ]).describe("The LSP operation that was performed"),
      result: _.string().describe("The formatted result of the LSP operation"),
      filePath: _.string().describe(
        "The file path the operation was performed on",
      ),
      resultCount: _.number()
        .int()
        .nonnegative()
        .optional()
        .describe("Number of results (definitions, references, symbols)"),
      fileCount: _.number()
        .int()
        .nonnegative()
        .optional()
        .describe("Number of files containing results"),
    })),
    (SA0 = {
      name: Dh2,
      async description() {
        return TA0;
      },
      userFacingName: zh2,
      isEnabled() {
        return !0;
      },
      inputSchema: hs5,
      outputSchema: gs5,
      isConcurrencySafe() {
        return !0;
      },
      isReadOnly() {
        return !0;
      },
      getPath({ filePath: A }) {
        return M9(A);
      },
      async validateInput(A) {
        let B = Ah2.safeParse(A);
        if (!B.success)
          return {
            result: !1,
            message: `Invalid input: ${B.error.message}`,
            errorCode: 3,
          };
        let Q = NA(),
          I = M9(A.filePath);
        if (!Q.existsSync(I))
          return {
            result: !1,
            message: `File does not exist: ${A.filePath}`,
            errorCode: 1,
          };
        try {
          if (!Q.statSync(I).isFile())
            return {
              result: !1,
              message: `Path is not a file: ${A.filePath}`,
              errorCode: 2,
            };
        } catch (G) {
          let Z = G instanceof Error ? G : Error(String(G));
          return (
            BA(
              Error(
                `Failed to access file stats for LSP operation on ${A.filePath}: ${Z.message}`,
              ),
              j7,
            ),
            {
              result: !1,
              message: `Cannot access file: ${A.filePath}. ${Z.message}`,
              errorCode: 4,
            }
          );
        }
        return { result: !0 };
      },
      async checkPermissions(A, B) {
        let Q = await B.getAppState();
        return jm(SA0, A, Q.toolPermissionContext);
      },
      async prompt() {
        return TA0;
      },
      renderToolUseMessage: Uh2,
      renderToolUseRejectedMessage: wh2,
      renderToolUseErrorMessage: $h2,
      renderToolUseProgressMessage: qh2,
      renderToolResultMessage: Nh2,
      async call(A, B) {
        let Q = M9(A.filePath),
          I = G0(),
          G = Tm();
        if (!G)
          return (
            BA(
              Error("LSP server manager not initialized when tool was called"),
              dMA,
            ),
            {
              data: {
                operation: A.operation,
                result:
                  "LSP server manager not initialized. This may indicate a startup issue.",
                filePath: A.filePath,
              },
            }
          );
        let { method: Z, params: Y } = us5(A, Q);
        try {
          let J = await G.sendRequest(Q, Z, Y);
          if (J === void 0)
            return (
              g(
                `No LSP server available for file type ${jA0.extname(Q)} for operation ${A.operation} on file ${A.filePath}`,
              ),
              {
                data: {
                  operation: A.operation,
                  result: `No LSP server available for file type: ${jA0.extname(Q)}`,
                  filePath: A.filePath,
                },
              }
            );
          let {
            formatted: X,
            resultCount: W,
            fileCount: F,
          } = cs5(A.operation, J, I);
          return {
            data: {
              operation: A.operation,
              result: X,
              filePath: A.filePath,
              resultCount: W,
              fileCount: F,
            },
          };
        } catch (J) {
          let W = (J instanceof Error ? J : Error(String(J))).message;
          return (
            BA(
              Error(
                `LSP tool request failed for ${A.operation} on ${A.filePath}: ${W}`,
              ),
              j7,
            ),
            {
              data: {
                operation: A.operation,
                result: `Error performing ${A.operation}: ${W}`,
                filePath: A.filePath,
              },
            }
          );
        }
      },
      mapToolResultToToolResultBlockParam(A, B) {
        return { tool_use_id: B, type: "tool_result", content: A.result };
      },
    }));
});
var ps5;
var Rh2 = T(() => {
  nA();
  UF();
  qX();
  ps5 = IA(KA(), 1);
});
var Hp7, zp7;
var Th2 = T(() => {
  e2();
  Rh2();
  orA();
  iB();
  tq();
  H0();
  ((Hp7 = _.strictObject({
    message_prefix: _.string().describe(
      "The prefix of the user message to rewind to (searches backwards for first match)",
    ),
    course_correction: _.string().describe(
      "The new instructions to inject after rewinding, explaining what to do differently",
    ),
    restore_code: _.boolean()
      .default(!0)
      .describe(
        "Whether to restore code changes using file history (default: true)",
      ),
  })),
    (zp7 = _.object({
      target_message_preview: _.string().describe(
        "Preview of the message that was rewound to",
      ),
      course_correction: _.string().describe(
        "The course correction that was injected",
      ),
      code_restored: _.boolean().describe("Whether code was restored"),
    })));
});
var Ph2 = `
Lists available resources from configured MCP servers.
Each resource object includes a 'server' field indicating which server it's from.

Usage examples:
- List all resources from all servers: \`listMcpResources\`
- List resources from a specific server: \`listMcpResources({ server: "myserver" })\`
`,
  jh2 = `
List available resources from configured MCP servers.
Each returned resource will include all standard MCP resource fields plus a 'server' field 
indicating which server the resource belongs to.

Parameters:
- server (optional): The name of a specific MCP server to get resources from. If not provided,
  resources from all servers will be returned.
`;
function Sh2(A) {
  return A.server
    ? `List MCP resources from server "${A.server}"`
    : "List all MCP resources";
}
function yh2() {
  return DE.createElement(l5, null);
}
function kh2(A, { verbose: B }) {
  return DE.createElement(H6, { result: A, verbose: B });
}
function _h2() {
  return null;
}
function xh2(A, B, { verbose: Q }) {
  if (!A || A.length === 0)
    return DE.createElement(
      S,
      { justifyContent: "space-between", overflowX: "hidden", width: "100%" },
      DE.createElement(
        S,
        { flexDirection: "row" },
        DE.createElement(U, null, " "),
        DE.createElement(U, { dimColor: !0 }, "(No resources found)"),
      ),
    );
  let I = JSON.stringify(A, null, 2);
  return DE.createElement(dH, { content: I, verbose: Q });
}
var DE;
var vh2 = T(() => {
  nA();
  UF();
  qX();
  h4A();
  DE = IA(KA(), 1);
});
var ls5, is5, $b;
var b01 = T(() => {
  e2();
  UD();
  c1();
  vh2();
  ((ls5 = _.object({
    server: _.string()
      .optional()
      .describe("Optional server name to filter resources by"),
  })),
    (is5 = _.array(
      _.object({
        uri: _.string().describe("Resource URI"),
        name: _.string().describe("Resource name"),
        mimeType: _.string().optional().describe("MIME type of the resource"),
        description: _.string().optional().describe("Resource description"),
        server: _.string().describe("Server that provides this resource"),
      }),
    )),
    ($b = {
      isEnabled() {
        return !0;
      },
      isConcurrencySafe() {
        return !0;
      },
      isReadOnly() {
        return !0;
      },
      name: "ListMcpResourcesTool",
      async description() {
        return Ph2;
      },
      async prompt() {
        return jh2;
      },
      inputSchema: ls5,
      outputSchema: is5,
      async call(A, { options: { mcpClients: B } }) {
        let Q = [],
          { server: I } = A,
          G = I ? B.filter((Z) => Z.name === I) : B;
        if (I && G.length === 0)
          throw Error(
            `Server "${I}" not found. Available servers: ${B.map((Z) => Z.name).join(", ")}`,
          );
        for (let Z of G) {
          if (Z.type !== "connected") continue;
          let Y = Z;
          try {
            if (!Y.capabilities?.resources) continue;
            let J = await Y.client.request({ method: "resources/list" }, $l);
            if (!J.resources) continue;
            let X = J.resources.map((W) => ({ ...W, server: Z.name }));
            Q.push(...X);
          } catch (J) {
            OG(
              Z.name,
              `Failed to fetch resources: ${J instanceof Error ? J.message : String(J)}`,
            );
          }
        }
        return { data: Q };
      },
      async checkPermissions(A) {
        return { behavior: "allow", updatedInput: A };
      },
      renderToolUseMessage: Sh2,
      userFacingName: () => "listMcpResources",
      renderToolUseRejectedMessage: yh2,
      renderToolUseErrorMessage: kh2,
      renderToolUseProgressMessage: _h2,
      renderToolResultMessage: xh2,
      mapToolResultToToolResultBlockParam(A, B) {
        return {
          tool_use_id: B,
          type: "tool_result",
          content: JSON.stringify(A),
        };
      },
    }));
});
var bh2 = `
Reads a specific resource from an MCP server.
- server: The name of the MCP server to read from
- uri: The URI of the resource to read

Usage examples:
- Read a resource from a server: \`readMcpResource({ server: "myserver", uri: "my-resource-uri" })\`
`,
  fh2 = `
Reads a specific resource from an MCP server, identified by server name and resource URI.

Parameters:
- server (required): The name of the MCP server from which to read the resource
- uri (required): The URI of the resource to read
`;
function hh2(A) {
  if (!A.uri || !A.server) return null;
  return `Read resource "${A.uri}" from server "${A.server}"`;
}
function gh2() {
  return "readMcpResource";
}
function uh2() {
  return pw.createElement(l5, null);
}
function mh2(A, { verbose: B }) {
  return pw.createElement(H6, { result: A, verbose: B });
}
function dh2() {
  return null;
}
function ch2(A, B, { verbose: Q }) {
  if (!A || !A.contents || A.contents.length === 0)
    return pw.createElement(
      S,
      { justifyContent: "space-between", overflowX: "hidden", width: "100%" },
      pw.createElement(
        j0,
        { height: 1 },
        pw.createElement(U, { dimColor: !0 }, "(No content)"),
      ),
    );
  let I = JSON.stringify(A, null, 2);
  return pw.createElement(dH, { content: I, verbose: Q });
}
var pw;
var ph2 = T(() => {
  nA();
  UF();
  qX();
  L8();
  h4A();
  pw = IA(KA(), 1);
});
var ns5, as5, qb;
var f01 = T(() => {
  e2();
  UD();
  ph2();
  ((ns5 = _.object({
    server: _.string().describe("The MCP server name"),
    uri: _.string().describe("The resource URI to read"),
  })),
    (as5 = _.object({
      contents: _.array(
        _.object({
          uri: _.string().describe("Resource URI"),
          mimeType: _.string().optional().describe("MIME type of the content"),
          text: _.string().optional().describe("Text content of the resource"),
        }),
      ),
    })),
    (qb = {
      isEnabled() {
        return !0;
      },
      isConcurrencySafe() {
        return !0;
      },
      isReadOnly() {
        return !0;
      },
      name: "ReadMcpResourceTool",
      async description() {
        return bh2;
      },
      async prompt() {
        return fh2;
      },
      inputSchema: ns5,
      outputSchema: as5,
      async call(A, { options: { mcpClients: B } }) {
        let { server: Q, uri: I } = A,
          G = B.find((J) => J.name === Q);
        if (!G)
          throw Error(
            `Server "${Q}" not found. Available servers: ${B.map((J) => J.name).join(", ")}`,
          );
        if (G.type !== "connected")
          throw Error(`Server "${Q}" is not connected`);
        let Z = G;
        if (!Z.capabilities?.resources)
          throw Error(`Server "${Q}" does not support resources`);
        return {
          data: await Z.client.request(
            { method: "resources/read", params: { uri: I } },
            ZZA,
          ),
        };
      },
      async checkPermissions(A) {
        return { behavior: "allow", updatedInput: A };
      },
      renderToolUseMessage: hh2,
      userFacingName: gh2,
      renderToolUseRejectedMessage: uh2,
      renderToolUseErrorMessage: mh2,
      renderToolUseProgressMessage: dh2,
      renderToolResultMessage: ch2,
      mapToolResultToToolResultBlockParam(A, B) {
        return {
          tool_use_id: B,
          type: "tool_result",
          content: JSON.stringify(A),
        };
      },
    }));
});
function lh2(A) {
  let B = A.toLowerCase();
  if (!ss5.includes(B)) return null;
  return B;
}
function yA0() {
  let A = kA0(),
    B = A.map((Q) => Q.isEnabled());
  return A.filter((Q, I) => B[I]).map((Q) => Q.name);
}
function kA0() {
  return [
    dm,
    r2,
    $N,
    pj,
    JR,
    t4,
    Qz,
    QV,
    dO,
    RJ,
    oG,
    z$A,
    x01,
    _01,
    YtA,
    rd,
    od,
    ...(process.env.ENABLE_LSP_TOOL ? [SA0] : []),
    $b,
    qb,
  ];
}
var ss5,
  dc1,
  VaQ,
  KaQ,
  Yz = (A) => {
    let B = new Set([$b.name, qb.name]),
      Q = kA0().filter((Y) => !B.has(Y.name)),
      I = U7A(A),
      G = Q.filter((Y) => {
        return !I.some(
          (J) =>
            J.ruleValue.toolName === Y.name &&
            J.ruleValue.ruleContent === void 0,
        );
      }),
      Z = G.map((Y) => Y.isEnabled());
    return G.filter((Y, J) => Z[J]);
  };
var nO = T(() => {
  BnA();
  GtA();
  ZtA();
  EF();
  os();
  Ww();
  mm();
  WEA();
  X5A();
  gr();
  LA0();
  OA0();
  $A0();
  RA0();
  vn();
  RzA();
  ef2();
  JEA();
  JtA();
  Oh2();
  Th2();
  b01();
  f01();
  f3();
  ss5 = ["default"];
  ((dc1 = new Set([JR.name, x8, ...[]])),
    (VaQ = new Set([...dc1])),
    (KaQ = new Set([
      t4.name,
      z$A.name,
      oG.name,
      pj.name,
      RJ.name,
      $N.name,
      E4,
      Qz.name,
      QV.name,
      dO.name,
    ])));
});
var ih2, _A0;
var nh2 = T(() => {
  nA();
  rG();
  c1();
  C6();
  vC();
  N8();
  H0();
  R9();
  bP1();
  iC();
  tq();
  Q5();
  MBQ();
  iB();
  YEA();
  i0();
  Qr();
  nO();
  C0();
  ((ih2 = IA(KA(), 1)), (_A0 = IA(KA(), 1)));
});
var rs5;
var ah2 = T(() => {
  nh2();
  rs5 = IA(KA(), 1);
});
function os5(A, B, Q, I = "") {
  return xA0.createElement(GBQ, {
    abortSignal: B,
    messages: Q,
    initialDescription: I,
    onDone: A,
  });
}
var xA0, ts5, sh2;
var rh2 = T(() => {
  bP1();
  vB();
  xA0 = IA(KA(), 1);
  ((ts5 = {
    aliases: ["bug"],
    type: "local-jsx",
    name: "feedback",
    description: "Submit feedback about Claude Code",
    argumentHint: "[report]",
    isEnabled: () =>
      !(
        V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
        V0(process.env.CLAUDE_CODE_USE_VERTEX) ||
        process.env.DISABLE_FEEDBACK_COMMAND ||
        process.env.DISABLE_BUG_COMMAND ||
        process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC
      ),
    isHidden: !1,
    async call(A, { abortController: B, messages: Q }, I) {
      let G = I || "";
      return os5(A, B.signal, Q, G);
    },
    userFacingName() {
      return "feedback";
    },
  }),
    (sh2 = ts5));
});
async function es5({
  setMessages: A,
  readFileState: B,
  getAppState: Q,
  setAppState: I,
}) {
  if (
    (await vA0("clear", { getAppState: Q, setAppState: I }),
    await NY(),
    A(() => []),
    FV.cache.clear?.(),
    WV.cache.clear?.(),
    Nm1.cache.clear?.(),
    LF.cache.clear?.(),
    EN(GQ()),
    B.clear(),
    I)
  )
    I((Z) => ({
      ...Z,
      fileHistory: { snapshots: [], trackedFiles: new Set() },
      checkpointing: { ...Z.checkpointing, checkpoints: {} },
      mcp: { clients: [], tools: [], commands: [], resources: {} },
    }));
  (s40(), await Vy());
  let G = await Cw("clear");
  if (G.length > 0) A(() => G);
}
var Ar5, oh2;
var th2 = T(() => {
  ZS();
  lD();
  Xx();
  i0();
  xj();
  E7();
  Ps();
  mj();
  ((Ar5 = {
    type: "local",
    name: "clear",
    description: "Clear conversation history and free up context",
    aliases: ["reset", "new"],
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    async call(A, B) {
      return (await es5(B), { type: "text", value: "" });
    },
    userFacingName() {
      return "clear";
    },
  }),
    (oh2 = Ar5));
});
var Br5, eh2;
var Ag2 = T(() => {
  ZS();
  lD();
  diA();
  B5A();
  c1();
  f2();
  xlA();
  vB();
  ((Br5 = {
    type: "local",
    name: "compact",
    description:
      "Clear conversation history but keep a summary in context. Optional: /compact [instructions for summarization]",
    isEnabled: () => !V0(process.env.DISABLE_COMPACT),
    isHidden: !1,
    supportsNonInteractive: !0,
    argumentHint: "<optional custom summarization instructions>",
    async call(A, B) {
      let { abortController: Q, messages: I } = B;
      if (I.length === 0) throw Error("No messages to compact");
      let G = A.trim();
      try {
        let Y = (await Qd(I, void 0, B)).messages,
          J = await miA(Y, B, !1, G);
        (FV.cache.clear?.(), LF.cache.clear?.());
        let X = h8A("tip"),
          W = [
            ...(B.options.verbose ? [] : ["(ctrl+o to see full summary)"]),
            ...(J.userDisplayMessage ? [J.userDisplayMessage] : []),
            ...(X ? [X] : []),
          ];
        return {
          type: "compact",
          compactionResult: J,
          displayText: iA.dim(
            "Compacted " +
              W.join(`
`),
          ),
        };
      } catch (Z) {
        if (Q.signal.aborted) throw Error("Compaction canceled.");
        else if (Z instanceof Error && Z.message === eDA) throw Error(eDA);
        else
          throw (
            BA(Z instanceof Error ? Z : Error(String(Z)), KG0),
            Error(`Error during compaction: ${Z}`)
          );
      }
    },
    userFacingName() {
      return "compact";
    },
  }),
    (eh2 = Br5));
});
function tc({ title: A, color: B, defaultTab: Q, children: I, hidden: G }) {
  let Z = I.map((W) => [W.props.id ?? W.props.title, W.props.title]),
    Y = Q ? Z.findIndex((W) => Q === W[0]) : 0,
    [J, X] = kz.useState(Y !== -1 ? Y : 0);
  return (
    h1(
      (W, F) => {
        if (F.tab) {
          let C = F.shift ? -1 : 1;
          X((J + Z.length + C) % Z.length);
        }
      },
      { isActive: !G },
    ),
    kz.default.createElement(
      Bg2.Provider,
      { value: Z[J][0] },
      kz.default.createElement(
        S,
        { flexDirection: "column" },
        !G &&
          kz.default.createElement(
            S,
            { flexDirection: "row", gap: 1 },
            A !== void 0 &&
              kz.default.createElement(U, { bold: !0, color: B }, A),
            Z.map(([W, F], C) =>
              kz.default.createElement(
                U,
                {
                  key: W,
                  backgroundColor: B && J === C ? B : void 0,
                  color: B && J === C ? "inverseText" : void 0,
                  bold: J === C,
                },
                " ",
                F,
                " ",
              ),
            ),
            kz.default.createElement(U, { dimColor: !0 }, " (tab to cycle)"),
          ),
        kz.default.createElement(S, null, I),
      ),
    )
  );
}
function LV({ title: A, id: B, children: Q }) {
  if (kz.useContext(Bg2) !== (B ?? A)) return null;
  return Q;
}
var kz, Bg2;
var U$A = T(() => {
  nA();
  ((kz = IA(KA(), 1)), (Bg2 = kz.createContext(void 0)));
});
function Qg2({ context: A, flat: B } = {}) {
  let Q = LF(),
    I = [];
  if (A?.readFileState)
    ym(A.readFileState).forEach((Y) => {
      let J = A.readFileState.get(Y);
      if (J && Y.endsWith("/CLAUDE.md") && !Q.some((X) => X.path === Y))
        I.push({ path: Y, content: J.content, type: "Project", isNested: !0 });
    });
  let G = [...Q, ...I];
  if (G.length === 0) return null;
  if (B)
    return kJ.createElement(
      S,
      { flexDirection: "row", columnGap: 1, flexWrap: "wrap" },
      G.map((Y, J) => {
        let X = TY(Y.path),
          W = Y.isNested ? "nested" : Nv1(Y.type),
          F = J < G.length - 1 ? "," : "";
        return kJ.createElement(
          S,
          { key: J, flexDirection: "row", flexShrink: 0 },
          kJ.createElement(U, null, W, " "),
          kJ.createElement(U, { dimColor: !0 }, "(", X, ")"),
          kJ.createElement(U, null, F),
        );
      }),
    );
  let Z = new Map();
  return kJ.createElement(
    S,
    { flexDirection: "column" },
    G.map((Y, J) => {
      let X = TY(Y.path),
        W = Y.isNested ? "nested: " : `${Nv1(Y.type)}: `,
        F = Y.parent ? (Z.get(Y.parent) ?? 0) + 1 : 0;
      if ((Z.set(Y.path, F), F === 0))
        return kJ.createElement(
          U,
          { key: J },
          kJ.createElement(U, { dimColor: !0 }, " L "),
          `${W}${X}`,
        );
      else {
        let C = "  ".repeat(F - 1);
        return kJ.createElement(
          U,
          { key: J },
          " ".repeat(W.length + 2),
          C,
          kJ.createElement(U, { dimColor: !0 }, " L "),
          X,
        );
      }
    }),
  );
}
var kJ;
var Ig2 = T(() => {
  nA();
  lD();
  Z4();
  Lv1();
  zN();
  kJ = IA(KA(), 1);
});
function Gg2(A) {
  return [];
}
function Zg2() {
  return [];
}
function Yg2(A, B = null, Q) {
  let I = A?.find((G) => G.name === "ide");
  if (B) {
    let G = hj(B.ideType);
    if (B.error)
      if (UN(B.ideType))
        return [
          {
            label: "IDE",
            value: _R.createElement(
              U,
              null,
              OB("error", Q)(E1.cross),
              " Error installing",
              " ",
              G,
              " plugin: ",
              B.error,
              `
`,
              "Please restart your IDE or try installing from https://docs.claude.com/s/claude-code-jetbrains",
            ),
          },
        ];
      else
        return [
          {
            label: "IDE",
            value: _R.createElement(
              U,
              null,
              OB("error", Q)(E1.cross),
              " Error installing",
              " ",
              G,
              " extension: ",
              B.error,
              `
`,
              "Please restart your IDE and try again.",
            ),
          },
        ];
    if (B.installed)
      if (I && I.type === "connected")
        if (B.installedVersion !== I.serverInfo?.version)
          return [
            {
              label: "IDE",
              value: `Connected to ${G} extension version ${B.installedVersion} (server version: ${I.serverInfo?.version})`,
            },
          ];
        else
          return [
            {
              label: "IDE",
              value: `Connected to ${G} extension version ${B.installedVersion}`,
            },
          ];
      else if (UN(B.ideType))
        return [
          {
            label: "IDE",
            value: _R.createElement(
              U,
              null,
              "Installed ",
              G,
              " plugin but connection is not established.",
              `
`,
              "Please restart your IDE or try installing from https://docs.claude.com/s/claude-code-jetbrains",
            ),
          },
        ];
      else return [{ label: "IDE", value: `Installed ${G} extension` }];
  } else if (I) {
    let G = Qv1(I) ?? "IDE";
    if (I.type === "connected")
      return [{ label: "IDE", value: `Connected to ${G} extension` }];
    else
      return [
        {
          label: "IDE",
          value: `${OB("error", Q)(E1.cross)} Not connected to ${G}`,
        },
      ];
  }
  return [];
}
function Jg2(A = [], B) {
  let Q = A.filter((I) => I.name !== "ide");
  if (!Q.length) return [];
  return [
    {
      label: "MCP servers",
      value: _R.createElement(
        S,
        { flexDirection: "row" },
        Q.map((I, G) => {
          let Z = "";
          if (I.type === "connected") Z = OB("success", B)(E1.tick);
          else if (I.type === "pending") Z = OB("inactive", B)(E1.radioOff);
          else if (I.type === "needs-auth")
            Z = OB("warning", B)(E1.triangleUpOutline);
          else if (I.type === "failed") Z = OB("error", B)(E1.cross);
          else Z = OB("error", B)(E1.cross);
          let Y = G < Q.length - 1 ? "," : "";
          return _R.createElement(U, { key: G }, I.name, " ", Z, Y);
        }),
      ),
    },
  ];
}
function Xg2() {
  let A = qs(),
    B = Ns(),
    Q = [];
  if (
    (A.forEach((I) => {
      let G = TY(I.path);
      Q.push(
        `Large ${G} will impact performance (${yZ(I.content.length)} chars > ${yZ(fx)})`,
      );
    }),
    B && B.content.length > Q6A)
  )
    Q.push(
      `CLAUDE.md entries marked as IMPORTANT exceed ${yZ(Q6A)} characters (${yZ(B.content.length)} chars)`,
    );
  return Q;
}
function Wg2() {
  return [
    {
      label: "Setting sources",
      value: Xi().map((Q) => {
        switch (Q) {
          case "userSettings":
            return "User settings";
          case "projectSettings":
            return "Shared project settings";
          case "localSettings":
            return "Local";
          case "policySettings":
            return "Enterprise managed policies";
          case "flagSettings":
            return "Command line arguments";
        }
      }),
    },
  ];
}
async function Fg2() {
  return (await kS()).map((B) => B.message);
}
async function Cg2() {
  let A = await SIA(),
    B = [],
    { errors: Q } = oc();
  if (Q.length > 0) {
    let G = Array.from(new Set(Q.map((Z) => Z.file))).join(", ");
    B.push(`Found invalid settings files: ${G}. They will be ignored.`);
  }
  if (A.multipleInstallations.length > 1)
    B.push(
      `Multiple installations detected (${A.multipleInstallations.length} found)`,
    );
  if (
    (A.warnings.forEach((I) => {
      B.push(I.issue);
    }),
    A.hasUpdatePermissions === !1)
  )
    B.push("No write permissions for auto-updates (requires sudo)");
  if (A.configInstallMethod !== "not set") {
    let G = {
      "npm-local": "local",
      "npm-global": "global",
      native: "native",
      development: "development",
      unknown: "unknown",
    }[A.installationType];
    if (G && G !== A.configInstallMethod)
      B.push(
        `Installation config mismatch: running ${A.installationType} but config says ${A.configInstallMethod}`,
      );
  }
  return B;
}
function Vg2() {
  let A = h01();
  if (!A) return [];
  let B = [];
  if (A.subscription)
    B.push({ label: "Login method", value: `${A.subscription} Account` });
  if (A.tokenSource) B.push({ label: "Auth token", value: A.tokenSource });
  if (A.apiKeySource) B.push({ label: "API key", value: A.apiKeySource });
  if (A.organization) B.push({ label: "Organization", value: A.organization });
  if (A.email) B.push({ label: "Email", value: A.email });
  return B;
}
function Kg2() {
  let A = g3(),
    B = [];
  if (A !== "firstParty") {
    let G = { bedrock: "AWS Bedrock", vertex: "Google Vertex AI" }[A];
    B.push({ label: "API provider", value: G });
  }
  if (A === "firstParty") {
    let G = process.env.ANTHROPIC_BASE_URL;
    if (G) B.push({ label: "Anthropic base URL", value: G });
  } else if (A === "bedrock") {
    let G = process.env.BEDROCK_BASE_URL;
    if (G) B.push({ label: "Bedrock base URL", value: G });
    if (
      (B.push({ label: "AWS region", value: Ce() }),
      V0(process.env.CLAUDE_CODE_SKIP_BEDROCK_AUTH))
    )
      B.push({ value: "AWS auth skipped" });
  } else if (A === "vertex") {
    let G = process.env.VERTEX_BASE_URL;
    if (G) B.push({ label: "Vertex base URL", value: G });
    let Z = process.env.ANTHROPIC_VERTEX_PROJECT_ID;
    if (Z) B.push({ label: "GCP project", value: Z });
    if (
      (B.push({ label: "Default region", value: BM() }),
      V0(process.env.CLAUDE_CODE_SKIP_VERTEX_AUTH))
    )
      B.push({ value: "GCP auth skipped" });
  }
  let Q = ng();
  if (Q) B.push({ label: "Proxy", value: Q });
  let I = wq();
  if (process.env.NODE_EXTRA_CA_CERTS)
    B.push({
      label: "Additional CA cert(s)",
      value: process.env.NODE_EXTRA_CA_CERTS,
    });
  if (I) {
    if (I.cert && process.env.CLAUDE_CODE_CLIENT_CERT)
      B.push({
        label: "mTLS client cert",
        value: process.env.CLAUDE_CODE_CLIENT_CERT,
      });
    if (I.key && process.env.CLAUDE_CODE_CLIENT_KEY)
      B.push({
        label: "mTLS client key",
        value: process.env.CLAUDE_CODE_CLIENT_KEY,
      });
  }
  return B;
}
function Dg2(A) {
  let B = bP(A);
  if (A === null && nB()) {
    let Q = BbA();
    if (xU()) B = `${iA.bold("Default")} ${Q}`;
    else B = `${iA.bold("Sonnet")} ${Q}`;
  }
  return B;
}
var _R;
var Eg2 = T(() => {
  nA();
  FR();
  F2();
  zW();
  lD();
  Z4();
  EH();
  Y9();
  f2();
  Gc();
  vB();
  ag();
  Z2A();
  OQ();
  VW();
  s2();
  F2();
  NC();
  _R = IA(KA(), 1);
});
function Qr5() {
  return [
    {
      label: "Version",
      value: {
        ISSUES_EXPLAINER:
          "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.claude.com/s/claude-code",
        VERSION: "2.0.42",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
      }.VERSION,
    },
    { label: "Session ID", value: L0() },
    { label: "cwd", value: G0() },
    ...Vg2(),
    ...Kg2(),
  ];
}
function Ir5({ appState: A, theme: B, context: Q }) {
  return [
    { label: "Model", value: Dg2(A.mainLoopModel) },
    ...Yg2(A.mcp.clients, Q.options.ideInstallationStatus, B),
    ...Jg2(A.mcp.clients, B),
    { label: "Memory", value: t8.createElement(Qg2, { context: Q, flat: !0 }) },
    ...Zg2(),
    ...Gg2(A.checkpointing),
    ...Wg2(),
  ];
}
async function Gr5() {
  return [...((await tr()) ? await Fg2() : []), ...(await Cg2()), ...Xg2()];
}
function Zr5({ value: A }) {
  if (Array.isArray(A))
    return t8.createElement(
      S,
      { flexWrap: "wrap", columnGap: 1, flexShrink: 99 },
      A.map((B, Q) => {
        return t8.createElement(U, { key: Q }, B, Q < A.length - 1 ? "," : "");
      }),
    );
  if (typeof A === "string") return t8.createElement(U, null, A);
  return A;
}
function Hg2({ context: A }) {
  let [B] = lB(),
    [Q, I] = t8.useState([]),
    [G, Z] = t8.useState([]),
    Y = A.options.ideInstallationStatus,
    [J] = HQ();
  return (
    t8.useEffect(() => {
      async function X() {
        let W = [Qr5(), Ir5({ appState: B, theme: J, context: A })],
          F = await Gr5();
        (I(W), Z(F));
      }
      X();
    }, [B, J, Y, A]),
    t8.createElement(
      S,
      { flexDirection: "column" },
      t8.createElement(
        S,
        { flexDirection: "column", gap: 1, marginTop: 1 },
        Q.map(
          (X, W) =>
            X.length > 0 &&
            t8.createElement(
              S,
              { key: W, flexDirection: "column" },
              X.map(({ label: F, value: C }, V) =>
                t8.createElement(
                  S,
                  { key: V, flexDirection: "row", gap: 1, flexShrink: 0 },
                  F !== void 0 && t8.createElement(U, { bold: !0 }, F, ":"),
                  t8.createElement(Zr5, { value: C }),
                ),
              ),
            ),
        ),
        G.length > 0 &&
          t8.createElement(
            S,
            { flexDirection: "column", paddingBottom: 1 },
            t8.createElement(U, { bold: !0 }, "System Diagnostics"),
            G.map((X, W) =>
              t8.createElement(
                S,
                { key: W, flexDirection: "row", gap: 1, paddingX: 1 },
                t8.createElement(U, { color: "error" }, E1.warning),
                typeof X === "string"
                  ? t8.createElement(U, { wrap: "wrap" }, X)
                  : X,
              ),
            ),
          ),
      ),
      t8.createElement(U, { dimColor: !0, italic: !0 }, "Esc to exit"),
    )
  );
}
var t8;
var zg2 = T(() => {
  nA();
  s2();
  c9();
  i0();
  Ig2();
  FR();
  Eg2();
  V2();
  t8 = IA(KA(), 1);
});
function Ug2() {
  if (process.platform === "darwin") {
    let A = gm();
    J7(`security delete-generic-password -a $USER -s "${A}"`);
  }
}
function lw(A) {
  return A.slice(-20);
}
var w$A = T(() => {
  BEA();
  fTA();
});
function g01({
  onThemeSelect: A,
  showIntroText: B = !1,
  helpText: Q = "",
  showHelpTextBelow: I = !1,
  hideEscToCancel: G = !1,
  skipExitHandling: Z = !1,
}) {
  let [Y] = HQ(),
    { setPreviewTheme: J, savePreview: X } = TY1(),
    W = IB(Z ? () => {} : void 0),
    C = H4.createElement(
      S,
      { flexDirection: "column", gap: 1 },
      H4.createElement(
        S,
        { flexDirection: "column", gap: 1, marginX: 1 },
        B
          ? H4.createElement(U, null, "Let's get started.")
          : H4.createElement(U, { bold: !0, color: "permission" }, "Theme"),
        H4.createElement(
          S,
          { flexDirection: "column" },
          H4.createElement(
            U,
            { bold: !0 },
            "Choose the text style that looks best with your terminal",
          ),
          Q && !I && H4.createElement(U, { dimColor: !0 }, Q),
        ),
        H4.createElement($0, {
          options: [
            { label: "Dark mode", value: "dark" },
            { label: "Light mode", value: "light" },
            {
              label: "Dark mode (colorblind-friendly)",
              value: "dark-daltonized",
            },
            {
              label: "Light mode (colorblind-friendly)",
              value: "light-daltonized",
            },
            { label: "Dark mode (ANSI colors only)", value: "dark-ansi" },
            { label: "Light mode (ANSI colors only)", value: "light-ansi" },
          ],
          onFocus: (V) => {
            J(V);
          },
          onChange: (V) => {
            (X(), A(V));
          },
          onCancel: Z
            ? () => {
                X();
              }
            : async () => {
                (X(), await P6(0));
              },
          visibleOptionCount: 6,
          defaultValue: Y,
        }),
      ),
      H4.createElement(
        S,
        {
          flexDirection: "column",
          width: "100%",
          marginBottom: 1,
          borderTop: !0,
          borderBottom: !0,
          borderLeft: !1,
          borderRight: !1,
          borderStyle: "dashed",
          borderColor: "subtle",
          borderDimColor: !0,
        },
        H4.createElement(Bz, {
          patch: {
            oldStart: 1,
            newStart: 1,
            oldLines: 3,
            newLines: 3,
            lines: [
              " function greet() {",
              '-  console.log("Hello, World!");',
              '+  console.log("Hello, Claude!");',
              " }",
            ],
          },
          dim: !1,
          filePath: "demo.js",
          skipHighlighting: !0,
        }),
      ),
    );
  if (!B)
    return H4.createElement(
      H4.Fragment,
      null,
      H4.createElement(S, { flexDirection: "column" }, C),
      H4.createElement(
        S,
        { marginX: 1 },
        I &&
          Q &&
          H4.createElement(
            S,
            { marginLeft: 3, marginTop: 1 },
            H4.createElement(U, { dimColor: !0 }, Q),
          ),
        !G &&
          H4.createElement(
            S,
            { marginLeft: 3 },
            H4.createElement(
              U,
              { dimColor: !0 },
              W.pending
                ? H4.createElement(
                    H4.Fragment,
                    null,
                    "Press ",
                    W.keyName,
                    " again to exit",
                  )
                : H4.createElement(H4.Fragment, null, "Esc to cancel"),
            ),
          ),
      ),
    );
  return C;
}
var H4;
var bA0 = T(() => {
  nA();
  R5();
  um();
  R9();
  xY();
  nA();
  H4 = IA(KA(), 1);
});
function m01({
  initial: A,
  sessionModel: B,
  onSelect: Q,
  isStandaloneCommand: I,
}) {
  let G = A === null ? fA0 : A,
    [Z, Y] = u01.useState(G),
    J = u01.useMemo(() => IbA(), []),
    X = IB(),
    W = nB() && i3() === "pro",
    F = 10,
    C = Math.min(10, J.length),
    V = Math.max(0, J.length - C);
  return z4.createElement(
    S,
    { flexDirection: "column", width: "100%" },
    I && z4.createElement(p5, { dividerColor: "permission" }),
    z4.createElement(
      S,
      { flexDirection: "column", paddingX: I ? 1 : 0 },
      z4.createElement(
        S,
        { flexDirection: "column" },
        z4.createElement(
          S,
          { marginBottom: 1, flexDirection: "column" },
          z4.createElement(U, { color: "remember", bold: !0 }, "Select model"),
          z4.createElement(
            U,
            { dimColor: !0 },
            "Switch between Claude models. Applies to this session and future Claude Code sessions. For other/previous model names, specify with --model.",
          ),
        ),
        B &&
          z4.createElement(
            S,
            { marginBottom: 1, flexDirection: "column" },
            z4.createElement(
              U,
              { dimColor: !0 },
              "Currently using ",
              bP(B),
              " for this session (set by plan mode). Selecting a model will undo this.",
            ),
          ),
        z4.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          z4.createElement(
            S,
            { flexDirection: "column" },
            z4.createElement($0, {
              defaultValue: Z,
              focusValue: J.some((K) => K.value === Z)
                ? Z
                : (J[0]?.value ?? void 0),
              options: J.map((K) => ({
                ...K,
                value: K.value === null ? fA0 : K.value,
              })),
              onFocus: (K) => Y(K),
              onChange: (K) => Q(K === fA0 ? null : K),
              onCancel: () => {},
              visibleOptionCount: C,
            }),
          ),
          V > 0 &&
            z4.createElement(
              S,
              { paddingLeft: 3 },
              z4.createElement(U, { dimColor: !0 }, "and ", V, " more"),
            ),
        ),
        W &&
          z4.createElement(
            S,
            { marginBottom: 1, flexDirection: "column" },
            z4.createElement(
              U,
              { dimColor: !0 },
              "Want Opus 4.1? Run ",
              z4.createElement(U, { color: "remember" }, "/upgrade"),
              " to upgrade to Max",
            ),
          ),
      ),
      I &&
        z4.createElement(
          U,
          { dimColor: !0, italic: !0 },
          X.pending
            ? z4.createElement(
                z4.Fragment,
                null,
                "Press ",
                X.keyName,
                " again to exit",
              )
            : z4.createElement(
                z4.Fragment,
                null,
                "Enter to confirm  Esc to exit",
              ),
        ),
    ),
  );
}
var z4,
  u01,
  fA0 = "__NO_PREFERENCE__";
var hA0 = T(() => {
  nA();
  Y9();
  R5();
  R9();
  F2();
  iC();
  ((z4 = IA(KA(), 1)), (u01 = IA(KA(), 1)));
});
function d01({ onDone: A, isStandaloneDialog: B }) {
  sK.default.useEffect(() => {
    GA("tengu_claude_md_includes_dialog_shown", {});
  }, []);
  function Q(G) {
    let Z = v6();
    if (G === "no")
      (GA("tengu_claude_md_external_includes_dialog_declined", {}),
        uG({
          ...Z,
          hasClaudeMdExternalIncludesApproved: !1,
          hasClaudeMdExternalIncludesWarningShown: !0,
        }));
    else
      (GA("tengu_claude_md_external_includes_dialog_accepted", {}),
        uG({
          ...Z,
          hasClaudeMdExternalIncludesApproved: !0,
          hasClaudeMdExternalIncludesWarningShown: !0,
        }));
    A();
  }
  let I = IB();
  return (
    h1((G, Z) => {
      if (Z.escape) {
        Q("no");
        return;
      }
    }),
    sK.default.createElement(
      sK.default.Fragment,
      null,
      sK.default.createElement(
        S,
        {
          flexDirection: "column",
          gap: 1,
          paddingX: B ? 1 : 0,
          marginBottom: 1,
          borderStyle: B ? "round" : void 0,
          borderTop: B,
          borderLeft: !1,
          borderRight: !1,
          borderBottom: !1,
          borderColor: "warning",
        },
        sK.default.createElement(
          U,
          { bold: !0, color: "warning" },
          "Allow external CLAUDE.md file imports?",
        ),
        sK.default.createElement(
          U,
          null,
          "This project's CLAUDE.md imports files outside the current working directory. Never allow this for third-party repositories.",
        ),
        sK.default.createElement(
          U,
          { dimColor: !0 },
          "Important: Only use Claude Code with files you trust. Accessing untrusted files may pose security risks",
          " ",
          sK.default.createElement(R8, {
            url: "https://code.claude.com/docs/en/security",
          }),
          " ",
        ),
        sK.default.createElement($0, {
          options: [
            { label: "Yes, allow external imports", value: "yes" },
            { label: "No, disable external imports", value: "no" },
          ],
          onChange: (G) => Q(G),
          onCancel: () => Q("no"),
        }),
      ),
      B &&
        sK.default.createElement(
          S,
          { marginLeft: 1 },
          sK.default.createElement(
            U,
            { dimColor: !0, italic: !0 },
            I.pending
              ? sK.default.createElement(
                  sK.default.Fragment,
                  null,
                  "Press ",
                  I.keyName,
                  " again to exit",
                )
              : sK.default.createElement(
                  sK.default.Fragment,
                  null,
                  "Enter to confirm  Esc to disable external includes",
                ),
          ),
        ),
    )
  );
}
var sK;
var gA0 = T(() => {
  nA();
  R5();
  kB();
  H0();
  R9();
  vK();
  sK = IA(KA(), 1);
});
function wg2(A) {
  return Object.entries(A).map(([B, Q]) => ({
    label: Q?.name ?? Yr5,
    value: B,
    description: Q?.description ?? Jr5,
  }));
}
function c01({
  initialStyle: A,
  onComplete: B,
  onCancel: Q,
  isStandaloneCommand: I,
}) {
  let [G, Z] = Jt.useState([]),
    [Y, J] = Jt.useState(!0);
  Jt.useEffect(() => {
    Xt()
      .then((W) => {
        let F = wg2(W);
        (Z(F), J(!1));
      })
      .catch(() => {
        let W = wg2(ro);
        (Z(W), J(!1));
      });
  }, []);
  let X = Jt.useCallback(
    (W) => {
      B(W);
    },
    [B],
  );
  return iw.createElement(
    Wc,
    {
      title: "Preferred output style",
      onCancel: Q,
      borderDimColor: !0,
      hideInputGuide: !I,
      hideBorder: !I,
    },
    iw.createElement(
      S,
      { flexDirection: "column", gap: 1 },
      iw.createElement(
        S,
        { marginTop: 1 },
        iw.createElement(
          U,
          { dimColor: !0 },
          "This changes how Claude Code communicates with you",
        ),
      ),
      Y
        ? iw.createElement(U, { dimColor: !0 }, "Loading output styles")
        : iw.createElement($0, {
            options: G,
            onChange: X,
            onCancel: Q,
            visibleOptionCount: 10,
            defaultValue: A,
          }),
    ),
  );
}
var iw,
  Jt,
  Yr5 = "Default",
  Jr5 =
    "Claude completes coding tasks efficiently and provides concise responses";
var uA0 = T(() => {
  nA();
  Z5();
  Gy();
  lzA();
  ((iw = IA(KA(), 1)), (Jt = IA(KA(), 1)));
});
function $g2({
  onClose: A,
  context: B,
  setTabsHidden: Q,
  setIsWarning: I,
  setHideMargin: G,
}) {
  let [Z, Y] = HQ(),
    [J, X] = Wt.useState(L1()),
    W = zB.useRef(L1()),
    [F, C] = Wt.useState(N0()),
    [V, K] = Wt.useState(F?.outputStyle || nF),
    D = zB.useRef(V),
    [E, H] = Wt.useState(0),
    [{ mainLoopModel: w, verbose: L }, N] = lB(),
    [$, O] = Wt.useState({}),
    [P, k] = Wt.useState(null),
    [b, x] = zB.useState(!1);
  zB.useEffect(() => {
    async function e() {
      let QA =
        (await _F("tengu_auto_checkpointing")) &&
        !V0(process.env.CLAUDE_CODE_DISABLE_AUTOCHECKPOINTING);
      x(QA);
    }
    e();
  }, []);
  let n = PiA(B.options.mcpClients),
    m = !V0(process.env.CLAUDE_CODE_DISABLE_FILE_CHECKPOINTING),
    o = Xv1();
  async function l(e) {
    (GA("tengu_config_model_changed", { from_model: w, to_model: e }),
      N((WA) => ({ ...WA, mainLoopModel: e })),
      O((WA) => {
        let JA = bP(e);
        if ("model" in WA) {
          let { model: wA, ...xA } = WA;
          return { ...xA, model: JA };
        }
        return { ...WA, model: JA };
      }));
  }
  function y(e) {
    let QA = { ...L1(), verbose: e };
    (n0(QA),
      X(QA),
      N((WA) => ({ ...WA, verbose: e })),
      O((WA) => {
        if ("verbose" in WA) {
          let { verbose: JA, ...wA } = WA;
          return wA;
        }
        return { ...WA, verbose: e };
      }));
  }
  let c = [
    {
      id: "autoCompactEnabled",
      label: "Auto-compact",
      value: J.autoCompactEnabled,
      type: "boolean",
      onChange(e) {
        let QA = { ...L1(), autoCompactEnabled: e };
        (n0(QA),
          X(QA),
          GA("tengu_auto_compact_setting_changed", { enabled: e }));
      },
    },
    {
      id: "spinnerTipsEnabled",
      label: "Show tips",
      value: F?.spinnerTipsEnabled ?? !0,
      type: "boolean",
      onChange(e) {
        (B2("localSettings", { spinnerTipsEnabled: e }),
          C((QA) => ({ ...QA, spinnerTipsEnabled: e })),
          GA("tengu_tips_setting_changed", { enabled: e }));
      },
    },
    ...(b
      ? [
          {
            id: "autocheckpointingEnabled",
            label: "Auto-checkpointing",
            value: J.autocheckpointingEnabled,
            type: "boolean",
            onChange(e) {
              let QA = { ...L1(), autocheckpointingEnabled: e };
              (n0(QA),
                X(QA),
                GA("tengu_autocheckpointing_setting_changed", { enabled: e }),
                N((WA) => ({
                  ...WA,
                  checkpointing: {
                    ...WA.checkpointing,
                    autocheckpointEnabled:
                      b &&
                      e &&
                      !V0(process.env.CLAUDE_CODE_DISABLE_AUTOCHECKPOINTING),
                  },
                })));
            },
          },
        ]
      : []),
    ...(m
      ? [
          {
            id: "fileCheckpointingEnabled",
            label: "Rewind code (checkpoints)",
            value: J.fileCheckpointingEnabled,
            type: "boolean",
            onChange(e) {
              let QA = { ...L1(), fileCheckpointingEnabled: e };
              (n0(QA),
                X(QA),
                GA("tengu_file_history_snapshots_setting_changed", {
                  enabled: e,
                }));
            },
          },
        ]
      : []),
    {
      id: "verbose",
      label: "Verbose output",
      value: L,
      type: "boolean",
      onChange: y,
    },
    ...(ac()
      ? [
          {
            id: "defaultPermissionMode",
            label: "Default permission mode",
            value: F?.permissions?.defaultMode || "default",
            options: (() => {
              let e = ["default", "plan"],
                QA = ["bypassPermissions"];
              return [
                ...e,
                ...Wi.filter((WA) => !e.includes(WA) && !QA.includes(WA)),
              ];
            })(),
            type: "enum",
            onChange(e) {
              let QA = HTA(e),
                WA = B2("userSettings", {
                  permissions: { ...F?.permissions, defaultMode: QA },
                });
              if (WA.error) {
                BA(WA.error, OZA);
                return;
              }
              (C((JA) => ({
                ...JA,
                permissions: { ...JA?.permissions, defaultMode: QA },
              })),
                O((JA) => ({ ...JA, defaultPermissionMode: e })),
                GA("tengu_config_changed", {
                  setting: "defaultPermissionMode",
                  value: e,
                }));
            },
          },
        ]
      : []),
    {
      id: "respectGitignore",
      label: "Respect .gitignore in file picker",
      value: J.respectGitignore,
      type: "boolean",
      onChange(e) {
        let QA = { ...L1(), respectGitignore: e };
        (n0(QA),
          X(QA),
          GA("tengu_respect_gitignore_setting_changed", { enabled: e }));
      },
    },
    { id: "theme", label: "Theme", value: Z, type: "managedEnum", onChange: Y },
    {
      id: "notifChannel",
      label: "Notifications",
      value: J.preferredNotifChannel,
      options: [
        "auto",
        "iterm2",
        "terminal_bell",
        "iterm2_with_bell",
        "kitty",
        "ghostty",
        "notifications_disabled",
      ],
      type: "enum",
      onChange(e) {
        let QA = { ...L1(), preferredNotifChannel: e };
        (n0(QA), X(QA));
      },
    },
    {
      id: "outputStyle",
      label: "Output style",
      value: V,
      type: "managedEnum",
      onChange: () => {},
    },
    {
      id: "editorMode",
      label: "Editor mode",
      value: J.editorMode === "emacs" ? "normal" : J.editorMode || "normal",
      options: ["normal", "vim"],
      type: "enum",
      onChange(e) {
        let QA = { ...L1(), editorMode: e };
        (n0(QA),
          X(QA),
          GA("tengu_editor_mode_changed", { mode: e, source: "config_panel" }));
      },
    },
    {
      id: "model",
      label: "Model",
      value: w === null ? "Default (recommended)" : w,
      type: "managedEnum",
      onChange: l,
    },
    ...(n
      ? [
          {
            id: "diffTool",
            label: "Diff tool",
            value: J.diffTool ?? "auto",
            options: ["terminal", "auto"],
            type: "enum",
            onChange(e) {
              let QA = { ...L1(), diffTool: e };
              (n0(QA),
                X(QA),
                GA("tengu_diff_tool_changed", {
                  tool: e,
                  source: "config_panel",
                }));
            },
          },
        ]
      : []),
    ...(!UW()
      ? [
          {
            id: "autoConnectIde",
            label: "Auto-connect to IDE (external terminal)",
            value: J.autoConnectIde ?? !1,
            type: "boolean",
            onChange(e) {
              let QA = { ...L1(), autoConnectIde: e };
              (n0(QA),
                X(QA),
                GA("tengu_auto_connect_ide_changed", {
                  enabled: e,
                  source: "config_panel",
                }));
            },
          },
        ]
      : []),
    ...(UW()
      ? [
          {
            id: "autoInstallIdeExtension",
            label: "Auto-install IDE extension",
            value: J.autoInstallIdeExtension ?? !0,
            type: "boolean",
            onChange(e) {
              let QA = { ...L1(), autoInstallIdeExtension: e };
              (n0(QA),
                X(QA),
                GA("tengu_auto_install_ide_extension_changed", {
                  enabled: e,
                  source: "config_panel",
                }));
            },
          },
        ]
      : []),
    ...(o
      ? [
          {
            id: "showExternalIncludesDialog",
            label: "External CLAUDE.md includes",
            value: (() => {
              if (v6().hasClaudeMdExternalIncludesApproved) return "true";
              else return "false";
            })(),
            type: "managedEnum",
            onChange() {},
          },
        ]
      : []),
    ...(process.env.ANTHROPIC_API_KEY
      ? [
          {
            id: "apiKey",
            label: `Use custom API key: ${iA.bold(lw(process.env.ANTHROPIC_API_KEY))}`,
            value: Boolean(
              process.env.ANTHROPIC_API_KEY &&
                J.customApiKeyResponses?.approved?.includes(
                  lw(process.env.ANTHROPIC_API_KEY),
                ),
            ),
            type: "boolean",
            onChange(e) {
              let QA = { ...L1() };
              if (!QA.customApiKeyResponses)
                QA.customApiKeyResponses = { approved: [], rejected: [] };
              if (!QA.customApiKeyResponses.approved)
                QA.customApiKeyResponses.approved = [];
              if (!QA.customApiKeyResponses.rejected)
                QA.customApiKeyResponses.rejected = [];
              if (process.env.ANTHROPIC_API_KEY) {
                let WA = lw(process.env.ANTHROPIC_API_KEY);
                if (e)
                  ((QA.customApiKeyResponses.approved = [
                    ...QA.customApiKeyResponses.approved.filter(
                      (JA) => JA !== WA,
                    ),
                    WA,
                  ]),
                    (QA.customApiKeyResponses.rejected =
                      QA.customApiKeyResponses.rejected.filter(
                        (JA) => JA !== WA,
                      )));
                else
                  ((QA.customApiKeyResponses.approved =
                    QA.customApiKeyResponses.approved.filter(
                      (JA) => JA !== WA,
                    )),
                    (QA.customApiKeyResponses.rejected = [
                      ...QA.customApiKeyResponses.rejected.filter(
                        (JA) => JA !== WA,
                      ),
                      WA,
                    ]));
              }
              (n0(QA), X(QA));
            },
          },
        ]
      : []),
  ];
  return (
    h1((e, QA) => {
      if (QA.escape) {
        if (P !== null) {
          (Q(!1), I(!1), G(!1), k(null));
          return;
        }
        let JA = Object.entries($).map(([rA, qA]) => {
            return (
              GA("tengu_config_changed", { key: rA, value: qA }),
              `Set ${rA} to ${iA.bold(qA)}`
            );
          }),
          wA = Boolean(
            process.env.ANTHROPIC_API_KEY &&
              W.current.customApiKeyResponses?.approved?.includes(
                lw(process.env.ANTHROPIC_API_KEY),
              ),
          ),
          xA = Boolean(
            process.env.ANTHROPIC_API_KEY &&
              J.customApiKeyResponses?.approved?.includes(
                lw(process.env.ANTHROPIC_API_KEY),
              ),
          );
        if (wA !== xA)
          (JA.push(`${xA ? "Enabled" : "Disabled"} custom API key`),
            GA("tengu_config_changed", {
              key: "env.ANTHROPIC_API_KEY",
              value: xA,
            }));
        if (J.theme !== W.current.theme)
          JA.push(`Set theme to ${iA.bold(J.theme)}`);
        if (J.preferredNotifChannel !== W.current.preferredNotifChannel)
          JA.push(`Set notifications to ${iA.bold(J.preferredNotifChannel)}`);
        if (V !== D.current) JA.push(`Set output style to ${iA.bold(V)}`);
        if (J.editorMode !== W.current.editorMode)
          JA.push(`Set editor mode to ${iA.bold(J.editorMode || "emacs")}`);
        if (J.diffTool !== W.current.diffTool)
          JA.push(`Set diff tool to ${iA.bold(J.diffTool)}`);
        if (J.autoConnectIde !== W.current.autoConnectIde)
          JA.push(
            `${J.autoConnectIde ? "Enabled" : "Disabled"} auto-connect to IDE`,
          );
        if (J.autoInstallIdeExtension !== W.current.autoInstallIdeExtension)
          JA.push(
            `${J.autoInstallIdeExtension ? "Enabled" : "Disabled"} auto-install IDE extension`,
          );
        if (J.autoCompactEnabled !== W.current.autoCompactEnabled)
          JA.push(
            `${J.autoCompactEnabled ? "Enabled" : "Disabled"} auto-compact`,
          );
        if (J.respectGitignore !== W.current.respectGitignore)
          JA.push(
            `${J.respectGitignore ? "Enabled" : "Disabled"} respect .gitignore in file picker`,
          );
        if (JA.length > 0)
          A(
            JA.join(`
`),
          );
        else A("Config dialog dismissed", { display: "system" });
        return;
      }
      if (P !== null) return;
      function WA() {
        let JA = c[E];
        if (!JA || !JA.onChange) return;
        if (JA.type === "boolean") {
          JA.onChange(!JA.value);
          return;
        }
        if (JA.id === "theme" && QA.return) {
          (k(0), Q(!0), G(!0));
          return;
        }
        if (JA.id === "model" && QA.return) {
          (k(1), Q(!0));
          return;
        }
        if (JA.id === "showExternalIncludesDialog" && QA.return) {
          (k(2), Q(!0), I(!0));
          return;
        }
        if (JA.id === "outputStyle" && QA.return) {
          (k(3), Q(!0));
          return;
        }
        if (JA.type === "enum") {
          let xA = (JA.options.indexOf(JA.value) + 1) % JA.options.length;
          JA.onChange(JA.options[xA]);
          return;
        }
      }
      if (QA.return || e === " ") {
        WA();
        return;
      }
      if (QA.upArrow) H((JA) => Math.max(0, JA - 1));
      if (QA.downArrow) H((JA) => Math.min(c.length - 1, JA + 1));
    }),
    zB.createElement(
      S,
      { flexDirection: "column", width: "100%" },
      P === 0
        ? zB.createElement(
            zB.Fragment,
            null,
            zB.createElement(g01, {
              initialTheme: Z,
              onThemeSelect: (e) => {
                (Y(e), k(null), G(!1), Q(!1));
              },
              hideEscToCancel: !0,
              skipExitHandling: !0,
            }),
            zB.createElement(
              S,
              { marginLeft: 1 },
              zB.createElement(U, { dimColor: !0, italic: !0 }, "Esc to exit"),
            ),
          )
        : P === 1
          ? zB.createElement(
              zB.Fragment,
              null,
              zB.createElement(m01, {
                initial: w,
                onSelect: (e) => {
                  (l(e), k(null), Q(!1));
                },
              }),
              zB.createElement(
                U,
                { dimColor: !0, italic: !0 },
                "Enter to confirm  Esc to exit",
              ),
            )
          : P === 2
            ? zB.createElement(
                zB.Fragment,
                null,
                zB.createElement(d01, {
                  onDone: () => {
                    (k(null), Q(!1), I(!1));
                  },
                }),
                zB.createElement(
                  U,
                  { dimColor: !0, italic: !0 },
                  "Enter to confirm  Esc to disable external includes",
                ),
              )
            : P === 3
              ? zB.createElement(
                  zB.Fragment,
                  null,
                  zB.createElement(c01, {
                    initialStyle: V,
                    onComplete: (e) => {
                      (K(e ?? nF),
                        k(null),
                        Q(!1),
                        B2("localSettings", { outputStyle: e }),
                        GA("tengu_output_style_changed", {
                          style: e ?? nF,
                          source: "config_panel",
                          settings_source: "localSettings",
                        }));
                    },
                    onCancel: () => {
                      (k(null), Q(!1));
                    },
                  }),
                  zB.createElement(
                    U,
                    { dimColor: !0, italic: !0 },
                    "Enter to confirm  Esc to exit",
                  ),
                )
              : zB.createElement(
                  S,
                  { flexDirection: "column", marginY: 1, gap: 1 },
                  zB.createElement(
                    U,
                    null,
                    "Configure Claude Code preferences",
                  ),
                  zB.createElement(
                    S,
                    { flexDirection: "column" },
                    c.map((e, QA) => {
                      let WA = QA === E;
                      return zB.createElement(
                        S,
                        { key: e.id },
                        zB.createElement(
                          S,
                          { width: 44 },
                          zB.createElement(
                            U,
                            { color: WA ? "suggestion" : void 0 },
                            WA ? E1.pointer : " ",
                            " ",
                            e.label,
                          ),
                        ),
                        zB.createElement(
                          S,
                          null,
                          e.type === "boolean"
                            ? zB.createElement(
                                U,
                                { color: WA ? "suggestion" : void 0 },
                                e.value.toString(),
                              )
                            : e.id === "theme"
                              ? zB.createElement(
                                  U,
                                  { color: WA ? "suggestion" : void 0 },
                                  (() => {
                                    return (
                                      {
                                        dark: "Dark mode",
                                        light: "Light mode",
                                        "dark-daltonized":
                                          "Dark mode (colorblind-friendly)",
                                        "light-daltonized":
                                          "Light mode (colorblind-friendly)",
                                        "dark-ansi":
                                          "Dark mode (ANSI colors only)",
                                        "light-ansi":
                                          "Light mode (ANSI colors only)",
                                      }[e.value.toString()] ||
                                      e.value.toString()
                                    );
                                  })(),
                                )
                              : e.id === "notifChannel"
                                ? zB.createElement(
                                    U,
                                    { color: WA ? "suggestion" : void 0 },
                                    (() => {
                                      switch (e.value.toString()) {
                                        case "auto":
                                          return "Auto";
                                        case "iterm2":
                                          return zB.createElement(
                                            zB.Fragment,
                                            null,
                                            "iTerm2 ",
                                            zB.createElement(
                                              U,
                                              { dimColor: !0 },
                                              "(OSC 9)",
                                            ),
                                          );
                                        case "terminal_bell":
                                          return zB.createElement(
                                            zB.Fragment,
                                            null,
                                            "Terminal Bell ",
                                            zB.createElement(
                                              U,
                                              { dimColor: !0 },
                                              "(\\a)",
                                            ),
                                          );
                                        case "kitty":
                                          return zB.createElement(
                                            zB.Fragment,
                                            null,
                                            "Kitty ",
                                            zB.createElement(
                                              U,
                                              { dimColor: !0 },
                                              "(OSC 99)",
                                            ),
                                          );
                                        case "ghostty":
                                          return zB.createElement(
                                            zB.Fragment,
                                            null,
                                            "Ghostty ",
                                            zB.createElement(
                                              U,
                                              { dimColor: !0 },
                                              "(OSC 777)",
                                            ),
                                          );
                                        case "iterm2_with_bell":
                                          return "iTerm2 w/ Bell";
                                        case "notifications_disabled":
                                          return "Disabled";
                                        default:
                                          return e.value.toString();
                                      }
                                    })(),
                                  )
                                : e.id === "defaultPermissionMode"
                                  ? zB.createElement(
                                      U,
                                      { color: WA ? "suggestion" : void 0 },
                                      Sk(e.value),
                                    )
                                  : zB.createElement(
                                      U,
                                      { color: WA ? "suggestion" : void 0 },
                                      e.value.toString(),
                                    ),
                        ),
                      );
                    }),
                  ),
                  zB.createElement(
                    U,
                    { dimColor: !0, italic: !0 },
                    "Enter/Space to change  Esc to exit",
                  ),
                ),
    )
  );
}
var zB, Wt;
var qg2 = T(() => {
  nA();
  s2();
  kB();
  w$A();
  kB();
  f2();
  MM();
  c1();
  f4();
  H0();
  bA0();
  c9();
  hA0();
  Y9();
  gA0();
  uA0();
  lD();
  zW();
  OQ();
  Gy();
  vB();
  ((zB = IA(KA(), 1)), (Wt = IA(KA(), 1)));
});
async function Ng2() {
  if (!nB()) return {};
  let A = $Y();
  if (A.error) throw Error(`Auth error: ${A.error}`);
  let B = {
      "Content-Type": "application/json",
      "User-Agent": WW(),
      ...A.headers,
    },
    Q = `${G4().BASE_API_URL}/api/oauth/usage`;
  return (await DB.get(Q, { headers: B, timeout: 5000 })).data;
}
var Lg2 = T(() => {
  _I();
  yH();
  QW();
  F2();
});
function mA0({ ratio: A, width: B, fillColor: Q, emptyColor: I }) {
  let G = Math.min(1, Math.max(0, A)),
    Z = Math.floor(G * B),
    Y = [$$A[$$A.length - 1].repeat(Z)];
  if (Z < B) {
    let J = G * B - Z,
      X = Math.floor(J * $$A.length);
    Y.push($$A[X]);
    let W = B - Z - 1;
    if (W > 0) Y.push($$A[0].repeat(W));
  }
  return Mg2.default.createElement(
    U,
    { color: Q, backgroundColor: I },
    Y.join(""),
  );
}
var Mg2, $$A;
var Og2 = T(() => {
  nA();
  ((Mg2 = IA(KA(), 1)), ($$A = [" ", "", "", "", "", "", "", "", ""]));
});
function Xr5({ title: A, limit: B, maxWidth: Q }) {
  let { utilization: I, resets_at: G } = B;
  if (I === null) return null;
  let Z = `${Math.floor(I)}% used`,
    Y = void 0;
  if (G) {
    let W = new Date(G);
    Y = `Resets ${pT(Math.floor(W.getTime() / 1000), !0)}`;
  }
  let J = 50;
  if (Q >= J + 12)
    return T9.createElement(
      S,
      { flexDirection: "column" },
      T9.createElement(U, { bold: !0 }, A),
      T9.createElement(
        S,
        { flexDirection: "row", gap: 1 },
        T9.createElement(mA0, {
          ratio: I / 100,
          width: J,
          fillColor: "rate_limit_fill",
          emptyColor: "rate_limit_empty",
        }),
        T9.createElement(U, null, Z),
      ),
      Y !== void 0 && T9.createElement(U, { dimColor: !0 }, Y),
    );
  else
    return T9.createElement(
      S,
      { flexDirection: "column" },
      T9.createElement(
        U,
        null,
        T9.createElement(U, { bold: !0 }, A),
        Y !== void 0 &&
          T9.createElement(
            T9.Fragment,
            null,
            T9.createElement(U, null, " "),
            T9.createElement(U, { dimColor: !0 }, " ", Y),
          ),
      ),
      T9.createElement(mA0, {
        ratio: I / 100,
        width: Q,
        fillColor: "rate_limit_fill",
        emptyColor: "rate_limit_empty",
      }),
      T9.createElement(U, null, Z),
    );
}
function Rg2() {
  let [A, B] = q$A.useState(null),
    [Q, I] = q$A.useState(null),
    { columns: G } = aB(),
    Z = G - 2,
    Y = Math.min(Z, 80);
  if (
    (q$A.useEffect(() => {
      async function X() {
        try {
          let W = await Ng2();
          B(W);
        } catch (W) {
          (BA(W, mJ0), I("Failed to load usage data"));
        }
      }
      X();
    }, []),
    Q)
  )
    return T9.createElement(
      S,
      { flexDirection: "column", marginTop: 1, gap: 1 },
      T9.createElement(U, { color: "error" }, "Error: ", Q),
      T9.createElement(U, { dimColor: !0, italic: !0 }, "Esc to exit"),
    );
  if (!A)
    return T9.createElement(
      S,
      { flexDirection: "column", marginTop: 1, gap: 1 },
      T9.createElement(U, { dimColor: !0 }, "Loading usage data"),
      T9.createElement(U, { dimColor: !0, italic: !0 }, "Esc to exit"),
    );
  let J = [
    { title: "Current session", limit: A.five_hour },
    { title: "Current week (all models)", limit: A.seven_day },
    { title: "Current week (Opus)", limit: A.seven_day_opus },
  ];
  return T9.createElement(
    S,
    { flexDirection: "column", marginTop: 1, gap: 1, width: "100%" },
    J.some(({ limit: X }) => X) ||
      T9.createElement(
        U,
        { dimColor: !0 },
        "/usage is only available for subscription plans.",
      ),
    J.map(
      ({ title: X, limit: W }) =>
        W && T9.createElement(Xr5, { key: X, title: X, limit: W, maxWidth: Y }),
    ),
    T9.createElement(U, { dimColor: !0, italic: !0 }, "Esc to exit"),
  );
}
var T9, q$A;
var Tg2 = T(() => {
  nA();
  N8();
  Lg2();
  c1();
  Og2();
  ((T9 = IA(KA(), 1)), (q$A = IA(KA(), 1)));
});
function w7A({ onClose: A, context: B, defaultTab: Q }) {
  let [I, G] = p01.useState(!1),
    [Z, Y] = p01.useState(!1),
    [J, X] = p01.useState(!1);
  return (
    h1((F, C) => {
      if (C.escape || (C.ctrl && (F === "c" || F === "d")))
        A("Status dialog dismissed", { display: "system" });
    }),
    _J.createElement(
      S,
      { flexDirection: "column" },
      _J.createElement(p5, {
        dividerColor: Z ? "warning" : "permission",
        dividerDimColor: !Z,
      }),
      _J.createElement(
        S,
        { marginX: J ? 0 : 1 },
        _J.createElement(
          tc,
          { title: "Settings:", color: "permission", defaultTab: Q, hidden: I },
          [
            _J.createElement(
              LV,
              { key: "status", title: "Status" },
              _J.createElement(Hg2, { context: B }),
            ),
            _J.createElement(
              LV,
              { key: "config", title: "Config" },
              _J.createElement($g2, {
                context: B,
                onClose: A,
                setTabsHidden: G,
                setIsWarning: Y,
                setHideMargin: X,
              }),
            ),
            _J.createElement(
              LV,
              { key: "usage", title: "Usage" },
              _J.createElement(Rg2, null),
            ),
          ],
        ),
      ),
    )
  );
}
var _J, p01;
var l01 = T(() => {
  nA();
  iC();
  U$A();
  zg2();
  qg2();
  Tg2();
  ((_J = IA(KA(), 1)), (p01 = IA(KA(), 1)));
});
var dA0, Wr5, Pg2;
var jg2 = T(() => {
  l01();
  ((dA0 = IA(KA(), 1)),
    (Wr5 = {
      aliases: ["theme"],
      type: "local-jsx",
      name: "config",
      description: "Open config panel",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        return dA0.createElement(w7A, {
          onClose: A,
          context: B,
          defaultTab: "Config",
        });
      },
      userFacingName() {
        return "config";
      },
    }),
    (Pg2 = Wr5));
});
function Fr5(A) {
  return `${Math.round(A / 1000)}k`;
}
function Sg2({ data: A }) {
  let {
      categories: B,
      totalTokens: Q,
      rawMaxTokens: I,
      percentage: G,
      gridRows: Z,
      model: Y,
      memoryFiles: J,
      mcpTools: X,
      agents: W,
      slashCommands: F,
      skills: C,
      messageBreakdown: V,
    } = A,
    { columns: K } = aB(),
    D = K < 80,
    E = B.filter(
      (w) => w.tokens > 0 && w.name !== "Free space" && w.name !== i01,
    ),
    H = B.find((w) => w.name === i01);
  return t0.createElement(
    S,
    { flexDirection: "column", padding: D ? 0 : 1 },
    t0.createElement(U, { bold: !0 }, "Context Usage"),
    t0.createElement(
      S,
      { flexDirection: "row", gap: 2 },
      t0.createElement(
        S,
        { flexDirection: "column", flexShrink: 0 },
        Z.map((w, L) =>
          t0.createElement(
            S,
            { key: L, flexDirection: "row", marginLeft: -1 },
            w.map((N, $) => {
              if (N.categoryName === "Free space")
                return t0.createElement(U, { key: $, dimColor: !0 }, " ");
              if (N.categoryName === i01)
                return t0.createElement(U, { key: $, color: N.color }, " ");
              return t0.createElement(
                U,
                { key: $, color: N.color },
                N.squareFullness >= 0.7 ? " " : " ",
              );
            }),
          ),
        ),
      ),
      t0.createElement(
        S,
        { flexDirection: "column", gap: 0, flexShrink: 0 },
        t0.createElement(
          U,
          { dimColor: !0 },
          Y,
          "  ",
          Math.round(Q / 1000),
          "k/",
          Math.round(I / 1000),
          "k tokens (",
          G,
          "%)",
        ),
        t0.createElement(U, null, " "),
        E.map((w, L) => {
          let N =
              w.tokens < 1000
                ? `${w.tokens}`
                : `${(w.tokens / 1000).toFixed(1)}k`,
            $ = ((w.tokens / I) * 100).toFixed(1),
            O = w.name === i01,
            P = w.name,
            k = O ? "" : "";
          return t0.createElement(
            S,
            { key: L },
            t0.createElement(U, { color: w.color }, k),
            t0.createElement(U, null, " ", P, ": "),
            t0.createElement(U, { dimColor: !0 }, N, " tokens (", $, "%)"),
          );
        }),
        (B.find((w) => w.name === "Free space")?.tokens ?? 0) > 0 &&
          t0.createElement(
            S,
            null,
            t0.createElement(U, { dimColor: !0 }, ""),
            t0.createElement(U, null, " Free space: "),
            t0.createElement(
              U,
              { dimColor: !0 },
              Fr5(B.find((w) => w.name === "Free space")?.tokens || 0),
              " ",
              "(",
              (
                ((B.find((w) => w.name === "Free space")?.tokens || 0) / I) *
                100
              ).toFixed(1),
              "%)",
            ),
          ),
        H &&
          H.tokens > 0 &&
          t0.createElement(
            S,
            null,
            t0.createElement(U, { color: H.color }, ""),
            t0.createElement(U, { dimColor: !0 }, " ", H.name, ": "),
            t0.createElement(
              U,
              { dimColor: !0 },
              H.tokens < 1000
                ? `${H.tokens}`
                : `${(H.tokens / 1000).toFixed(1)}k`,
              " ",
              "tokens (",
              ((H.tokens / I) * 100).toFixed(1),
              "%)",
            ),
          ),
      ),
    ),
    t0.createElement(
      S,
      { flexDirection: "column", marginLeft: -1 },
      X.length > 0 &&
        t0.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          t0.createElement(
            S,
            null,
            t0.createElement(U, { bold: !0 }, "MCP tools"),
            t0.createElement(U, { dimColor: !0 }, "  /mcp"),
          ),
          X.map((w, L) =>
            t0.createElement(
              S,
              { key: L },
              t0.createElement(
                U,
                null,
                " ",
                w.name,
                " (",
                w.serverName,
                "):",
                " ",
              ),
              t0.createElement(
                U,
                { dimColor: !0 },
                w.tokens < 1000
                  ? `${w.tokens}`
                  : `${(w.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            ),
          ),
        ),
      W.length > 0 &&
        t0.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          t0.createElement(
            S,
            null,
            t0.createElement(U, { bold: !0 }, "Custom agents"),
            t0.createElement(U, { dimColor: !0 }, "  /agents"),
          ),
          W.map((w, L) => {
            let N =
              w.source === "projectSettings"
                ? "Project"
                : w.source === "userSettings"
                  ? "User"
                  : w.source === "localSettings"
                    ? "Local"
                    : w.source === "flagSettings"
                      ? "Flag"
                      : w.source === "policySettings"
                        ? "Policy"
                        : w.source === "plugin"
                          ? "Plugin"
                          : w.source === "built-in"
                            ? "Built-in"
                            : String(w.source);
            return t0.createElement(
              S,
              { key: L },
              t0.createElement(U, null, " ", w.agentType, " (", N, "):", " "),
              t0.createElement(
                U,
                { dimColor: !0 },
                w.tokens < 1000
                  ? `${w.tokens}`
                  : `${(w.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            );
          }),
        ),
      J.length > 0 &&
        t0.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          t0.createElement(
            S,
            null,
            t0.createElement(U, { bold: !0 }, "Memory files"),
            t0.createElement(U, { dimColor: !0 }, "  /memory"),
          ),
          J.map((w, L) =>
            t0.createElement(
              S,
              { key: L },
              t0.createElement(U, null, " ", w.type, " (", w.path, "):", " "),
              t0.createElement(
                U,
                { dimColor: !0 },
                w.tokens < 1000
                  ? `${w.tokens}`
                  : `${(w.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            ),
          ),
        ),
      F &&
        F.tokens > 0 &&
        t0.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          t0.createElement(
            S,
            null,
            t0.createElement(U, { bold: !0 }, "SlashCommand Tool"),
            t0.createElement(
              U,
              { dimColor: !0 },
              " ",
              "",
              " ",
              F.includedCommands < F.totalCommands
                ? `${F.includedCommands} of ${F.totalCommands} commands`
                : `${F.totalCommands} commands`,
            ),
          ),
          t0.createElement(
            S,
            null,
            t0.createElement(U, null, " Total: "),
            t0.createElement(
              U,
              { dimColor: !0 },
              F.tokens < 1000
                ? `${F.tokens}`
                : `${(F.tokens / 1000).toFixed(1)}k`,
              " ",
              "tokens",
            ),
          ),
        ),
      C && C.tokens > 0 && !1,
      V && !1,
    ),
  );
}
var t0,
  i01 = "Autocompact buffer";
var yg2 = T(() => {
  nA();
  N8();
  t0 = IA(KA(), 1);
});
import { PassThrough as Cr5 } from "stream";
function $7A(A) {
  return new Promise(async (B) => {
    let Q = "",
      I = new Cr5();
    I.on("data", (Z) => {
      Q += Z.toString();
    });
    let G = await I5(A, { stdout: I });
    process.nextTick(() => {
      (G.unmount(), B(Q));
    });
  });
}
var n01 = T(() => {
  nA();
});
function Nb(A) {
  return A < 1000 ? `${A}` : `${(A / 1000).toFixed(1)}k`;
}
function Kr5(A) {
  let {
      categories: B,
      totalTokens: Q,
      rawMaxTokens: I,
      percentage: G,
      model: Z,
      memoryFiles: Y,
      mcpTools: J,
      agents: X,
      slashCommands: W,
      skills: F,
      messageBreakdown: C,
    } = A,
    V = `## Context Usage

`;
  ((V += `**Model:** ${Z}  
`),
    (V += `**Tokens:** ${Nb(Q)} / ${Nb(I)} (${G}%)

`));
  let K = B.filter(
    (D) =>
      D.tokens > 0 &&
      D.name !== "Free space" &&
      D.name !== "Autocompact buffer",
  );
  if (K.length > 0) {
    ((V += `### Categories

`),
      (V += `| Category | Tokens | Percentage |
`),
      (V += `|----------|--------|------------|
`));
    for (let H of K) {
      let w = ((H.tokens / I) * 100).toFixed(1);
      V += `| ${H.name} | ${Nb(H.tokens)} | ${w}% |
`;
    }
    let D = B.find((H) => H.name === "Free space");
    if (D && D.tokens > 0) {
      let H = ((D.tokens / I) * 100).toFixed(1);
      V += `| Free space | ${Nb(D.tokens)} | ${H}% |
`;
    }
    let E = B.find((H) => H.name === "Autocompact buffer");
    if (E && E.tokens > 0) {
      let H = ((E.tokens / I) * 100).toFixed(1);
      V += `| Autocompact buffer | ${Nb(E.tokens)} | ${H}% |
`;
    }
    V += `
`;
  }
  if (J.length > 0) {
    ((V += `### MCP Tools

`),
      (V += `| Tool | Server | Tokens |
`),
      (V += `|------|--------|--------|
`));
    for (let D of J)
      V += `| ${D.name} | ${D.serverName} | ${Nb(D.tokens)} |
`;
    V += `
`;
  }
  if (X.length > 0) {
    ((V += `### Custom Agents

`),
      (V += `| Agent Type | Source | Tokens |
`),
      (V += `|------------|--------|--------|
`));
    for (let D of X) {
      let E;
      switch (D.source) {
        case "projectSettings":
          E = "Project";
          break;
        case "userSettings":
          E = "User";
          break;
        case "localSettings":
          E = "Local";
          break;
        case "flagSettings":
          E = "Flag";
          break;
        case "policySettings":
          E = "Policy";
          break;
        case "plugin":
          E = "Plugin";
          break;
        case "built-in":
          E = "Built-in";
          break;
        default:
          E = String(D.source);
      }
      V += `| ${D.agentType} | ${E} | ${Nb(D.tokens)} |
`;
    }
    V += `
`;
  }
  if (Y.length > 0) {
    ((V += `### Memory Files

`),
      (V += `| Type | Path | Tokens |
`),
      (V += `|------|------|--------|
`));
    for (let D of Y)
      V += `| ${D.type} | ${D.path} | ${Nb(D.tokens)} |
`;
    V += `
`;
  }
  if (W && W.tokens > 0)
    ((V += `### SlashCommand Tool

`),
      (V += `**Commands:** ${W.includedCommands < W.totalCommands ? `${W.includedCommands} of ${W.totalCommands}` : W.totalCommands}  
`),
      (V += `**Total tokens:** ${Nb(W.tokens)}

`));
  return (F && F.tokens > 0, V);
}
var cA0, Vr5, kg2;
var _g2 = T(() => {
  yg2();
  AsA();
  n01();
  B5A();
  iB();
  ((cA0 = IA(KA(), 1)),
    (Vr5 = {
      name: "context",
      description: "Visualize current context usage as a colored grid",
      isEnabled: () => !0,
      isHidden: !1,
      type: "local",
      supportsNonInteractive: !0,
      userFacingName() {
        return this.name;
      },
      async call(
        A,
        {
          messages: B,
          getAppState: Q,
          options: { mainLoopModel: I, tools: G, isNonInteractiveSession: Z },
        },
      ) {
        let Y = dj(B),
          { messages: J } = await Qd(Y),
          X = process.stdout.columns || 80,
          W = await Q(),
          F = await UdQ(
            J,
            I,
            async () => W.toolPermissionContext,
            G,
            W.agentDefinitions,
            X,
          );
        if (Z) return { type: "text", value: Kr5(F) };
        return {
          type: "text",
          value: await $7A(cA0.createElement(Sg2, { data: F })),
        };
      },
    }));
  kg2 = Vr5;
});
var Dr5, xg2;
var vg2 = T(() => {
  ux();
  F2();
  ((Dr5 = {
    type: "local",
    name: "cost",
    description: "Show the total cost and duration of the current session",
    isEnabled: () => !0,
    get isHidden() {
      return nB();
    },
    supportsNonInteractive: !0,
    async call() {
      if (nB())
        return {
          type: "text",
          value: `With your ${twA()} subscription, no need to monitor cost  your subscription includes Claude Code usage`,
        };
      return { type: "text", value: Cv1() };
    },
    userFacingName() {
      return "cost";
    },
  }),
    (xg2 = Dr5));
});
var bg2 = () => {};
function a01() {
  return N$A.createElement(
    U,
    { color: "permission" },
    "Press ",
    N$A.createElement(U, { bold: !0 }, "Enter"),
    " to continue",
  );
}
var N$A;
var pA0 = T(() => {
  nA();
  N$A = IA(KA(), 1);
});
function Er5(A, B, Q, I) {
  if (!MZ(A)) return A;
  B = KT(B, A);
  var G = -1,
    Z = B.length,
    Y = Z - 1,
    J = A;
  while (J != null && ++G < Z) {
    var X = T$(B[G]),
      W = Q;
    if (X === "__proto__" || X === "constructor" || X === "prototype") return A;
    if (G != Y) {
      var F = J[X];
      if (((W = I ? I(F, X, J) : void 0), W === void 0))
        W = MZ(F) ? F : Lf(B[G + 1]) ? [] : {};
    }
    (df(J, X, W), (J = J[X]));
  }
  return A;
}
var fg2;
var hg2 = T(() => {
  wZA();
  Te();
  OGA();
  O$();
  Yl();
  fg2 = Er5;
});
function Hr5(A, B, Q, I) {
  return (
    (I = typeof I == "function" ? I : void 0),
    A == null ? A : fg2(A, B, Q, I)
  );
}
var gg2;
var ug2 = T(() => {
  hg2();
  gg2 = Hr5;
});
function mg2(A, B = {}) {
  let {
      showValues: Q = !0,
      hideFunctions: I = !1,
      themeName: G = "dark",
      treeCharColors: Z = {},
    } = B,
    Y = [],
    J = new WeakSet();
  function X(C, V) {
    if (!V) return C;
    return OB(V, G)(C);
  }
  function W(C, V, K, D = 0) {
    if (typeof C === "string") {
      Y.push(V + X(C, Z.value));
      return;
    }
    if (typeof C !== "object" || C === null) {
      if (Q) {
        let H = String(C);
        Y.push(V + X(H, Z.value));
      }
      return;
    }
    if (J.has(C)) {
      Y.push(V + X("[Circular]", Z.value));
      return;
    }
    J.add(C);
    let E = Object.keys(C).filter((H) => {
      let w = C[H];
      if (I && typeof w === "function") return !1;
      return !0;
    });
    E.forEach((H, w) => {
      let L = C[H],
        N = w === E.length - 1,
        $ = D === 0 && w === 0 ? "" : V,
        O = N ? L$A.lastBranch : L$A.branch,
        P = X(O, Z.treeChar),
        k = H.trim() === "" ? "" : X(H, Z.key),
        b = $ + P + (k ? " " + k : ""),
        x = H.trim() !== "";
      if (L && typeof L === "object" && J.has(L)) {
        let n = X("[Circular]", Z.value);
        Y.push(b + (x ? ": " : b ? " " : "") + n);
      } else if (L && typeof L === "object" && !Array.isArray(L)) {
        Y.push(b);
        let n = N ? L$A.empty : L$A.line,
          m = X(n, Z.treeChar),
          o = $ + m + " ";
        W(L, o, N, D + 1);
      } else if (Array.isArray(L))
        Y.push(b + (x ? ": " : b ? " " : "") + "[Array(" + L.length + ")]");
      else if (Q) {
        let n = typeof L === "function" ? "[Function]" : String(L),
          m = X(n, Z.value);
        ((b += (x ? ": " : b ? " " : "") + m), Y.push(b));
      } else Y.push(b);
    });
  }
  let F = Object.keys(A);
  if (F.length === 0) return X("(empty)", Z.value);
  if (
    F.length === 1 &&
    F[0] !== void 0 &&
    F[0].trim() === "" &&
    typeof A[F[0]] === "string"
  ) {
    let C = F[0],
      V = X(L$A.lastBranch, Z.treeChar),
      K = X(A[C], Z.value);
    return V + " " + K;
  }
  return (
    W(A, "", !0),
    Y.join(`
`)
  );
}
var L$A;
var dg2 = T(() => {
  s2();
  nA();
  L$A = {
    branch: E1.lineUpDownRight,
    lastBranch: E1.lineUpRight,
    line: E1.lineVertical,
    empty: " ",
  };
});
function zr5(A) {
  let B = {};
  return (
    A.forEach((Q) => {
      if (!Q.path) {
        B[""] = Q.message;
        return;
      }
      let I = Q.path.split("."),
        G = Q.path;
      if (
        Q.invalidValue !== null &&
        Q.invalidValue !== void 0 &&
        I.length > 0
      ) {
        let Z = [];
        for (let Y = 0; Y < I.length; Y++) {
          let J = I[Y];
          if (!J) continue;
          let X = parseInt(J, 10);
          if (!isNaN(X) && Y === I.length - 1) {
            let W;
            if (typeof Q.invalidValue === "string") W = `"${Q.invalidValue}"`;
            else if (Q.invalidValue === null) W = "null";
            else if (Q.invalidValue === void 0) W = "undefined";
            else W = String(Q.invalidValue);
            Z.push(W);
          } else Z.push(J);
        }
        G = Z.join(".");
      }
      gg2(B, G, Q.message, Object);
    }),
    B
  );
}
function cg2({ errors: A }) {
  let [B] = HQ();
  if (A.length === 0) return null;
  let Q = A.reduce((G, Z) => {
      let Y = Z.file || "(file not specified)";
      if (!G[Y]) G[Y] = [];
      return (G[Y].push(Z), G);
    }, {}),
    I = Object.keys(Q).sort();
  return xJ.createElement(
    S,
    { flexDirection: "column", marginTop: 1, marginBottom: 1 },
    xJ.createElement(U, { bold: !0 }, "Invalid Settings"),
    I.map((G) => {
      let Z = Q[G] || [];
      Z.sort((W, F) => {
        if (!W.path && F.path) return -1;
        if (W.path && !F.path) return 1;
        return (W.path || "").localeCompare(F.path || "");
      });
      let Y = zr5(Z),
        J = new Map();
      Z.forEach((W) => {
        if (W.suggestion || W.docLink) {
          let F = `${W.suggestion || ""}|${W.docLink || ""}`;
          if (!J.has(F))
            J.set(F, { suggestion: W.suggestion, docLink: W.docLink });
        }
      });
      let X = mg2(Y, {
        showValues: !0,
        themeName: B,
        treeCharColors: {
          treeChar: "inactive",
          key: "text",
          value: "inactive",
        },
      });
      return xJ.createElement(
        S,
        { key: G, flexDirection: "column" },
        xJ.createElement(U, null, G),
        xJ.createElement(
          S,
          { marginLeft: 1 },
          xJ.createElement(U, { dimColor: !0 }, X),
        ),
        J.size > 0 &&
          xJ.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            Array.from(J.values()).map((W, F) =>
              xJ.createElement(
                S,
                {
                  key: `suggestion-pair-${F}`,
                  flexDirection: "column",
                  marginBottom: 1,
                },
                W.suggestion &&
                  xJ.createElement(
                    U,
                    { dimColor: !0, wrap: "wrap" },
                    W.suggestion,
                  ),
                W.docLink &&
                  xJ.createElement(
                    U,
                    { dimColor: !0, wrap: "wrap" },
                    "Learn more: ",
                    W.docLink,
                  ),
              ),
            ),
          ),
      );
    }),
  );
}
var xJ;
var pg2 = T(() => {
  nA();
  ug2();
  dg2();
  xJ = IA(KA(), 1);
});
function lA0({ scope: A, parsingErrors: B, warnings: Q }) {
  let I = B.length > 0,
    G = Q.length > 0;
  if (!I && !G) return null;
  return M7.default.createElement(
    S,
    { flexDirection: "column", marginTop: 1 },
    M7.default.createElement(
      S,
      null,
      (I || G) &&
        M7.default.createElement(
          U,
          { color: I ? "error" : "warning" },
          "[",
          I ? "Failed to parse" : "Contains warnings",
          "]",
          " ",
        ),
      M7.default.createElement(U, null, Nr(A)),
    ),
    M7.default.createElement(
      S,
      null,
      M7.default.createElement(U, { dimColor: !0 }, "Location: "),
      M7.default.createElement(U, { dimColor: !0 }, Lw(A)),
    ),
    M7.default.createElement(
      S,
      { marginLeft: 1, flexDirection: "column" },
      B.map((Z, Y) => {
        let J = Z.mcpErrorMetadata?.serverName;
        return M7.default.createElement(
          S,
          { key: `error-${Y}` },
          M7.default.createElement(
            U,
            null,
            M7.default.createElement(U, { dimColor: !0 }, " "),
            M7.default.createElement(U, { color: "error" }, "[Error]"),
            M7.default.createElement(
              U,
              { dimColor: !0 },
              " ",
              J && `[${J}] `,
              Z.path && Z.path !== "" ? `${Z.path}: ` : "",
              Z.message,
            ),
          ),
        );
      }),
      Q.map((Z, Y) => {
        let J = Z.mcpErrorMetadata?.serverName;
        return M7.default.createElement(
          S,
          { key: `warning-${Y}` },
          M7.default.createElement(
            U,
            null,
            M7.default.createElement(U, { dimColor: !0 }, " "),
            M7.default.createElement(U, { color: "warning" }, "[Warning]"),
            M7.default.createElement(
              U,
              { dimColor: !0 },
              " ",
              J && `[${J}] `,
              Z.path && Z.path !== "" ? `${Z.path}: ` : "",
              Z.message,
            ),
          ),
        );
      }),
    ),
  );
}
function s01() {
  let A = SX("user"),
    B = SX("project"),
    Q = SX("local"),
    I = {
      user: A.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal",
      ),
      project: B.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal",
      ),
      local: Q.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal",
      ),
    },
    G = {
      user: A.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning",
      ),
      project: B.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning",
      ),
      local: Q.errors.filter(
        (J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning",
      ),
    },
    Z = I.user.length > 0 || I.project.length > 0 || I.local.length > 0,
    Y = G.user.length > 0 || G.project.length > 0 || G.local.length > 0;
  if (!Z && !Y) return null;
  return M7.default.createElement(
    S,
    { flexDirection: "column", marginTop: 1, marginBottom: 1 },
    M7.default.createElement(U, { bold: !0 }, "MCP Config Diagnostics"),
    M7.default.createElement(
      S,
      { marginTop: 1 },
      M7.default.createElement(
        U,
        { dimColor: !0 },
        "For help configuring MCP servers, see:",
        " ",
        M7.default.createElement(
          R8,
          { url: "https://docs.claude.com/en/docs/claude-code/mcp" },
          "https://docs.claude.com/en/docs/claude-code/mcp",
        ),
      ),
    ),
    M7.default.createElement(lA0, {
      scope: "user",
      parsingErrors: I.user,
      warnings: G.user,
    }),
    M7.default.createElement(lA0, {
      scope: "project",
      parsingErrors: I.project,
      warnings: G.project,
    }),
    M7.default.createElement(lA0, {
      scope: "local",
      parsingErrors: I.local,
      warnings: G.local,
    }),
  );
}
var M7;
var iA0 = T(() => {
  nA();
  aN();
  kF();
  vK();
  M7 = IA(KA(), 1);
});
function lg2() {
  return M80()
    .map((B) => ({
      name: B.name,
      value: process.env[B.name],
      ...B.validate(process.env[B.name]),
    }))
    .filter((B) => B.status !== "valid");
}
var ig2 = T(() => {
  i0();
});
async function Ur5() {
  let A = qs();
  if (A.length === 0) return null;
  let B = A.sort((I, G) => G.content.length - I.content.length).map(
    (I) => `${I.path}: ${I.content.length.toLocaleString()} chars`,
  );
  return {
    type: "claudemd_files",
    severity: "warning",
    message:
      A.length === 1
        ? `Large CLAUDE.md file detected (${A[0].content.length.toLocaleString()} chars > ${fx.toLocaleString()})`
        : `${A.length} large CLAUDE.md files detected (each > ${fx.toLocaleString()} chars)`,
    details: B,
    currentValue: A.length,
    threshold: fx,
  };
}
async function wr5(A) {
  if (!A) return null;
  let B = nwA(A);
  if (B <= At) return null;
  let Q = A.activeAgents
      .filter((G) => G.source !== "built-in")
      .map((G) => {
        let Z = `${G.agentType}: ${G.whenToUse}`;
        return { name: G.agentType, tokens: i7(Z) };
      })
      .sort((G, Z) => Z.tokens - G.tokens),
    I = Q.slice(0, 5).map(
      (G) => `${G.name}: ~${G.tokens.toLocaleString()} tokens`,
    );
  if (Q.length > 5) I.push(`(${Q.length - 5} more custom agents)`);
  return {
    type: "agent_descriptions",
    severity: "warning",
    message: `Large agent descriptions (~${B.toLocaleString()} tokens > ${At.toLocaleString()})`,
    details: I,
    currentValue: B,
    threshold: At,
  };
}
async function $r5(A, B, Q) {
  let I = A.filter((G) => G.isMcp);
  if (I.length === 0) return null;
  try {
    let { mcpToolTokens: G, mcpToolDetails: Z } = await BHA(A, B, Q);
    if (G <= q7A) return null;
    let Y = new Map();
    for (let W of Z) {
      let C = W.name.split("__")[1] || "unknown",
        V = Y.get(C) || { count: 0, tokens: 0 };
      Y.set(C, { count: V.count + 1, tokens: V.tokens + W.tokens });
    }
    let J = Array.from(Y.entries()).sort((W, F) => F[1].tokens - W[1].tokens),
      X = J.slice(0, 5).map(
        ([W, F]) =>
          `${W}: ${F.count} tools (~${F.tokens.toLocaleString()} tokens)`,
      );
    if (J.length > 5) X.push(`(${J.length - 5} more servers)`);
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${G.toLocaleString()} tokens > ${q7A.toLocaleString()})`,
      details: X,
      currentValue: G,
      threshold: q7A,
    };
  } catch (G) {
    let Z = I.reduce((Y, J) => {
      let X = (J.name?.length || 0) + J.description.length;
      return Y + i7(X.toString());
    }, 0);
    if (Z <= q7A) return null;
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${Z.toLocaleString()} tokens estimated > ${q7A.toLocaleString()})`,
      details: [`${I.length} MCP tools detected (token count estimated)`],
      currentValue: Z,
      threshold: q7A,
    };
  }
}
async function ng2(A, B, Q) {
  let [I, G, Z] = await Promise.all([Ur5(), wr5(B), $r5(A, Q, B)]);
  return { claudeMdWarning: I, agentWarning: G, mcpWarning: Z };
}
var q7A = 25000;
var ag2 = T(() => {
  lD();
  je1();
  AsA();
  HN();
});
import { join as sg2 } from "path";
function r01({ onDone: A }) {
  let [B] = lB(),
    Q = B.agentDefinitions,
    I = sB.useMemo(() => {
      return B?.mcp?.tools || [];
    }, [B?.mcp?.tools]),
    [G, Z] = sB.useState(null),
    [Y, J] = sB.useState(null),
    [X, W] = sB.useState(null),
    C = M01().filter((K) => K.mcpErrorMetadata === void 0),
    V = sB.useMemo(() => lg2(), []);
  if (
    (sB.useEffect(() => {
      (SIA().then(Z),
        (async () => {
          let K = NA(),
            D = sg2(mB(), "agents"),
            E = sg2(GQ(), ".claude", "agents"),
            { activeAgents: H, allAgents: w, failedFiles: L } = Q,
            N = {
              activeAgents: H.map((O) => ({
                agentType: O.agentType,
                source: O.source,
              })),
              userAgentsDir: D,
              projectAgentsDir: E,
              userDirExists: K.existsSync(D),
              projectDirExists: K.existsSync(E),
              failedFiles: L,
            };
          J(N);
          let $ = await ng2(
            I,
            { activeAgents: H, allAgents: w, failedFiles: L },
            async () => B.toolPermissionContext,
          );
          W($);
        })());
    }, [B.toolPermissionContext, I, Q]),
    h1((K, D) => {
      if (D.return || D.escape || (D.ctrl && K === "c"))
        A("Claude Code diagnostics dismissed", { display: "system" });
    }),
    !G)
  )
    return sB.default.createElement(
      S,
      { paddingX: 1, paddingTop: 1 },
      sB.default.createElement(
        U,
        { dimColor: !0 },
        "Checking installation status",
      ),
    );
  return sB.default.createElement(
    S,
    { flexDirection: "column", gap: 1, paddingX: 1, paddingTop: 1 },
    sB.default.createElement(
      S,
      { flexDirection: "column" },
      sB.default.createElement(U, { bold: !0 }, "Diagnostics"),
      sB.default.createElement(
        U,
        null,
        " Currently running: ",
        G.installationType,
        " (",
        G.version,
        ")",
      ),
      G.packageManager &&
        sB.default.createElement(
          U,
          null,
          " Package manager: ",
          G.packageManager,
        ),
      sB.default.createElement(U, null, " Path: ", G.installationPath),
      sB.default.createElement(U, null, " Invoked: ", G.invokedBinary),
      sB.default.createElement(
        U,
        null,
        " Config install method: ",
        G.configInstallMethod,
      ),
      sB.default.createElement(
        U,
        null,
        " Auto-updates:",
        " ",
        G.packageManager ? "Managed by package manager" : G.autoUpdates,
      ),
      G.hasUpdatePermissions !== null &&
        sB.default.createElement(
          U,
          null,
          " Update permissions:",
          " ",
          G.hasUpdatePermissions ? "Yes" : "No (requires sudo)",
        ),
      sB.default.createElement(
        U,
        null,
        " Search: ",
        G.ripgrepStatus.working ? "OK" : "Not working",
        " (",
        G.ripgrepStatus.mode === "builtin"
          ? QX()
            ? "bundled"
            : "vendor"
          : G.ripgrepStatus.systemPath || "system",
        ")",
      ),
      G.recommendation &&
        sB.default.createElement(
          sB.default.Fragment,
          null,
          sB.default.createElement(U, null),
          sB.default.createElement(
            U,
            { color: "warning" },
            "Recommendation: ",
            G.recommendation.split(`
`)[0],
          ),
          sB.default.createElement(
            U,
            { dimColor: !0 },
            G.recommendation.split(`
`)[1],
          ),
        ),
      G.multipleInstallations.length > 1 &&
        sB.default.createElement(
          sB.default.Fragment,
          null,
          sB.default.createElement(U, null),
          sB.default.createElement(
            U,
            { color: "warning" },
            "Warning: Multiple installations found",
          ),
          G.multipleInstallations.map((K, D) =>
            sB.default.createElement(
              U,
              { key: D },
              " ",
              K.type,
              " at ",
              K.path,
            ),
          ),
        ),
      G.warnings.length > 0 &&
        sB.default.createElement(
          sB.default.Fragment,
          null,
          sB.default.createElement(U, null),
          G.warnings.map((K, D) =>
            sB.default.createElement(
              S,
              { key: D, flexDirection: "column" },
              sB.default.createElement(
                U,
                { color: "warning" },
                "Warning: ",
                K.issue,
              ),
              sB.default.createElement(U, null, "Fix: ", K.fix),
            ),
          ),
        ),
      C.length > 0 &&
        sB.default.createElement(
          sB.default.Fragment,
          null,
          sB.default.createElement(U, null),
          sB.default.createElement(cg2, { errors: C }),
        ),
    ),
    sB.default.createElement(s01, null),
    !1,
    V.length > 0 &&
      sB.default.createElement(
        S,
        { flexDirection: "column" },
        sB.default.createElement(U, { bold: !0 }, "Environment Variables"),
        V.map((K, D) =>
          sB.default.createElement(
            U,
            { key: D },
            " ",
            K.name,
            ":",
            " ",
            sB.default.createElement(
              U,
              { color: K.status === "capped" ? "warning" : "error" },
              K.message,
            ),
          ),
        ),
      ),
    Y?.failedFiles &&
      Y.failedFiles.length > 0 &&
      sB.default.createElement(
        S,
        { flexDirection: "column" },
        sB.default.createElement(
          U,
          { bold: !0, color: "error" },
          "Agent Parse Errors",
        ),
        sB.default.createElement(
          U,
          { color: "error" },
          " Failed to parse ",
          Y.failedFiles.length,
          " agent file(s):",
        ),
        Y.failedFiles.map((K, D) =>
          sB.default.createElement(
            U,
            { key: D, dimColor: !0 },
            "  ",
            " ",
            K.path,
            ": ",
            K.error,
          ),
        ),
      ),
    B.plugins.errors.length > 0 &&
      sB.default.createElement(
        S,
        { flexDirection: "column" },
        sB.default.createElement(
          U,
          { bold: !0, color: "error" },
          "Plugin Errors",
        ),
        sB.default.createElement(
          U,
          { color: "error" },
          " ",
          B.plugins.errors.length,
          " plugin error(s) detected:",
        ),
        B.plugins.errors.map((K, D) =>
          sB.default.createElement(
            U,
            { key: D, dimColor: !0 },
            "  ",
            " ",
            K.source || "unknown",
            "plugin" in K && K.plugin ? ` [${K.plugin}]` : "",
            ":",
            " ",
            nN(K),
          ),
        ),
      ),
    X &&
      (X.claudeMdWarning || X.agentWarning || X.mcpWarning) &&
      sB.default.createElement(
        S,
        { flexDirection: "column" },
        sB.default.createElement(U, { bold: !0 }, "Context Usage Warnings"),
        X.claudeMdWarning &&
          sB.default.createElement(
            sB.default.Fragment,
            null,
            sB.default.createElement(
              U,
              null,
              "",
              " ",
              sB.default.createElement(
                U,
                { color: "warning" },
                E1.warning,
                " ",
                X.claudeMdWarning.message,
              ),
            ),
            sB.default.createElement(U, null, "  ", " Files:"),
            X.claudeMdWarning.details.map((K, D) =>
              sB.default.createElement(
                U,
                { key: D, dimColor: !0 },
                "    ",
                " ",
                K,
              ),
            ),
          ),
        X.agentWarning &&
          sB.default.createElement(
            sB.default.Fragment,
            null,
            sB.default.createElement(
              U,
              null,
              "",
              " ",
              sB.default.createElement(
                U,
                { color: "warning" },
                E1.warning,
                " ",
                X.agentWarning.message,
              ),
            ),
            sB.default.createElement(U, null, "  ", " Top contributors:"),
            X.agentWarning.details.map((K, D) =>
              sB.default.createElement(
                U,
                { key: D, dimColor: !0 },
                "    ",
                " ",
                K,
              ),
            ),
          ),
        X.mcpWarning &&
          sB.default.createElement(
            sB.default.Fragment,
            null,
            sB.default.createElement(
              U,
              null,
              "",
              " ",
              sB.default.createElement(
                U,
                { color: "warning" },
                E1.warning,
                " ",
                X.mcpWarning.message,
              ),
            ),
            sB.default.createElement(U, null, "  ", " MCP servers:"),
            X.mcpWarning.details.map((K, D) =>
              sB.default.createElement(
                U,
                { key: D, dimColor: !0 },
                "    ",
                " ",
                K,
              ),
            ),
          ),
      ),
    sB.default.createElement(S, null, sB.default.createElement(a01, null)),
  );
}
var sB;
var nA0 = T(() => {
  nA();
  s2();
  Gc();
  pA0();
  JA0();
  pg2();
  iA0();
  i0();
  m0();
  vB();
  ig2();
  ag2();
  c9();
  sB = IA(KA(), 1);
});
var rg2, qr5, og2;
var tg2 = T(() => {
  nA0();
  ((rg2 = IA(KA(), 1)),
    (qr5 = {
      name: "doctor",
      description:
        "Diagnose and verify your Claude Code installation and settings",
      isEnabled: () => !process.env.DISABLE_DOCTOR_COMMAND,
      isHidden: !1,
      userFacingName() {
        return "doctor";
      },
      type: "local-jsx",
      call(A, B, Q) {
        return new Promise((I) =>
          I(rg2.default.createElement(r01, { onDone: A })),
        );
      },
    }),
    (og2 = qr5));
});
var aA0 = T(() => {
  vB();
});
var sA0 = T(() => {
  jHA();
  C0();
  m0();
  SHA();
  aA0();
});
var rA0 = T(() => {
  jHA();
  C0();
  c1();
  wc1();
  zc1();
  aA0();
  m0();
  SHA();
  sA0();
});
var Mr5;
var eg2 = T(() => {
  nA();
  R5();
  R9();
  nA();
  Mr5 = IA(KA(), 1);
});
var Au2;
var Bu2 = T(() => {
  nA();
  Au2 = IA(KA(), 1);
});
var oA0;
var Qu2 = T(() => {
  nA();
  rG();
  xX();
  sA0();
  C0();
  oA0 = IA(KA(), 1);
});
var o01;
var Iu2 = T(() => {
  nA();
  xX();
  rA0();
  eg2();
  Bu2();
  Qu2();
  C0();
  o01 = IA(KA(), 1);
});
var tA0;
var Gu2 = T(() => {
  nA();
  xX();
  rA0();
  C0();
  m0();
  hG();
  Iu2();
  tA0 = IA(KA(), 1);
});
function Rr5({ onDone: A }) {
  eA0.useState(() => {
    LF.cache.clear?.();
  });
  let { columns: B } = aB(),
    Q = async (X) => {
      try {
        if (X.includes(mB())) {
          let K = mB();
          if (!NA().existsSync(K)) NA().mkdirSync(K);
        }
        if (!NA().existsSync(X))
          NA().writeFileSync(X, "", { encoding: "utf8", flush: !0 });
        await LIA(X);
        let W = "default",
          F = "";
        if (process.env.VISUAL) ((W = "$VISUAL"), (F = process.env.VISUAL));
        else if (process.env.EDITOR)
          ((W = "$EDITOR"), (F = process.env.EDITOR));
        let C = W !== "default" ? `Using ${W}="${F}".` : "",
          V = C
            ? `> ${C} To change editor, set $EDITOR or $VISUAL environment variable.`
            : "> To use a different editor, set the $EDITOR or $VISUAL environment variable.";
        A(
          `Opened memory file at ${Ke1(X)}

${V}`,
          { display: "system" },
        );
      } catch (W) {
        (BA(W instanceof Error ? W : Error(String(W)), wG0),
          A(`Error opening memory file: ${W}`));
      }
    },
    I = () => {
      A("Cancelled memory editing", { display: "system" });
    },
    Z = [].length,
    [Y, J] = eA0.useState(!1);
  return (
    h1((X, W) => {}),
    nw.createElement(
      S,
      { flexDirection: "column" },
      nw.createElement(
        S,
        { marginTop: 1, marginBottom: 1 },
        nw.createElement(
          U,
          { dimColor: !0 },
          "Learn more:",
          " ",
          nw.createElement(R8, {
            url: "https://docs.claude.com/en/docs/claude-code/memory",
          }),
        ),
      ),
      !1,
      !1,
      !1,
      !Y &&
        nw.createElement(c11, {
          title: "Select memory to edit:",
          onSelect: Q,
          onCancel: I,
        }),
    )
  );
}
var nw, eA0, Or5, Zu2;
var Yu2 = T(() => {
  vB();
  c1();
  mr();
  m0();
  Ze1();
  De1();
  nA();
  vK();
  lD();
  N8();
  ((nw = IA(KA(), 1)),
    (eA0 = IA(KA(), 1)),
    (Or5 = {
      type: "local-jsx",
      name: "memory",
      description: "Edit Claude memory files",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A) {
        return nw.createElement(Rr5, { onDone: A });
      },
      userFacingName() {
        return this.name;
      },
    }));
  Zu2 = Or5;
});
function Ju2({ onCancel: A }) {
  return (
    h1((B, Q) => {
      if (Q.escape) A();
    }),
    EE.createElement(
      S,
      { flexDirection: "column", paddingY: 1, gap: 1 },
      EE.createElement(
        S,
        null,
        EE.createElement(
          U,
          null,
          "Claude understands your codebase, makes edits with your permission, and executes commands  right from your terminal.",
        ),
      ),
      EE.createElement(
        S,
        { flexDirection: "column" },
        EE.createElement(
          S,
          null,
          EE.createElement(U, { bold: !0 }, "Shortcuts"),
        ),
        EE.createElement(m11, { gap: 2 }),
      ),
    )
  );
}
var EE;
var Xu2 = T(() => {
  nA();
  Ie1();
  EE = IA(KA(), 1);
});
function A10({
  commands: A,
  maxHeight: B,
  title: Q,
  onCancel: I,
  emptyMessage: G,
}) {
  let Z = Math.max(1, B - 8),
    Y = Wu2.useMemo(
      () =>
        [...A]
          .sort((J, X) => J.name.localeCompare(X.name))
          .map((J) => ({
            label: `/${J.name}`,
            value: J.name,
            description: J.description,
          })),
      [A],
    );
  return rK.createElement(
    S,
    { flexDirection: "column", paddingY: 1 },
    A.length === 0 && G
      ? rK.createElement(U, { dimColor: !0 }, G)
      : rK.createElement(
          rK.Fragment,
          null,
          rK.createElement(U, null, Q),
          rK.createElement(
            S,
            { marginTop: 1 },
            rK.createElement($0, {
              options: Y,
              visibleOptionCount: Z,
              onCancel: I,
              disableSelection: !0,
              hideIndexes: !0,
            }),
          ),
        ),
  );
}
var rK, Wu2;
var Fu2 = T(() => {
  nA();
  Z5();
  ((rK = IA(KA(), 1)), (Wu2 = IA(KA(), 1)));
});
function Cu2({ onClose: A, commands: B }) {
  let { rows: Q } = aB(),
    I = Math.floor(Q / 2),
    G = () => A("Help dialog dismissed", { display: "system" }),
    Z = IB(G),
    Y = RS(),
    J = B.filter((C) => Y.has(C.name) && !C.isHidden),
    X = [],
    W = B.filter((C) => !Y.has(C.name) && !C.isHidden),
    F = [
      e8.createElement(
        LV,
        { key: "general", title: "general" },
        e8.createElement(Ju2, { onCancel: G }),
      ),
    ];
  return (
    F.push(
      e8.createElement(
        LV,
        { key: "commands", title: "commands" },
        e8.createElement(A10, {
          commands: J,
          maxHeight: I,
          title: "Browse default commands:",
          onCancel: G,
        }),
      ),
    ),
    F.push(
      e8.createElement(
        LV,
        { key: "custom", title: "custom-commands" },
        e8.createElement(A10, {
          commands: W,
          maxHeight: I,
          title: "Browse custom commands:",
          emptyMessage: "No custom commands found",
          onCancel: G,
        }),
      ),
    ),
    e8.createElement(
      S,
      { flexDirection: "column", height: I },
      e8.createElement(p5, { dividerColor: "professionalBlue" }),
      e8.createElement(
        S,
        { paddingX: 1, flexDirection: "column" },
        e8.createElement(
          tc,
          {
            title: `Claude Code v${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.VERSION}`,
            color: "professionalBlue",
            defaultTab: "general",
          },
          F,
        ),
        e8.createElement(
          S,
          { marginTop: 1 },
          e8.createElement(
            U,
            null,
            "For more help:",
            " ",
            e8.createElement(R8, {
              url: "https://docs.claude.com/en/docs/claude-code/overview",
            }),
          ),
        ),
        e8.createElement(
          S,
          { marginTop: 1 },
          e8.createElement(
            U,
            { dimColor: !0 },
            Z.pending
              ? e8.createElement(
                  e8.Fragment,
                  null,
                  "Press ",
                  Z.keyName,
                  " again to exit",
                )
              : e8.createElement(U, { italic: !0 }, "Esc to exit"),
          ),
        ),
      ),
    )
  );
}
var e8;
var Vu2 = T(() => {
  nA();
  iC();
  U$A();
  Xu2();
  Fu2();
  Gz();
  N8();
  R9();
  vK();
  e8 = IA(KA(), 1);
});
var B10, Tr5, Ku2;
var Du2 = T(() => {
  Vu2();
  ((B10 = IA(KA(), 1)),
    (Tr5 = {
      type: "local-jsx",
      name: "help",
      description: "Show help and available commands",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, { options: { commands: B } }) {
        return B10.createElement(Cu2, { commands: B, onClose: A });
      },
      userFacingName() {
        return "help";
      },
    }),
    (Ku2 = Tr5));
});
function Eu2({ onComplete: A }) {
  let B = IB(),
    Q = HE.useCallback(
      async (G) => {
        let Z = G === "yes",
          Y = L1();
        (n0({ ...Y, autoConnectIde: Z, hasIdeAutoConnectDialogBeenShown: !0 }),
          A());
      },
      [A],
    );
  return (
    h1((G, Z) => {
      if (Z.escape) A();
    }),
    HE.default.createElement(
      S,
      { marginTop: 1, flexDirection: "column" },
      HE.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: "ide",
          paddingX: 2,
          paddingY: 1,
          width: "100%",
        },
        HE.default.createElement(
          S,
          { marginBottom: 1 },
          HE.default.createElement(
            U,
            { color: "ide" },
            "Do you wish to enable auto-connect to IDE?",
          ),
        ),
        HE.default.createElement(
          S,
          { flexDirection: "column", paddingX: 1 },
          HE.default.createElement($0, {
            options: [
              { label: "Yes", value: "yes" },
              { label: "No", value: "no" },
            ],
            onChange: Q,
            defaultValue: "yes",
            onCancel: () => A(),
          }),
        ),
        HE.default.createElement(
          S,
          { marginTop: 1 },
          HE.default.createElement(
            U,
            { dimColor: !0 },
            "You can also configure this in /config or with the --ide flag",
          ),
        ),
      ),
      HE.default.createElement(
        S,
        { paddingX: 1 },
        HE.default.createElement(
          U,
          { dimColor: !0 },
          B.pending
            ? HE.default.createElement(
                HE.default.Fragment,
                null,
                "Press ",
                B.keyName,
                " again to exit",
              )
            : "Enter to confirm",
        ),
      ),
    )
  );
}
function Hu2() {
  let A = L1();
  return (
    !UW() &&
    A.autoConnectIde !== !0 &&
    A.hasIdeAutoConnectDialogBeenShown !== !0
  );
}
var HE;
var zu2 = T(() => {
  nA();
  kB();
  nA();
  R5();
  R9();
  zW();
  HE = IA(KA(), 1);
});
import * as wu2 from "path";
function Pr5({
  availableIDEs: A,
  unavailableIDEs: B,
  selectedIDE: Q,
  onClose: I,
  onSelect: G,
}) {
  let Z = IB(),
    [Y, J] = A4.useState(Q?.port?.toString() ?? "None"),
    [X, W] = A4.useState(!1),
    F = A4.useCallback(
      (K) => {
        if (K !== "None" && Hu2()) W(!0);
        else G(A.find((D) => D.port === parseInt(K)));
      },
      [A, G],
    ),
    C = A.reduce((K, D) => {
      return ((K[D.name] = (K[D.name] || 0) + 1), K);
    }, {}),
    V = A.map((K) => {
      let E = (C[K.name] || 0) > 1 && K.workspaceFolders.length > 0;
      return {
        label: K.name,
        value: K.port.toString(),
        description: E ? Uu2(K.workspaceFolders) : void 0,
      };
    }).concat([{ label: "None", value: "None", description: void 0 }]);
  return (
    h1((K, D) => {
      if (D.escape) I();
    }),
    X
      ? A4.default.createElement(Eu2, { onComplete: () => F(Y) })
      : A4.default.createElement(
          S,
          { marginTop: 1, flexDirection: "column" },
          A4.default.createElement(
            S,
            {
              flexDirection: "column",
              borderStyle: "round",
              borderColor: "ide",
              paddingX: 2,
              paddingY: 1,
              width: "100%",
            },
            A4.default.createElement(
              S,
              { flexDirection: "column" },
              A4.default.createElement(
                U,
                { color: "ide", bold: !0 },
                "Select IDE",
              ),
              A4.default.createElement(
                U,
                { dimColor: !0 },
                "Connect to an IDE for integrated development features.",
              ),
              A.length === 0 &&
                A4.default.createElement(
                  S,
                  { marginTop: 1 },
                  A4.default.createElement(
                    U,
                    { dimColor: !0 },
                    Av1()
                      ? `No available IDEs detected. Please install the plugin and restart your IDE:
https://docs.claude.com/s/claude-code-jetbrains`
                      : "No available IDEs detected. Make sure your IDE has the Claude Code extension or plugin installed and is running.",
                  ),
                ),
            ),
            A.length !== 0 &&
              A4.default.createElement(
                S,
                { flexDirection: "column", paddingX: 1, marginTop: 1 },
                A4.default.createElement($0, {
                  defaultValue: Y,
                  focusValue: Y,
                  options: V,
                  onFocus: (K) => J(K),
                  onChange: (K) => {
                    (J(K), F(K));
                  },
                  onCancel: () => I(),
                }),
              ),
            A.length !== 0 &&
              !UW() &&
              A4.default.createElement(
                S,
                { marginTop: 1 },
                A4.default.createElement(
                  U,
                  { dimColor: !0 },
                  " Tip: You can enable auto-connect to IDE in /config or with the --ide flag",
                ),
              ),
            B.length > 0 &&
              A4.default.createElement(
                S,
                { marginTop: 1, flexDirection: "column" },
                A4.default.createElement(
                  U,
                  { dimColor: !0 },
                  "Found ",
                  B.length,
                  " other running IDE(s). However, their workspace/project directories do not match the current cwd.",
                ),
                A4.default.createElement(
                  S,
                  { marginTop: 1, flexDirection: "column" },
                  B.map((K, D) =>
                    A4.default.createElement(
                      S,
                      { key: D, paddingLeft: 3 },
                      A4.default.createElement(
                        U,
                        { dimColor: !0 },
                        " ",
                        K.name,
                        ": ",
                        Uu2(K.workspaceFolders),
                      ),
                    ),
                  ),
                ),
              ),
          ),
          A4.default.createElement(
            S,
            { paddingX: 1 },
            A4.default.createElement(
              U,
              { dimColor: !0 },
              Z.pending
                ? A4.default.createElement(
                    A4.default.Fragment,
                    null,
                    "Press ",
                    Z.keyName,
                    " again to exit",
                  )
                : A4.default.createElement(
                    A4.default.Fragment,
                    null,
                    A.length !== 0 && "Enter to confirm  ",
                    "Esc to exit",
                  ),
            ),
          ),
        )
  );
}
async function jr5(A, B) {
  let Q = B?.ide;
  if (!Q || (Q.type !== "sse-ide" && Q.type !== "ws-ide")) return null;
  for (let I of A) if (I.url === Q.url) return I;
  return null;
}
function Sr5({ runningIDEs: A, onSelectIDE: B, onDone: Q }) {
  let I = IB(),
    [G, Z] = A4.useState(A[0] ?? ""),
    Y = A4.useCallback(
      (X) => {
        B(X);
      },
      [B],
    ),
    J = A.map((X) => ({ label: hj(X), value: X }));
  return (
    h1((X, W) => {
      if (W.escape) Q("IDE selection cancelled", { display: "system" });
    }),
    A4.default.createElement(
      A4.default.Fragment,
      null,
      A4.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: "ide",
          marginTop: 1,
          paddingX: 2,
          paddingY: 1,
          width: "100%",
        },
        A4.default.createElement(
          S,
          { marginBottom: 1 },
          A4.default.createElement(
            U,
            { color: "ide" },
            "Select IDE to install extension:",
          ),
        ),
        A4.default.createElement(
          S,
          { flexDirection: "column", paddingX: 1 },
          A4.default.createElement($0, {
            focusValue: G,
            options: J,
            onFocus: (X) => Z(X),
            onChange: (X) => {
              (Z(X), Y(X));
            },
            onCancel: () => Q("IDE selection cancelled", { display: "system" }),
          }),
        ),
      ),
      A4.default.createElement(
        S,
        { paddingLeft: 3 },
        A4.default.createElement(
          U,
          { dimColor: !0 },
          I.pending
            ? A4.default.createElement(
                A4.default.Fragment,
                null,
                "Press ",
                I.keyName,
                " again to exit",
              )
            : A4.default.createElement(
                A4.default.Fragment,
                null,
                "Enter to confirm  Esc to cancel",
              ),
        ),
      ),
    )
  );
}
function Uu2(A, B = 100) {
  if (A.length === 0) return "";
  let Q = G0(),
    I = A.slice(0, 2),
    G = A.length > 2,
    Z = G ? 3 : 0,
    Y = (I.length - 1) * 2,
    J = B - Y - Z,
    X = Math.floor(J / I.length),
    F = I.map((C) => {
      if (C.startsWith(Q + wu2.sep)) C = C.slice(Q.length + 1);
      if (C.length <= X) return C;
      return "" + C.slice(-(X - 1));
    }).join(", ");
  if (G) F += ", ";
  return F;
}
var A4, yr5, $u2;
var qu2 = T(() => {
  nA();
  R5();
  zu2();
  zW();
  H0();
  R9();
  c4A();
  V2();
  Q5();
  f2();
  A4 = IA(KA(), 1);
  ((yr5 = {
    type: "local-jsx",
    name: "ide",
    description: "Manage IDE integrations and show status",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[open]",
    async call(A, B, Q) {
      GA("tengu_ext_ide_command", {});
      let {
          options: { dynamicMcpConfig: I },
          onChangeDynamicMcpConfig: G,
        } = B,
        Z = await lDA(!0);
      if (Z.length === 0 && B.onInstallIDEExtension && !UW()) {
        let F = jiA(),
          C = (V) => {
            if (B.onInstallIDEExtension)
              if ((B.onInstallIDEExtension(V), UN(V)))
                A(`Installed plugin to ${iA.bold(hj(V))}
Please ${iA.bold("restart your IDE")} completely for it to take effect`);
              else A(`Installed extension to ${iA.bold(hj(V))}`);
          };
        if (F.length > 1)
          return A4.default.createElement(Sr5, {
            runningIDEs: F,
            onSelectIDE: C,
            onDone: () => {
              A("No IDE selected.", { display: "system" });
            },
          });
        else if (F.length === 1) {
          let V = F[0];
          return A4.default.createElement(() => {
            return (
              A4.useEffect(() => {
                C(V);
              }, []),
              null
            );
          }, null);
        }
      }
      let Y = Z.filter((F) => F.isValid),
        J = Z.filter((F) => !F.isValid),
        X = await jr5(Y, I);
      return A4.default.createElement(Pr5, {
        availableIDEs: Y,
        unavailableIDEs: J,
        selectedIDE: X,
        onClose: () => A("IDE selection cancelled", { display: "system" }),
        onSelect: async (F) => {
          try {
            if (!G) {
              A("Error connecting to IDE.");
              return;
            }
            let C = { ...(I || {}) };
            if (X) delete C.ide;
            if (!F) A(X ? `Disconnected from ${X.name}.` : "No IDE selected.");
            else {
              let V = F.url;
              ((C.ide = {
                type: V.startsWith("ws:") ? "ws-ide" : "sse-ide",
                url: V,
                ideName: F.name,
                authToken: F.authToken,
                ideRunningInWindows: F.ideRunningInWindows,
                scope: "dynamic",
              }),
                A(`Connected to ${F.name}.`));
            }
            G(C);
          } catch (C) {
            A("Error connecting to IDE.");
          }
        },
      });
    },
    userFacingName() {
      return "ide";
    },
  }),
    ($u2 = yr5));
});
var kr5, Nu2;
var Lu2 = T(() => {
  NJA();
  ((kr5 = {
    type: "prompt",
    name: "init",
    description: "Initialize a new CLAUDE.md file with codebase documentation",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing your codebase",
    userFacingName() {
      return "init";
    },
    source: "builtin",
    async getPromptForCommand() {
      return (
        P0A(),
        [
          {
            type: "text",
            text: `Please analyze this codebase and create a CLAUDE.md file, which will be given to future instances of Claude Code to operate in this repository.

What to add:
1. Commands that will be commonly used, such as how to build, lint, and run tests. Include the necessary commands to develop in this codebase, such as how to run a single test.
2. High-level code architecture and structure so that future instances can be productive more quickly. Focus on the "big picture" architecture that requires reading multiple files to understand.

Usage notes:
- If there's already a CLAUDE.md, suggest improvements to it.
- When you make the initial CLAUDE.md, do not repeat yourself and do not include obvious instructions like "Provide helpful error messages to users", "Write unit tests for all new utilities", "Never include sensitive information (API keys, tokens) in code or commits".
- Avoid listing every component or file structure that can be easily discovered.
- Don't include generic development practices.
- If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include the important parts.
- If there is a README.md, make sure to include the important parts.
- Do not make up information such as "Common Development Tasks", "Tips for Development", "Support and Documentation" unless this is expressly included in other files that you read.
- Be sure to prefix the file with the following text:

\`\`\`
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
\`\`\``,
          },
        ]
      );
    },
  }),
    (Nu2 = kr5));
});
var xR = z((mo7, AB1) => {
  var Mu2,
    Ou2,
    Ru2,
    Tu2,
    Pu2,
    ju2,
    Su2,
    yu2,
    ku2,
    _u2,
    xu2,
    vu2,
    bu2,
    t01,
    Q10,
    fu2,
    hu2,
    gu2,
    N7A,
    uu2,
    mu2,
    du2,
    cu2,
    pu2,
    lu2,
    iu2,
    nu2,
    au2,
    e01,
    su2,
    ru2,
    ou2;
  (function (A) {
    var B =
      typeof global === "object"
        ? global
        : typeof self === "object"
          ? self
          : typeof this === "object"
            ? this
            : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function (I) {
        A(Q(B, Q(I)));
      });
    else if (typeof AB1 === "object" && typeof mo7 === "object")
      A(Q(B, Q(mo7)));
    else A(Q(B));
    function Q(I, G) {
      if (I !== B)
        if (typeof Object.create === "function")
          Object.defineProperty(I, "__esModule", { value: !0 });
        else I.__esModule = !0;
      return function (Z, Y) {
        return (I[Z] = G ? G(Z, Y) : Y);
      };
    }
  })(function (A) {
    var B =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (Z, Y) {
          Z.__proto__ = Y;
        }) ||
      function (Z, Y) {
        for (var J in Y)
          if (Object.prototype.hasOwnProperty.call(Y, J)) Z[J] = Y[J];
      };
    ((Mu2 = function (Z, Y) {
      if (typeof Y !== "function" && Y !== null)
        throw TypeError(
          "Class extends value " + String(Y) + " is not a constructor or null",
        );
      B(Z, Y);
      function J() {
        this.constructor = Z;
      }
      Z.prototype =
        Y === null ? Object.create(Y) : ((J.prototype = Y.prototype), new J());
    }),
      (Ou2 =
        Object.assign ||
        function (Z) {
          for (var Y, J = 1, X = arguments.length; J < X; J++) {
            Y = arguments[J];
            for (var W in Y)
              if (Object.prototype.hasOwnProperty.call(Y, W)) Z[W] = Y[W];
          }
          return Z;
        }),
      (Ru2 = function (Z, Y) {
        var J = {};
        for (var X in Z)
          if (Object.prototype.hasOwnProperty.call(Z, X) && Y.indexOf(X) < 0)
            J[X] = Z[X];
        if (Z != null && typeof Object.getOwnPropertySymbols === "function") {
          for (
            var W = 0, X = Object.getOwnPropertySymbols(Z);
            W < X.length;
            W++
          )
            if (
              Y.indexOf(X[W]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(Z, X[W])
            )
              J[X[W]] = Z[X[W]];
        }
        return J;
      }),
      (Tu2 = function (Z, Y, J, X) {
        var W = arguments.length,
          F =
            W < 3
              ? Y
              : X === null
                ? (X = Object.getOwnPropertyDescriptor(Y, J))
                : X,
          C;
        if (
          typeof Reflect === "object" &&
          typeof Reflect.decorate === "function"
        )
          F = Reflect.decorate(Z, Y, J, X);
        else
          for (var V = Z.length - 1; V >= 0; V--)
            if ((C = Z[V]))
              F = (W < 3 ? C(F) : W > 3 ? C(Y, J, F) : C(Y, J)) || F;
        return (W > 3 && F && Object.defineProperty(Y, J, F), F);
      }),
      (Pu2 = function (Z, Y) {
        return function (J, X) {
          Y(J, X, Z);
        };
      }),
      (ju2 = function (Z, Y, J, X, W, F) {
        function C(P) {
          if (P !== void 0 && typeof P !== "function")
            throw TypeError("Function expected");
          return P;
        }
        var V = X.kind,
          K = V === "getter" ? "get" : V === "setter" ? "set" : "value",
          D = !Y && Z ? (X.static ? Z : Z.prototype) : null,
          E = Y || (D ? Object.getOwnPropertyDescriptor(D, X.name) : {}),
          H,
          w = !1;
        for (var L = J.length - 1; L >= 0; L--) {
          var N = {};
          for (var $ in X) N[$] = $ === "access" ? {} : X[$];
          for (var $ in X.access) N.access[$] = X.access[$];
          N.addInitializer = function (P) {
            if (w)
              throw TypeError(
                "Cannot add initializers after decoration has completed",
              );
            F.push(C(P || null));
          };
          var O = (0, J[L])(
            V === "accessor" ? { get: E.get, set: E.set } : E[K],
            N,
          );
          if (V === "accessor") {
            if (O === void 0) continue;
            if (O === null || typeof O !== "object")
              throw TypeError("Object expected");
            if ((H = C(O.get))) E.get = H;
            if ((H = C(O.set))) E.set = H;
            if ((H = C(O.init))) W.unshift(H);
          } else if ((H = C(O)))
            if (V === "field") W.unshift(H);
            else E[K] = H;
        }
        if (D) Object.defineProperty(D, X.name, E);
        w = !0;
      }),
      (Su2 = function (Z, Y, J) {
        var X = arguments.length > 2;
        for (var W = 0; W < Y.length; W++)
          J = X ? Y[W].call(Z, J) : Y[W].call(Z);
        return X ? J : void 0;
      }),
      (yu2 = function (Z) {
        return typeof Z === "symbol" ? Z : "".concat(Z);
      }),
      (ku2 = function (Z, Y, J) {
        if (typeof Y === "symbol")
          Y = Y.description ? "[".concat(Y.description, "]") : "";
        return Object.defineProperty(Z, "name", {
          configurable: !0,
          value: J ? "".concat(J, " ", Y) : Y,
        });
      }),
      (_u2 = function (Z, Y) {
        if (
          typeof Reflect === "object" &&
          typeof Reflect.metadata === "function"
        )
          return Reflect.metadata(Z, Y);
      }),
      (xu2 = function (Z, Y, J, X) {
        function W(F) {
          return F instanceof J
            ? F
            : new J(function (C) {
                C(F);
              });
        }
        return new (J || (J = Promise))(function (F, C) {
          function V(E) {
            try {
              D(X.next(E));
            } catch (H) {
              C(H);
            }
          }
          function K(E) {
            try {
              D(X.throw(E));
            } catch (H) {
              C(H);
            }
          }
          function D(E) {
            E.done ? F(E.value) : W(E.value).then(V, K);
          }
          D((X = X.apply(Z, Y || [])).next());
        });
      }),
      (vu2 = function (Z, Y) {
        var J = {
            label: 0,
            sent: function () {
              if (F[0] & 1) throw F[1];
              return F[1];
            },
            trys: [],
            ops: [],
          },
          X,
          W,
          F,
          C = Object.create(
            (typeof Iterator === "function" ? Iterator : Object).prototype,
          );
        return (
          (C.next = V(0)),
          (C.throw = V(1)),
          (C.return = V(2)),
          typeof Symbol === "function" &&
            (C[Symbol.iterator] = function () {
              return this;
            }),
          C
        );
        function V(D) {
          return function (E) {
            return K([D, E]);
          };
        }
        function K(D) {
          if (X) throw TypeError("Generator is already executing.");
          while ((C && ((C = 0), D[0] && (J = 0)), J))
            try {
              if (
                ((X = 1),
                W &&
                  (F =
                    D[0] & 2
                      ? W.return
                      : D[0]
                        ? W.throw || ((F = W.return) && F.call(W), 0)
                        : W.next) &&
                  !(F = F.call(W, D[1])).done)
              )
                return F;
              if (((W = 0), F)) D = [D[0] & 2, F.value];
              switch (D[0]) {
                case 0:
                case 1:
                  F = D;
                  break;
                case 4:
                  return (J.label++, { value: D[1], done: !1 });
                case 5:
                  (J.label++, (W = D[1]), (D = [0]));
                  continue;
                case 7:
                  ((D = J.ops.pop()), J.trys.pop());
                  continue;
                default:
                  if (
                    ((F = J.trys), !(F = F.length > 0 && F[F.length - 1])) &&
                    (D[0] === 6 || D[0] === 2)
                  ) {
                    J = 0;
                    continue;
                  }
                  if (D[0] === 3 && (!F || (D[1] > F[0] && D[1] < F[3]))) {
                    J.label = D[1];
                    break;
                  }
                  if (D[0] === 6 && J.label < F[1]) {
                    ((J.label = F[1]), (F = D));
                    break;
                  }
                  if (F && J.label < F[2]) {
                    ((J.label = F[2]), J.ops.push(D));
                    break;
                  }
                  if (F[2]) J.ops.pop();
                  J.trys.pop();
                  continue;
              }
              D = Y.call(Z, J);
            } catch (E) {
              ((D = [6, E]), (W = 0));
            } finally {
              X = F = 0;
            }
          if (D[0] & 5) throw D[1];
          return { value: D[0] ? D[1] : void 0, done: !0 };
        }
      }),
      (bu2 = function (Z, Y) {
        for (var J in Z)
          if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J))
            e01(Y, Z, J);
      }),
      (e01 = Object.create
        ? function (Z, Y, J, X) {
            if (X === void 0) X = J;
            var W = Object.getOwnPropertyDescriptor(Y, J);
            if (
              !W ||
              ("get" in W ? !Y.__esModule : W.writable || W.configurable)
            )
              W = {
                enumerable: !0,
                get: function () {
                  return Y[J];
                },
              };
            Object.defineProperty(Z, X, W);
          }
        : function (Z, Y, J, X) {
            if (X === void 0) X = J;
            Z[X] = Y[J];
          }),
      (t01 = function (Z) {
        var Y = typeof Symbol === "function" && Symbol.iterator,
          J = Y && Z[Y],
          X = 0;
        if (J) return J.call(Z);
        if (Z && typeof Z.length === "number")
          return {
            next: function () {
              if (Z && X >= Z.length) Z = void 0;
              return { value: Z && Z[X++], done: !Z };
            },
          };
        throw TypeError(
          Y ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      }),
      (Q10 = function (Z, Y) {
        var J = typeof Symbol === "function" && Z[Symbol.iterator];
        if (!J) return Z;
        var X = J.call(Z),
          W,
          F = [],
          C;
        try {
          while ((Y === void 0 || Y-- > 0) && !(W = X.next()).done)
            F.push(W.value);
        } catch (V) {
          C = { error: V };
        } finally {
          try {
            if (W && !W.done && (J = X.return)) J.call(X);
          } finally {
            if (C) throw C.error;
          }
        }
        return F;
      }),
      (fu2 = function () {
        for (var Z = [], Y = 0; Y < arguments.length; Y++)
          Z = Z.concat(Q10(arguments[Y]));
        return Z;
      }),
      (hu2 = function () {
        for (var Z = 0, Y = 0, J = arguments.length; Y < J; Y++)
          Z += arguments[Y].length;
        for (var X = Array(Z), W = 0, Y = 0; Y < J; Y++)
          for (var F = arguments[Y], C = 0, V = F.length; C < V; C++, W++)
            X[W] = F[C];
        return X;
      }),
      (gu2 = function (Z, Y, J) {
        if (J || arguments.length === 2) {
          for (var X = 0, W = Y.length, F; X < W; X++)
            if (F || !(X in Y)) {
              if (!F) F = Array.prototype.slice.call(Y, 0, X);
              F[X] = Y[X];
            }
        }
        return Z.concat(F || Array.prototype.slice.call(Y));
      }),
      (N7A = function (Z) {
        return this instanceof N7A ? ((this.v = Z), this) : new N7A(Z);
      }),
      (uu2 = function (Z, Y, J) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var X = J.apply(Z, Y || []),
          W,
          F = [];
        return (
          (W = Object.create(
            (typeof AsyncIterator === "function" ? AsyncIterator : Object)
              .prototype,
          )),
          V("next"),
          V("throw"),
          V("return", C),
          (W[Symbol.asyncIterator] = function () {
            return this;
          }),
          W
        );
        function C(L) {
          return function (N) {
            return Promise.resolve(N).then(L, H);
          };
        }
        function V(L, N) {
          if (X[L]) {
            if (
              ((W[L] = function ($) {
                return new Promise(function (O, P) {
                  F.push([L, $, O, P]) > 1 || K(L, $);
                });
              }),
              N)
            )
              W[L] = N(W[L]);
          }
        }
        function K(L, N) {
          try {
            D(X[L](N));
          } catch ($) {
            w(F[0][3], $);
          }
        }
        function D(L) {
          L.value instanceof N7A
            ? Promise.resolve(L.value.v).then(E, H)
            : w(F[0][2], L);
        }
        function E(L) {
          K("next", L);
        }
        function H(L) {
          K("throw", L);
        }
        function w(L, N) {
          if ((L(N), F.shift(), F.length)) K(F[0][0], F[0][1]);
        }
      }),
      (mu2 = function (Z) {
        var Y, J;
        return (
          (Y = {}),
          X("next"),
          X("throw", function (W) {
            throw W;
          }),
          X("return"),
          (Y[Symbol.iterator] = function () {
            return this;
          }),
          Y
        );
        function X(W, F) {
          Y[W] = Z[W]
            ? function (C) {
                return (J = !J)
                  ? { value: N7A(Z[W](C)), done: !1 }
                  : F
                    ? F(C)
                    : C;
              }
            : F;
        }
      }),
      (du2 = function (Z) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var Y = Z[Symbol.asyncIterator],
          J;
        return Y
          ? Y.call(Z)
          : ((Z = typeof t01 === "function" ? t01(Z) : Z[Symbol.iterator]()),
            (J = {}),
            X("next"),
            X("throw"),
            X("return"),
            (J[Symbol.asyncIterator] = function () {
              return this;
            }),
            J);
        function X(F) {
          J[F] =
            Z[F] &&
            function (C) {
              return new Promise(function (V, K) {
                ((C = Z[F](C)), W(V, K, C.done, C.value));
              });
            };
        }
        function W(F, C, V, K) {
          Promise.resolve(K).then(function (D) {
            F({ value: D, done: V });
          }, C);
        }
      }),
      (cu2 = function (Z, Y) {
        if (Object.defineProperty)
          Object.defineProperty(Z, "raw", { value: Y });
        else Z.raw = Y;
        return Z;
      }));
    var Q = Object.create
        ? function (Z, Y) {
            Object.defineProperty(Z, "default", { enumerable: !0, value: Y });
          }
        : function (Z, Y) {
            Z.default = Y;
          },
      I = function (Z) {
        return (
          (I =
            Object.getOwnPropertyNames ||
            function (Y) {
              var J = [];
              for (var X in Y)
                if (Object.prototype.hasOwnProperty.call(Y, X)) J[J.length] = X;
              return J;
            }),
          I(Z)
        );
      };
    ((pu2 = function (Z) {
      if (Z && Z.__esModule) return Z;
      var Y = {};
      if (Z != null) {
        for (var J = I(Z), X = 0; X < J.length; X++)
          if (J[X] !== "default") e01(Y, Z, J[X]);
      }
      return (Q(Y, Z), Y);
    }),
      (lu2 = function (Z) {
        return Z && Z.__esModule ? Z : { default: Z };
      }),
      (iu2 = function (Z, Y, J, X) {
        if (J === "a" && !X)
          throw TypeError("Private accessor was defined without a getter");
        if (typeof Y === "function" ? Z !== Y || !X : !Y.has(Z))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return J === "m" ? X : J === "a" ? X.call(Z) : X ? X.value : Y.get(Z);
      }),
      (nu2 = function (Z, Y, J, X, W) {
        if (X === "m") throw TypeError("Private method is not writable");
        if (X === "a" && !W)
          throw TypeError("Private accessor was defined without a setter");
        if (typeof Y === "function" ? Z !== Y || !W : !Y.has(Z))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return (X === "a" ? W.call(Z, J) : W ? (W.value = J) : Y.set(Z, J), J);
      }),
      (au2 = function (Z, Y) {
        if (Y === null || (typeof Y !== "object" && typeof Y !== "function"))
          throw TypeError("Cannot use 'in' operator on non-object");
        return typeof Z === "function" ? Y === Z : Z.has(Y);
      }),
      (su2 = function (Z, Y, J) {
        if (Y !== null && Y !== void 0) {
          if (typeof Y !== "object" && typeof Y !== "function")
            throw TypeError("Object expected.");
          var X, W;
          if (J) {
            if (!Symbol.asyncDispose)
              throw TypeError("Symbol.asyncDispose is not defined.");
            X = Y[Symbol.asyncDispose];
          }
          if (X === void 0) {
            if (!Symbol.dispose)
              throw TypeError("Symbol.dispose is not defined.");
            if (((X = Y[Symbol.dispose]), J)) W = X;
          }
          if (typeof X !== "function")
            throw TypeError("Object not disposable.");
          if (W)
            X = function () {
              try {
                W.call(this);
              } catch (F) {
                return Promise.reject(F);
              }
            };
          Z.stack.push({ value: Y, dispose: X, async: J });
        } else if (J) Z.stack.push({ async: !0 });
        return Y;
      }));
    var G =
      typeof SuppressedError === "function"
        ? SuppressedError
        : function (Z, Y, J) {
            var X = Error(J);
            return (
              (X.name = "SuppressedError"),
              (X.error = Z),
              (X.suppressed = Y),
              X
            );
          };
    ((ru2 = function (Z) {
      function Y(F) {
        ((Z.error = Z.hasError
          ? new G(F, Z.error, "An error was suppressed during disposal.")
          : F),
          (Z.hasError = !0));
      }
      var J,
        X = 0;
      function W() {
        while ((J = Z.stack.pop()))
          try {
            if (!J.async && X === 1)
              return ((X = 0), Z.stack.push(J), Promise.resolve().then(W));
            if (J.dispose) {
              var F = J.dispose.call(J.value);
              if (J.async)
                return (
                  (X |= 2),
                  Promise.resolve(F).then(W, function (C) {
                    return (Y(C), W());
                  })
                );
            } else X |= 1;
          } catch (C) {
            Y(C);
          }
        if (X === 1)
          return Z.hasError ? Promise.reject(Z.error) : Promise.resolve();
        if (Z.hasError) throw Z.error;
      }
      return W();
    }),
      (ou2 = function (Z, Y) {
        if (typeof Z === "string" && /^\.\.?\//.test(Z))
          return Z.replace(
            /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
            function (J, X, W, F, C) {
              return X
                ? Y
                  ? ".jsx"
                  : ".js"
                : W && (!F || !C)
                  ? J
                  : W + F + "." + C.toLowerCase() + "js";
            },
          );
        return Z;
      }),
      A("__extends", Mu2),
      A("__assign", Ou2),
      A("__rest", Ru2),
      A("__decorate", Tu2),
      A("__param", Pu2),
      A("__esDecorate", ju2),
      A("__runInitializers", Su2),
      A("__propKey", yu2),
      A("__setFunctionName", ku2),
      A("__metadata", _u2),
      A("__awaiter", xu2),
      A("__generator", vu2),
      A("__exportStar", bu2),
      A("__createBinding", e01),
      A("__values", t01),
      A("__read", Q10),
      A("__spread", fu2),
      A("__spreadArrays", hu2),
      A("__spreadArray", gu2),
      A("__await", N7A),
      A("__asyncGenerator", uu2),
      A("__asyncDelegator", mu2),
      A("__asyncValues", du2),
      A("__makeTemplateObject", cu2),
      A("__importStar", pu2),
      A("__importDefault", lu2),
      A("__classPrivateFieldGet", iu2),
      A("__classPrivateFieldSet", nu2),
      A("__classPrivateFieldIn", au2),
      A("__addDisposableResource", su2),
      A("__disposeResources", ru2),
      A("__rewriteRelativeImportExtension", ou2));
  });
});
var eu2 = z((tu2) => {
  Object.defineProperty(tu2, "__esModule", { value: !0 });
});
var Bm2 = z((Am2) => {
  Object.defineProperty(Am2, "__esModule", { value: !0 });
});
var I10 = z((Qm2) => {
  Object.defineProperty(Qm2, "__esModule", { value: !0 });
});
var G10 = z((xr5) => {
  function _r5(A, B, Q) {
    B.split && (B = B.split("."));
    var I = 0,
      G = B.length,
      Z = A,
      Y,
      J;
    while (I < G) {
      if (
        ((J = "" + B[I++]),
        J === "__proto__" || J === "constructor" || J === "prototype")
      )
        break;
      Z = Z[J] =
        I === G
          ? Q
          : typeof (Y = Z[J]) === typeof B
            ? Y
            : B[I] * 0 !== 0 || !!~("" + B[I]).indexOf(".")
              ? {}
              : [];
    }
  }
  xr5.dset = _r5;
});
var Zm2 = z((Im2) => {
  Object.defineProperty(Im2, "__esModule", { value: !0 });
  Im2.pickBy = void 0;
  var br5 = function (A, B) {
    return Object.keys(A)
      .filter(function (Q) {
        return B(Q, A[Q]);
      })
      .reduce(function (Q, I) {
        return ((Q[I] = A[I]), Q);
      }, {});
  };
  Im2.pickBy = br5;
});
var Z10 = z((Ym2) => {
  Object.defineProperty(Ym2, "__esModule", { value: !0 });
  Ym2.ValidationError = void 0;
  var fr5 = xR(),
    hr5 = (function (A) {
      fr5.__extends(B, A);
      function B(Q, I) {
        var G = A.call(this, "".concat(Q, " ").concat(I)) || this;
        return ((G.field = Q), G);
      }
      return B;
    })(Error);
  Ym2.ValidationError = hr5;
});
var Y10 = z((Xm2) => {
  Object.defineProperty(Xm2, "__esModule", { value: !0 });
  Xm2.isPlainObject =
    Xm2.exists =
    Xm2.isFunction =
    Xm2.isNumber =
    Xm2.isString =
      void 0;
  function gr5(A) {
    return typeof A === "string";
  }
  Xm2.isString = gr5;
  function ur5(A) {
    return typeof A === "number";
  }
  Xm2.isNumber = ur5;
  function mr5(A) {
    return typeof A === "function";
  }
  Xm2.isFunction = mr5;
  function dr5(A) {
    return A !== void 0 && A !== null;
  }
  Xm2.exists = dr5;
  function cr5(A) {
    return (
      Object.prototype.toString.call(A).slice(8, -1).toLowerCase() === "object"
    );
  }
  Xm2.isPlainObject = cr5;
});
var W10 = z((zm2) => {
  Object.defineProperty(zm2, "__esModule", { value: !0 });
  zm2.validateEvent =
    zm2.assertTraits =
    zm2.assertTrackEventProperties =
    zm2.assertTrackEventName =
    zm2.assertEventType =
    zm2.assertEventExists =
    zm2.assertUserIdentity =
      void 0;
  var ec = Z10(),
    Ft = Y10(),
    J10 = "is not a string",
    X10 = "is not an object",
    Fm2 = "is nil";
  function Cm2(A) {
    var B = ".userId/anonymousId/previousId/groupId",
      Q = function (G) {
        var Z, Y, J;
        return (J =
          (Y = (Z = G.userId) !== null && Z !== void 0 ? Z : G.anonymousId) !==
            null && Y !== void 0
            ? Y
            : G.groupId) !== null && J !== void 0
          ? J
          : G.previousId;
      },
      I = Q(A);
    if (!(0, Ft.exists)(I)) throw new ec.ValidationError(B, Fm2);
    else if (!(0, Ft.isString)(I)) throw new ec.ValidationError(B, J10);
  }
  zm2.assertUserIdentity = Cm2;
  function Vm2(A) {
    if (!(0, Ft.exists)(A)) throw new ec.ValidationError("Event", Fm2);
    if (typeof A !== "object") throw new ec.ValidationError("Event", X10);
  }
  zm2.assertEventExists = Vm2;
  function Km2(A) {
    if (!(0, Ft.isString)(A.type)) throw new ec.ValidationError(".type", J10);
  }
  zm2.assertEventType = Km2;
  function Dm2(A) {
    if (!(0, Ft.isString)(A.event)) throw new ec.ValidationError(".event", J10);
  }
  zm2.assertTrackEventName = Dm2;
  function Em2(A) {
    if (!(0, Ft.isPlainObject)(A.properties))
      throw new ec.ValidationError(".properties", X10);
  }
  zm2.assertTrackEventProperties = Em2;
  function Hm2(A) {
    if (!(0, Ft.isPlainObject)(A.traits))
      throw new ec.ValidationError(".traits", X10);
  }
  zm2.assertTraits = Hm2;
  function ar5(A) {
    if ((Vm2(A), Km2(A), A.type === "track")) (Dm2(A), Em2(A));
    if (["group", "identify"].includes(A.type)) Hm2(A);
    Cm2(A);
  }
  zm2.validateEvent = ar5;
});
var qm2 = z((F10) => {
  Object.defineProperty(F10, "__esModule", { value: !0 });
  F10.EventFactory = void 0;
  var A6 = xR();
  A6.__exportStar(I10(), F10);
  var wm2 = G10(),
    Bo5 = Zm2(),
    Qo5 = W10(),
    Io5 = (function () {
      function A(B) {
        ((this.user = B.user), (this.createMessageId = B.createMessageId));
      }
      return (
        (A.prototype.track = function (B, Q, I, G) {
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), {
              event: B,
              type: "track",
              properties: Q !== null && Q !== void 0 ? Q : {},
              options: A6.__assign({}, I),
              integrations: A6.__assign({}, G),
            }),
          );
        }),
        (A.prototype.page = function (B, Q, I, G, Z) {
          var Y,
            J = {
              type: "page",
              properties: A6.__assign({}, I),
              options: A6.__assign({}, G),
              integrations: A6.__assign({}, Z),
            };
          if (B !== null)
            ((J.category = B),
              (J.properties =
                (Y = J.properties) !== null && Y !== void 0 ? Y : {}),
              (J.properties.category = B));
          if (Q !== null) J.name = Q;
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), J),
          );
        }),
        (A.prototype.screen = function (B, Q, I, G, Z) {
          var Y = {
            type: "screen",
            properties: A6.__assign({}, I),
            options: A6.__assign({}, G),
            integrations: A6.__assign({}, Z),
          };
          if (B !== null) Y.category = B;
          if (Q !== null) Y.name = Q;
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), Y),
          );
        }),
        (A.prototype.identify = function (B, Q, I, G) {
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), {
              type: "identify",
              userId: B,
              traits: Q !== null && Q !== void 0 ? Q : {},
              options: A6.__assign({}, I),
              integrations: G,
            }),
          );
        }),
        (A.prototype.group = function (B, Q, I, G) {
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), {
              type: "group",
              traits: Q !== null && Q !== void 0 ? Q : {},
              options: A6.__assign({}, I),
              integrations: A6.__assign({}, G),
              groupId: B,
            }),
          );
        }),
        (A.prototype.alias = function (B, Q, I, G) {
          var Z = {
            userId: B,
            type: "alias",
            options: A6.__assign({}, I),
            integrations: A6.__assign({}, G),
          };
          if (Q !== null) Z.previousId = Q;
          if (B === void 0)
            return this.normalize(
              A6.__assign(A6.__assign({}, Z), this.baseEvent()),
            );
          return this.normalize(
            A6.__assign(A6.__assign({}, this.baseEvent()), Z),
          );
        }),
        (A.prototype.baseEvent = function () {
          var B = { integrations: {}, options: {} };
          if (!this.user) return B;
          var Q = this.user;
          if (Q.id()) B.userId = Q.id();
          if (Q.anonymousId()) B.anonymousId = Q.anonymousId();
          return B;
        }),
        (A.prototype.context = function (B) {
          var Q,
            I = ["userId", "anonymousId", "timestamp"];
          delete B.integrations;
          var G = Object.keys(B),
            Z = (Q = B.context) !== null && Q !== void 0 ? Q : {},
            Y = {};
          return (
            G.forEach(function (J) {
              if (J === "context") return;
              if (I.includes(J)) (0, wm2.dset)(Y, J, B[J]);
              else (0, wm2.dset)(Z, J, B[J]);
            }),
            [Z, Y]
          );
        }),
        (A.prototype.normalize = function (B) {
          var Q,
            I,
            G = Object.keys(
              (Q = B.integrations) !== null && Q !== void 0 ? Q : {},
            ).reduce(function (K, D) {
              var E, H;
              return A6.__assign(
                A6.__assign({}, K),
                ((E = {}),
                (E[D] = Boolean(
                  (H = B.integrations) === null || H === void 0 ? void 0 : H[D],
                )),
                E),
              );
            }, {});
          B.options = (0, Bo5.pickBy)(B.options || {}, function (K, D) {
            return D !== void 0;
          });
          var Z = A6.__assign(
              A6.__assign({}, G),
              (I = B.options) === null || I === void 0
                ? void 0
                : I.integrations,
            ),
            Y = B.options ? this.context(B.options) : [],
            J = Y[0],
            X = Y[1],
            W = B.options,
            F = A6.__rest(B, ["options"]),
            C = A6.__assign(
              A6.__assign(A6.__assign({ timestamp: new Date() }, F), {
                integrations: Z,
                context: J,
              }),
              X,
            ),
            V = A6.__assign(A6.__assign({}, C), {
              messageId: this.createMessageId(),
            });
          return ((0, Qo5.validateEvent)(V), V);
        }),
        A
      );
    })();
  F10.EventFactory = Io5;
});
var C10 = z((Mm2) => {
  Object.defineProperty(Mm2, "__esModule", { value: !0 });
  Mm2.invokeCallback = Mm2.sleep = Mm2.pTimeout = void 0;
  function Nm2(A, B) {
    return new Promise(function (Q, I) {
      var G = setTimeout(function () {
        I(Error("Promise timed out"));
      }, B);
      A.then(function (Z) {
        return (clearTimeout(G), Q(Z));
      }).catch(I);
    });
  }
  Mm2.pTimeout = Nm2;
  function Lm2(A) {
    return new Promise(function (B) {
      return setTimeout(B, A);
    });
  }
  Mm2.sleep = Lm2;
  function Go5(A, B, Q) {
    var I = function () {
      try {
        return Promise.resolve(B(A));
      } catch (G) {
        return Promise.reject(G);
      }
    };
    return Lm2(Q)
      .then(function () {
        return Nm2(I(), 1000);
      })
      .catch(function (G) {
        (A === null ||
          A === void 0 ||
          A.log("warn", "Callback Error", { error: G }),
          A === null || A === void 0 || A.stats.increment("callback_error"));
      })
      .then(function () {
        return A;
      });
  }
  Mm2.invokeCallback = Go5;
});
var GB1 = z((to7, IB1) => {
  var Rm2,
    Tm2,
    Pm2,
    jm2,
    Sm2,
    ym2,
    km2,
    _m2,
    xm2,
    vm2,
    bm2,
    fm2,
    hm2,
    BB1,
    V10,
    gm2,
    um2,
    mm2,
    L7A,
    dm2,
    cm2,
    pm2,
    lm2,
    im2,
    nm2,
    am2,
    sm2,
    rm2,
    QB1,
    om2,
    tm2,
    em2;
  (function (A) {
    var B =
      typeof global === "object"
        ? global
        : typeof self === "object"
          ? self
          : typeof this === "object"
            ? this
            : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function (I) {
        A(Q(B, Q(I)));
      });
    else if (typeof IB1 === "object" && typeof to7 === "object")
      A(Q(B, Q(to7)));
    else A(Q(B));
    function Q(I, G) {
      if (I !== B)
        if (typeof Object.create === "function")
          Object.defineProperty(I, "__esModule", { value: !0 });
        else I.__esModule = !0;
      return function (Z, Y) {
        return (I[Z] = G ? G(Z, Y) : Y);
      };
    }
  })(function (A) {
    var B =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (Z, Y) {
          Z.__proto__ = Y;
        }) ||
      function (Z, Y) {
        for (var J in Y)
          if (Object.prototype.hasOwnProperty.call(Y, J)) Z[J] = Y[J];
      };
    ((Rm2 = function (Z, Y) {
      if (typeof Y !== "function" && Y !== null)
        throw TypeError(
          "Class extends value " + String(Y) + " is not a constructor or null",
        );
      B(Z, Y);
      function J() {
        this.constructor = Z;
      }
      Z.prototype =
        Y === null ? Object.create(Y) : ((J.prototype = Y.prototype), new J());
    }),
      (Tm2 =
        Object.assign ||
        function (Z) {
          for (var Y, J = 1, X = arguments.length; J < X; J++) {
            Y = arguments[J];
            for (var W in Y)
              if (Object.prototype.hasOwnProperty.call(Y, W)) Z[W] = Y[W];
          }
          return Z;
        }),
      (Pm2 = function (Z, Y) {
        var J = {};
        for (var X in Z)
          if (Object.prototype.hasOwnProperty.call(Z, X) && Y.indexOf(X) < 0)
            J[X] = Z[X];
        if (Z != null && typeof Object.getOwnPropertySymbols === "function") {
          for (
            var W = 0, X = Object.getOwnPropertySymbols(Z);
            W < X.length;
            W++
          )
            if (
              Y.indexOf(X[W]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(Z, X[W])
            )
              J[X[W]] = Z[X[W]];
        }
        return J;
      }),
      (jm2 = function (Z, Y, J, X) {
        var W = arguments.length,
          F =
            W < 3
              ? Y
              : X === null
                ? (X = Object.getOwnPropertyDescriptor(Y, J))
                : X,
          C;
        if (
          typeof Reflect === "object" &&
          typeof Reflect.decorate === "function"
        )
          F = Reflect.decorate(Z, Y, J, X);
        else
          for (var V = Z.length - 1; V >= 0; V--)
            if ((C = Z[V]))
              F = (W < 3 ? C(F) : W > 3 ? C(Y, J, F) : C(Y, J)) || F;
        return (W > 3 && F && Object.defineProperty(Y, J, F), F);
      }),
      (Sm2 = function (Z, Y) {
        return function (J, X) {
          Y(J, X, Z);
        };
      }),
      (ym2 = function (Z, Y, J, X, W, F) {
        function C(P) {
          if (P !== void 0 && typeof P !== "function")
            throw TypeError("Function expected");
          return P;
        }
        var V = X.kind,
          K = V === "getter" ? "get" : V === "setter" ? "set" : "value",
          D = !Y && Z ? (X.static ? Z : Z.prototype) : null,
          E = Y || (D ? Object.getOwnPropertyDescriptor(D, X.name) : {}),
          H,
          w = !1;
        for (var L = J.length - 1; L >= 0; L--) {
          var N = {};
          for (var $ in X) N[$] = $ === "access" ? {} : X[$];
          for (var $ in X.access) N.access[$] = X.access[$];
          N.addInitializer = function (P) {
            if (w)
              throw TypeError(
                "Cannot add initializers after decoration has completed",
              );
            F.push(C(P || null));
          };
          var O = (0, J[L])(
            V === "accessor" ? { get: E.get, set: E.set } : E[K],
            N,
          );
          if (V === "accessor") {
            if (O === void 0) continue;
            if (O === null || typeof O !== "object")
              throw TypeError("Object expected");
            if ((H = C(O.get))) E.get = H;
            if ((H = C(O.set))) E.set = H;
            if ((H = C(O.init))) W.unshift(H);
          } else if ((H = C(O)))
            if (V === "field") W.unshift(H);
            else E[K] = H;
        }
        if (D) Object.defineProperty(D, X.name, E);
        w = !0;
      }),
      (km2 = function (Z, Y, J) {
        var X = arguments.length > 2;
        for (var W = 0; W < Y.length; W++)
          J = X ? Y[W].call(Z, J) : Y[W].call(Z);
        return X ? J : void 0;
      }),
      (_m2 = function (Z) {
        return typeof Z === "symbol" ? Z : "".concat(Z);
      }),
      (xm2 = function (Z, Y, J) {
        if (typeof Y === "symbol")
          Y = Y.description ? "[".concat(Y.description, "]") : "";
        return Object.defineProperty(Z, "name", {
          configurable: !0,
          value: J ? "".concat(J, " ", Y) : Y,
        });
      }),
      (vm2 = function (Z, Y) {
        if (
          typeof Reflect === "object" &&
          typeof Reflect.metadata === "function"
        )
          return Reflect.metadata(Z, Y);
      }),
      (bm2 = function (Z, Y, J, X) {
        function W(F) {
          return F instanceof J
            ? F
            : new J(function (C) {
                C(F);
              });
        }
        return new (J || (J = Promise))(function (F, C) {
          function V(E) {
            try {
              D(X.next(E));
            } catch (H) {
              C(H);
            }
          }
          function K(E) {
            try {
              D(X.throw(E));
            } catch (H) {
              C(H);
            }
          }
          function D(E) {
            E.done ? F(E.value) : W(E.value).then(V, K);
          }
          D((X = X.apply(Z, Y || [])).next());
        });
      }),
      (fm2 = function (Z, Y) {
        var J = {
            label: 0,
            sent: function () {
              if (F[0] & 1) throw F[1];
              return F[1];
            },
            trys: [],
            ops: [],
          },
          X,
          W,
          F,
          C = Object.create(
            (typeof Iterator === "function" ? Iterator : Object).prototype,
          );
        return (
          (C.next = V(0)),
          (C.throw = V(1)),
          (C.return = V(2)),
          typeof Symbol === "function" &&
            (C[Symbol.iterator] = function () {
              return this;
            }),
          C
        );
        function V(D) {
          return function (E) {
            return K([D, E]);
          };
        }
        function K(D) {
          if (X) throw TypeError("Generator is already executing.");
          while ((C && ((C = 0), D[0] && (J = 0)), J))
            try {
              if (
                ((X = 1),
                W &&
                  (F =
                    D[0] & 2
                      ? W.return
                      : D[0]
                        ? W.throw || ((F = W.return) && F.call(W), 0)
                        : W.next) &&
                  !(F = F.call(W, D[1])).done)
              )
                return F;
              if (((W = 0), F)) D = [D[0] & 2, F.value];
              switch (D[0]) {
                case 0:
                case 1:
                  F = D;
                  break;
                case 4:
                  return (J.label++, { value: D[1], done: !1 });
                case 5:
                  (J.label++, (W = D[1]), (D = [0]));
                  continue;
                case 7:
                  ((D = J.ops.pop()), J.trys.pop());
                  continue;
                default:
                  if (
                    ((F = J.trys), !(F = F.length > 0 && F[F.length - 1])) &&
                    (D[0] === 6 || D[0] === 2)
                  ) {
                    J = 0;
                    continue;
                  }
                  if (D[0] === 3 && (!F || (D[1] > F[0] && D[1] < F[3]))) {
                    J.label = D[1];
                    break;
                  }
                  if (D[0] === 6 && J.label < F[1]) {
                    ((J.label = F[1]), (F = D));
                    break;
                  }
                  if (F && J.label < F[2]) {
                    ((J.label = F[2]), J.ops.push(D));
                    break;
                  }
                  if (F[2]) J.ops.pop();
                  J.trys.pop();
                  continue;
              }
              D = Y.call(Z, J);
            } catch (E) {
              ((D = [6, E]), (W = 0));
            } finally {
              X = F = 0;
            }
          if (D[0] & 5) throw D[1];
          return { value: D[0] ? D[1] : void 0, done: !0 };
        }
      }),
      (hm2 = function (Z, Y) {
        for (var J in Z)
          if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J))
            QB1(Y, Z, J);
      }),
      (QB1 = Object.create
        ? function (Z, Y, J, X) {
            if (X === void 0) X = J;
            var W = Object.getOwnPropertyDescriptor(Y, J);
            if (
              !W ||
              ("get" in W ? !Y.__esModule : W.writable || W.configurable)
            )
              W = {
                enumerable: !0,
                get: function () {
                  return Y[J];
                },
              };
            Object.defineProperty(Z, X, W);
          }
        : function (Z, Y, J, X) {
            if (X === void 0) X = J;
            Z[X] = Y[J];
          }),
      (BB1 = function (Z) {
        var Y = typeof Symbol === "function" && Symbol.iterator,
          J = Y && Z[Y],
          X = 0;
        if (J) return J.call(Z);
        if (Z && typeof Z.length === "number")
          return {
            next: function () {
              if (Z && X >= Z.length) Z = void 0;
              return { value: Z && Z[X++], done: !Z };
            },
          };
        throw TypeError(
          Y ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      }),
      (V10 = function (Z, Y) {
        var J = typeof Symbol === "function" && Z[Symbol.iterator];
        if (!J) return Z;
        var X = J.call(Z),
          W,
          F = [],
          C;
        try {
          while ((Y === void 0 || Y-- > 0) && !(W = X.next()).done)
            F.push(W.value);
        } catch (V) {
          C = { error: V };
        } finally {
          try {
            if (W && !W.done && (J = X.return)) J.call(X);
          } finally {
            if (C) throw C.error;
          }
        }
        return F;
      }),
      (gm2 = function () {
        for (var Z = [], Y = 0; Y < arguments.length; Y++)
          Z = Z.concat(V10(arguments[Y]));
        return Z;
      }),
      (um2 = function () {
        for (var Z = 0, Y = 0, J = arguments.length; Y < J; Y++)
          Z += arguments[Y].length;
        for (var X = Array(Z), W = 0, Y = 0; Y < J; Y++)
          for (var F = arguments[Y], C = 0, V = F.length; C < V; C++, W++)
            X[W] = F[C];
        return X;
      }),
      (mm2 = function (Z, Y, J) {
        if (J || arguments.length === 2) {
          for (var X = 0, W = Y.length, F; X < W; X++)
            if (F || !(X in Y)) {
              if (!F) F = Array.prototype.slice.call(Y, 0, X);
              F[X] = Y[X];
            }
        }
        return Z.concat(F || Array.prototype.slice.call(Y));
      }),
      (L7A = function (Z) {
        return this instanceof L7A ? ((this.v = Z), this) : new L7A(Z);
      }),
      (dm2 = function (Z, Y, J) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var X = J.apply(Z, Y || []),
          W,
          F = [];
        return (
          (W = Object.create(
            (typeof AsyncIterator === "function" ? AsyncIterator : Object)
              .prototype,
          )),
          V("next"),
          V("throw"),
          V("return", C),
          (W[Symbol.asyncIterator] = function () {
            return this;
          }),
          W
        );
        function C(L) {
          return function (N) {
            return Promise.resolve(N).then(L, H);
          };
        }
        function V(L, N) {
          if (X[L]) {
            if (
              ((W[L] = function ($) {
                return new Promise(function (O, P) {
                  F.push([L, $, O, P]) > 1 || K(L, $);
                });
              }),
              N)
            )
              W[L] = N(W[L]);
          }
        }
        function K(L, N) {
          try {
            D(X[L](N));
          } catch ($) {
            w(F[0][3], $);
          }
        }
        function D(L) {
          L.value instanceof L7A
            ? Promise.resolve(L.value.v).then(E, H)
            : w(F[0][2], L);
        }
        function E(L) {
          K("next", L);
        }
        function H(L) {
          K("throw", L);
        }
        function w(L, N) {
          if ((L(N), F.shift(), F.length)) K(F[0][0], F[0][1]);
        }
      }),
      (cm2 = function (Z) {
        var Y, J;
        return (
          (Y = {}),
          X("next"),
          X("throw", function (W) {
            throw W;
          }),
          X("return"),
          (Y[Symbol.iterator] = function () {
            return this;
          }),
          Y
        );
        function X(W, F) {
          Y[W] = Z[W]
            ? function (C) {
                return (J = !J)
                  ? { value: L7A(Z[W](C)), done: !1 }
                  : F
                    ? F(C)
                    : C;
              }
            : F;
        }
      }),
      (pm2 = function (Z) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var Y = Z[Symbol.asyncIterator],
          J;
        return Y
          ? Y.call(Z)
          : ((Z = typeof BB1 === "function" ? BB1(Z) : Z[Symbol.iterator]()),
            (J = {}),
            X("next"),
            X("throw"),
            X("return"),
            (J[Symbol.asyncIterator] = function () {
              return this;
            }),
            J);
        function X(F) {
          J[F] =
            Z[F] &&
            function (C) {
              return new Promise(function (V, K) {
                ((C = Z[F](C)), W(V, K, C.done, C.value));
              });
            };
        }
        function W(F, C, V, K) {
          Promise.resolve(K).then(function (D) {
            F({ value: D, done: V });
          }, C);
        }
      }),
      (lm2 = function (Z, Y) {
        if (Object.defineProperty)
          Object.defineProperty(Z, "raw", { value: Y });
        else Z.raw = Y;
        return Z;
      }));
    var Q = Object.create
        ? function (Z, Y) {
            Object.defineProperty(Z, "default", { enumerable: !0, value: Y });
          }
        : function (Z, Y) {
            Z.default = Y;
          },
      I = function (Z) {
        return (
          (I =
            Object.getOwnPropertyNames ||
            function (Y) {
              var J = [];
              for (var X in Y)
                if (Object.prototype.hasOwnProperty.call(Y, X)) J[J.length] = X;
              return J;
            }),
          I(Z)
        );
      };
    ((im2 = function (Z) {
      if (Z && Z.__esModule) return Z;
      var Y = {};
      if (Z != null) {
        for (var J = I(Z), X = 0; X < J.length; X++)
          if (J[X] !== "default") QB1(Y, Z, J[X]);
      }
      return (Q(Y, Z), Y);
    }),
      (nm2 = function (Z) {
        return Z && Z.__esModule ? Z : { default: Z };
      }),
      (am2 = function (Z, Y, J, X) {
        if (J === "a" && !X)
          throw TypeError("Private accessor was defined without a getter");
        if (typeof Y === "function" ? Z !== Y || !X : !Y.has(Z))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return J === "m" ? X : J === "a" ? X.call(Z) : X ? X.value : Y.get(Z);
      }),
      (sm2 = function (Z, Y, J, X, W) {
        if (X === "m") throw TypeError("Private method is not writable");
        if (X === "a" && !W)
          throw TypeError("Private accessor was defined without a setter");
        if (typeof Y === "function" ? Z !== Y || !W : !Y.has(Z))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return (X === "a" ? W.call(Z, J) : W ? (W.value = J) : Y.set(Z, J), J);
      }),
      (rm2 = function (Z, Y) {
        if (Y === null || (typeof Y !== "object" && typeof Y !== "function"))
          throw TypeError("Cannot use 'in' operator on non-object");
        return typeof Z === "function" ? Y === Z : Z.has(Y);
      }),
      (om2 = function (Z, Y, J) {
        if (Y !== null && Y !== void 0) {
          if (typeof Y !== "object" && typeof Y !== "function")
            throw TypeError("Object expected.");
          var X, W;
          if (J) {
            if (!Symbol.asyncDispose)
              throw TypeError("Symbol.asyncDispose is not defined.");
            X = Y[Symbol.asyncDispose];
          }
          if (X === void 0) {
            if (!Symbol.dispose)
              throw TypeError("Symbol.dispose is not defined.");
            if (((X = Y[Symbol.dispose]), J)) W = X;
          }
          if (typeof X !== "function")
            throw TypeError("Object not disposable.");
          if (W)
            X = function () {
              try {
                W.call(this);
              } catch (F) {
                return Promise.reject(F);
              }
            };
          Z.stack.push({ value: Y, dispose: X, async: J });
        } else if (J) Z.stack.push({ async: !0 });
        return Y;
      }));
    var G =
      typeof SuppressedError === "function"
        ? SuppressedError
        : function (Z, Y, J) {
            var X = Error(J);
            return (
              (X.name = "SuppressedError"),
              (X.error = Z),
              (X.suppressed = Y),
              X
            );
          };
    ((tm2 = function (Z) {
      function Y(F) {
        ((Z.error = Z.hasError
          ? new G(F, Z.error, "An error was suppressed during disposal.")
          : F),
          (Z.hasError = !0));
      }
      var J,
        X = 0;
      function W() {
        while ((J = Z.stack.pop()))
          try {
            if (!J.async && X === 1)
              return ((X = 0), Z.stack.push(J), Promise.resolve().then(W));
            if (J.dispose) {
              var F = J.dispose.call(J.value);
              if (J.async)
                return (
                  (X |= 2),
                  Promise.resolve(F).then(W, function (C) {
                    return (Y(C), W());
                  })
                );
            } else X |= 1;
          } catch (C) {
            Y(C);
          }
        if (X === 1)
          return Z.hasError ? Promise.reject(Z.error) : Promise.resolve();
        if (Z.hasError) throw Z.error;
      }
      return W();
    }),
      (em2 = function (Z, Y) {
        if (typeof Z === "string" && /^\.\.?\//.test(Z))
          return Z.replace(
            /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
            function (J, X, W, F, C) {
              return X
                ? Y
                  ? ".jsx"
                  : ".js"
                : W && (!F || !C)
                  ? J
                  : W + F + "." + C.toLowerCase() + "js";
            },
          );
        return Z;
      }),
      A("__extends", Rm2),
      A("__assign", Tm2),
      A("__rest", Pm2),
      A("__decorate", jm2),
      A("__param", Sm2),
      A("__esDecorate", ym2),
      A("__runInitializers", km2),
      A("__propKey", _m2),
      A("__setFunctionName", xm2),
      A("__metadata", vm2),
      A("__awaiter", bm2),
      A("__generator", fm2),
      A("__exportStar", hm2),
      A("__createBinding", QB1),
      A("__values", BB1),
      A("__read", V10),
      A("__spread", gm2),
      A("__spreadArrays", um2),
      A("__spreadArray", mm2),
      A("__await", L7A),
      A("__asyncGenerator", dm2),
      A("__asyncDelegator", cm2),
      A("__asyncValues", pm2),
      A("__makeTemplateObject", lm2),
      A("__importStar", im2),
      A("__importDefault", nm2),
      A("__classPrivateFieldGet", am2),
      A("__classPrivateFieldSet", sm2),
      A("__classPrivateFieldIn", rm2),
      A("__addDisposableResource", om2),
      A("__disposeResources", tm2),
      A("__rewriteRelativeImportExtension", em2));
  });
});
var Qd2 = z((Ad2) => {
  Object.defineProperty(Ad2, "__esModule", { value: !0 });
  Ad2.createDeferred = void 0;
  var Jo5 = function () {
    var A,
      B,
      Q = new Promise(function (I, G) {
        ((A = I), (B = G));
      });
    return { resolve: A, reject: B, promise: Q };
  };
  Ad2.createDeferred = Jo5;
});
var Id2 = z((K10) => {
  Object.defineProperty(K10, "__esModule", { value: !0 });
  var Xo5 = GB1();
  Xo5.__exportStar(Qd2(), K10);
});
var Yd2 = z((Gd2) => {
  Object.defineProperty(Gd2, "__esModule", { value: !0 });
  Gd2.Emitter = void 0;
  var Wo5 = (function () {
    function A(B) {
      var Q;
      ((this.callbacks = {}),
        (this.warned = !1),
        (this.maxListeners =
          (Q = B === null || B === void 0 ? void 0 : B.maxListeners) !== null &&
          Q !== void 0
            ? Q
            : 10));
    }
    return (
      (A.prototype.warnIfPossibleMemoryLeak = function (B) {
        if (this.warned) return;
        if (this.maxListeners && this.callbacks[B].length > this.maxListeners)
          (console.warn(
            "Event Emitter: Possible memory leak detected; "
              .concat(String(B), " has exceeded ")
              .concat(this.maxListeners, " listeners."),
          ),
            (this.warned = !0));
      }),
      (A.prototype.on = function (B, Q) {
        if (!this.callbacks[B]) this.callbacks[B] = [Q];
        else (this.callbacks[B].push(Q), this.warnIfPossibleMemoryLeak(B));
        return this;
      }),
      (A.prototype.once = function (B, Q) {
        var I = this,
          G = function () {
            var Z = [];
            for (var Y = 0; Y < arguments.length; Y++) Z[Y] = arguments[Y];
            (I.off(B, G), Q.apply(I, Z));
          };
        return (this.on(B, G), this);
      }),
      (A.prototype.off = function (B, Q) {
        var I,
          G = (I = this.callbacks[B]) !== null && I !== void 0 ? I : [],
          Z = G.filter(function (Y) {
            return Y !== Q;
          });
        return ((this.callbacks[B] = Z), this);
      }),
      (A.prototype.emit = function (B) {
        var Q = this,
          I,
          G = [];
        for (var Z = 1; Z < arguments.length; Z++) G[Z - 1] = arguments[Z];
        var Y = (I = this.callbacks[B]) !== null && I !== void 0 ? I : [];
        return (
          Y.forEach(function (J) {
            J.apply(Q, G);
          }),
          this
        );
      }),
      A
    );
  })();
  Gd2.Emitter = Wo5;
});
var Jd2 = z((D10) => {
  Object.defineProperty(D10, "__esModule", { value: !0 });
  var Fo5 = GB1();
  Fo5.__exportStar(Yd2(), D10);
});
var M7A = z((ZB1) => {
  Object.defineProperty(ZB1, "__esModule", { value: !0 });
  var Xd2 = GB1();
  Xd2.__exportStar(Id2(), ZB1);
  Xd2.__exportStar(Jd2(), ZB1);
});
var E10 = z((Wd2) => {
  Object.defineProperty(Wd2, "__esModule", { value: !0 });
  Wd2.backoff = void 0;
  function Co5(A) {
    var B = Math.random() + 1,
      Q = A.minTimeout,
      I = Q === void 0 ? 500 : Q,
      G = A.factor,
      Z = G === void 0 ? 2 : G,
      Y = A.attempt,
      J = A.maxTimeout,
      X = J === void 0 ? 1 / 0 : J;
    return Math.min(B * I * Math.pow(Z, Y), X);
  }
  Wd2.backoff = Co5;
});
var H10 = z((Cd2) => {
  Object.defineProperty(Cd2, "__esModule", { value: !0 });
  Cd2.PriorityQueue = Cd2.ON_REMOVE_FROM_FUTURE = void 0;
  var Vo5 = xR(),
    Ko5 = M7A(),
    Do5 = E10();
  Cd2.ON_REMOVE_FROM_FUTURE = "onRemoveFromFuture";
  var Eo5 = (function (A) {
    Vo5.__extends(B, A);
    function B(Q, I, G) {
      var Z = A.call(this) || this;
      return (
        (Z.future = []),
        (Z.maxAttempts = Q),
        (Z.queue = I),
        (Z.seen = G !== null && G !== void 0 ? G : {}),
        Z
      );
    }
    return (
      (B.prototype.push = function () {
        var Q = this,
          I = [];
        for (var G = 0; G < arguments.length; G++) I[G] = arguments[G];
        var Z = I.map(function (Y) {
          var J = Q.updateAttempts(Y);
          if (J > Q.maxAttempts || Q.includes(Y)) return !1;
          return (Q.queue.push(Y), !0);
        });
        return (
          (this.queue = this.queue.sort(function (Y, J) {
            return Q.getAttempts(Y) - Q.getAttempts(J);
          })),
          Z
        );
      }),
      (B.prototype.pushWithBackoff = function (Q) {
        var I = this;
        if (this.getAttempts(Q) === 0) return this.push(Q)[0];
        var G = this.updateAttempts(Q);
        if (G > this.maxAttempts || this.includes(Q)) return !1;
        var Z = (0, Do5.backoff)({ attempt: G - 1 });
        return (
          setTimeout(function () {
            (I.queue.push(Q),
              (I.future = I.future.filter(function (Y) {
                return Y.id !== Q.id;
              })),
              I.emit(Cd2.ON_REMOVE_FROM_FUTURE));
          }, Z),
          this.future.push(Q),
          !0
        );
      }),
      (B.prototype.getAttempts = function (Q) {
        var I;
        return (I = this.seen[Q.id]) !== null && I !== void 0 ? I : 0;
      }),
      (B.prototype.updateAttempts = function (Q) {
        return (
          (this.seen[Q.id] = this.getAttempts(Q) + 1),
          this.getAttempts(Q)
        );
      }),
      (B.prototype.includes = function (Q) {
        return (
          this.queue.includes(Q) ||
          this.future.includes(Q) ||
          Boolean(
            this.queue.find(function (I) {
              return I.id === Q.id;
            }),
          ) ||
          Boolean(
            this.future.find(function (I) {
              return I.id === Q.id;
            }),
          )
        );
      }),
      (B.prototype.pop = function () {
        return this.queue.shift();
      }),
      Object.defineProperty(B.prototype, "length", {
        get: function () {
          return this.queue.length;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(B.prototype, "todo", {
        get: function () {
          return this.queue.length + this.future.length;
        },
        enumerable: !1,
        configurable: !0,
      }),
      B
    );
  })(Ko5.Emitter);
  Cd2.PriorityQueue = Eo5;
});
var z10 = z((zo5) => {
  var Ct = 256,
    JB1 = [],
    YB1;
  while (Ct--) JB1[Ct] = (Ct + 256).toString(16).substring(1);
  function Ho5() {
    var A = 0,
      B,
      Q = "";
    if (!YB1 || Ct + 16 > 256) {
      YB1 = Array((A = 256));
      while (A--) YB1[A] = (256 * Math.random()) | 0;
      A = Ct = 0;
    }
    for (; A < 16; A++) {
      if (((B = YB1[Ct + A]), A == 6)) Q += JB1[(B & 15) | 64];
      else if (A == 8) Q += JB1[(B & 63) | 128];
      else Q += JB1[B];
      if (A & 1 && A > 1 && A < 11) Q += "-";
    }
    return (Ct++, Q);
  }
  zo5.v4 = Ho5;
});
var U10 = z((Dd2) => {
  Object.defineProperty(Dd2, "__esModule", { value: !0 });
  Dd2.CoreLogger = void 0;
  var XB1 = xR(),
    wo5 = (function () {
      function A() {
        this._logs = [];
      }
      return (
        (A.prototype.log = function (B, Q, I) {
          var G = new Date();
          this._logs.push({ level: B, message: Q, time: G, extras: I });
        }),
        Object.defineProperty(A.prototype, "logs", {
          get: function () {
            return this._logs;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (A.prototype.flush = function () {
          if (this.logs.length > 1) {
            var B = this._logs.reduce(function (Q, I) {
              var G,
                Z,
                Y,
                J = XB1.__assign(XB1.__assign({}, I), {
                  json: JSON.stringify(I.extras, null, " "),
                  extras: I.extras,
                });
              delete J.time;
              var X =
                (Y =
                  (Z = I.time) === null || Z === void 0
                    ? void 0
                    : Z.toISOString()) !== null && Y !== void 0
                  ? Y
                  : "";
              if (Q[X]) X = "".concat(X, "-").concat(Math.random());
              return XB1.__assign(
                XB1.__assign({}, Q),
                ((G = {}), (G[X] = J), G),
              );
            }, {});
            if (console.table) console.table(B);
            else console.log(B);
          } else
            this.logs.forEach(function (Q) {
              var { level: I, message: G, extras: Z } = Q;
              if (I === "info" || I === "debug")
                console.log(G, Z !== null && Z !== void 0 ? Z : "");
              else console[I](G, Z !== null && Z !== void 0 ? Z : "");
            });
          this._logs = [];
        }),
        A
      );
    })();
  Dd2.CoreLogger = wo5;
});
var $10 = z((zd2) => {
  Object.defineProperty(zd2, "__esModule", { value: !0 });
  zd2.NullStats = zd2.CoreStats = void 0;
  var w10 = xR(),
    $o5 = function (A) {
      var B = { gauge: "g", counter: "c" };
      return B[A];
    },
    Hd2 = (function () {
      function A() {
        this.metrics = [];
      }
      return (
        (A.prototype.increment = function (B, Q, I) {
          if (Q === void 0) Q = 1;
          this.metrics.push({
            metric: B,
            value: Q,
            tags: I !== null && I !== void 0 ? I : [],
            type: "counter",
            timestamp: Date.now(),
          });
        }),
        (A.prototype.gauge = function (B, Q, I) {
          this.metrics.push({
            metric: B,
            value: Q,
            tags: I !== null && I !== void 0 ? I : [],
            type: "gauge",
            timestamp: Date.now(),
          });
        }),
        (A.prototype.flush = function () {
          var B = this.metrics.map(function (Q) {
            return w10.__assign(w10.__assign({}, Q), {
              tags: Q.tags.join(","),
            });
          });
          if (console.table) console.table(B);
          else console.log(B);
          this.metrics = [];
        }),
        (A.prototype.serialize = function () {
          return this.metrics.map(function (B) {
            return {
              m: B.metric,
              v: B.value,
              t: B.tags,
              k: $o5(B.type),
              e: B.timestamp,
            };
          });
        }),
        A
      );
    })();
  zd2.CoreStats = Hd2;
  var qo5 = (function (A) {
    w10.__extends(B, A);
    function B() {
      return (A !== null && A.apply(this, arguments)) || this;
    }
    return (
      (B.prototype.gauge = function () {
        var Q = [];
        for (var I = 0; I < arguments.length; I++) Q[I] = arguments[I];
      }),
      (B.prototype.increment = function () {
        var Q = [];
        for (var I = 0; I < arguments.length; I++) Q[I] = arguments[I];
      }),
      (B.prototype.flush = function () {
        var Q = [];
        for (var I = 0; I < arguments.length; I++) Q[I] = arguments[I];
      }),
      (B.prototype.serialize = function () {
        var Q = [];
        for (var I = 0; I < arguments.length; I++) Q[I] = arguments[I];
        return [];
      }),
      B
    );
  })(Hd2);
  zd2.NullStats = qo5;
});
var WB1 = z(($d2) => {
  Object.defineProperty($d2, "__esModule", { value: !0 });
  $d2.CoreContext = $d2.ContextCancelation = void 0;
  var Lo5 = z10(),
    Mo5 = G10(),
    Oo5 = U10(),
    Ro5 = $10(),
    wd2 = (function () {
      function A(B) {
        var Q, I, G;
        ((this.retry = (Q = B.retry) !== null && Q !== void 0 ? Q : !0),
          (this.type =
            (I = B.type) !== null && I !== void 0 ? I : "plugin Error"),
          (this.reason = (G = B.reason) !== null && G !== void 0 ? G : ""));
      }
      return A;
    })();
  $d2.ContextCancelation = wd2;
  var To5 = (function () {
    function A(B, Q, I, G) {
      if (Q === void 0) Q = (0, Lo5.v4)();
      if (I === void 0) I = new Ro5.NullStats();
      if (G === void 0) G = new Oo5.CoreLogger();
      ((this.attempts = 0),
        (this.event = B),
        (this._id = Q),
        (this.logger = G),
        (this.stats = I));
    }
    return (
      (A.system = function () {}),
      (A.prototype.isSame = function (B) {
        return B.id === this.id;
      }),
      (A.prototype.cancel = function (B) {
        if (B) throw B;
        throw new wd2({ reason: "Context Cancel" });
      }),
      (A.prototype.log = function (B, Q, I) {
        this.logger.log(B, Q, I);
      }),
      Object.defineProperty(A.prototype, "id", {
        get: function () {
          return this._id;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (A.prototype.updateEvent = function (B, Q) {
        var I;
        if (B.split(".")[0] === "integrations") {
          var G = B.split(".")[1];
          if (
            ((I = this.event.integrations) === null || I === void 0
              ? void 0
              : I[G]) === !1
          )
            return this.event;
        }
        return ((0, Mo5.dset)(this.event, B, Q), this.event);
      }),
      (A.prototype.failedDelivery = function () {
        return this._failedDelivery;
      }),
      (A.prototype.setFailedDelivery = function (B) {
        this._failedDelivery = B;
      }),
      (A.prototype.logs = function () {
        return this.logger.logs;
      }),
      (A.prototype.flush = function () {
        (this.logger.flush(), this.stats.flush());
      }),
      (A.prototype.toJSON = function () {
        return {
          id: this._id,
          event: this.event,
          logs: this.logger.logs,
          metrics: this.stats.metrics,
        };
      }),
      A
    );
  })();
  $d2.CoreContext = To5;
});
var Od2 = z((Ld2) => {
  Object.defineProperty(Ld2, "__esModule", { value: !0 });
  Ld2.groupBy = void 0;
  var Nd2 = xR();
  function jo5(A, B) {
    var Q = {};
    return (
      A.forEach(function (I) {
        var G,
          Z = void 0;
        if (typeof B === "string") {
          var Y = I[B];
          Z = typeof Y !== "string" ? JSON.stringify(Y) : Y;
        } else if (B instanceof Function) Z = B(I);
        if (Z === void 0) return;
        Q[Z] = Nd2.__spreadArray(
          Nd2.__spreadArray(
            [],
            (G = Q[Z]) !== null && G !== void 0 ? G : [],
            !0,
          ),
          [I],
          !1,
        );
      }),
      Q
    );
  }
  Ld2.groupBy = jo5;
});
var Pd2 = z((Rd2) => {
  Object.defineProperty(Rd2, "__esModule", { value: !0 });
  Rd2.isThenable = void 0;
  var So5 = function (A) {
    return (
      typeof A === "object" &&
      A !== null &&
      "then" in A &&
      typeof A.then === "function"
    );
  };
  Rd2.isThenable = So5;
});
var yd2 = z((jd2) => {
  Object.defineProperty(jd2, "__esModule", { value: !0 });
  jd2.createTaskGroup = void 0;
  var yo5 = Pd2(),
    ko5 = function () {
      var A,
        B,
        Q = 0;
      return {
        done: function () {
          return A;
        },
        run: function (I) {
          var G = I();
          if ((0, yo5.isThenable)(G)) {
            if (++Q === 1)
              A = new Promise(function (Z) {
                return (B = Z);
              });
            G.finally(function () {
              return --Q === 0 && B();
            });
          }
          return G;
        },
      };
    };
  jd2.createTaskGroup = ko5;
});
var N10 = z((xd2) => {
  Object.defineProperty(xd2, "__esModule", { value: !0 });
  xd2.ensure = xd2.attempt = void 0;
  var kd2 = xR(),
    q10 = WB1();
  function _o5(A) {
    return kd2.__awaiter(this, void 0, void 0, function () {
      var B;
      return kd2.__generator(this, function (Q) {
        switch (Q.label) {
          case 0:
            return (Q.trys.push([0, 2, , 3]), [4, A()]);
          case 1:
            return [2, Q.sent()];
          case 2:
            return ((B = Q.sent()), [2, Promise.reject(B)]);
          case 3:
            return [2];
        }
      });
    });
  }
  function _d2(A, B) {
    A.log("debug", "plugin", { plugin: B.name });
    var Q = new Date().getTime(),
      I = B[A.event.type];
    if (I === void 0) return Promise.resolve(A);
    var G = _o5(function () {
      return I.apply(B, [A]);
    })
      .then(function (Z) {
        var Y = new Date().getTime() - Q;
        return (Z.stats.gauge("plugin_time", Y, ["plugin:".concat(B.name)]), Z);
      })
      .catch(function (Z) {
        if (
          Z instanceof q10.ContextCancelation &&
          Z.type === "middleware_cancellation"
        )
          throw Z;
        if (Z instanceof q10.ContextCancelation)
          return (A.log("warn", Z.type, { plugin: B.name, error: Z }), Z);
        return (
          A.log("error", "plugin Error", { plugin: B.name, error: Z }),
          A.stats.increment("plugin_error", 1, ["plugin:".concat(B.name)]),
          Z
        );
      });
    return G;
  }
  xd2.attempt = _d2;
  function xo5(A, B) {
    return _d2(A, B).then(function (Q) {
      if (Q instanceof q10.CoreContext) return Q;
      (A.log("debug", "Context canceled"),
        A.stats.increment("context_canceled"),
        A.cancel(Q));
    });
  }
  xd2.ensure = xo5;
});
var hd2 = z((bd2) => {
  Object.defineProperty(bd2, "__esModule", { value: !0 });
  bd2.CoreEventQueue = void 0;
  var MV = xR(),
    bo5 = Od2(),
    fo5 = H10(),
    L10 = WB1(),
    ho5 = M7A(),
    go5 = yd2(),
    FB1 = N10(),
    uo5 = (function (A) {
      MV.__extends(B, A);
      function B(Q) {
        var I = A.call(this) || this;
        return (
          (I.criticalTasks = (0, go5.createTaskGroup)()),
          (I.plugins = []),
          (I.failedInitializations = []),
          (I.flushing = !1),
          (I.queue = Q),
          I.queue.on(fo5.ON_REMOVE_FROM_FUTURE, function () {
            I.scheduleFlush(0);
          }),
          I
        );
      }
      return (
        (B.prototype.register = function (Q, I, G) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var Z = this;
            return MV.__generator(this, function (Y) {
              switch (Y.label) {
                case 0:
                  return [
                    4,
                    Promise.resolve(I.load(Q, G))
                      .then(function () {
                        Z.plugins.push(I);
                      })
                      .catch(function (J) {
                        if (I.type === "destination") {
                          (Z.failedInitializations.push(I.name),
                            console.warn(I.name, J),
                            Q.log("warn", "Failed to load destination", {
                              plugin: I.name,
                              error: J,
                            }));
                          return;
                        }
                        throw J;
                      }),
                  ];
                case 1:
                  return (Y.sent(), [2]);
              }
            });
          });
        }),
        (B.prototype.deregister = function (Q, I, G) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var Z;
            return MV.__generator(this, function (Y) {
              switch (Y.label) {
                case 0:
                  if ((Y.trys.push([0, 3, , 4]), !I.unload)) return [3, 2];
                  return [4, Promise.resolve(I.unload(Q, G))];
                case 1:
                  (Y.sent(), (Y.label = 2));
                case 2:
                  return (
                    (this.plugins = this.plugins.filter(function (J) {
                      return J.name !== I.name;
                    })),
                    [3, 4]
                  );
                case 3:
                  return (
                    (Z = Y.sent()),
                    Q.log("warn", "Failed to unload destination", {
                      plugin: I.name,
                      error: Z,
                    }),
                    [3, 4]
                  );
                case 4:
                  return [2];
              }
            });
          });
        }),
        (B.prototype.dispatch = function (Q) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var I;
            return MV.__generator(this, function (G) {
              return (
                Q.log("debug", "Dispatching"),
                Q.stats.increment("message_dispatched"),
                this.queue.push(Q),
                (I = this.subscribeToDelivery(Q)),
                this.scheduleFlush(0),
                [2, I]
              );
            });
          });
        }),
        (B.prototype.subscribeToDelivery = function (Q) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var I = this;
            return MV.__generator(this, function (G) {
              return [
                2,
                new Promise(function (Z) {
                  var Y = function (J, X) {
                    if (J.isSame(Q))
                      if ((I.off("flush", Y), X)) Z(J);
                      else Z(J);
                  };
                  I.on("flush", Y);
                }),
              ];
            });
          });
        }),
        (B.prototype.dispatchSingle = function (Q) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var I = this;
            return MV.__generator(this, function (G) {
              return (
                Q.log("debug", "Dispatching"),
                Q.stats.increment("message_dispatched"),
                this.queue.updateAttempts(Q),
                (Q.attempts = 1),
                [
                  2,
                  this.deliver(Q).catch(function (Z) {
                    var Y = I.enqueuRetry(Z, Q);
                    if (!Y) return (Q.setFailedDelivery({ reason: Z }), Q);
                    return I.subscribeToDelivery(Q);
                  }),
                ]
              );
            });
          });
        }),
        (B.prototype.isEmpty = function () {
          return this.queue.length === 0;
        }),
        (B.prototype.scheduleFlush = function (Q) {
          var I = this;
          if (Q === void 0) Q = 500;
          if (this.flushing) return;
          ((this.flushing = !0),
            setTimeout(function () {
              I.flush().then(function () {
                setTimeout(function () {
                  if (((I.flushing = !1), I.queue.length)) I.scheduleFlush(0);
                }, 0);
              });
            }, Q));
        }),
        (B.prototype.deliver = function (Q) {
          return MV.__awaiter(this, void 0, void 0, function () {
            var I, G, Z, Y;
            return MV.__generator(this, function (J) {
              switch (J.label) {
                case 0:
                  return [4, this.criticalTasks.done()];
                case 1:
                  (J.sent(), (I = Date.now()), (J.label = 2));
                case 2:
                  return (J.trys.push([2, 4, , 5]), [4, this.flushOne(Q)]);
                case 3:
                  return (
                    (Q = J.sent()),
                    (G = Date.now() - I),
                    this.emit("delivery_success", Q),
                    Q.stats.gauge("delivered", G),
                    Q.log("debug", "Delivered", Q.event),
                    [2, Q]
                  );
                case 4:
                  throw (
                    (Z = J.sent()),
                    (Y = Z),
                    Q.log("error", "Failed to deliver", Y),
                    this.emit("delivery_failure", Q, Y),
                    Q.stats.increment("delivery_failed"),
                    Z
                  );
                case 5:
                  return [2];
              }
            });
          });
        }),
        (B.prototype.enqueuRetry = function (Q, I) {
          var G = !(Q instanceof L10.ContextCancelation) || Q.retry;
          if (!G) return !1;
          return this.queue.pushWithBackoff(I);
        }),
        (B.prototype.flush = function () {
          return MV.__awaiter(this, void 0, void 0, function () {
            var Q, I, G;
            return MV.__generator(this, function (Z) {
              switch (Z.label) {
                case 0:
                  if (this.queue.length === 0) return [2, []];
                  if (((Q = this.queue.pop()), !Q)) return [2, []];
                  ((Q.attempts = this.queue.getAttempts(Q)), (Z.label = 1));
                case 1:
                  return (Z.trys.push([1, 3, , 4]), [4, this.deliver(Q)]);
                case 2:
                  return ((Q = Z.sent()), this.emit("flush", Q, !0), [3, 4]);
                case 3:
                  if (((I = Z.sent()), (G = this.enqueuRetry(I, Q)), !G))
                    (Q.setFailedDelivery({ reason: I }),
                      this.emit("flush", Q, !1));
                  return [2, []];
                case 4:
                  return [2, [Q]];
              }
            });
          });
        }),
        (B.prototype.isReady = function () {
          return !0;
        }),
        (B.prototype.availableExtensions = function (Q) {
          var I = this.plugins.filter(function (K) {
              var D, E, H;
              if (K.type !== "destination" && K.name !== "Segment.io")
                return !0;
              var w = void 0;
              return (
                (D = K.alternativeNames) === null ||
                  D === void 0 ||
                  D.forEach(function (L) {
                    if (Q[L] !== void 0) w = Q[L];
                  }),
                (H = (E = Q[K.name]) !== null && E !== void 0 ? E : w) !==
                  null && H !== void 0
                  ? H
                  : (K.name === "Segment.io" ? !0 : Q.All) !== !1
              );
            }),
            G = (0, bo5.groupBy)(I, "type"),
            Z = G.before,
            Y = Z === void 0 ? [] : Z,
            J = G.enrichment,
            X = J === void 0 ? [] : J,
            W = G.destination,
            F = W === void 0 ? [] : W,
            C = G.after,
            V = C === void 0 ? [] : C;
          return { before: Y, enrichment: X, destinations: F, after: V };
        }),
        (B.prototype.flushOne = function (Q) {
          var I, G;
          return MV.__awaiter(this, void 0, void 0, function () {
            var Z, Y, J, X, W, F, D, C, V, K, D, E, H, w, L;
            return MV.__generator(this, function (N) {
              switch (N.label) {
                case 0:
                  if (!this.isReady()) throw Error("Not ready");
                  if (Q.attempts > 1) this.emit("delivery_retry", Q);
                  ((Z = this.availableExtensions(
                    (I = Q.event.integrations) !== null && I !== void 0
                      ? I
                      : {},
                  )),
                    (Y = Z.before),
                    (J = Z.enrichment),
                    (X = 0),
                    (W = Y),
                    (N.label = 1));
                case 1:
                  if (!(X < W.length)) return [3, 4];
                  return ((F = W[X]), [4, (0, FB1.ensure)(Q, F)]);
                case 2:
                  if (((D = N.sent()), D instanceof L10.CoreContext)) Q = D;
                  (this.emit("message_enriched", Q, F), (N.label = 3));
                case 3:
                  return (X++, [3, 1]);
                case 4:
                  ((C = 0), (V = J), (N.label = 5));
                case 5:
                  if (!(C < V.length)) return [3, 8];
                  return ((K = V[C]), [4, (0, FB1.attempt)(Q, K)]);
                case 6:
                  if (((D = N.sent()), D instanceof L10.CoreContext)) Q = D;
                  (this.emit("message_enriched", Q, K), (N.label = 7));
                case 7:
                  return (C++, [3, 5]);
                case 8:
                  return (
                    (E = this.availableExtensions(
                      (G = Q.event.integrations) !== null && G !== void 0
                        ? G
                        : {},
                    )),
                    (H = E.destinations),
                    (w = E.after),
                    [
                      4,
                      new Promise(function ($, O) {
                        setTimeout(function () {
                          var P = H.map(function (k) {
                            return (0, FB1.attempt)(Q, k);
                          });
                          Promise.all(P).then($).catch(O);
                        }, 0);
                      }),
                    ]
                  );
                case 9:
                  return (
                    N.sent(),
                    Q.stats.increment("message_delivered"),
                    this.emit("message_delivered", Q),
                    (L = w.map(function ($) {
                      return (0, FB1.attempt)(Q, $);
                    })),
                    [4, Promise.all(L)]
                  );
                case 10:
                  return (N.sent(), [2, Q]);
              }
            });
          });
        }),
        B
      );
    })(ho5.Emitter);
  bd2.CoreEventQueue = uo5;
});
var ud2 = z((gd2) => {
  Object.defineProperty(gd2, "__esModule", { value: !0 });
});
var ld2 = z((dd2) => {
  Object.defineProperty(dd2, "__esModule", { value: !0 });
  dd2.dispatch = dd2.getDelay = void 0;
  var md2 = xR(),
    mo5 = C10(),
    do5 = function (A, B) {
      var Q = Date.now() - A;
      return Math.max((B !== null && B !== void 0 ? B : 300) - Q, 0);
    };
  dd2.getDelay = do5;
  function co5(A, B, Q, I) {
    return md2.__awaiter(this, void 0, void 0, function () {
      var G, Z;
      return md2.__generator(this, function (Y) {
        switch (Y.label) {
          case 0:
            if ((Q.emit("dispatch_start", A), (G = Date.now()), !B.isEmpty()))
              return [3, 2];
            return [4, B.dispatchSingle(A)];
          case 1:
            return ((Z = Y.sent()), [3, 4]);
          case 2:
            return [4, B.dispatch(A)];
          case 3:
            ((Z = Y.sent()), (Y.label = 4));
          case 4:
            if (!(I === null || I === void 0 ? void 0 : I.callback))
              return [3, 6];
            return [
              4,
              (0, mo5.invokeCallback)(
                Z,
                I.callback,
                dd2.getDelay(G, I.timeout),
              ),
            ];
          case 5:
            ((Z = Y.sent()), (Y.label = 6));
          case 6:
            if (I === null || I === void 0 ? void 0 : I.debug) Z.flush();
            return [2, Z];
        }
      });
    });
  }
  dd2.dispatch = co5;
});
var ad2 = z((id2) => {
  Object.defineProperty(id2, "__esModule", { value: !0 });
  id2.bindAll = void 0;
  function po5(A) {
    var B = A.constructor.prototype;
    for (var Q = 0, I = Object.getOwnPropertyNames(B); Q < I.length; Q++) {
      var G = I[Q];
      if (G !== "constructor") {
        var Z = Object.getOwnPropertyDescriptor(A.constructor.prototype, G);
        if (!!Z && typeof Z.value === "function") A[G] = A[G].bind(A);
      }
    }
    return A;
  }
  id2.bindAll = po5;
});
var Ap = z((hX) => {
  Object.defineProperty(hX, "__esModule", { value: !0 });
  hX.CoreLogger = hX.backoff = void 0;
  var oK = xR();
  oK.__exportStar(eu2(), hX);
  oK.__exportStar(Bm2(), hX);
  oK.__exportStar(I10(), hX);
  oK.__exportStar(qm2(), hX);
  oK.__exportStar(C10(), hX);
  oK.__exportStar(H10(), hX);
  var lo5 = E10();
  Object.defineProperty(hX, "backoff", {
    enumerable: !0,
    get: function () {
      return lo5.backoff;
    },
  });
  oK.__exportStar(WB1(), hX);
  oK.__exportStar(hd2(), hX);
  oK.__exportStar(ud2(), hX);
  oK.__exportStar(ld2(), hX);
  oK.__exportStar(Y10(), hX);
  oK.__exportStar(Z10(), hX);
  oK.__exportStar(W10(), hX);
  oK.__exportStar(ad2(), hX);
  oK.__exportStar($10(), hX);
  var io5 = U10();
  Object.defineProperty(hX, "CoreLogger", {
    enumerable: !0,
    get: function () {
      return io5.CoreLogger;
    },
  });
  oK.__exportStar(N10(), hX);
});
var od2 = z((sd2) => {
  Object.defineProperty(sd2, "__esModule", { value: !0 });
  sd2.validateSettings = void 0;
  var ao5 = Ap(),
    so5 = (A) => {
      if (!A.writeKey)
        throw new ao5.ValidationError("writeKey", "writeKey is missing.");
    };
  sd2.validateSettings = so5;
});
var M10 = z((td2) => {
  Object.defineProperty(td2, "__esModule", { value: !0 });
  td2.version = void 0;
  td2.version = "1.3.0";
});
var Qc2 = z((Ac2) => {
  Object.defineProperty(Ac2, "__esModule", { value: !0 });
  Ac2.tryCreateFormattedUrl = void 0;
  var ro5 = (A) => A.replace(/\/$/, ""),
    oo5 = (A, B) => {
      return ro5(new URL(B || "", A).href);
    };
  Ac2.tryCreateFormattedUrl = oo5;
});
var R10 = z((O10) => {
  Object.defineProperty(O10, "__esModule", { value: !0 });
  O10.uuid = void 0;
  var to5 = z10();
  Object.defineProperty(O10, "uuid", {
    enumerable: !0,
    get: function () {
      return to5.v4;
    },
  });
});
var Xc2 = z((Yc2) => {
  Object.defineProperty(Yc2, "__esModule", { value: !0 });
  Yc2.ContextBatch = void 0;
  var At5 = R10(),
    Ic2 = 32,
    Gc2 = 480;
  class Zc2 {
    constructor(A) {
      ((this.id = (0, At5.uuid)()),
        (this.items = []),
        (this.sizeInBytes = 0),
        (this.maxEventCount = Math.max(1, A)));
    }
    tryAdd(A) {
      if (this.length === this.maxEventCount)
        return {
          success: !1,
          message: `Event limit of ${this.maxEventCount} has been exceeded.`,
        };
      let B = this.calculateSize(A.context);
      if (B > Ic2 * 1024)
        return {
          success: !1,
          message: `Event exceeds maximum event size of ${Ic2} KB`,
        };
      if (this.sizeInBytes + B > Gc2 * 1024)
        return {
          success: !1,
          message: `Event has caused batch size to exceed ${Gc2} KB`,
        };
      return (this.items.push(A), (this.sizeInBytes += B), { success: !0 });
    }
    get length() {
      return this.items.length;
    }
    calculateSize(A) {
      return encodeURI(JSON.stringify(A.event)).split(/%..|i/).length;
    }
    getEvents() {
      return this.items.map(({ context: B }) => B.event);
    }
    getContexts() {
      return this.items.map((A) => A.context);
    }
    resolveEvents() {
      this.items.forEach(({ resolver: A, context: B }) => A(B));
    }
  }
  Yc2.ContextBatch = Zc2;
});
var Cc2 = z((Wc2) => {
  Object.defineProperty(Wc2, "__esModule", { value: !0 });
  Wc2.b64encode = void 0;
  var Bt5 = EA("buffer"),
    Qt5 = (A) => {
      return Bt5.Buffer.from(A).toString("base64");
    };
  Wc2.b64encode = Qt5;
});
var Hc2 = z((Dc2) => {
  Object.defineProperty(Dc2, "__esModule", { value: !0 });
  Dc2.Publisher = void 0;
  var It5 = Ap(),
    Gt5 = Qc2(),
    Zt5 = M7A(),
    Yt5 = Xc2(),
    Jt5 = Cc2();
  function Xt5(A) {
    return new Promise((B) => setTimeout(B, A));
  }
  function M$A() {}
  class Kc2 {
    constructor(
      {
        host: A,
        path: B,
        maxRetries: Q,
        flushAt: I,
        flushInterval: G,
        writeKey: Z,
        httpRequestTimeout: Y,
        httpClient: J,
        disable: X,
      },
      W,
    ) {
      ((this._emitter = W),
        (this._maxRetries = Q),
        (this._flushAt = Math.max(I, 1)),
        (this._flushInterval = G),
        (this._auth = (0, Jt5.b64encode)(`${Z}:`)),
        (this._url = (0, Gt5.tryCreateFormattedUrl)(
          A ?? "https://api.segment.io",
          B ?? "/v1/batch",
        )),
        (this._httpRequestTimeout = Y ?? 1e4),
        (this._disable = Boolean(X)),
        (this._httpClient = J));
    }
    createBatch() {
      this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout);
      let A = new Yt5.ContextBatch(this._flushAt);
      return (
        (this._batch = A),
        (this.pendingFlushTimeout = setTimeout(() => {
          if (A === this._batch) this._batch = void 0;
          if (((this.pendingFlushTimeout = void 0), A.length))
            this.send(A).catch(M$A);
        }, this._flushInterval)),
        A
      );
    }
    clearBatch() {
      (this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout),
        (this._batch = void 0));
    }
    flush(A) {
      if (!A) return;
      if (((this._flushPendingItemsCount = A), !this._batch)) return;
      if (this._batch.length === A)
        (this.send(this._batch).catch(M$A), this.clearBatch());
    }
    enqueue(A) {
      let B = this._batch ?? this.createBatch(),
        { promise: Q, resolve: I } = (0, Zt5.createDeferred)(),
        G = { context: A, resolver: I };
      if (B.tryAdd(G).success) {
        let X = B.length === this._flushPendingItemsCount;
        if (B.length === this._flushAt || X)
          (this.send(B).catch(M$A), this.clearBatch());
        return Q;
      }
      if (B.length) (this.send(B).catch(M$A), this.clearBatch());
      let Y = this.createBatch(),
        J = Y.tryAdd(G);
      if (J.success) {
        if (Y.length === this._flushPendingItemsCount)
          (this.send(Y).catch(M$A), this.clearBatch());
        return Q;
      } else
        return (
          A.setFailedDelivery({ reason: Error(J.message) }),
          Promise.resolve(A)
        );
    }
    async send(A) {
      if (this._flushPendingItemsCount)
        this._flushPendingItemsCount -= A.length;
      let B = A.getEvents(),
        Q = this._maxRetries + 1,
        I = 0;
      while (I < Q) {
        I++;
        let G;
        try {
          if (this._disable) return A.resolveEvents();
          let Z = {
            url: this._url,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Basic ${this._auth}`,
              "User-Agent": "analytics-node-next/latest",
            },
            data: { batch: B, sentAt: new Date() },
            httpRequestTimeout: this._httpRequestTimeout,
          };
          this._emitter.emit("http_request", {
            body: Z.data,
            method: Z.method,
            url: Z.url,
            headers: Z.headers,
          });
          let Y = await this._httpClient.makeRequest(Z);
          if (Y.status >= 200 && Y.status < 300) {
            A.resolveEvents();
            return;
          } else if (Y.status === 400) {
            Vc2(A, Error(`[${Y.status}] ${Y.statusText}`));
            return;
          } else G = Error(`[${Y.status}] ${Y.statusText}`);
        } catch (Z) {
          G = Z;
        }
        if (I === Q) {
          Vc2(A, G);
          return;
        }
        await Xt5(
          (0, It5.backoff)({ attempt: I, minTimeout: 25, maxTimeout: 1000 }),
        );
      }
    }
  }
  Dc2.Publisher = Kc2;
  function Vc2(A, B) {
    (A.getContexts().forEach((Q) => Q.setFailedDelivery({ reason: B })),
      A.resolveEvents());
  }
});
var T10 = z((zc2) => {
  Object.defineProperty(zc2, "__esModule", { value: !0 });
  zc2.detectRuntime = void 0;
  var Wt5 = () => {
    if (
      typeof process === "object" &&
      process &&
      typeof process.env === "object" &&
      process.env &&
      typeof process.version === "string"
    )
      return "node";
    if (typeof window === "object") return "browser";
    if (typeof WebSocketPair < "u") return "cloudflare-worker";
    if (typeof EdgeRuntime === "string") return "vercel-edge";
    if (typeof WorkerGlobalScope < "u" && typeof importScripts === "function")
      return "web-worker";
    return "unknown";
  };
  zc2.detectRuntime = Wt5;
});
var Nc2 = z(($c2) => {
  Object.defineProperty($c2, "__esModule", { value: !0 });
  $c2.createConfiguredNodePlugin = $c2.createNodePlugin = void 0;
  var Ft5 = Hc2(),
    Ct5 = M10(),
    Vt5 = T10();
  function Kt5(A) {
    (A.updateEvent("context.library.name", "@segment/analytics-node"),
      A.updateEvent("context.library.version", Ct5.version));
    let B = (0, Vt5.detectRuntime)();
    if (B === "node") A.updateEvent("_metadata.nodeVersion", process.version);
    A.updateEvent("_metadata.jsRuntime", B);
  }
  function wc2(A) {
    function B(Q) {
      return (Kt5(Q), A.enqueue(Q));
    }
    return {
      name: "Segment.io",
      type: "destination",
      version: "1.0.0",
      isLoaded: () => !0,
      load: () => Promise.resolve(),
      alias: B,
      group: B,
      identify: B,
      page: B,
      screen: B,
      track: B,
    };
  }
  $c2.createNodePlugin = wc2;
  var Dt5 = (A, B) => {
    let Q = new Ft5.Publisher(A, B);
    return { publisher: Q, plugin: wc2(Q) };
  };
  $c2.createConfiguredNodePlugin = Dt5;
});
var Oc2 = z((Lc2) => {
  Object.defineProperty(Lc2, "__esModule", { value: !0 });
  Lc2.createMessageId = void 0;
  var Ht5 = R10(),
    zt5 = () => {
      return `node-next-${Date.now()}-${(0, Ht5.uuid)()}`;
    };
  Lc2.createMessageId = zt5;
});
var jc2 = z((Tc2) => {
  Object.defineProperty(Tc2, "__esModule", { value: !0 });
  Tc2.NodeEventFactory = void 0;
  var Ut5 = Ap(),
    wt5 = Oc2();
  class Rc2 extends Ut5.EventFactory {
    constructor() {
      super({ createMessageId: wt5.createMessageId });
    }
  }
  Tc2.NodeEventFactory = Rc2;
});
var CB1 = z((yc2) => {
  Object.defineProperty(yc2, "__esModule", { value: !0 });
  yc2.Context = void 0;
  var $t5 = Ap();
  class Sc2 extends $t5.CoreContext {
    static system() {
      return new this({ type: "track", event: "system" });
    }
  }
  yc2.Context = Sc2;
});
var vc2 = z((_c2) => {
  Object.defineProperty(_c2, "__esModule", { value: !0 });
  _c2.dispatchAndEmit = void 0;
  var qt5 = Ap(),
    Nt5 = CB1(),
    Lt5 = (A) => (B) => {
      let Q = B.failedDelivery();
      return Q ? A(Q.reason, B) : A(void 0, B);
    },
    Mt5 = async (A, B, Q, I) => {
      try {
        let G = new Nt5.Context(A),
          Z = await (0, qt5.dispatch)(G, B, Q, {
            ...(I ? { callback: Lt5(I) } : {}),
          }),
          Y = Z.failedDelivery();
        if (Y)
          Q.emit("error", {
            code: "delivery_failure",
            reason: Y.reason,
            ctx: Z,
          });
        else Q.emit(A.type, Z);
      } catch (G) {
        Q.emit("error", { code: "unknown", reason: G });
      }
    };
  _c2.dispatchAndEmit = Mt5;
});
var gc2 = z((fc2) => {
  Object.defineProperty(fc2, "__esModule", { value: !0 });
  fc2.NodeEmitter = void 0;
  var Ot5 = M7A();
  class bc2 extends Ot5.Emitter {}
  fc2.NodeEmitter = bc2;
});
var lc2 = z((cc2) => {
  Object.defineProperty(cc2, "__esModule", { value: !0 });
  cc2.NodeEventQueue = void 0;
  var uc2 = Ap();
  class mc2 extends uc2.PriorityQueue {
    constructor() {
      super(1, []);
    }
    getAttempts(A) {
      return A.attempts ?? 0;
    }
    updateAttempts(A) {
      return ((A.attempts = this.getAttempts(A) + 1), this.getAttempts(A));
    }
  }
  class dc2 extends uc2.CoreEventQueue {
    constructor() {
      super(new mc2());
    }
  }
  cc2.NodeEventQueue = dc2;
});
var sc2 = z((nc2) => {
  Object.defineProperty(nc2, "__esModule", { value: !0 });
  nc2.abortSignalAfterTimeout = nc2.AbortSignal = void 0;
  var Rt5 = M7A(),
    Tt5 = T10();
  class P10 {
    constructor() {
      ((this.onabort = null),
        (this.aborted = !1),
        (this.eventEmitter = new Rt5.Emitter()));
    }
    toString() {
      return "[object AbortSignal]";
    }
    get [Symbol.toStringTag]() {
      return "AbortSignal";
    }
    removeEventListener(...A) {
      this.eventEmitter.off(...A);
    }
    addEventListener(...A) {
      this.eventEmitter.on(...A);
    }
    dispatchEvent(A) {
      let B = { type: A, target: this },
        Q = `on${A}`;
      if (typeof this[Q] === "function") this[Q](B);
      this.eventEmitter.emit(A, B);
    }
  }
  nc2.AbortSignal = P10;
  class ic2 {
    constructor() {
      this.signal = new P10();
    }
    abort() {
      if (this.signal.aborted) return;
      ((this.signal.aborted = !0), this.signal.dispatchEvent("abort"));
    }
    toString() {
      return "[object AbortController]";
    }
    get [Symbol.toStringTag]() {
      return "AbortController";
    }
  }
  var Pt5 = (A) => {
    if ((0, Tt5.detectRuntime)() === "cloudflare-worker") return [];
    let B = new (globalThis.AbortController || ic2)(),
      Q = setTimeout(() => {
        B.abort();
      }, A);
    return (Q?.unref?.(), [B.signal, Q]);
  };
  nc2.abortSignalAfterTimeout = Pt5;
});
var rc2 = z((Dy) => {
  var St5 =
      (Dy && Dy.__createBinding) ||
      (Object.create
        ? function (A, B, Q, I) {
            if (I === void 0) I = Q;
            var G = Object.getOwnPropertyDescriptor(B, Q);
            if (
              !G ||
              ("get" in G ? !B.__esModule : G.writable || G.configurable)
            )
              G = {
                enumerable: !0,
                get: function () {
                  return B[Q];
                },
              };
            Object.defineProperty(A, I, G);
          }
        : function (A, B, Q, I) {
            if (I === void 0) I = Q;
            A[I] = B[Q];
          }),
    yt5 =
      (Dy && Dy.__setModuleDefault) ||
      (Object.create
        ? function (A, B) {
            Object.defineProperty(A, "default", { enumerable: !0, value: B });
          }
        : function (A, B) {
            A.default = B;
          }),
    kt5 =
      (Dy && Dy.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var B = {};
        if (A != null) {
          for (var Q in A)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(A, Q))
              St5(B, A, Q);
        }
        return (yt5(B, A), B);
      };
  Object.defineProperty(Dy, "__esModule", { value: !0 });
  Dy.fetch = void 0;
  var _t5 = async (...A) => {
    if (globalThis.fetch) return globalThis.fetch(...A);
    else if (typeof EdgeRuntime !== "string")
      return (await Promise.resolve().then(() => kt5(hR1()))).default(...A);
    else
      throw Error(
        "Invariant: an edge runtime that does not support fetch should not exist",
      );
  };
  Dy.fetch = _t5;
});
var j10 = z((tc2) => {
  Object.defineProperty(tc2, "__esModule", { value: !0 });
  tc2.FetchHTTPClient = void 0;
  var xt5 = sc2(),
    vt5 = rc2();
  class oc2 {
    constructor(A) {
      this._fetch = A ?? vt5.fetch;
    }
    async makeRequest(A) {
      let [B, Q] = (0, xt5.abortSignalAfterTimeout)(A.httpRequestTimeout),
        I = {
          url: A.url,
          method: A.method,
          headers: A.headers,
          body: JSON.stringify(A.data),
          signal: B,
        };
      return this._fetch(A.url, I).finally(() => clearTimeout(Q));
    }
  }
  tc2.FetchHTTPClient = oc2;
});
var S10 = z((Gp2) => {
  Object.defineProperty(Gp2, "__esModule", { value: !0 });
  Gp2.Analytics = void 0;
  var Ap2 = Ap(),
    bt5 = od2(),
    ft5 = M10(),
    ht5 = Nc2(),
    gt5 = jc2(),
    ut5 = vc2(),
    mt5 = gc2(),
    Bp2 = CB1(),
    dt5 = lc2(),
    Qp2 = j10();
  class Ip2 extends mt5.NodeEmitter {
    constructor(A) {
      super();
      ((this._isClosed = !1),
        (this._pendingEvents = 0),
        (this._isFlushing = !1),
        (0, bt5.validateSettings)(A),
        (this._eventFactory = new gt5.NodeEventFactory()),
        (this._queue = new dt5.NodeEventQueue()));
      let B = A.flushInterval ?? 1e4;
      this._closeAndFlushDefaultTimeout = B * 1.25;
      let { plugin: Q, publisher: I } = (0, ht5.createConfiguredNodePlugin)(
        {
          writeKey: A.writeKey,
          host: A.host,
          path: A.path,
          maxRetries: A.maxRetries ?? 3,
          flushAt: A.flushAt ?? A.maxEventsInBatch ?? 15,
          httpRequestTimeout: A.httpRequestTimeout,
          disable: A.disable,
          flushInterval: B,
          httpClient:
            typeof A.httpClient === "function"
              ? new Qp2.FetchHTTPClient(A.httpClient)
              : (A.httpClient ?? new Qp2.FetchHTTPClient()),
        },
        this,
      );
      ((this._publisher = I),
        (this.ready = this.register(Q).then(() => {
          return;
        })),
        this.emit("initialize", A),
        (0, Ap2.bindAll)(this));
    }
    get VERSION() {
      return ft5.version;
    }
    closeAndFlush({ timeout: A = this._closeAndFlushDefaultTimeout } = {}) {
      return this.flush({ timeout: A, close: !0 });
    }
    async flush({ timeout: A, close: B = !1 } = {}) {
      if (this._isFlushing) {
        console.warn(
          "Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again",
        );
        return;
      } else this._isFlushing = !0;
      if (B) this._isClosed = !0;
      this._publisher.flush(this._pendingEvents);
      let Q = new Promise((I) => {
        if (!this._pendingEvents) I();
        else
          this.once("drained", () => {
            I();
          });
      }).finally(() => {
        this._isFlushing = !1;
      });
      return A
        ? (0, Ap2.pTimeout)(Q, A).catch(() => {
            return;
          })
        : Q;
    }
    _dispatch(A, B) {
      if (this._isClosed) {
        this.emit("call_after_close", A);
        return;
      }
      (this._pendingEvents++,
        (0, ut5.dispatchAndEmit)(A, this._queue, this, B)
          .catch((Q) => Q)
          .finally(() => {
            if ((this._pendingEvents--, !this._pendingEvents))
              this.emit("drained");
          }));
    }
    alias(
      { userId: A, previousId: B, context: Q, timestamp: I, integrations: G },
      Z,
    ) {
      let Y = this._eventFactory.alias(A, B, {
        context: Q,
        integrations: G,
        timestamp: I,
      });
      this._dispatch(Y, Z);
    }
    group(
      {
        timestamp: A,
        groupId: B,
        userId: Q,
        anonymousId: I,
        traits: G = {},
        context: Z,
        integrations: Y,
      },
      J,
    ) {
      let X = this._eventFactory.group(B, G, {
        context: Z,
        anonymousId: I,
        userId: Q,
        timestamp: A,
        integrations: Y,
      });
      this._dispatch(X, J);
    }
    identify(
      {
        userId: A,
        anonymousId: B,
        traits: Q = {},
        context: I,
        timestamp: G,
        integrations: Z,
      },
      Y,
    ) {
      let J = this._eventFactory.identify(A, Q, {
        context: I,
        anonymousId: B,
        userId: A,
        timestamp: G,
        integrations: Z,
      });
      this._dispatch(J, Y);
    }
    page(
      {
        userId: A,
        anonymousId: B,
        category: Q,
        name: I,
        properties: G,
        context: Z,
        timestamp: Y,
        integrations: J,
      },
      X,
    ) {
      let W = this._eventFactory.page(Q ?? null, I ?? null, G, {
        context: Z,
        anonymousId: B,
        userId: A,
        timestamp: Y,
        integrations: J,
      });
      this._dispatch(W, X);
    }
    screen(
      {
        userId: A,
        anonymousId: B,
        category: Q,
        name: I,
        properties: G,
        context: Z,
        timestamp: Y,
        integrations: J,
      },
      X,
    ) {
      let W = this._eventFactory.screen(Q ?? null, I ?? null, G, {
        context: Z,
        anonymousId: B,
        userId: A,
        timestamp: Y,
        integrations: J,
      });
      this._dispatch(W, X);
    }
    track(
      {
        userId: A,
        anonymousId: B,
        event: Q,
        properties: I,
        context: G,
        timestamp: Z,
        integrations: Y,
      },
      J,
    ) {
      let X = this._eventFactory.track(Q, I, {
        context: G,
        userId: A,
        anonymousId: B,
        timestamp: Z,
        integrations: Y,
      });
      this._dispatch(X, J);
    }
    register(...A) {
      return this._queue.criticalTasks.run(async () => {
        let B = Bp2.Context.system(),
          Q = A.map((I) => this._queue.register(B, I, this));
        (await Promise.all(Q),
          this.emit(
            "register",
            A.map((I) => I.name),
          ));
      });
    }
    async deregister(...A) {
      let B = Bp2.Context.system(),
        Q = A.map((I) => {
          let G = this._queue.plugins.find((Z) => Z.name === I);
          if (G) return this._queue.deregister(B, G, this);
          else B.log("warn", `plugin ${I} not found`);
        });
      (await Promise.all(Q), this.emit("deregister", A));
    }
  }
  Gp2.Analytics = Ip2;
});
var Yp2 = z((O$A) => {
  Object.defineProperty(O$A, "__esModule", { value: !0 });
  O$A.FetchHTTPClient = O$A.Context = O$A.Analytics = void 0;
  var ct5 = S10();
  Object.defineProperty(O$A, "Analytics", {
    enumerable: !0,
    get: function () {
      return ct5.Analytics;
    },
  });
  var pt5 = CB1();
  Object.defineProperty(O$A, "Context", {
    enumerable: !0,
    get: function () {
      return pt5.Context;
    },
  });
  var lt5 = j10();
  Object.defineProperty(O$A, "FetchHTTPClient", {
    enumerable: !0,
    get: function () {
      return lt5.FetchHTTPClient;
    },
  });
  var it5 = S10();
  O$A.default = it5.Analytics;
});
async function ot5() {
  let [A, B] = await Promise.all([O0.getPackageManagers(), O0.getRuntimes()]);
  return {
    platform: O0.platform,
    arch: O0.arch,
    nodeVersion: O0.nodeVersion,
    terminal: eH.terminal,
    packageManagers: A.join(","),
    runtimes: B.join(","),
    isRunningWithBun: O0.isRunningWithBun(),
    isCi: V0(!1),
    isClaubbit: process.env.CLAUBBIT === "true",
    isClaudeCodeRemote: process.env.CLAUDE_CODE_REMOTE === "true",
    isConductor: O0.isConductor(),
    ...(process.env.CLAUDE_CODE_REMOTE_ENVIRONMENT_TYPE && {
      remoteEnvironmentType: process.env.CLAUDE_CODE_REMOTE_ENVIRONMENT_TYPE,
    }),
    ...(process.env.CLAUDE_CODE_CONTAINER_ID && {
      claudeCodeContainerId: process.env.CLAUDE_CODE_CONTAINER_ID,
    }),
    ...(process.env.CLAUDE_CODE_TAGS && { tags: process.env.CLAUDE_CODE_TAGS }),
    isGithubAction: process.env.GITHUB_ACTIONS === "true",
    isClaudeCodeAction:
      process.env.CLAUDE_CODE_ACTION === "1" ||
      process.env.CLAUDE_CODE_ACTION === "true",
    isClaudeAiAuth: nB(),
    version: {
      ISSUES_EXPLAINER:
        "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.claude.com/s/claude-code",
      VERSION: "2.0.42",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
    }.VERSION,
    versionBase: rt5(),
    deploymentEnvironment: O0.detectDeploymentEnvironment(),
    ...(process.env.GITHUB_ACTIONS === "true" && {
      githubEventName: process.env.GITHUB_EVENT_NAME,
      githubActionsRunnerEnvironment: process.env.RUNNER_ENVIRONMENT,
      githubActionsRunnerOs: process.env.RUNNER_OS,
      githubActionRef: process.env.GITHUB_ACTION_PATH?.includes(
        "claude-code-action/",
      )
        ? process.env.GITHUB_ACTION_PATH.split("claude-code-action/")[1]
        : void 0,
    }),
    ...(Ji() && { wslVersion: Ji() }),
  };
}
function tt5() {
  return;
}
async function Bp(A = {}) {
  let B = A.model ? String(A.model) : mI(),
    Q = eU(B),
    I = await ot5(),
    G = tt5();
  return {
    model: B,
    sessionId: L0(),
    userType: "external",
    ...(Q.length > 0 ? { betas: Q.join(",") } : {}),
    envContext: I,
    ...(process.env.CLAUDE_CODE_ENTRYPOINT && {
      entrypoint: process.env.CLAUDE_CODE_ENTRYPOINT,
    }),
    ...(process.env.CLAUDE_AGENT_SDK_VERSION && {
      agentSdkVersion: process.env.CLAUDE_AGENT_SDK_VERSION,
    }),
    isInteractive: String(ZLA()),
    clientType: YLA(),
    ...(G && { processMetrics: G }),
    sweBenchRunId: process.env.SWE_BENCH_RUN_ID || "",
    sweBenchInstanceId: process.env.SWE_BENCH_INSTANCE_ID || "",
    sweBenchTaskId: process.env.SWE_BENCH_TASK_ID || "",
  };
}
function Jp2(A, B = {}) {
  let Q = {};
  for (let [I, G] of Object.entries(B)) if (G !== void 0) Q[I] = String(G);
  for (let [I, G] of Object.entries(A)) {
    if (G === void 0) continue;
    if (I === "envContext") Q.env = JSON.stringify(G);
    else if (I === "processMetrics") Q.process = JSON.stringify(G);
    else Q[I] = String(G);
  }
  return Q;
}
function Xp2(A, B = {}) {
  let { envContext: Q, processMetrics: I, ...G } = A;
  return { ...B, ...G, env: Q, ...(I && { process: I }), surface: st5 };
}
function Wp2(A, B = {}) {
  let { envContext: Q, processMetrics: I, ...G } = A,
    Z = {
      platform: Q.platform,
      arch: Q.arch,
      node_version: Q.nodeVersion,
      terminal: Q.terminal || "unknown",
      package_managers: Q.packageManagers,
      runtimes: Q.runtimes,
      is_running_with_bun: Q.isRunningWithBun,
      is_ci: Q.isCi,
      is_claubbit: Q.isClaubbit,
      is_claude_code_remote: Q.isClaudeCodeRemote,
      is_conductor: Q.isConductor,
      is_github_action: Q.isGithubAction,
      is_claude_code_action: Q.isClaudeCodeAction,
      is_claude_ai_auth: Q.isClaudeAiAuth,
      version: Q.version,
      deployment_environment: Q.deploymentEnvironment,
    };
  if (Q.remoteEnvironmentType)
    Z.remote_environment_type = Q.remoteEnvironmentType;
  if (Q.claudeCodeContainerId)
    Z.claude_code_container_id = Q.claudeCodeContainerId;
  if (Q.tags) Z.tags = Q.tags;
  if (Q.githubEventName) Z.github_event_name = Q.githubEventName;
  if (Q.githubActionsRunnerEnvironment)
    Z.github_actions_runner_environment = Q.githubActionsRunnerEnvironment;
  if (Q.githubActionsRunnerOs)
    Z.github_actions_runner_os = Q.githubActionsRunnerOs;
  if (Q.githubActionRef) Z.github_action_ref = Q.githubActionRef;
  if (Q.wslVersion) Z.wsl_version = Q.wslVersion;
  if (Q.versionBase) Z.version_base = Q.versionBase;
  let Y = {
    session_id: G.sessionId,
    model: G.model,
    user_type: G.userType,
    is_interactive: G.isInteractive === "true",
    client_type: G.clientType,
  };
  if (G.betas) Y.betas = G.betas;
  if (G.entrypoint) Y.entrypoint = G.entrypoint;
  if (G.agentSdkVersion) Y.agent_sdk_version = G.agentSdkVersion;
  if (G.sweBenchRunId) Y.swe_bench_run_id = G.sweBenchRunId;
  if (G.sweBenchInstanceId) Y.swe_bench_instance_id = G.sweBenchInstanceId;
  if (G.sweBenchTaskId) Y.swe_bench_task_id = G.sweBenchTaskId;
  return {
    env: Z,
    ...(I && { process: JSON.stringify(I) }),
    core: Y,
    additional: B,
  };
}
var st5 = "claude-code",
  rt5;
var R$A = T(() => {
  a2();
  C6();
  Us();
  Jx();
  Y9();
  i0();
  vB();
  F2();
  E5();
  rt5 = I0(() => {
    let A = {
      ISSUES_EXPLAINER:
        "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.claude.com/s/claude-code",
      VERSION: "2.0.42",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
    }.VERSION.match(/^\d+\.\d+\.\d+(?:-[a-z]+)?/);
    return A ? A[0] : void 0;
  });
});
function Ae5() {
  let A = ["test", "dev"].includes("production") ? "development" : "production";
  return et5[A];
}
async function Be5() {
  if (NV()) return !1;
  return !0;
}
async function y10(A, B) {
  let Q = await Cp2();
  if (!Q) return;
  try {
    let I = _10(),
      G = HG(),
      Z = await Bp({ model: B.model }),
      Y = Xp2(Z, B),
      J = { anonymousId: I, event: A, properties: Y };
    if (G) {
      let X = Iy(!0);
      J.userId = X.userID;
    }
    Q.track(J);
  } catch (I) {
    BA(I instanceof Error ? I : Error(String(I)), GX0);
  }
}
async function Vp2(A) {
  let B = await Cp2();
  if (!B) return;
  try {
    let Q = _10(),
      I = HG(),
      G = { anonymousId: Q, traits: A };
    if (I) {
      let Z = Iy(!0);
      G.userId = Z.userID;
    }
    B.identify(G);
  } catch (Q) {
    BA(Q instanceof Error ? Q : Error(String(Q)), ZX0);
  }
}
var Fp2,
  et5,
  VB1 = null,
  Cp2;
var k10 = T(() => {
  a2();
  U2A();
  kB();
  c1();
  F2();
  R$A();
  J7A();
  ((Fp2 = IA(Yp2(), 1)),
    (et5 = {
      production: "LKJN8LsLERHEOXkw487o7qCTFOrGPimI",
      development: "b64sf1kxwDGe1PiSAlv5ixuH0f509RKK",
    }));
  Cp2 = I0(async () => {
    if (!(await Be5())) return null;
    try {
      return (
        (VB1 = new Fp2.Analytics({ writeKey: Ae5() })),
        process.on("beforeExit", async () => {
          await VB1?.closeAndFlush();
        }),
        process.on("exit", () => {
          VB1?.closeAndFlush();
        }),
        VB1
      );
    } catch (B) {
      return (BA(B instanceof Error ? B : Error(String(B)), IX0), null);
    }
  });
});
function Qe5() {
  let A = HG();
  if (!A) return {};
  return {
    email: A.emailAddress,
    account_uuid: A.accountUuid,
    organization_uuid: A.organizationUuid,
    billing_type: A.organizationBillingType ?? void 0,
  };
}
function x10(A) {
  let B = Jc(),
    Q = IB(() => A.onDone(!1, B));
  return (
    h1((I, G) => {
      if (G.escape) A.onDone(!1, B);
    }),
    tK.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      tK.createElement(dc, {
        onDone: () => A.onDone(!0, B),
        startingMessage: A.startingMessage,
      }),
      tK.createElement(
        S,
        { marginLeft: 1 },
        tK.createElement(
          U,
          { dimColor: !0 },
          Q.pending
            ? tK.createElement(
                tK.Fragment,
                null,
                "Press ",
                Q.keyName,
                " again to exit",
              )
            : "",
        ),
      ),
    )
  );
}
var tK,
  Kp2 = () => ({
    type: "local-jsx",
    name: "login",
    description: Dp2()
      ? "Switch Anthropic accounts"
      : "Sign in with your Anthropic account",
    isEnabled: () => !process.env.DISABLE_LOGIN_COMMAND,
    isHidden: !1,
    async call(A, B) {
      return tK.createElement(x10, {
        onDone: async (Q) => {
          if ((B.onChangeAPIKey(), Q)) (y91(), er(), Vp2(Qe5()));
          A(Q ? "Login successful" : "Login interrupted");
        },
      });
    },
    userFacingName() {
      return "login";
    },
  });
var v10 = T(() => {
  $wA();
  R9();
  nA();
  F2();
  czA();
  f4();
  i0();
  k10();
  F2();
  tK = IA(KA(), 1);
});
function Hp2() {
  return Ep2.default.createElement(
    U,
    null,
    "Checking GitHub CLI installation",
  );
}
var Ep2;
var zp2 = T(() => {
  nA();
  Ep2 = IA(KA(), 1);
});
function Up2({
  currentRepo: A,
  useCurrentRepo: B,
  repoUrl: Q,
  onRepoUrlChange: I,
  onSubmit: G,
  onToggleUseCurrentRepo: Z,
}) {
  let [Y, J] = gX.useState(0),
    [X, W] = gX.useState(!1),
    C = aB().columns,
    V = () => {
      if (!(B ? A : Q)?.trim()) {
        W(!0);
        return;
      }
      G();
    };
  return (
    h1((K, D) => {
      if (D.upArrow) (Z(!0), W(!1));
      else if (D.downArrow) (Z(!1), W(!1));
      else if (D.return) V();
    }),
    gX.default.createElement(
      gX.default.Fragment,
      null,
      gX.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderDimColor: !0,
          paddingX: 1,
        },
        gX.default.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          gX.default.createElement(U, { bold: !0 }, "Install GitHub App"),
          gX.default.createElement(
            U,
            { dimColor: !0 },
            "Select GitHub repository",
          ),
        ),
        A &&
          gX.default.createElement(
            S,
            { marginBottom: 1 },
            gX.default.createElement(
              U,
              { bold: B, color: B ? "permission" : void 0 },
              B ? "> " : "  ",
              "Use current repository: ",
              A,
            ),
          ),
        gX.default.createElement(
          S,
          { marginBottom: 1 },
          gX.default.createElement(
            U,
            { bold: !B || !A, color: !B || !A ? "permission" : void 0 },
            !B || !A ? "> " : "  ",
            A ? "Enter a different repository" : "Enter repository",
          ),
        ),
        (!B || !A) &&
          gX.default.createElement(
            S,
            { marginLeft: 2, marginBottom: 1 },
            gX.default.createElement(O4, {
              value: Q,
              onChange: (K) => {
                (I(K), W(!1));
              },
              onSubmit: V,
              focus: !0,
              placeholder:
                "Enter a repo as owner/repo or https://github.com/owner/repo",
              columns: C,
              cursorOffset: Y,
              onChangeCursorOffset: J,
              showCursor: !0,
            }),
          ),
      ),
      X &&
        gX.default.createElement(
          S,
          { marginLeft: 3, marginBottom: 1 },
          gX.default.createElement(
            U,
            { color: "error" },
            "Please enter a repository name to continue",
          ),
        ),
      gX.default.createElement(
        S,
        { marginLeft: 3 },
        gX.default.createElement(
          U,
          { dimColor: !0 },
          A ? "/ to select  " : "",
          "Enter to continue",
        ),
      ),
    )
  );
}
var gX;
var wp2 = T(() => {
  nA();
  rG();
  N8();
  gX = IA(KA(), 1);
});
var $p2 = "Add Claude Code GitHub Workflow",
  Ey =
    "https://github.com/anthropics/claude-code-action/blob/main/docs/setup.md",
  qp2 = `name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read

          # Optional: Give a custom prompt to Claude. If this is not specified, Claude will perform the instructions specified in the comment that tagged it.
          # prompt: 'Update the pull request description to include a summary of changes.'

          # Optional: Add claude_args to customize behavior and configuration
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options
          # claude_args: '--allowed-tools Bash(gh pr:*)'

`,
  Np2 = `## \uD83E\uDD16 Installing Claude Code GitHub App

This PR adds a GitHub Actions workflow that enables Claude Code integration in our repository.

### What is Claude Code?

[Claude Code](https://claude.com/claude-code) is an AI coding agent that can help with:
- Bug fixes and improvements  
- Documentation updates
- Implementing new features
- Code reviews and suggestions
- Writing tests
- And more!

### How it works

Once this PR is merged, we'll be able to interact with Claude by mentioning @claude in a pull request or issue comment.
Once the workflow is triggered, Claude will analyze the comment and surrounding context, and execute on the request in a GitHub action.

### Important Notes

- **This workflow won't take effect until this PR is merged**
- **@claude mentions won't work until after the merge is complete**
- The workflow runs automatically whenever Claude is mentioned in PR or issue comments
- Claude gets access to the entire PR or issue context including files, diffs, and previous comments

### Security

- Our Anthropic API key is securely stored as a GitHub Actions secret
- Only users with write access to the repository can trigger the workflow
- All Claude runs are stored in the GitHub Actions run history
- Claude's default tools are limited to reading/writing files and interacting with our repo by creating comments, branches, and commits.
- We can add more allowed tools by adding them to the workflow file like:

\`\`\`
allowed_tools: Bash(npm install),Bash(npm run build),Bash(npm run lint),Bash(npm run test)
\`\`\`

There's more information in the [Claude Code action repo](https://github.com/anthropics/claude-code-action).

After merging this PR, let's try mentioning @claude in a comment on any PR to get started!`,
  Lp2 = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'

    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            REPO: \${{ github.repository }}
            PR NUMBER: \${{ github.event.pull_request.number }}

            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage

            Use the repository's CLAUDE.md for guidance on style and conventions. Be constructive and helpful in your feedback.

            Use \`gh pr comment\` with your Bash tool to leave your review as a comment on the PR.

          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options
          claude_args: '--allowed-tools "Bash(gh issue view:*),Bash(gh search:*),Bash(gh issue list:*),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh pr list:*)"'

`,
  Mp2 = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'

    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          plugin_marketplaces: 'https://github.com/anthropics/claude-code.git'
          plugins: 'code-review@claude-code-plugins'
          prompt: '/code-review:code-review \${{ github.repository }}/pull/\${{ github.event.pull_request.number }}'
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options

`;
function Op2({ repoUrl: A, onSubmit: B }) {
  return (
    h1((Q, I) => {
      if (I.return) B();
    }),
    uX.default.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderDimColor: !0,
        paddingX: 1,
      },
      uX.default.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        uX.default.createElement(
          U,
          { bold: !0 },
          "Install the Claude GitHub App",
        ),
      ),
      uX.default.createElement(
        S,
        { marginBottom: 1 },
        uX.default.createElement(
          U,
          null,
          "Opening browser to install the Claude GitHub App",
        ),
      ),
      uX.default.createElement(
        S,
        { marginBottom: 1 },
        uX.default.createElement(
          U,
          null,
          "If your browser doesn't open automatically, visit:",
        ),
      ),
      uX.default.createElement(
        S,
        { marginBottom: 1 },
        uX.default.createElement(
          U,
          { underline: !0 },
          "https://github.com/apps/claude",
        ),
      ),
      uX.default.createElement(
        S,
        { marginBottom: 1 },
        uX.default.createElement(
          U,
          null,
          "Please install the app for repository: ",
          uX.default.createElement(U, { bold: !0 }, A),
        ),
      ),
      uX.default.createElement(
        S,
        { marginBottom: 1 },
        uX.default.createElement(
          U,
          { dimColor: !0 },
          "Important: Make sure to grant access to this specific repository",
        ),
      ),
      uX.default.createElement(
        S,
        null,
        uX.default.createElement(
          U,
          { bold: !0, color: "permission" },
          "Press Enter once you've installed the app",
          E1.ellipsis,
        ),
      ),
      uX.default.createElement(
        S,
        { marginTop: 1 },
        uX.default.createElement(
          U,
          { dimColor: !0 },
          "Having trouble? See manual setup instructions at:",
          " ",
          uX.default.createElement(U, { color: "claude" }, Ey),
        ),
      ),
    )
  );
}
var uX;
var Rp2 = T(() => {
  nA();
  s2();
  uX = IA(KA(), 1);
});
function Tp2({
  useExistingSecret: A,
  secretName: B,
  onToggleUseExistingSecret: Q,
  onSecretNameChange: I,
  onSubmit: G,
}) {
  let [Z, Y] = VZ.useState(0),
    J = aB(),
    [X] = HQ();
  return (
    h1((W, F) => {
      if (F.upArrow) Q(!0);
      else if (F.downArrow) Q(!1);
      else if (F.return) G();
    }),
    VZ.default.createElement(
      VZ.default.Fragment,
      null,
      VZ.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderDimColor: !0,
          paddingX: 1,
        },
        VZ.default.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          VZ.default.createElement(U, { bold: !0 }, "Install GitHub App"),
          VZ.default.createElement(U, { dimColor: !0 }, "Setup API key secret"),
        ),
        VZ.default.createElement(
          S,
          { marginBottom: 1 },
          VZ.default.createElement(
            U,
            { color: "warning" },
            "ANTHROPIC_API_KEY already exists in repository secrets!",
          ),
        ),
        VZ.default.createElement(
          S,
          { marginBottom: 1 },
          VZ.default.createElement(U, null, "Would you like to:"),
        ),
        VZ.default.createElement(
          S,
          { marginBottom: 1 },
          VZ.default.createElement(
            U,
            null,
            A ? OB("success", X)("> ") : "  ",
            "Use the existing API key",
          ),
        ),
        VZ.default.createElement(
          S,
          { marginBottom: 1 },
          VZ.default.createElement(
            U,
            null,
            !A ? OB("success", X)("> ") : "  ",
            "Create a new secret with a different name",
          ),
        ),
        !A &&
          VZ.default.createElement(
            VZ.default.Fragment,
            null,
            VZ.default.createElement(
              S,
              { marginBottom: 1 },
              VZ.default.createElement(
                U,
                null,
                "Enter new secret name (alphanumeric with underscores):",
              ),
            ),
            VZ.default.createElement(O4, {
              value: B,
              onChange: I,
              onSubmit: G,
              focus: !0,
              placeholder: "e.g., CLAUDE_API_KEY",
              columns: J.columns,
              cursorOffset: Z,
              onChangeCursorOffset: Y,
              showCursor: !0,
            }),
          ),
      ),
      VZ.default.createElement(
        S,
        { marginLeft: 3 },
        VZ.default.createElement(
          U,
          { dimColor: !0 },
          "/ to select  Enter to continue",
        ),
      ),
    )
  );
}
var VZ;
var Pp2 = T(() => {
  nA();
  rG();
  N8();
  VZ = IA(KA(), 1);
});
function jp2({
  existingApiKey: A,
  apiKeyOrOAuthToken: B,
  onApiKeyChange: Q,
  onSubmit: I,
  onToggleUseExistingKey: G,
  onCreateOAuthToken: Z,
  selectedOption: Y = A ? "existing" : Z ? "oauth" : "new",
  onSelectOption: J,
}) {
  let [X, W] = oF.useState(0),
    F = aB(),
    [C] = HQ();
  return (
    h1((V, K) => {
      if (K.upArrow) {
        if (Y === "new" && Z) J?.("oauth");
        else if (Y === "oauth" && A) (J?.("existing"), G(!0));
      } else if (K.downArrow) {
        if (Y === "existing") (J?.(Z ? "oauth" : "new"), G(!1));
        else if (Y === "oauth") J?.("new");
      }
      if (K.return)
        if (Y === "oauth" && Z) Z();
        else I();
    }),
    oF.default.createElement(
      oF.default.Fragment,
      null,
      oF.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderDimColor: !0,
          paddingX: 1,
        },
        oF.default.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          oF.default.createElement(U, { bold: !0 }, "Install GitHub App"),
          oF.default.createElement(U, { dimColor: !0 }, "Choose API key"),
        ),
        A &&
          oF.default.createElement(
            S,
            { marginBottom: 1 },
            oF.default.createElement(
              U,
              null,
              Y === "existing" ? OB("success", C)("> ") : "  ",
              "Use your existing Claude Code API key",
            ),
          ),
        Z &&
          oF.default.createElement(
            S,
            { marginBottom: 1 },
            oF.default.createElement(
              U,
              null,
              Y === "oauth" ? OB("success", C)("> ") : "  ",
              "Create a long-lived token with your Claude subscription",
            ),
          ),
        oF.default.createElement(
          S,
          { marginBottom: 1 },
          oF.default.createElement(
            U,
            null,
            Y === "new" ? OB("success", C)("> ") : "  ",
            "Enter a new API key",
          ),
        ),
        Y === "new" &&
          oF.default.createElement(O4, {
            value: B,
            onChange: Q,
            onSubmit: I,
            onPaste: Q,
            focus: !0,
            placeholder:
              "sk-ant (Create a new key at https://console.anthropic.com/settings/keys)",
            mask: "*",
            columns: F.columns,
            cursorOffset: X,
            onChangeCursorOffset: W,
            showCursor: !0,
          }),
      ),
      oF.default.createElement(
        S,
        { marginLeft: 3 },
        oF.default.createElement(
          U,
          { dimColor: !0 },
          "/ to select  Enter to continue",
        ),
      ),
    )
  );
}
var oF;
var Sp2 = T(() => {
  nA();
  rG();
  N8();
  oF = IA(KA(), 1);
});
function yp2({
  currentWorkflowInstallStep: A,
  secretExists: B,
  useExistingSecret: Q,
  secretName: I,
  skipWorkflow: G = !1,
  selectedWorkflows: Z,
}) {
  let Y = G
    ? [
        "Getting repository information",
        B && Q ? "Using existing API key secret" : `Setting up ${I} secret`,
      ]
    : [
        "Getting repository information",
        "Creating branch",
        Z.length > 1 ? "Creating workflow files" : "Creating workflow file",
        B && Q ? "Using existing API key secret" : `Setting up ${I} secret`,
        "Opening pull request page",
      ];
  return Lb.default.createElement(
    Lb.default.Fragment,
    null,
    Lb.default.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderDimColor: !0,
        paddingX: 1,
      },
      Lb.default.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        Lb.default.createElement(U, { bold: !0 }, "Install GitHub App"),
        Lb.default.createElement(
          U,
          { dimColor: !0 },
          "Create GitHub Actions workflow",
        ),
      ),
      Y.map((J, X) => {
        let W = "pending";
        if (X < A) W = "completed";
        else if (X === A) W = "in-progress";
        return Lb.default.createElement(
          S,
          { key: X },
          Lb.default.createElement(
            U,
            {
              color:
                W === "completed"
                  ? "success"
                  : W === "in-progress"
                    ? "warning"
                    : void 0,
            },
            W === "completed" ? " " : "",
            J,
            W === "in-progress" ? "" : "",
          ),
        );
      }),
    ),
  );
}
var Lb;
var kp2 = T(() => {
  nA();
  Lb = IA(KA(), 1);
});
function _p2({
  secretExists: A,
  useExistingSecret: B,
  secretName: Q,
  skipWorkflow: I = !1,
}) {
  return o7.default.createElement(
    o7.default.Fragment,
    null,
    o7.default.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderDimColor: !0,
        paddingX: 1,
      },
      o7.default.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        o7.default.createElement(U, { bold: !0 }, "Install GitHub App"),
        o7.default.createElement(U, { dimColor: !0 }, "Success"),
      ),
      !I &&
        o7.default.createElement(
          U,
          { color: "success" },
          " GitHub Actions workflow created!",
        ),
      A &&
        B &&
        o7.default.createElement(
          S,
          { marginTop: 1 },
          o7.default.createElement(
            U,
            { color: "success" },
            " Using existing ANTHROPIC_API_KEY secret",
          ),
        ),
      (!A || !B) &&
        o7.default.createElement(
          S,
          { marginTop: 1 },
          o7.default.createElement(
            U,
            { color: "success" },
            " API key saved as ",
            Q,
            " secret",
          ),
        ),
      o7.default.createElement(
        S,
        { marginTop: 1 },
        o7.default.createElement(U, null, "Next steps:"),
      ),
      I
        ? o7.default.createElement(
            o7.default.Fragment,
            null,
            o7.default.createElement(
              U,
              null,
              "1. Install the Claude GitHub App if you haven't already",
            ),
            o7.default.createElement(
              U,
              null,
              "2. Your workflow file was kept unchanged",
            ),
            o7.default.createElement(
              U,
              null,
              "3. API key is configured and ready to use",
            ),
          )
        : o7.default.createElement(
            o7.default.Fragment,
            null,
            o7.default.createElement(
              U,
              null,
              "1. A pre-filled PR page has been created",
            ),
            o7.default.createElement(
              U,
              null,
              "2. Install the Claude GitHub App if you haven't already",
            ),
            o7.default.createElement(
              U,
              null,
              "3. Merge the PR to enable Claude PR assistance",
            ),
          ),
    ),
    o7.default.createElement(
      S,
      { marginLeft: 3 },
      o7.default.createElement(U, { dimColor: !0 }, "Press any key to exit"),
    ),
  );
}
var o7;
var xp2 = T(() => {
  nA();
  o7 = IA(KA(), 1);
});
function vp2({ error: A, errorReason: B, errorInstructions: Q }) {
  return jW.default.createElement(
    jW.default.Fragment,
    null,
    jW.default.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderDimColor: !0,
        paddingX: 1,
      },
      jW.default.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        jW.default.createElement(U, { bold: !0 }, "Install GitHub App"),
      ),
      jW.default.createElement(U, { color: "error" }, "Error: ", A),
      B &&
        jW.default.createElement(
          S,
          { marginTop: 1 },
          jW.default.createElement(U, { dimColor: !0 }, "Reason: ", B),
        ),
      Q &&
        Q.length > 0 &&
        jW.default.createElement(
          S,
          { flexDirection: "column", marginTop: 1 },
          jW.default.createElement(U, { dimColor: !0 }, "How to fix:"),
          Q.map((I, G) =>
            jW.default.createElement(
              S,
              { key: G, marginLeft: 2 },
              jW.default.createElement(U, { dimColor: !0 }, " "),
              jW.default.createElement(U, null, I),
            ),
          ),
        ),
      jW.default.createElement(
        S,
        { marginTop: 1 },
        jW.default.createElement(
          U,
          { dimColor: !0 },
          "For manual setup instructions, see:",
          " ",
          jW.default.createElement(U, { color: "claude" }, Ey),
        ),
      ),
    ),
    jW.default.createElement(
      S,
      { marginLeft: 3 },
      jW.default.createElement(U, { dimColor: !0 }, "Press any key to exit"),
    ),
  );
}
var jW;
var bp2 = T(() => {
  nA();
  jW = IA(KA(), 1);
});
function fp2({ repoName: A, onSelectAction: B }) {
  return _z.default.createElement(
    S,
    {
      flexDirection: "column",
      borderStyle: "round",
      borderDimColor: !0,
      paddingX: 1,
    },
    _z.default.createElement(
      S,
      { flexDirection: "column", marginBottom: 1 },
      _z.default.createElement(U, { bold: !0 }, "Existing Workflow Found"),
      _z.default.createElement(U, { dimColor: !0 }, "Repository: ", A),
    ),
    _z.default.createElement(
      S,
      { flexDirection: "column", marginBottom: 1 },
      _z.default.createElement(
        U,
        null,
        "A Claude workflow file already exists at",
        " ",
        _z.default.createElement(
          U,
          { color: "claude" },
          ".github/workflows/claude.yml",
        ),
      ),
      _z.default.createElement(
        U,
        { dimColor: !0 },
        "What would you like to do?",
      ),
    ),
    _z.default.createElement(
      S,
      { flexDirection: "column" },
      _z.default.createElement($0, {
        options: [
          {
            label: "Update workflow file with latest version",
            value: "update",
          },
          {
            label: "Skip workflow update (configure secrets only)",
            value: "skip",
          },
          { label: "Exit without making changes", value: "exit" },
        ],
        onChange: (Z) => {
          B(Z);
        },
        onCancel: () => {
          B("exit");
        },
      }),
    ),
    _z.default.createElement(
      S,
      { marginTop: 1 },
      _z.default.createElement(
        U,
        { dimColor: !0 },
        "View the latest workflow template at:",
        " ",
        _z.default.createElement(
          U,
          { color: "claude" },
          "https://github.com/anthropics/claude-code-action/blob/main/examples/claude.yml",
        ),
      ),
    ),
  );
}
var _z;
var hp2 = T(() => {
  nA();
  R5();
  _z = IA(KA(), 1);
});
function gp2({ warnings: A, onContinue: B }) {
  return (
    h1((Q, I) => {
      if (I.return) B();
    }),
    OV.default.createElement(
      OV.default.Fragment,
      null,
      OV.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderDimColor: !0,
          paddingX: 1,
        },
        OV.default.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          OV.default.createElement(
            U,
            { bold: !0 },
            E1.warning,
            " Setup Warnings",
          ),
          OV.default.createElement(
            U,
            { dimColor: !0 },
            "We found some potential issues, but you can continue anyway",
          ),
        ),
        A.map((Q, I) =>
          OV.default.createElement(
            S,
            { key: I, flexDirection: "column", marginBottom: 1 },
            OV.default.createElement(
              U,
              { color: "warning", bold: !0 },
              Q.title,
            ),
            OV.default.createElement(U, null, Q.message),
            Q.instructions.length > 0 &&
              OV.default.createElement(
                S,
                { flexDirection: "column", marginLeft: 2, marginTop: 1 },
                Q.instructions.map((G, Z) =>
                  OV.default.createElement(
                    U,
                    { key: Z, dimColor: !0 },
                    " ",
                    G,
                  ),
                ),
              ),
          ),
        ),
        OV.default.createElement(
          S,
          { marginTop: 1 },
          OV.default.createElement(
            U,
            { bold: !0, color: "permission" },
            "Press Enter to continue anyway, or Ctrl+C to exit and fix issues",
          ),
        ),
        OV.default.createElement(
          S,
          { marginTop: 1 },
          OV.default.createElement(
            U,
            { dimColor: !0 },
            "You can also try the manual setup steps if needed:",
            " ",
            OV.default.createElement(U, { color: "claude" }, Ey),
          ),
        ),
      ),
    )
  );
}
var OV;
var up2 = T(() => {
  nA();
  s2();
  OV = IA(KA(), 1);
});
function mp2({ onSubmit: A, defaultSelections: B }) {
  let [Q, I] = RG.useState(new Set(B)),
    [G, Z] = RG.useState(0),
    [Y, J] = RG.useState(!1),
    X = [
      {
        value: "claude",
        label: "@Claude Code",
        description: "Tag @claude in issues and PR comments",
      },
      {
        value: "claude-review",
        label: "Claude Code Review",
        description: "Automated code review on new PRs",
      },
    ];
  return (
    h1((W, F) => {
      if (F.upArrow) (Z((C) => (C > 0 ? C - 1 : X.length - 1)), J(!1));
      else if (F.downArrow) (Z((C) => (C < X.length - 1 ? C + 1 : 0)), J(!1));
      else if (W === " ") {
        let C = X[G]?.value;
        if (C)
          I((V) => {
            let K = new Set(V);
            if (K.has(C)) K.delete(C);
            else K.add(C);
            return K;
          });
      } else if (F.return)
        if (Q.size === 0) J(!0);
        else A(Array.from(Q));
    }),
    RG.default.createElement(
      RG.default.Fragment,
      null,
      RG.default.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderDimColor: !0,
          paddingX: 1,
          width: "100%",
        },
        RG.default.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          RG.default.createElement(
            U,
            { bold: !0 },
            "Select GitHub workflows to install",
          ),
          RG.default.createElement(
            U,
            { dimColor: !0 },
            "We'll create a workflow file in your repository for each one you select.",
          ),
          RG.default.createElement(
            S,
            { marginTop: 1 },
            RG.default.createElement(
              U,
              { dimColor: !0 },
              "More workflow examples (issue triage, CI fixes, etc.) at:",
              " ",
              RG.default.createElement(
                n5A,
                {
                  url: "https://github.com/anthropics/claude-code-action/blob/main/examples/",
                },
                "https://github.com/anthropics/claude-code-action/blob/main/examples/",
              ),
            ),
          ),
        ),
        RG.default.createElement(
          S,
          { flexDirection: "column", paddingX: 1 },
          X.map((W, F) => {
            let C = Q.has(W.value),
              V = F === G;
            return RG.default.createElement(
              S,
              {
                key: W.value,
                flexDirection: "row",
                marginBottom: F < X.length - 1 ? 1 : 0,
              },
              RG.default.createElement(
                S,
                { marginRight: 1, minWidth: 2 },
                RG.default.createElement(U, { bold: V }, C ? "" : " "),
              ),
              RG.default.createElement(
                S,
                { flexDirection: "column" },
                RG.default.createElement(U, { bold: V }, W.label),
                RG.default.createElement(U, { dimColor: !0 }, W.description),
              ),
            );
          }),
        ),
      ),
      RG.default.createElement(
        S,
        { marginLeft: 2 },
        RG.default.createElement(
          U,
          { dimColor: !0 },
          " Navigate  Space to toggle  Enter to confirm",
        ),
      ),
      Y &&
        RG.default.createElement(
          S,
          { marginLeft: 1 },
          RG.default.createElement(
            U,
            { color: "error" },
            "You must select at least one workflow to continue",
          ),
        ),
    )
  );
}
var RG;
var dp2 = T(() => {
  nA();
  NrA();
  RG = IA(KA(), 1);
});
async function Ie5(A, B, Q, I, G, Z, Y) {
  let J = await r0("gh", ["api", `repos/${A}/contents/${Q}`, "--jq", ".sha"]),
    X = null;
  if (J.code === 0) X = J.stdout.trim();
  let W = I;
  if (G === "CLAUDE_CODE_OAUTH_TOKEN")
    W = I.replace(
      /anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g,
      "claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}",
    );
  else if (G !== "ANTHROPIC_API_KEY")
    W = I.replace(
      /anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g,
      `anthropic_api_key: \${{ secrets.${G} }}`,
    );
  let F = Buffer.from(W).toString("base64"),
    C = [
      "api",
      "--method",
      "PUT",
      `repos/${A}/contents/${Q}`,
      "-f",
      `message=${X ? `"Update ${Z}"` : `"${Z}"`}`,
      "-f",
      `content=${F}`,
      "-f",
      `branch=${B}`,
    ];
  if (X) C.push("-f", `sha=${X}`);
  let V = await r0("gh", C);
  if (V.code !== 0) {
    if (V.stderr.includes("422") && V.stderr.includes("sha"))
      throw (
        GA("tengu_setup_github_actions_failed", {
          reason: "failed_to_create_workflow_file",
          exit_code: V.code,
          ...Y,
        }),
        Error(
          `Failed to create workflow file ${Q}: A Claude workflow file already exists in this repository. Please remove it first or update it manually.`,
        )
      );
    GA("tengu_setup_github_actions_failed", {
      reason: "failed_to_create_workflow_file",
      exit_code: V.code,
      ...Y,
    });
    let K =
      `

Need help? Common issues:
` +
      ` Permission denied  Run: gh auth refresh -h github.com -s repo,workflow
` +
      ` Not authorized  Ensure you have admin access to the repository
` +
      " For manual setup  Visit: https://github.com/anthropics/claude-code-action";
    throw Error(`Failed to create workflow file ${Q}: ${V.stderr}${K}`);
  }
}
async function cp2(A, B, Q, I, G = !1, Z, Y, J) {
  try {
    GA("tengu_setup_github_actions_started", {
      skip_workflow: G,
      has_api_key: !!B,
      using_default_secret_name: Q === "ANTHROPIC_API_KEY",
      selected_claude_workflow: Z.includes("claude"),
      selected_claude_review_workflow: Z.includes("claude-review"),
      ...J,
    });
    let X = await r0("gh", ["api", `repos/${A}`, "--jq", ".id"]);
    if (X.code !== 0)
      throw (
        GA("tengu_setup_github_actions_failed", {
          reason: "repo_not_found",
          exit_code: X.code,
          ...J,
        }),
        Error(`Failed to access repository ${A}`)
      );
    let W = await r0("gh", ["api", `repos/${A}`, "--jq", ".default_branch"]);
    if (W.code !== 0)
      throw (
        GA("tengu_setup_github_actions_failed", {
          reason: "failed_to_get_default_branch",
          exit_code: W.code,
          ...J,
        }),
        Error(`Failed to get default branch: ${W.stderr}`)
      );
    let F = W.stdout.trim(),
      C = await r0("gh", [
        "api",
        `repos/${A}/git/ref/heads/${F}`,
        "--jq",
        ".object.sha",
      ]);
    if (C.code !== 0)
      throw (
        GA("tengu_setup_github_actions_failed", {
          reason: "failed_to_get_branch_sha",
          exit_code: C.code,
          ...J,
        }),
        Error(`Failed to get branch SHA: ${C.stderr}`)
      );
    let V = C.stdout.trim(),
      K = null;
    if (!G) {
      (I(), (K = `add-claude-github-actions-${Date.now()}`));
      let D = await r0("gh", [
        "api",
        "--method",
        "POST",
        `repos/${A}/git/refs`,
        "-f",
        `ref=refs/heads/${K}`,
        "-f",
        `sha=${V}`,
      ]);
      if (D.code !== 0)
        throw (
          GA("tengu_setup_github_actions_failed", {
            reason: "failed_to_create_branch",
            exit_code: D.code,
            ...J,
          }),
          Error(`Failed to create branch: ${D.stderr}`)
        );
      I();
      let E = [];
      if (Z.includes("claude"))
        E.push({
          path: ".github/workflows/claude.yml",
          content: qp2,
          message: "Claude PR Assistant workflow",
        });
      if (Z.includes("claude-review")) {
        let H = xC("tengu_gha_plugin_code_review");
        E.push({
          path: ".github/workflows/claude-code-review.yml",
          content: H ? Mp2 : Lp2,
          message: "Claude Code Review workflow",
        });
      }
      for (let H of E) await Ie5(A, K, H.path, H.content, Q, H.message, J);
    }
    if ((I(), B)) {
      let D = await r0("gh", ["secret", "set", Q, "--body", B, "--repo", A]);
      if (D.code !== 0) {
        GA("tengu_setup_github_actions_failed", {
          reason: "failed_to_set_api_key_secret",
          exit_code: D.code,
          ...J,
        });
        let E =
          `

Need help? Common issues:
` +
          ` Permission denied  Run: gh auth refresh -h github.com -s repo
` +
          ` Not authorized  Ensure you have admin access to the repository
` +
          " For manual setup  Visit: https://github.com/anthropics/claude-code-action";
        throw Error(
          `Failed to set API key secret: ${D.stderr || "Unknown error"}${E}`,
        );
      }
    }
    if (!G && K) {
      I();
      let D = `https://github.com/${A}/compare/${F}...${K}?quick_pull=1&title=${encodeURIComponent($p2)}&body=${encodeURIComponent(Np2)}`;
      await d7(D);
    }
    (GA("tengu_setup_github_actions_completed", {
      skip_workflow: G,
      has_api_key: !!B,
      auth_type: Y,
      using_default_secret_name: Q === "ANTHROPIC_API_KEY",
      selected_claude_workflow: Z.includes("claude"),
      selected_claude_review_workflow: Z.includes("claude-review"),
      ...J,
    }),
      n0({
        ...L1(),
        githubActionSetupCount: (L1().githubActionSetupCount ?? 0) + 1,
      }));
  } catch (X) {
    if (!X || !(X instanceof Error) || !X.message.includes("Failed to"))
      GA("tengu_setup_github_actions_failed", {
        reason: "unexpected_error",
        ...J,
      });
    if (X instanceof Error) BA(X, HG0);
    throw X;
  }
}
var pp2 = T(() => {
  Q5();
  rq();
  f4();
  H0();
  c1();
  kB();
});
function ip2({ onSuccess: A, onCancel: B }) {
  let [Q, I] = l9.useState({ state: "starting" }),
    [G] = l9.useState(() => new HwA()),
    [Z, Y] = l9.useState(""),
    [J, X] = l9.useState(0),
    [W, F] = l9.useState(!1),
    C = l9.useRef(new Set()),
    V = aB(),
    K = Math.max(50, V.columns - lp2.length - 4);
  h1((w, L) => {
    if (Q.state === "error")
      if (L.return && Q.toRetry)
        (Y(""), X(0), I({ state: "about_to_retry", nextState: Q.toRetry }));
      else B();
  });
  async function D(w, L) {
    try {
      let [N, $] = w.split("#");
      if (!N || !$) {
        I({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: { state: "waiting_for_login", url: L },
        });
        return;
      }
      (GA("tengu_oauth_manual_entry", {}),
        G.handleManualAuthCodeInput({ authorizationCode: N, state: $ }));
    } catch (N) {
      (BA(N instanceof Error ? N : Error(String(N)), DG0),
        I({
          state: "error",
          message: N.message,
          toRetry: { state: "waiting_for_login", url: L },
        }));
    }
  }
  let E = l9.useCallback(async () => {
    (C.current.forEach((w) => clearTimeout(w)), C.current.clear());
    try {
      let w = await G.startOAuthFlow(
        async ($) => {
          I({ state: "waiting_for_login", url: $ });
          let O = setTimeout(() => F(!0), 3000);
          C.current.add(O);
        },
        { loginWithClaudeAi: !0, inferenceOnly: !0, expiresIn: 31536000 },
      );
      (await NY(), I({ state: "processing" }));
      let L = qwA(w);
      if (L.warning) GA("tengu_oauth_storage_warning", { warning: L.warning });
      let N = setTimeout(() => {
        I({ state: "success", token: w.accessToken });
        let $ = setTimeout(() => {
          A(w.accessToken);
        }, 1000);
        C.current.add($);
      }, 100);
      C.current.add(N);
    } catch (w) {
      let L = w.message;
      (await NY(),
        I({ state: "error", message: L, toRetry: { state: "starting" } }),
        BA(w instanceof Error ? w : Error(String(w)), EG0),
        GA("tengu_oauth_error", { error: L }));
    }
  }, [G, A]);
  (l9.useEffect(() => {
    if (Q.state === "starting") E();
  }, [Q.state, E]),
    l9.useEffect(() => {
      if (Q.state === "about_to_retry") {
        NY();
        let w = setTimeout(() => {
          if (Q.nextState.state === "waiting_for_login") F(!0);
          else F(!1);
          I(Q.nextState);
        }, 500);
        C.current.add(w);
      }
    }, [Q]),
    l9.useEffect(() => {
      let w = C.current;
      return () => {
        (G.cleanup(), w.forEach((L) => clearTimeout(L)), w.clear());
      };
    }, [G]));
  function H() {
    switch (Q.state) {
      case "starting":
        return l9.default.createElement(
          S,
          null,
          l9.default.createElement(E8, null),
          l9.default.createElement(U, null, "Starting authentication"),
        );
      case "waiting_for_login":
        return l9.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          !W &&
            l9.default.createElement(
              S,
              null,
              l9.default.createElement(E8, null),
              l9.default.createElement(
                U,
                null,
                "Opening browser to sign in with your Claude account",
              ),
            ),
          W &&
            l9.default.createElement(
              S,
              null,
              l9.default.createElement(U, null, lp2),
              l9.default.createElement(O4, {
                value: Z,
                onChange: Y,
                onSubmit: (w) => D(w, Q.url),
                cursorOffset: J,
                onChangeCursorOffset: X,
                columns: K,
              }),
            ),
        );
      case "processing":
        return l9.default.createElement(
          S,
          null,
          l9.default.createElement(E8, null),
          l9.default.createElement(U, null, "Processing authentication"),
        );
      case "success":
        return l9.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          l9.default.createElement(
            U,
            { color: "success" },
            " Authentication token created successfully!",
          ),
          l9.default.createElement(
            U,
            { dimColor: !0 },
            "Using token for GitHub Actions setup",
          ),
        );
      case "error":
        return l9.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          l9.default.createElement(
            U,
            { color: "error" },
            "OAuth error: ",
            Q.message,
          ),
          Q.toRetry
            ? l9.default.createElement(
                U,
                { dimColor: !0 },
                "Press Enter to try again, or any other key to cancel",
              )
            : l9.default.createElement(
                U,
                { dimColor: !0 },
                "Press any key to return to API key selection",
              ),
        );
      case "about_to_retry":
        return l9.default.createElement(
          S,
          { flexDirection: "column", gap: 1 },
          l9.default.createElement(U, { color: "permission" }, "Retrying"),
        );
      default:
        return null;
    }
  }
  return l9.default.createElement(
    S,
    { flexDirection: "column", gap: 1 },
    Q.state === "starting" &&
      l9.default.createElement(
        S,
        { flexDirection: "column", gap: 1, paddingBottom: 1 },
        l9.default.createElement(
          U,
          { bold: !0 },
          "Create Authentication Token",
        ),
        l9.default.createElement(
          U,
          { dimColor: !0 },
          "Creating a long-lived token for GitHub Actions",
        ),
      ),
    Q.state !== "success" &&
      Q.state !== "starting" &&
      Q.state !== "processing" &&
      l9.default.createElement(
        S,
        { key: "header", flexDirection: "column", gap: 1, paddingBottom: 1 },
        l9.default.createElement(
          U,
          { bold: !0 },
          "Create Authentication Token",
        ),
        l9.default.createElement(
          U,
          { dimColor: !0 },
          "Creating a long-lived token for GitHub Actions",
        ),
      ),
    Q.state === "waiting_for_login" &&
      W &&
      l9.default.createElement(
        S,
        { flexDirection: "column", key: "urlToCopy", gap: 1, paddingBottom: 1 },
        l9.default.createElement(
          S,
          { paddingX: 1 },
          l9.default.createElement(
            U,
            { dimColor: !0 },
            "Browser didn't open? Use the url below to sign in:",
          ),
        ),
        l9.default.createElement(
          S,
          { width: 1000 },
          l9.default.createElement(U, { dimColor: !0 }, Q.url),
        ),
      ),
    l9.default.createElement(
      S,
      { paddingLeft: 1, flexDirection: "column", gap: 1 },
      H(),
    ),
  );
}
var l9,
  lp2 = "Paste code here if prompted > ";
var np2 = T(() => {
  nA();
  rG();
  Pt1();
  F2();
  H0();
  xX();
  c1();
  N8();
  Xx();
  l9 = IA(KA(), 1);
});
import { execSync as KB1 } from "child_process";
function Ze5(A) {
  let [B] = TG.useState(() => kU()),
    [Q, I] = TG.useState({
      ...Ge5,
      useExistingKey: !!B,
      selectedApiKeyOption: B ? "existing" : Sz() ? "oauth" : "new",
    });
  (IB(),
    TG.default.useEffect(() => {
      GA("tengu_install_github_app_started", {});
    }, []));
  let G = TG.useCallback(async () => {
    let P = [];
    try {
      KB1("gh --version", { stdio: "ignore" });
    } catch {
      P.push({
        title: "GitHub CLI not found",
        message:
          "GitHub CLI (gh) does not appear to be installed or accessible.",
        instructions: [
          "Install GitHub CLI from https://cli.github.com/",
          "macOS: brew install gh",
          "Windows: winget install --id GitHub.cli",
          "Linux: See installation instructions at https://github.com/cli/cli#installation",
        ],
      });
    }
    try {
      let x = KB1("gh auth status -a", { encoding: "utf8" }).match(
        /Token scopes:.*$/m,
      );
      if (x) {
        let n = x[0],
          m = [];
        if (!n.includes("repo")) m.push("repo");
        if (!n.includes("workflow")) m.push("workflow");
        if (m.length > 0) {
          I((o) => ({
            ...o,
            step: "error",
            error: `GitHub CLI is missing required permissions: ${m.join(", ")}.`,
            errorReason: "Missing required scopes",
            errorInstructions: [
              `Your GitHub CLI authentication is missing the "${m.join('" and "')}" scope${m.length > 1 ? "s" : ""} needed to manage GitHub Actions and secrets.`,
              "",
              "To fix this, run:",
              "  gh auth refresh -h github.com -s repo,workflow",
              "",
              "This will add the necessary permissions to manage workflows and secrets.",
            ],
          }));
          return;
        }
      }
    } catch {
      P.push({
        title: "GitHub CLI not authenticated",
        message: "GitHub CLI does not appear to be authenticated.",
        instructions: [
          "Run: gh auth login",
          "Follow the prompts to authenticate with GitHub",
          "Or set up authentication using environment variables or other methods",
        ],
      });
    }
    let k = "";
    try {
      KB1("git rev-parse --is-inside-work-tree", { stdio: "ignore" });
      let x = KB1("git remote get-url origin", { encoding: "utf8" })
        .trim()
        .match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
      if (x) k = x[1]?.replace(/\.git$/, "") || "";
    } catch {}
    (GA("tengu_install_github_app_step_completed", { step: "check-gh" }),
      I((b) => ({
        ...b,
        warnings: P,
        currentRepo: k,
        selectedRepoName: k,
        useCurrentRepo: !!k,
        step: P.length > 0 ? "warnings" : "choose-repo",
      })));
  }, []);
  TG.default.useEffect(() => {
    if (Q.step === "check-gh") G();
  }, [Q.step, G]);
  let Z = TG.useCallback(
    async (P, k) => {
      I((b) => ({ ...b, step: "creating", currentWorkflowInstallStep: 0 }));
      try {
        (await cp2(
          Q.selectedRepoName,
          P,
          k,
          () => {
            I((b) => ({
              ...b,
              currentWorkflowInstallStep: b.currentWorkflowInstallStep + 1,
            }));
          },
          Q.workflowAction === "skip",
          Q.selectedWorkflows,
          Q.authType,
          {
            useCurrentRepo: Q.useCurrentRepo,
            workflowExists: Q.workflowExists,
            secretExists: Q.secretExists,
          },
        ),
          GA("tengu_install_github_app_step_completed", { step: "creating" }),
          I((b) => ({ ...b, step: "success" })));
      } catch (b) {
        let x =
          b instanceof Error ? b.message : "Failed to set up GitHub Actions";
        if (x.includes("workflow file already exists"))
          (GA("tengu_install_github_app_error", {
            reason: "workflow_file_exists",
          }),
            I((n) => ({
              ...n,
              step: "error",
              error:
                "A Claude workflow file already exists in this repository.",
              errorReason: "Workflow file conflict",
              errorInstructions: [
                "The file .github/workflows/claude.yml already exists",
                "You can either:",
                "  1. Delete the existing file and run this command again",
                "  2. Update the existing file manually using the template from:",
                `     ${Ey}`,
              ],
            })));
        else
          (GA("tengu_install_github_app_error", {
            reason: "setup_github_actions_failed",
          }),
            I((n) => ({
              ...n,
              step: "error",
              error: x,
              errorReason: "GitHub Actions setup failed",
              errorInstructions: [],
            })));
      }
    },
    [
      Q.selectedRepoName,
      Q.workflowAction,
      Q.selectedWorkflows,
      Q.useCurrentRepo,
      Q.workflowExists,
      Q.secretExists,
      Q.authType,
    ],
  );
  async function Y() {
    await d7("https://github.com/apps/claude");
  }
  async function J(P) {
    try {
      let k = await r0("gh", [
        "api",
        `repos/${P}`,
        "--jq",
        ".permissions.admin",
      ]);
      if (k.code === 0) return { hasAccess: k.stdout.trim() === "true" };
      if (k.stderr.includes("404") || k.stderr.includes("Not Found"))
        return { hasAccess: !1, error: "repository_not_found" };
      return { hasAccess: !1 };
    } catch {
      return { hasAccess: !1 };
    }
  }
  async function X(P) {
    return (
      (
        await r0("gh", [
          "api",
          `repos/${P}/contents/.github/workflows/claude.yml`,
          "--jq",
          ".sha",
        ])
      ).code === 0
    );
  }
  async function W() {
    let P = await r0("gh", [
      "secret",
      "list",
      "--app",
      "actions",
      "--repo",
      Q.selectedRepoName,
    ]);
    if (P.code === 0)
      if (
        P.stdout
          .split(
            `
`,
          )
          .some((x) => {
            return /^ANTHROPIC_API_KEY\s+/.test(x);
          })
      )
        I((x) => ({ ...x, secretExists: !0, step: "check-existing-secret" }));
      else if (B)
        (I((x) => ({ ...x, apiKeyOrOAuthToken: B, useExistingKey: !0 })),
          await Z(B, Q.secretName));
      else I((x) => ({ ...x, step: "api-key" }));
    else if (B)
      (I((k) => ({ ...k, apiKeyOrOAuthToken: B, useExistingKey: !0 })),
        await Z(B, Q.secretName));
    else I((k) => ({ ...k, step: "api-key" }));
  }
  let F = async () => {
      if (Q.step === "warnings")
        (GA("tengu_install_github_app_step_completed", { step: "warnings" }),
          I((P) => ({ ...P, step: "install-app" })),
          setTimeout(() => {
            Y();
          }, 0));
      else if (Q.step === "choose-repo") {
        let P = Q.useCurrentRepo ? Q.currentRepo : Q.selectedRepoName;
        if (!P.trim()) return;
        let k = [];
        if (P.includes("github.com")) {
          let n = P.match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
          if (!n)
            k.push({
              title: "Invalid GitHub URL format",
              message: "The repository URL format appears to be invalid.",
              instructions: [
                "Use format: owner/repo or https://github.com/owner/repo",
                "Example: anthropics/claude-cli",
              ],
            });
          else P = n[1]?.replace(/\.git$/, "") || "";
        }
        if (!P.includes("/"))
          k.push({
            title: "Repository format warning",
            message: 'Repository should be in format "owner/repo"',
            instructions: [
              "Use format: owner/repo",
              "Example: anthropics/claude-cli",
            ],
          });
        let b = await J(P);
        if (b.error === "repository_not_found")
          k.push({
            title: "Repository not found",
            message: `Repository ${P} was not found or you don't have access.`,
            instructions: [
              `Check that the repository name is correct: ${P}`,
              "Ensure you have access to this repository",
              'For private repositories, make sure your GitHub token has the "repo" scope',
              "You can add the repo scope with: gh auth refresh -h github.com -s repo,workflow",
            ],
          });
        else if (!b.hasAccess)
          k.push({
            title: "Admin permissions required",
            message: `You might need admin permissions on ${P} to set up GitHub Actions.`,
            instructions: [
              "Repository admins can install GitHub Apps and set secrets",
              "Ask a repository admin to run this command if setup fails",
              "Alternatively, you can use the manual setup instructions",
            ],
          });
        let x = await X(P);
        if (k.length > 0) {
          let n = [...Q.warnings, ...k];
          I((m) => ({
            ...m,
            selectedRepoName: P,
            workflowExists: x,
            warnings: n,
            step: "warnings",
          }));
        } else
          (GA("tengu_install_github_app_step_completed", {
            step: "choose-repo",
          }),
            I((n) => ({
              ...n,
              selectedRepoName: P,
              workflowExists: x,
              step: "install-app",
            })),
            setTimeout(() => {
              Y();
            }, 0));
      } else if (Q.step === "install-app")
        if (
          (GA("tengu_install_github_app_step_completed", {
            step: "install-app",
          }),
          Q.workflowExists)
        )
          I((P) => ({ ...P, step: "check-existing-workflow" }));
        else I((P) => ({ ...P, step: "select-workflows" }));
      else if (Q.step === "check-existing-workflow") return;
      else if (Q.step === "select-workflows") return;
      else if (Q.step === "check-existing-secret")
        if (
          (GA("tengu_install_github_app_step_completed", {
            step: "check-existing-secret",
          }),
          Q.useExistingSecret)
        )
          await Z(null, Q.secretName);
        else await Z(Q.apiKeyOrOAuthToken, Q.secretName);
      else if (Q.step === "api-key") {
        if (Q.selectedApiKeyOption === "oauth") return;
        let P =
          Q.selectedApiKeyOption === "existing" ? B : Q.apiKeyOrOAuthToken;
        if (!P) {
          (GA("tengu_install_github_app_error", { reason: "api_key_missing" }),
            I((b) => ({ ...b, step: "error", error: "API key is required" })));
          return;
        }
        I((b) => ({
          ...b,
          apiKeyOrOAuthToken: P,
          useExistingKey: Q.selectedApiKeyOption === "existing",
        }));
        let k = await r0("gh", [
          "secret",
          "list",
          "--app",
          "actions",
          "--repo",
          Q.selectedRepoName,
        ]);
        if (k.code === 0)
          if (
            k.stdout
              .split(
                `
`,
              )
              .some((n) => {
                return /^ANTHROPIC_API_KEY\s+/.test(n);
              })
          )
            (GA("tengu_install_github_app_step_completed", { step: "api-key" }),
              I((n) => ({
                ...n,
                secretExists: !0,
                step: "check-existing-secret",
              })));
          else
            (GA("tengu_install_github_app_step_completed", { step: "api-key" }),
              await Z(P, Q.secretName));
        else
          (GA("tengu_install_github_app_step_completed", { step: "api-key" }),
            await Z(P, Q.secretName));
      }
    },
    C = (P) => {
      I((k) => ({ ...k, selectedRepoName: P }));
    },
    V = (P) => {
      I((k) => ({ ...k, apiKeyOrOAuthToken: P }));
    },
    K = (P) => {
      I((k) => ({ ...k, selectedApiKeyOption: P }));
    },
    D = TG.useCallback(() => {
      (GA("tengu_install_github_app_step_completed", { step: "api-key" }),
        I((P) => ({ ...P, step: "oauth-flow" })));
    }, []),
    E = TG.useCallback(
      (P) => {
        (GA("tengu_install_github_app_step_completed", { step: "oauth-flow" }),
          I((k) => ({
            ...k,
            apiKeyOrOAuthToken: P,
            useExistingKey: !1,
            secretName: "CLAUDE_CODE_OAUTH_TOKEN",
            authType: "oauth_token",
          })),
          Z(P, "CLAUDE_CODE_OAUTH_TOKEN"));
      },
      [Z],
    ),
    H = TG.useCallback(() => {
      I((P) => ({ ...P, step: "api-key" }));
    }, []),
    w = (P) => {
      if (P && !/^[a-zA-Z0-9_]+$/.test(P)) return;
      I((k) => ({ ...k, secretName: P }));
    },
    L = (P) => {
      I((k) => ({
        ...k,
        useCurrentRepo: P,
        selectedRepoName: P ? k.currentRepo : "",
      }));
    },
    N = (P) => {
      I((k) => ({ ...k, useExistingKey: P }));
    },
    $ = (P) => {
      I((k) => ({
        ...k,
        useExistingSecret: P,
        secretName: P ? "ANTHROPIC_API_KEY" : "",
      }));
    },
    O = async (P) => {
      if (P === "exit") {
        A.onDone("Installation cancelled by user");
        return;
      }
      if (
        (GA("tengu_install_github_app_step_completed", {
          step: "check-existing-workflow",
        }),
        I((k) => ({ ...k, workflowAction: P })),
        P === "skip" || P === "update")
      )
        if (B) await W();
        else I((k) => ({ ...k, step: "api-key" }));
    };
  switch (
    (h1(() => {
      if (Q.step === "success" || Q.step === "error") {
        if (Q.step === "success") GA("tengu_install_github_app_completed", {});
        A.onDone(
          Q.step === "success"
            ? "GitHub Actions setup complete!"
            : Q.error
              ? `Couldn't install GitHub App: ${Q.error}
For manual setup instructions, see: ${Ey}`
              : `GitHub App installation failed
For manual setup instructions, see: ${Ey}`,
        );
      }
    }),
    Q.step)
  ) {
    case "check-gh":
      return TG.default.createElement(Hp2, null);
    case "warnings":
      return TG.default.createElement(gp2, {
        warnings: Q.warnings,
        onContinue: F,
      });
    case "choose-repo":
      return TG.default.createElement(Up2, {
        currentRepo: Q.currentRepo,
        useCurrentRepo: Q.useCurrentRepo,
        repoUrl: Q.selectedRepoName,
        onRepoUrlChange: C,
        onToggleUseCurrentRepo: L,
        onSubmit: F,
      });
    case "install-app":
      return TG.default.createElement(Op2, {
        repoUrl: Q.selectedRepoName,
        onSubmit: F,
      });
    case "check-existing-workflow":
      return TG.default.createElement(fp2, {
        repoName: Q.selectedRepoName,
        onSelectAction: O,
      });
    case "check-existing-secret":
      return TG.default.createElement(Tp2, {
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        onToggleUseExistingSecret: $,
        onSecretNameChange: w,
        onSubmit: F,
      });
    case "api-key":
      return TG.default.createElement(jp2, {
        existingApiKey: B,
        useExistingKey: Q.useExistingKey,
        apiKeyOrOAuthToken: Q.apiKeyOrOAuthToken,
        onApiKeyChange: V,
        onToggleUseExistingKey: N,
        onSubmit: F,
        onCreateOAuthToken: Sz() ? D : void 0,
        selectedOption: Q.selectedApiKeyOption,
        onSelectOption: K,
      });
    case "creating":
      return TG.default.createElement(yp2, {
        currentWorkflowInstallStep: Q.currentWorkflowInstallStep,
        secretExists: Q.secretExists,
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        skipWorkflow: Q.workflowAction === "skip",
        selectedWorkflows: Q.selectedWorkflows,
      });
    case "success":
      return TG.default.createElement(_p2, {
        secretExists: Q.secretExists,
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        skipWorkflow: Q.workflowAction === "skip",
      });
    case "error":
      return TG.default.createElement(vp2, {
        error: Q.error,
        errorReason: Q.errorReason,
        errorInstructions: Q.errorInstructions,
      });
    case "select-workflows":
      return TG.default.createElement(mp2, {
        defaultSelections: Q.selectedWorkflows,
        onSubmit: (P) => {
          if (
            (GA("tengu_install_github_app_step_completed", {
              step: "select-workflows",
            }),
            I((k) => ({ ...k, selectedWorkflows: P })),
            B)
          )
            W();
          else I((k) => ({ ...k, step: "api-key" }));
        },
      });
    case "oauth-flow":
      return TG.default.createElement(ip2, { onSuccess: E, onCancel: H });
  }
}
var TG, Ge5, Ye5, ap2;
var sp2 = T(() => {
  nA();
  F2();
  R9();
  Q5();
  rq();
  zp2();
  wp2();
  Rp2();
  Pp2();
  Sp2();
  kp2();
  xp2();
  bp2();
  hp2();
  up2();
  dp2();
  pp2();
  np2();
  H0();
  ((TG = IA(KA(), 1)),
    (Ge5 = {
      step: "check-gh",
      selectedRepoName: "",
      currentRepo: "",
      useCurrentRepo: !1,
      apiKeyOrOAuthToken: "",
      useExistingKey: !0,
      currentWorkflowInstallStep: 0,
      warnings: [],
      secretExists: !1,
      secretName: "ANTHROPIC_API_KEY",
      useExistingSecret: !0,
      workflowExists: !1,
      selectedWorkflows: ["claude", "claude-review"],
      selectedApiKeyOption: "new",
      authType: "api_key",
    }));
  ((Ye5 = {
    type: "local-jsx",
    name: "install-github-app",
    description: "Set up Claude GitHub Actions for a repository",
    isEnabled: () => !process.env.DISABLE_INSTALL_GITHUB_APP_COMMAND && !mc(),
    isHidden: !1,
    async call(A) {
      return TG.default.createElement(Ze5, { onDone: A });
    },
    userFacingName() {
      return "install-github-app";
    },
  }),
    (ap2 = Ye5));
});
function O7A({ onPress: A }) {
  return (
    h1((B, Q) => {
      if (Q.return) A();
      else if (Q.escape) D8(1);
    }),
    tQ.default.createElement(
      U,
      null,
      "Press ",
      tQ.default.createElement(U, { bold: !0 }, "Enter"),
      " to continue or ",
      tQ.default.createElement(U, { bold: !0 }, "Esc"),
      " to exit",
    )
  );
}
function R7A() {
  let [A, B] = tQ.useState("intro"),
    [Q, I] = tQ.useState(""),
    [G, Z] = tQ.useState("");
  if (
    (IB(() => {
      (Ic("canceled", "user_exit"), D8(1));
    }),
    tQ.useEffect(() => {
      Ic("start");
    }, []),
    tQ.useEffect(() => {
      let Y = async () => {
          try {
            if (!Zi1())
              (I("Local package creation failed"),
                B("error"),
                Ic("failure", "environement_setup"));
            switch (await lr()) {
              case "success": {
                (B("success"), Ic("success"));
                break;
              }
              case "in_progress":
                (I("Update already in progress"),
                  B("error"),
                  Ic("failure", "in_progress"));
                break;
              case "install_failed":
                (I(
                  `Install of ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.PACKAGE_URL} failed`,
                ),
                  B("error"),
                  Ic("failure", "other_failure"));
                break;
            }
          } catch (W) {
            (I(String(W)), B("error"), Ic("failure", "unexpected_error"));
          }
        },
        J = async () => {
          try {
            let W = await N02();
            (Z(W), B("setup"));
          } catch (W) {
            (I(String(W)), B("error"));
          }
        },
        X = async () => {
          try {
            if (await L02()) B("uninstall-success");
            else B("uninstall-failed");
          } catch (W) {
            (I(String(W)), B("uninstall-failed"));
          }
        };
      switch (A) {
        case "installing":
          Y();
          break;
        case "setup-alias":
          J();
          break;
        case "uninstall":
          X();
          break;
        default:
          break;
      }
    }, [A]),
    A === "intro")
  )
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(U, { bold: !0 }, "Claude Code Local Installer"),
      tQ.default.createElement(
        S,
        { flexDirection: "column" },
        tQ.default.createElement(
          U,
          { dimColor: !0 },
          "This will install Claude Code to ~/.claude/local",
        ),
        tQ.default.createElement(
          U,
          { dimColor: !0 },
          "instead of using a global npm installation.",
        ),
      ),
      tQ.default.createElement(O7A, { onPress: () => B("installing") }),
    );
  if (A === "installing")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0 },
        "Installing Claude Code locally...",
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(E8, null),
        tQ.default.createElement(U, null, " Installing to ", Ac),
      ),
    );
  if (A === "success")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0, color: "success" },
        " Local installation successful!",
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(
          U,
          null,
          "Next, let's add an alias for `claude`",
        ),
      ),
      tQ.default.createElement(O7A, { onPress: () => B("setup-alias") }),
    );
  if (A === "setup-alias")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0 },
        "Setting up alias for claude...",
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(E8, null),
        tQ.default.createElement(U, null, " Configuring shell environment"),
      ),
    );
  if (A === "setup")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(U, { bold: !0 }, "Alias setup complete"),
      tQ.default.createElement(
        S,
        { flexDirection: "column", marginY: 1 },
        tQ.default.createElement(U, null, G),
        tQ.default.createElement(
          S,
          { marginY: 1 },
          tQ.default.createElement(
            U,
            null,
            "Next, we'll remove the globally installed npm package",
          ),
        ),
      ),
      tQ.default.createElement(O7A, { onPress: () => B("uninstall") }),
    );
  if (A === "uninstall")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0 },
        "Uninstalling global Claude Code...",
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(E8, null),
        tQ.default.createElement(U, null, " Removing global npm installation"),
      ),
    );
  if (A === "uninstall-success")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0, color: "success" },
        " Global installation removed successfully!",
      ),
      tQ.default.createElement(
        S,
        { flexDirection: "column", marginY: 1 },
        tQ.default.createElement(
          U,
          null,
          "Claude Code is now installed locally.",
        ),
        tQ.default.createElement(
          U,
          null,
          "Please restart your shell, then run",
          " ",
          tQ.default.createElement(U, { color: "claude" }, iA.bold("claude")),
          ".",
        ),
        tQ.default.createElement(
          S,
          { flexDirection: "row", marginY: 1 },
          tQ.default.createElement(E8, null),
          tQ.default.createElement(U, null, " Happy Clauding!"),
        ),
      ),
      tQ.default.createElement(O7A, { onPress: () => D8(0) }),
    );
  if (A === "uninstall-failed")
    return tQ.default.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      tQ.default.createElement(
        U,
        { bold: !0, color: "warning" },
        "! Could not remove global installation",
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(
          U,
          null,
          "The local installation is installed, but we couldn't remove the global npm package automatically.",
        ),
      ),
      tQ.default.createElement(
        S,
        { marginY: 1 },
        tQ.default.createElement(
          U,
          null,
          "You can remove it manually later with:",
          `
`,
          iA.bold(
            `npm uninstall -g --force ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.PACKAGE_URL}`,
          ),
        ),
      ),
      tQ.default.createElement(O7A, { onPress: () => D8(0) }),
    );
  return tQ.default.createElement(
    S,
    { flexDirection: "column", marginY: 1 },
    tQ.default.createElement(
      U,
      { bold: !0, color: "error" },
      " Installation failed",
    ),
    tQ.default.createElement(
      S,
      { marginY: 1 },
      tQ.default.createElement(
        U,
        null,
        Q || "An unexpected error occurred during installation.",
      ),
    ),
    tQ.default.createElement(O7A, { onPress: () => D8(1) }),
  );
}
var tQ;
var DB1 = T(() => {
  nA();
  f2();
  xX();
  R9();
  WR();
  xY();
  tQ = IA(KA(), 1);
});
var rp2, Je5, op2;
var tp2 = T(() => {
  nA();
  DB1();
  WR();
  ((rp2 = IA(KA(), 1)),
    (Je5 = {
      type: "local",
      name: "migrate-installer",
      description: "Migrate from global npm installation to local installation",
      isEnabled: () =>
        !process.env.DISABLE_MIGRATE_INSTALLER_COMMAND && !Bc() && !QX(),
      isHidden: !1,
      supportsNonInteractive: !1,
      async call() {
        let { waitUntilExit: A } = await I5(
          rp2.default.createElement(R7A, null),
        );
        return (await A(), { type: "text", value: "" });
      },
      userFacingName() {
        return "migrate-installer";
      },
    }),
    (op2 = Je5));
});
var b10 = z((Ve5) => {
  function ep2() {
    var A = {};
    return (
      (A["align-content"] = !1),
      (A["align-items"] = !1),
      (A["align-self"] = !1),
      (A["alignment-adjust"] = !1),
      (A["alignment-baseline"] = !1),
      (A.all = !1),
      (A["anchor-point"] = !1),
      (A.animation = !1),
      (A["animation-delay"] = !1),
      (A["animation-direction"] = !1),
      (A["animation-duration"] = !1),
      (A["animation-fill-mode"] = !1),
      (A["animation-iteration-count"] = !1),
      (A["animation-name"] = !1),
      (A["animation-play-state"] = !1),
      (A["animation-timing-function"] = !1),
      (A.azimuth = !1),
      (A["backface-visibility"] = !1),
      (A.background = !0),
      (A["background-attachment"] = !0),
      (A["background-clip"] = !0),
      (A["background-color"] = !0),
      (A["background-image"] = !0),
      (A["background-origin"] = !0),
      (A["background-position"] = !0),
      (A["background-repeat"] = !0),
      (A["background-size"] = !0),
      (A["baseline-shift"] = !1),
      (A.binding = !1),
      (A.bleed = !1),
      (A["bookmark-label"] = !1),
      (A["bookmark-level"] = !1),
      (A["bookmark-state"] = !1),
      (A.border = !0),
      (A["border-bottom"] = !0),
      (A["border-bottom-color"] = !0),
      (A["border-bottom-left-radius"] = !0),
      (A["border-bottom-right-radius"] = !0),
      (A["border-bottom-style"] = !0),
      (A["border-bottom-width"] = !0),
      (A["border-collapse"] = !0),
      (A["border-color"] = !0),
      (A["border-image"] = !0),
      (A["border-image-outset"] = !0),
      (A["border-image-repeat"] = !0),
      (A["border-image-slice"] = !0),
      (A["border-image-source"] = !0),
      (A["border-image-width"] = !0),
      (A["border-left"] = !0),
      (A["border-left-color"] = !0),
      (A["border-left-style"] = !0),
      (A["border-left-width"] = !0),
      (A["border-radius"] = !0),
      (A["border-right"] = !0),
      (A["border-right-color"] = !0),
      (A["border-right-style"] = !0),
      (A["border-right-width"] = !0),
      (A["border-spacing"] = !0),
      (A["border-style"] = !0),
      (A["border-top"] = !0),
      (A["border-top-color"] = !0),
      (A["border-top-left-radius"] = !0),
      (A["border-top-right-radius"] = !0),
      (A["border-top-style"] = !0),
      (A["border-top-width"] = !0),
      (A["border-width"] = !0),
      (A.bottom = !1),
      (A["box-decoration-break"] = !0),
      (A["box-shadow"] = !0),
      (A["box-sizing"] = !0),
      (A["box-snap"] = !0),
      (A["box-suppress"] = !0),
      (A["break-after"] = !0),
      (A["break-before"] = !0),
      (A["break-inside"] = !0),
      (A["caption-side"] = !1),
      (A.chains = !1),
      (A.clear = !0),
      (A.clip = !1),
      (A["clip-path"] = !1),
      (A["clip-rule"] = !1),
      (A.color = !0),
      (A["color-interpolation-filters"] = !0),
      (A["column-count"] = !1),
      (A["column-fill"] = !1),
      (A["column-gap"] = !1),
      (A["column-rule"] = !1),
      (A["column-rule-color"] = !1),
      (A["column-rule-style"] = !1),
      (A["column-rule-width"] = !1),
      (A["column-span"] = !1),
      (A["column-width"] = !1),
      (A.columns = !1),
      (A.contain = !1),
      (A.content = !1),
      (A["counter-increment"] = !1),
      (A["counter-reset"] = !1),
      (A["counter-set"] = !1),
      (A.crop = !1),
      (A.cue = !1),
      (A["cue-after"] = !1),
      (A["cue-before"] = !1),
      (A.cursor = !1),
      (A.direction = !1),
      (A.display = !0),
      (A["display-inside"] = !0),
      (A["display-list"] = !0),
      (A["display-outside"] = !0),
      (A["dominant-baseline"] = !1),
      (A.elevation = !1),
      (A["empty-cells"] = !1),
      (A.filter = !1),
      (A.flex = !1),
      (A["flex-basis"] = !1),
      (A["flex-direction"] = !1),
      (A["flex-flow"] = !1),
      (A["flex-grow"] = !1),
      (A["flex-shrink"] = !1),
      (A["flex-wrap"] = !1),
      (A.float = !1),
      (A["float-offset"] = !1),
      (A["flood-color"] = !1),
      (A["flood-opacity"] = !1),
      (A["flow-from"] = !1),
      (A["flow-into"] = !1),
      (A.font = !0),
      (A["font-family"] = !0),
      (A["font-feature-settings"] = !0),
      (A["font-kerning"] = !0),
      (A["font-language-override"] = !0),
      (A["font-size"] = !0),
      (A["font-size-adjust"] = !0),
      (A["font-stretch"] = !0),
      (A["font-style"] = !0),
      (A["font-synthesis"] = !0),
      (A["font-variant"] = !0),
      (A["font-variant-alternates"] = !0),
      (A["font-variant-caps"] = !0),
      (A["font-variant-east-asian"] = !0),
      (A["font-variant-ligatures"] = !0),
      (A["font-variant-numeric"] = !0),
      (A["font-variant-position"] = !0),
      (A["font-weight"] = !0),
      (A.grid = !1),
      (A["grid-area"] = !1),
      (A["grid-auto-columns"] = !1),
      (A["grid-auto-flow"] = !1),
      (A["grid-auto-rows"] = !1),
      (A["grid-column"] = !1),
      (A["grid-column-end"] = !1),
      (A["grid-column-start"] = !1),
      (A["grid-row"] = !1),
      (A["grid-row-end"] = !1),
      (A["grid-row-start"] = !1),
      (A["grid-template"] = !1),
      (A["grid-template-areas"] = !1),
      (A["grid-template-columns"] = !1),
      (A["grid-template-rows"] = !1),
      (A["hanging-punctuation"] = !1),
      (A.height = !0),
      (A.hyphens = !1),
      (A.icon = !1),
      (A["image-orientation"] = !1),
      (A["image-resolution"] = !1),
      (A["ime-mode"] = !1),
      (A["initial-letters"] = !1),
      (A["inline-box-align"] = !1),
      (A["justify-content"] = !1),
      (A["justify-items"] = !1),
      (A["justify-self"] = !1),
      (A.left = !1),
      (A["letter-spacing"] = !0),
      (A["lighting-color"] = !0),
      (A["line-box-contain"] = !1),
      (A["line-break"] = !1),
      (A["line-grid"] = !1),
      (A["line-height"] = !1),
      (A["line-snap"] = !1),
      (A["line-stacking"] = !1),
      (A["line-stacking-ruby"] = !1),
      (A["line-stacking-shift"] = !1),
      (A["line-stacking-strategy"] = !1),
      (A["list-style"] = !0),
      (A["list-style-image"] = !0),
      (A["list-style-position"] = !0),
      (A["list-style-type"] = !0),
      (A.margin = !0),
      (A["margin-bottom"] = !0),
      (A["margin-left"] = !0),
      (A["margin-right"] = !0),
      (A["margin-top"] = !0),
      (A["marker-offset"] = !1),
      (A["marker-side"] = !1),
      (A.marks = !1),
      (A.mask = !1),
      (A["mask-box"] = !1),
      (A["mask-box-outset"] = !1),
      (A["mask-box-repeat"] = !1),
      (A["mask-box-slice"] = !1),
      (A["mask-box-source"] = !1),
      (A["mask-box-width"] = !1),
      (A["mask-clip"] = !1),
      (A["mask-image"] = !1),
      (A["mask-origin"] = !1),
      (A["mask-position"] = !1),
      (A["mask-repeat"] = !1),
      (A["mask-size"] = !1),
      (A["mask-source-type"] = !1),
      (A["mask-type"] = !1),
      (A["max-height"] = !0),
      (A["max-lines"] = !1),
      (A["max-width"] = !0),
      (A["min-height"] = !0),
      (A["min-width"] = !0),
      (A["move-to"] = !1),
      (A["nav-down"] = !1),
      (A["nav-index"] = !1),
      (A["nav-left"] = !1),
      (A["nav-right"] = !1),
      (A["nav-up"] = !1),
      (A["object-fit"] = !1),
      (A["object-position"] = !1),
      (A.opacity = !1),
      (A.order = !1),
      (A.orphans = !1),
      (A.outline = !1),
      (A["outline-color"] = !1),
      (A["outline-offset"] = !1),
      (A["outline-style"] = !1),
      (A["outline-width"] = !1),
      (A.overflow = !1),
      (A["overflow-wrap"] = !1),
      (A["overflow-x"] = !1),
      (A["overflow-y"] = !1),
      (A.padding = !0),
      (A["padding-bottom"] = !0),
      (A["padding-left"] = !0),
      (A["padding-right"] = !0),
      (A["padding-top"] = !0),
      (A.page = !1),
      (A["page-break-after"] = !1),
      (A["page-break-before"] = !1),
      (A["page-break-inside"] = !1),
      (A["page-policy"] = !1),
      (A.pause = !1),
      (A["pause-after"] = !1),
      (A["pause-before"] = !1),
      (A.perspective = !1),
      (A["perspective-origin"] = !1),
      (A.pitch = !1),
      (A["pitch-range"] = !1),
      (A["play-during"] = !1),
      (A.position = !1),
      (A["presentation-level"] = !1),
      (A.quotes = !1),
      (A["region-fragment"] = !1),
      (A.resize = !1),
      (A.rest = !1),
      (A["rest-after"] = !1),
      (A["rest-before"] = !1),
      (A.richness = !1),
      (A.right = !1),
      (A.rotation = !1),
      (A["rotation-point"] = !1),
      (A["ruby-align"] = !1),
      (A["ruby-merge"] = !1),
      (A["ruby-position"] = !1),
      (A["shape-image-threshold"] = !1),
      (A["shape-outside"] = !1),
      (A["shape-margin"] = !1),
      (A.size = !1),
      (A.speak = !1),
      (A["speak-as"] = !1),
      (A["speak-header"] = !1),
      (A["speak-numeral"] = !1),
      (A["speak-punctuation"] = !1),
      (A["speech-rate"] = !1),
      (A.stress = !1),
      (A["string-set"] = !1),
      (A["tab-size"] = !1),
      (A["table-layout"] = !1),
      (A["text-align"] = !0),
      (A["text-align-last"] = !0),
      (A["text-combine-upright"] = !0),
      (A["text-decoration"] = !0),
      (A["text-decoration-color"] = !0),
      (A["text-decoration-line"] = !0),
      (A["text-decoration-skip"] = !0),
      (A["text-decoration-style"] = !0),
      (A["text-emphasis"] = !0),
      (A["text-emphasis-color"] = !0),
      (A["text-emphasis-position"] = !0),
      (A["text-emphasis-style"] = !0),
      (A["text-height"] = !0),
      (A["text-indent"] = !0),
      (A["text-justify"] = !0),
      (A["text-orientation"] = !0),
      (A["text-overflow"] = !0),
      (A["text-shadow"] = !0),
      (A["text-space-collapse"] = !0),
      (A["text-transform"] = !0),
      (A["text-underline-position"] = !0),
      (A["text-wrap"] = !0),
      (A.top = !1),
      (A.transform = !1),
      (A["transform-origin"] = !1),
      (A["transform-style"] = !1),
      (A.transition = !1),
      (A["transition-delay"] = !1),
      (A["transition-duration"] = !1),
      (A["transition-property"] = !1),
      (A["transition-timing-function"] = !1),
      (A["unicode-bidi"] = !1),
      (A["vertical-align"] = !1),
      (A.visibility = !1),
      (A["voice-balance"] = !1),
      (A["voice-duration"] = !1),
      (A["voice-family"] = !1),
      (A["voice-pitch"] = !1),
      (A["voice-range"] = !1),
      (A["voice-rate"] = !1),
      (A["voice-stress"] = !1),
      (A["voice-volume"] = !1),
      (A.volume = !1),
      (A["white-space"] = !1),
      (A.widows = !1),
      (A.width = !0),
      (A["will-change"] = !1),
      (A["word-break"] = !0),
      (A["word-spacing"] = !0),
      (A["word-wrap"] = !0),
      (A["wrap-flow"] = !1),
      (A["wrap-through"] = !1),
      (A["writing-mode"] = !1),
      (A["z-index"] = !1),
      A
    );
  }
  function Xe5(A, B, Q) {}
  function We5(A, B, Q) {}
  var Fe5 = /javascript\s*\:/gim;
  function Ce5(A, B) {
    if (Fe5.test(B)) return "";
    return B;
  }
  Ve5.whiteList = ep2();
  Ve5.getDefaultWhiteList = ep2;
  Ve5.onAttr = Xe5;
  Ve5.onIgnoreAttr = We5;
  Ve5.safeAttrValue = Ce5;
});
var f10 = z((A1G, Al2) => {
  Al2.exports = {
    indexOf: function (A, B) {
      var Q, I;
      if (Array.prototype.indexOf) return A.indexOf(B);
      for (Q = 0, I = A.length; Q < I; Q++) if (A[Q] === B) return Q;
      return -1;
    },
    forEach: function (A, B, Q) {
      var I, G;
      if (Array.prototype.forEach) return A.forEach(B, Q);
      for (I = 0, G = A.length; I < G; I++) B.call(Q, A[I], I, A);
    },
    trim: function (A) {
      if (String.prototype.trim) return A.trim();
      return A.replace(/(^\s*)|(\s*$)/g, "");
    },
    trimRight: function (A) {
      if (String.prototype.trimRight) return A.trimRight();
      return A.replace(/(\s*$)/g, "");
    },
  };
});
var Ql2 = z((B1G, Bl2) => {
  var T$A = f10();
  function Ue5(A, B) {
    if (((A = T$A.trimRight(A)), A[A.length - 1] !== ";")) A += ";";
    var Q = A.length,
      I = !1,
      G = 0,
      Z = 0,
      Y = "";
    function J() {
      if (!I) {
        var F = T$A.trim(A.slice(G, Z)),
          C = F.indexOf(":");
        if (C !== -1) {
          var V = T$A.trim(F.slice(0, C)),
            K = T$A.trim(F.slice(C + 1));
          if (V) {
            var D = B(G, Y.length, V, K, F);
            if (D) Y += D + "; ";
          }
        }
      }
      G = Z + 1;
    }
    for (; Z < Q; Z++) {
      var X = A[Z];
      if (X === "/" && A[Z + 1] === "*") {
        var W = A.indexOf("*/", Z + 2);
        if (W === -1) break;
        ((Z = W + 1), (G = Z + 1), (I = !1));
      } else if (X === "(") I = !0;
      else if (X === ")") I = !1;
      else if (X === ";")
        if (I);
        else J();
      else if (
        X ===
        `
`
      )
        J();
    }
    return T$A.trim(Y);
  }
  Bl2.exports = Ue5;
});
var Yl2 = z((I1G, Zl2) => {
  var EB1 = b10(),
    we5 = Ql2(),
    Q1G = f10();
  function Il2(A) {
    return A === void 0 || A === null;
  }
  function $e5(A) {
    var B = {};
    for (var Q in A) B[Q] = A[Q];
    return B;
  }
  function Gl2(A) {
    ((A = $e5(A || {})),
      (A.whiteList = A.whiteList || EB1.whiteList),
      (A.onAttr = A.onAttr || EB1.onAttr),
      (A.onIgnoreAttr = A.onIgnoreAttr || EB1.onIgnoreAttr),
      (A.safeAttrValue = A.safeAttrValue || EB1.safeAttrValue),
      (this.options = A));
  }
  Gl2.prototype.process = function (A) {
    if (((A = A || ""), (A = A.toString()), !A)) return "";
    var B = this,
      Q = B.options,
      I = Q.whiteList,
      G = Q.onAttr,
      Z = Q.onIgnoreAttr,
      Y = Q.safeAttrValue,
      J = we5(A, function (X, W, F, C, V) {
        var K = I[F],
          D = !1;
        if (K === !0) D = K;
        else if (typeof K === "function") D = K(C);
        else if (K instanceof RegExp) D = K.test(C);
        if (D !== !0) D = !1;
        if (((C = Y(F, C)), !C)) return;
        var E = { position: W, sourcePosition: X, source: V, isWhite: D };
        if (D) {
          var H = G(F, C, E);
          if (Il2(H)) return F + ":" + C;
          else return H;
        } else {
          var H = Z(F, C, E);
          if (!Il2(H)) return H;
        }
      });
    return J;
  };
  Zl2.exports = Gl2;
});
var UB1 = z((zB1, h10) => {
  var Jl2 = b10(),
    Xl2 = Yl2();
  function qe5(A, B) {
    var Q = new Xl2(B);
    return Q.process(A);
  }
  zB1 = h10.exports = qe5;
  zB1.FilterCSS = Xl2;
  for (HB1 in Jl2) zB1[HB1] = Jl2[HB1];
  var HB1;
  if (typeof window < "u") window.filterCSS = h10.exports;
});
var wB1 = z((G1G, Wl2) => {
  Wl2.exports = {
    indexOf: function (A, B) {
      var Q, I;
      if (Array.prototype.indexOf) return A.indexOf(B);
      for (Q = 0, I = A.length; Q < I; Q++) if (A[Q] === B) return Q;
      return -1;
    },
    forEach: function (A, B, Q) {
      var I, G;
      if (Array.prototype.forEach) return A.forEach(B, Q);
      for (I = 0, G = A.length; I < G; I++) B.call(Q, A[I], I, A);
    },
    trim: function (A) {
      if (String.prototype.trim) return A.trim();
      return A.replace(/(^\s*)|(\s*$)/g, "");
    },
    spaceIndex: function (A) {
      var B = /\s|\n|\t/,
        Q = B.exec(A);
      return Q ? Q.index : -1;
    },
  };
});
var g10 = z((ue5) => {
  var Ne5 = UB1().FilterCSS,
    Le5 = UB1().getDefaultWhiteList,
    qB1 = wB1();
  function Vl2() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src",
      ],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height", "loading"],
      ins: ["datetime"],
      kbd: [],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "height",
        "width",
      ],
    };
  }
  var Kl2 = new Ne5();
  function Me5(A, B, Q) {}
  function Oe5(A, B, Q) {}
  function Re5(A, B, Q) {}
  function Te5(A, B, Q) {}
  function Dl2(A) {
    return A.replace(je5, "&lt;").replace(Se5, "&gt;");
  }
  function Pe5(A, B, Q, I) {
    if (((Q = $l2(Q)), B === "href" || B === "src")) {
      if (((Q = qB1.trim(Q)), Q === "#")) return "#";
      if (
        !(
          Q.substr(0, 7) === "http://" ||
          Q.substr(0, 8) === "https://" ||
          Q.substr(0, 7) === "mailto:" ||
          Q.substr(0, 4) === "tel:" ||
          Q.substr(0, 11) === "data:image/" ||
          Q.substr(0, 6) === "ftp://" ||
          Q.substr(0, 2) === "./" ||
          Q.substr(0, 3) === "../" ||
          Q[0] === "#" ||
          Q[0] === "/"
        )
      )
        return "";
    } else if (B === "background") {
      if ((($B1.lastIndex = 0), $B1.test(Q))) return "";
    } else if (B === "style") {
      if (((Fl2.lastIndex = 0), Fl2.test(Q))) return "";
      if (((Cl2.lastIndex = 0), Cl2.test(Q))) {
        if ((($B1.lastIndex = 0), $B1.test(Q))) return "";
      }
      if (I !== !1) ((I = I || Kl2), (Q = I.process(Q)));
    }
    return ((Q = ql2(Q)), Q);
  }
  var je5 = /</g,
    Se5 = />/g,
    ye5 = /"/g,
    ke5 = /&quot;/g,
    _e5 = /&#([a-zA-Z0-9]*);?/gim,
    xe5 = /&colon;?/gim,
    ve5 = /&newline;?/gim,
    $B1 =
      /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi,
    Fl2 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,
    Cl2 = /u\s*r\s*l\s*\(.*/gi;
  function El2(A) {
    return A.replace(ye5, "&quot;");
  }
  function Hl2(A) {
    return A.replace(ke5, '"');
  }
  function zl2(A) {
    return A.replace(_e5, function (Q, I) {
      return I[0] === "x" || I[0] === "X"
        ? String.fromCharCode(parseInt(I.substr(1), 16))
        : String.fromCharCode(parseInt(I, 10));
    });
  }
  function Ul2(A) {
    return A.replace(xe5, ":").replace(ve5, " ");
  }
  function wl2(A) {
    var B = "";
    for (var Q = 0, I = A.length; Q < I; Q++)
      B += A.charCodeAt(Q) < 32 ? " " : A.charAt(Q);
    return qB1.trim(B);
  }
  function $l2(A) {
    return ((A = Hl2(A)), (A = zl2(A)), (A = Ul2(A)), (A = wl2(A)), A);
  }
  function ql2(A) {
    return ((A = El2(A)), (A = Dl2(A)), A);
  }
  function be5() {
    return "";
  }
  function fe5(A, B) {
    if (typeof B !== "function") B = function () {};
    var Q = !Array.isArray(A);
    function I(Y) {
      if (Q) return !0;
      return qB1.indexOf(A, Y) !== -1;
    }
    var G = [],
      Z = !1;
    return {
      onIgnoreTag: function (Y, J, X) {
        if (I(Y))
          if (X.isClosing) {
            var W = "[/removed]",
              F = X.position + W.length;
            return (G.push([Z !== !1 ? Z : X.position, F]), (Z = !1), W);
          } else {
            if (!Z) Z = X.position;
            return "[removed]";
          }
        else return B(Y, J, X);
      },
      remove: function (Y) {
        var J = "",
          X = 0;
        return (
          qB1.forEach(G, function (W) {
            ((J += Y.slice(X, W[0])), (X = W[1]));
          }),
          (J += Y.slice(X)),
          J
        );
      },
    };
  }
  function he5(A) {
    var B = "",
      Q = 0;
    while (Q < A.length) {
      var I = A.indexOf("<!--", Q);
      if (I === -1) {
        B += A.slice(Q);
        break;
      }
      B += A.slice(Q, I);
      var G = A.indexOf("-->", I);
      if (G === -1) break;
      Q = G + 3;
    }
    return B;
  }
  function ge5(A) {
    var B = A.split("");
    return (
      (B = B.filter(function (Q) {
        var I = Q.charCodeAt(0);
        if (I === 127) return !1;
        if (I <= 31) {
          if (I === 10 || I === 13) return !0;
          return !1;
        }
        return !0;
      })),
      B.join("")
    );
  }
  ue5.whiteList = Vl2();
  ue5.getDefaultWhiteList = Vl2;
  ue5.onTag = Me5;
  ue5.onIgnoreTag = Oe5;
  ue5.onTagAttr = Re5;
  ue5.onIgnoreTagAttr = Te5;
  ue5.safeAttrValue = Pe5;
  ue5.escapeHtml = Dl2;
  ue5.escapeQuote = El2;
  ue5.unescapeQuote = Hl2;
  ue5.escapeHtmlEntities = zl2;
  ue5.escapeDangerHtml5Entities = Ul2;
  ue5.clearNonPrintableCharacter = wl2;
  ue5.friendlyAttrValue = $l2;
  ue5.escapeAttrValue = ql2;
  ue5.onIgnoreTagStripAll = be5;
  ue5.StripTagBody = fe5;
  ue5.stripCommentTag = he5;
  ue5.stripBlankChar = ge5;
  ue5.attributeWrapSign = '"';
  ue5.cssFilter = Kl2;
  ue5.getDefaultCSSWhiteList = Le5;
});
var u10 = z((UAI) => {
  var Qp = wB1();
  function WAI(A) {
    var B = Qp.spaceIndex(A),
      Q;
    if (B === -1) Q = A.slice(1, -1);
    else Q = A.slice(1, B + 1);
    if (((Q = Qp.trim(Q).toLowerCase()), Q.slice(0, 1) === "/")) Q = Q.slice(1);
    if (Q.slice(-1) === "/") Q = Q.slice(0, -1);
    return Q;
  }
  function FAI(A) {
    return A.slice(0, 2) === "</";
  }
  function CAI(A, B, Q) {
    var I = "",
      G = 0,
      Z = !1,
      Y = !1,
      J = 0,
      X = A.length,
      W = "",
      F = "";
    A: for (J = 0; J < X; J++) {
      var C = A.charAt(J);
      if (Z === !1) {
        if (C === "<") {
          Z = J;
          continue;
        }
      } else if (Y === !1) {
        if (C === "<") {
          ((I += Q(A.slice(G, J))), (Z = J), (G = J));
          continue;
        }
        if (C === ">" || J === X - 1) {
          ((I += Q(A.slice(G, Z))),
            (F = A.slice(Z, J + 1)),
            (W = WAI(F)),
            (I += B(Z, I.length, W, F, FAI(F))),
            (G = J + 1),
            (Z = !1));
          continue;
        }
        if (C === '"' || C === "'") {
          var V = 1,
            K = A.charAt(J - V);
          while (K.trim() === "" || K === "=") {
            if (K === "=") {
              Y = C;
              continue A;
            }
            K = A.charAt(J - ++V);
          }
        }
      } else if (C === Y) {
        Y = !1;
        continue;
      }
    }
    if (G < X) I += Q(A.substr(G));
    return I;
  }
  var VAI = /[^a-zA-Z0-9\\_:.-]/gim;
  function KAI(A, B) {
    var Q = 0,
      I = 0,
      G = [],
      Z = !1,
      Y = A.length;
    function J(V, K) {
      if (
        ((V = Qp.trim(V)), (V = V.replace(VAI, "").toLowerCase()), V.length < 1)
      )
        return;
      var D = B(V, K || "");
      if (D) G.push(D);
    }
    for (var X = 0; X < Y; X++) {
      var W = A.charAt(X),
        F,
        C;
      if (Z === !1 && W === "=") {
        ((Z = A.slice(Q, X)),
          (Q = X + 1),
          (I = A.charAt(Q) === '"' || A.charAt(Q) === "'" ? Q : EAI(A, X + 1)));
        continue;
      }
      if (Z !== !1) {
        if (X === I)
          if (((C = A.indexOf(W, X + 1)), C === -1)) break;
          else {
            ((F = Qp.trim(A.slice(I + 1, C))),
              J(Z, F),
              (Z = !1),
              (X = C),
              (Q = X + 1));
            continue;
          }
      }
      if (/\s|\n|\t/.test(W))
        if (((A = A.replace(/\s|\n|\t/g, " ")), Z === !1))
          if (((C = DAI(A, X)), C === -1)) {
            ((F = Qp.trim(A.slice(Q, X))), J(F), (Z = !1), (Q = X + 1));
            continue;
          } else {
            X = C - 1;
            continue;
          }
        else if (((C = HAI(A, X - 1)), C === -1)) {
          ((F = Qp.trim(A.slice(Q, X))),
            (F = Nl2(F)),
            J(Z, F),
            (Z = !1),
            (Q = X + 1));
          continue;
        } else continue;
    }
    if (Q < A.length)
      if (Z === !1) J(A.slice(Q));
      else J(Z, Nl2(Qp.trim(A.slice(Q))));
    return Qp.trim(G.join(" "));
  }
  function DAI(A, B) {
    for (; B < A.length; B++) {
      var Q = A[B];
      if (Q === " ") continue;
      if (Q === "=") return B;
      return -1;
    }
  }
  function EAI(A, B) {
    for (; B < A.length; B++) {
      var Q = A[B];
      if (Q === " ") continue;
      if (Q === "'" || Q === '"') return B;
      return -1;
    }
  }
  function HAI(A, B) {
    for (; B > 0; B--) {
      var Q = A[B];
      if (Q === " ") continue;
      if (Q === "=") return B;
      return -1;
    }
  }
  function zAI(A) {
    if (
      (A[0] === '"' && A[A.length - 1] === '"') ||
      (A[0] === "'" && A[A.length - 1] === "'")
    )
      return !0;
    else return !1;
  }
  function Nl2(A) {
    if (zAI(A)) return A.substr(1, A.length - 2);
    else return A;
  }
  UAI.parseTag = CAI;
  UAI.parseAttr = KAI;
});
var Rl2 = z((J1G, Ol2) => {
  var qAI = UB1().FilterCSS,
    HL = g10(),
    Ll2 = u10(),
    NAI = Ll2.parseTag,
    LAI = Ll2.parseAttr,
    LB1 = wB1();
  function NB1(A) {
    return A === void 0 || A === null;
  }
  function MAI(A) {
    var B = LB1.spaceIndex(A);
    if (B === -1) return { html: "", closing: A[A.length - 2] === "/" };
    A = LB1.trim(A.slice(B + 1, -1));
    var Q = A[A.length - 1] === "/";
    if (Q) A = LB1.trim(A.slice(0, -1));
    return { html: A, closing: Q };
  }
  function OAI(A) {
    var B = {};
    for (var Q in A) B[Q] = A[Q];
    return B;
  }
  function RAI(A) {
    var B = {};
    for (var Q in A)
      if (Array.isArray(A[Q]))
        B[Q.toLowerCase()] = A[Q].map(function (I) {
          return I.toLowerCase();
        });
      else B[Q.toLowerCase()] = A[Q];
    return B;
  }
  function Ml2(A) {
    if (((A = OAI(A || {})), A.stripIgnoreTag)) {
      if (A.onIgnoreTag)
        console.error(
          'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time',
        );
      A.onIgnoreTag = HL.onIgnoreTagStripAll;
    }
    if (A.whiteList || A.allowList)
      A.whiteList = RAI(A.whiteList || A.allowList);
    else A.whiteList = HL.whiteList;
    if (
      ((this.attributeWrapSign =
        A.singleQuotedAttributeValue === !0 ? "'" : HL.attributeWrapSign),
      (A.onTag = A.onTag || HL.onTag),
      (A.onTagAttr = A.onTagAttr || HL.onTagAttr),
      (A.onIgnoreTag = A.onIgnoreTag || HL.onIgnoreTag),
      (A.onIgnoreTagAttr = A.onIgnoreTagAttr || HL.onIgnoreTagAttr),
      (A.safeAttrValue = A.safeAttrValue || HL.safeAttrValue),
      (A.escapeHtml = A.escapeHtml || HL.escapeHtml),
      (this.options = A),
      A.css === !1)
    )
      this.cssFilter = !1;
    else ((A.css = A.css || {}), (this.cssFilter = new qAI(A.css)));
  }
  Ml2.prototype.process = function (A) {
    if (((A = A || ""), (A = A.toString()), !A)) return "";
    var B = this,
      Q = B.options,
      I = Q.whiteList,
      G = Q.onTag,
      Z = Q.onIgnoreTag,
      Y = Q.onTagAttr,
      J = Q.onIgnoreTagAttr,
      X = Q.safeAttrValue,
      W = Q.escapeHtml,
      F = B.attributeWrapSign,
      C = B.cssFilter;
    if (Q.stripBlankChar) A = HL.stripBlankChar(A);
    if (!Q.allowCommentTag) A = HL.stripCommentTag(A);
    var V = !1;
    if (Q.stripIgnoreTagBody)
      ((V = HL.StripTagBody(Q.stripIgnoreTagBody, Z)), (Z = V.onIgnoreTag));
    var K = NAI(
      A,
      function (D, E, H, w, L) {
        var N = {
            sourcePosition: D,
            position: E,
            isClosing: L,
            isWhite: Object.prototype.hasOwnProperty.call(I, H),
          },
          $ = G(H, w, N);
        if (!NB1($)) return $;
        if (N.isWhite) {
          if (N.isClosing) return "</" + H + ">";
          var O = MAI(w),
            P = I[H],
            k = LAI(O.html, function (b, x) {
              var n = LB1.indexOf(P, b) !== -1,
                m = Y(H, b, x, n);
              if (!NB1(m)) return m;
              if (n)
                if (((x = X(H, b, x, C)), x)) return b + "=" + F + x + F;
                else return b;
              else {
                if (((m = J(H, b, x, n)), !NB1(m))) return m;
                return;
              }
            });
          if (((w = "<" + H), k)) w += " " + k;
          if (O.closing) w += " /";
          return ((w += ">"), w);
        } else {
          if ((($ = Z(H, w, N)), !NB1($))) return $;
          return W(w);
        }
      },
      W,
    );
    if (V) K = V.remove(K);
    return K;
  };
  Ol2.exports = Ml2;
});
var yl2 = z((T7A, MB1) => {
  var Tl2 = g10(),
    Pl2 = u10(),
    jl2 = Rl2();
  function Sl2(A, B) {
    var Q = new jl2(B);
    return Q.process(A);
  }
  T7A = MB1.exports = Sl2;
  T7A.filterXSS = Sl2;
  T7A.FilterXSS = jl2;
  (function () {
    for (var A in Tl2) T7A[A] = Tl2[A];
    for (var B in Pl2) T7A[B] = Pl2[B];
  })();
  if (typeof window < "u") window.filterXSS = MB1.exports;
  function TAI() {
    return (
      typeof self < "u" &&
      typeof DedicatedWorkerGlobalScope < "u" &&
      self instanceof DedicatedWorkerGlobalScope
    );
  }
  if (TAI()) self.filterXSS = MB1.exports;
});
import { createServer as m10 } from "http";
import { parse as PAI } from "url";
import { createHash as jAI, randomBytes as SAI } from "crypto";
function _AI() {
  let A = parseInt(process.env.MCP_OAUTH_CALLBACK_PORT || "", 10);
  return A > 0 ? A : void 0;
}
async function xAI() {
  let A = _AI();
  if (A) return A;
  let { min: B, max: Q } = yAI,
    I = Q - B + 1,
    G = Math.min(I, 100);
  for (let Z = 0; Z < G; Z++) {
    let Y = B + Math.floor(Math.random() * I);
    try {
      return (
        await new Promise((J, X) => {
          let W = m10();
          (W.once("error", X),
            W.listen(Y, () => {
              W.close(() => J());
            }));
        }),
        Y
      );
    } catch {
      continue;
    }
  }
  try {
    return (
      await new Promise((Z, Y) => {
        let J = m10();
        (J.once("error", Y),
          J.listen(kl2, () => {
            J.close(() => Z());
          }));
      }),
      kl2
    );
  } catch {
    throw Error("No available ports for OAuth redirect");
  }
}
function Vt(A, B) {
  let Q = JSON.stringify({
      type: B.type,
      url: B.url,
      headers: B.headers || {},
    }),
    I = jAI("sha256").update(Q).digest("hex").substring(0, 16);
  return `${A}|${I}`;
}
async function c10(A, B) {
  let I = kw().read();
  if (!I?.mcpOAuth) return;
  let G = Vt(A, B),
    Z = I.mcpOAuth[G];
  if (!Z?.accessToken) {
    P0(A, "No tokens to revoke");
    return;
  }
  try {
    let Y = await HZA(B.url);
    if (!Y?.revocation_endpoint) {
      P0(A, "Server does not support token revocation");
      return;
    }
    P0(A, "Revoking tokens on server");
    let J = String(Y.revocation_endpoint);
    P0(A, `Revocation endpoint: ${J}`);
    let X = new URLSearchParams();
    if (
      (X.set("token", Z.accessToken),
      X.set("token_type_hint", "access_token"),
      Z.clientId)
    )
      X.set("client_id", Z.clientId);
    if (
      (await DB.post(J, X, {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${Z.accessToken}`,
        },
      }),
      P0(A, "Successfully revoked access token"),
      Z.refreshToken)
    ) {
      let W = new URLSearchParams();
      if (
        (W.set("token", Z.refreshToken),
        W.set("token_type_hint", "refresh_token"),
        Z.clientId)
      )
        W.set("client_id", Z.clientId);
      (await DB.post(J, W, {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${Z.accessToken}`,
        },
      }),
        P0(A, "Successfully revoked refresh token"));
    }
  } catch (Y) {
    if (DB.isAxiosError(Y) && Y.response)
      P0(
        A,
        `Failed to revoke tokens on server: ${Y.message}, Status: ${Y.response.status}, Data: ${JSON.stringify(Y.response.data)}`,
      );
    else P0(A, `Failed to revoke tokens on server: ${Y}`);
  }
  _l2(A, B);
}
function _l2(A, B) {
  let Q = kw(),
    I = Q.read();
  if (!I?.mcpOAuth) return;
  let G = Vt(A, B);
  if (I.mcpOAuth[G])
    (delete I.mcpOAuth[G], Q.update(I), P0(A, "Cleared stored tokens"));
}
async function xl2(A, B, Q, I) {
  (_l2(A, B), GA("tengu_mcp_oauth_flow_start", { isOAuthFlow: !0 }));
  let G = await xAI(),
    Z = `http://localhost:${G}/callback`;
  P0(A, `Using redirect port: ${G}`);
  let Y = new Kt(A, B, Z, !0);
  try {
    let K = await HZA(B.url);
    if (K)
      (Y.setMetadata(K),
        P0(
          A,
          `Fetched OAuth metadata with scope: ${K.scope || K.default_scope || K.scopes_supported?.join(" ") || "NONE"}`,
        ));
  } catch (K) {
    P0(
      A,
      `Failed to fetch OAuth metadata: ${K instanceof Error ? K.message : String(K)}`,
    );
  }
  let J,
    X = await Y.state(),
    W = null,
    F = null,
    C = () => {
      if (W) (W.close(), (W = null));
      if (F) (clearTimeout(F), (F = null));
      P0(A, "MCP OAuth server cleaned up");
    },
    V = await new Promise((K, D) => {
      if (I) {
        let E = () => {
          (C(), D(new OB1()));
        };
        if (I.aborted) {
          E();
          return;
        }
        I.addEventListener("abort", E);
      }
      ((W = m10((E, H) => {
        let w = PAI(E.url || "", !0);
        if (w.pathname === "/callback") {
          let L = w.query.code,
            N = w.query.state,
            $ = w.query.error,
            O = w.query.error_description,
            P = w.query.error_uri;
          if (!$ && N !== X) {
            (H.writeHead(400, { "Content-Type": "text/html" }),
              H.end(
                "<h1>Authentication Error</h1><p>Invalid state parameter. Please try again.</p><p>You can close this window.</p>",
              ),
              C(),
              D(Error("OAuth state mismatch - possible CSRF attack")));
            return;
          }
          if ($) {
            H.writeHead(200, { "Content-Type": "text/html" });
            let k = d10.default(String($)),
              b = O ? d10.default(String(O)) : "";
            (H.end(
              `<h1>Authentication Error</h1><p>${k}: ${b}</p><p>You can close this window.</p>`,
            ),
              C());
            let x = `OAuth error: ${$}`;
            if (O) x += ` - ${O}`;
            if (P) x += ` (See: ${P})`;
            D(Error(x));
            return;
          }
          if (L)
            (H.writeHead(200, { "Content-Type": "text/html" }),
              H.end(
                "<h1>Authentication Successful</h1><p>You can close this window. Return to Claude Code.</p>",
              ),
              C(),
              K(L));
        }
      })),
        W.listen(G, async () => {
          try {
            (P0(A, "Starting SDK auth"), P0(A, `Server URL: ${B.url}`));
            let E = await DM(Y, { serverUrl: B.url });
            if (
              (P0(A, `Initial auth result: ${E}`), (J = Y.authorizationUrl), J)
            )
              Q(J);
            if (E !== "REDIRECT")
              P0(A, `Unexpected auth result, expected REDIRECT: ${E}`);
          } catch (E) {
            (P0(A, `SDK auth error: ${E}`), C(), D(E));
          }
        }),
        (F = setTimeout(() => {
          (C(), D(Error("Authentication timeout")));
        }, 300000)));
    });
  try {
    P0(A, "Completing auth flow with authorization code");
    let K = await DM(Y, { serverUrl: B.url, authorizationCode: V });
    if ((P0(A, `Auth result: ${K}`), K === "AUTHORIZED")) {
      let D = await Y.tokens();
      if ((P0(A, `Tokens after auth: ${D ? "Present" : "Missing"}`), D))
        (P0(A, `Token access_token length: ${D.access_token?.length}`),
          P0(A, `Token expires_in: ${D.expires_in}`));
      GA("tengu_mcp_oauth_flow_success", {});
    } else throw Error("Unexpected auth result: " + K);
  } catch (K) {
    if ((P0(A, `Error during auth completion: ${K}`), DB.isAxiosError(K)))
      try {
        let D = DMA.parse(K.response?.data);
        if (
          D.error === "invalid_client" &&
          D.error_description?.includes("Client not found")
        ) {
          let E = kw(),
            H = E.read() || {},
            w = Vt(A, B);
          if (H.mcpOAuth?.[w])
            (delete H.mcpOAuth[w].clientId,
              delete H.mcpOAuth[w].clientSecret,
              E.update(H));
        }
      } catch {}
    throw (GA("tengu_mcp_oauth_flow_error", {}), K);
  }
}
class Kt {
  serverName;
  serverConfig;
  redirectUri;
  handleRedirection;
  _codeVerifier;
  _authorizationUrl;
  _state;
  _scopes;
  _metadata;
  _refreshInProgress;
  constructor(A, B, Q = kAI, I = !1) {
    ((this.serverName = A),
      (this.serverConfig = B),
      (this.redirectUri = Q),
      (this.handleRedirection = I));
  }
  get redirectUrl() {
    return this.redirectUri;
  }
  get authorizationUrl() {
    return this._authorizationUrl;
  }
  get clientMetadata() {
    let A = {
        client_name: `Claude Code (${this.serverName})`,
        redirect_uris: [this.redirectUri],
        grant_types: ["authorization_code", "refresh_token"],
        response_types: ["code"],
        token_endpoint_auth_method: "none",
      },
      B =
        this._metadata?.scope ||
        this._metadata?.default_scope ||
        this._metadata?.scopes_supported?.join(" ");
    if (B)
      ((A.scope = B),
        P0(this.serverName, `Using scope from metadata: ${A.scope}`));
    return A;
  }
  setMetadata(A) {
    this._metadata = A;
  }
  async state() {
    if (!this._state)
      ((this._state = SAI(32).toString("base64url")),
        P0(this.serverName, "Generated new OAuth state"));
    return this._state;
  }
  async clientInformation() {
    let B = kw().read(),
      Q = Vt(this.serverName, this.serverConfig),
      I = B?.mcpOAuth?.[Q];
    if (I?.clientId)
      return (
        P0(this.serverName, "Found client info"),
        { client_id: I.clientId, client_secret: I.clientSecret }
      );
    P0(this.serverName, "No client info found");
    return;
  }
  async saveClientInformation(A) {
    let B = kw(),
      Q = B.read() || {},
      I = Vt(this.serverName, this.serverConfig),
      G = {
        ...Q,
        mcpOAuth: {
          ...Q.mcpOAuth,
          [I]: {
            ...Q.mcpOAuth?.[I],
            serverName: this.serverName,
            serverUrl: this.serverConfig.url,
            clientId: A.client_id,
            clientSecret: A.client_secret,
            accessToken: Q.mcpOAuth?.[I]?.accessToken || "",
            expiresAt: Q.mcpOAuth?.[I]?.expiresAt || 0,
          },
        },
      };
    B.update(G);
  }
  async tokens() {
    let B = kw().read(),
      Q = Vt(this.serverName, this.serverConfig),
      I = B?.mcpOAuth?.[Q];
    if (!I) {
      P0(this.serverName, "No token data found");
      return;
    }
    let G = (I.expiresAt - Date.now()) / 1000;
    if (G <= 0 && !I.refreshToken) {
      P0(this.serverName, "Token expired without refresh token");
      return;
    }
    if (G <= 300 && I.refreshToken) {
      if (!this._refreshInProgress)
        (P0(
          this.serverName,
          `Token expires in ${Math.floor(G)}s, attempting proactive refresh`,
        ),
          (this._refreshInProgress = this.refreshAuthorization(
            I.refreshToken,
          ).finally(() => {
            this._refreshInProgress = void 0;
          })));
      else
        P0(
          this.serverName,
          "Token refresh already in progress, reusing existing promise",
        );
      try {
        let Y = await this._refreshInProgress;
        if (Y) return (P0(this.serverName, "Token refreshed successfully"), Y);
        P0(this.serverName, "Token refresh failed, returning current tokens");
      } catch (Y) {
        P0(
          this.serverName,
          `Token refresh error: ${Y instanceof Error ? Y.message : String(Y)}`,
        );
      }
    }
    let Z = {
      access_token: I.accessToken,
      refresh_token: I.refreshToken,
      expires_in: G,
      scope: I.scope,
      token_type: "Bearer",
    };
    return (
      P0(this.serverName, "Returning tokens"),
      P0(this.serverName, `Token length: ${Z.access_token?.length}`),
      P0(this.serverName, `Has refresh token: ${!!Z.refresh_token}`),
      P0(this.serverName, `Expires in: ${Math.floor(G)}s`),
      Z
    );
  }
  async saveTokens(A) {
    let B = kw(),
      Q = B.read() || {},
      I = Vt(this.serverName, this.serverConfig);
    (P0(this.serverName, "Saving tokens"),
      P0(this.serverName, `Token expires in: ${A.expires_in}`),
      P0(this.serverName, `Has refresh token: ${!!A.refresh_token}`));
    let G = {
      ...Q,
      mcpOAuth: {
        ...Q.mcpOAuth,
        [I]: {
          ...Q.mcpOAuth?.[I],
          serverName: this.serverName,
          serverUrl: this.serverConfig.url,
          accessToken: A.access_token,
          refreshToken: A.refresh_token,
          expiresAt: Date.now() + (A.expires_in || 3600) * 1000,
          scope: A.scope,
        },
      },
    };
    B.update(G);
  }
  async redirectToAuthorization(A) {
    this._authorizationUrl = A.toString();
    let B = A.searchParams.get("scope");
    if (
      (P0(this.serverName, `Authorization URL: ${A.toString()}`),
      P0(this.serverName, `Scopes in URL: ${B || "NOT FOUND"}`),
      B)
    )
      ((this._scopes = B),
        P0(this.serverName, `Captured scopes from authorization URL: ${B}`));
    else {
      let G =
        this._metadata?.scope ||
        this._metadata?.default_scope ||
        this._metadata?.scopes_supported?.join(" ");
      if (G)
        ((this._scopes = G),
          P0(this.serverName, `Using scopes from metadata: ${G}`));
      else P0(this.serverName, "No scopes available from URL or metadata");
    }
    if (!this.handleRedirection) {
      P0(
        this.serverName,
        "Redirection handling is disabled, skipping redirect",
      );
      return;
    }
    let Q = A.toString();
    if (!Q.startsWith("http://") && !Q.startsWith("https://"))
      throw Error(
        "Invalid authorization URL: must use http:// or https:// scheme",
      );
    if (
      (P0(this.serverName, "Redirecting to authorization URL"),
      P0(this.serverName, `Authorization URL: ${Q}`),
      P0(this.serverName, `Opening authorization URL: ${Q}`),
      !(await d7(Q)))
    )
      process.stdout.write(`
Couldn't open browser automatically. Please manually open the URL above in your browser.
`);
  }
  async saveCodeVerifier(A) {
    (P0(this.serverName, "Saving code verifier"), (this._codeVerifier = A));
  }
  async codeVerifier() {
    if (!this._codeVerifier)
      throw (
        P0(this.serverName, "No code verifier saved"),
        Error("No code verifier saved")
      );
    return (P0(this.serverName, "Returning code verifier"), this._codeVerifier);
  }
  async refreshAuthorization(A) {
    try {
      P0(this.serverName, "Starting token refresh");
      let B = await HZA(new URL(this.serverConfig.url));
      if (!B) {
        P0(this.serverName, "Failed to discover OAuth metadata");
        return;
      }
      let Q = await this.clientInformation();
      if (!Q) {
        P0(this.serverName, "No client information available for refresh");
        return;
      }
      let I = await d81(new URL(this.serverConfig.url), {
        metadata: B,
        clientInformation: Q,
        refreshToken: A,
        resource: new URL(this.serverConfig.url),
      });
      if (I)
        return (
          P0(this.serverName, "Token refresh successful, saving new tokens"),
          await this.saveTokens(I),
          I
        );
      P0(this.serverName, "Token refresh returned no tokens");
      return;
    } catch (B) {
      P0(
        this.serverName,
        `Token refresh failed: ${B instanceof Error ? B.message : String(B)}`,
      );
      return;
    }
  }
}
var d10,
  OB1,
  yAI,
  kl2 = 3118,
  kAI = "http://localhost:3118/callback";
var RB1 = T(() => {
  dtA();
  H0();
  EMA();
  zZA();
  rq();
  _I();
  c1();
  E5();
  d10 = IA(yl2(), 1);
  OB1 = class OB1 extends Error {
    constructor() {
      super("Authentication was cancelled");
      this.name = "AuthenticationCancelledError";
    }
  };
  yAI =
    EB() === "windows"
      ? { min: 39152, max: 49151 }
      : { min: 49152, max: 65535 };
});
function p10({ servers: A, onSelectServer: B, onComplete: Q }) {
  let [I] = HQ(),
    G = IB();
  if (A.length === 0) return null;
  let Z = kGA(),
    Y = A.some((X) => X.client.type === "failed"),
    J = A.map((X) => {
      let W = "",
        F = "",
        C = "";
      if (X.client.type === "disabled")
        ((F = OB("inactive", I)(E1.radioOff)),
          (W = "disabled  Enter to view details"),
          (C = `${F} ${W}`));
      else if (X.client.type === "connected")
        ((F = OB("success", I)(E1.tick)),
          (W = "connected  Enter to view details"),
          (C = `${F} ${W}`));
      else if (X.client.type === "pending")
        ((F = OB("inactive", I)(E1.radioOff)),
          (W = "connecting..."),
          (C = `${F} ${W}`));
      else if (X.client.type === "needs-auth")
        ((F = OB("warning", I)(E1.triangleUpOutline)),
          (W = "disconnected  Enter to login"),
          (C = `${F} ${W}`));
      else if (X.client.type === "failed")
        ((F = OB("error", I)(E1.cross)),
          (W = "failed  Enter to view details"),
          (C = `${F} ${W}`));
      else ((F = OB("error", I)(E1.cross)), (W = "failed"), (C = `${F} ${W}`));
      return {
        label: iA.bold(X.name),
        value: X.name,
        description: C,
        dimDescription: !1,
      };
    });
  return KZ.default.createElement(
    S,
    { flexDirection: "column" },
    KZ.default.createElement(s01, null),
    KZ.default.createElement(
      S,
      {
        flexDirection: "column",
        paddingX: 1,
        borderStyle: "round",
        borderDimColor: !0,
      },
      KZ.default.createElement(
        S,
        { marginBottom: 1 },
        KZ.default.createElement(U, { bold: !0 }, "Manage MCP servers"),
      ),
      KZ.default.createElement($0, {
        options: J,
        onChange: (X) => {
          let W = A.find((F) => F.name === X);
          if (W) B(W);
        },
        onCancel: () => Q("MCP dialog dismissed", { display: "system" }),
      }),
      Y &&
        KZ.default.createElement(
          S,
          { marginTop: 1 },
          KZ.default.createElement(
            U,
            { dimColor: !0 },
            " Tip:",
            " ",
            Z
              ? `Error logs will be shown inline. Log files are also saved in
  ${Hy.baseLogs()}`
              : `Run claude --debug to see logs inline, or view log files in
  ${Hy.baseLogs()}`,
          ),
        ),
      KZ.default.createElement(
        S,
        { flexDirection: "column", marginTop: 1 },
        KZ.default.createElement(
          U,
          { dimColor: !0 },
          "MCP Config locations (by scope):",
        ),
        ["user", "project", "local"].map((X) =>
          KZ.default.createElement(
            S,
            { key: X, flexDirection: "column", marginLeft: 1 },
            KZ.default.createElement(U, { dimColor: !0 }, " ", Nr(X), ":"),
            KZ.default.createElement(
              S,
              { marginLeft: 2 },
              KZ.default.createElement(U, { dimColor: !0 }, " ", Lw(X)),
            ),
          ),
        ),
      ),
      KZ.default.createElement(
        S,
        { marginTop: 1, marginLeft: 0 },
        KZ.default.createElement(
          U,
          { dimColor: !0 },
          "For help configuring MCP servers, see:",
          " ",
          KZ.default.createElement(
            R8,
            { url: "https://docs.claude.com/en/docs/claude-code/mcp" },
            "https://docs.claude.com/en/docs/claude-code/mcp",
          ),
        ),
      ),
    ),
    KZ.default.createElement(
      S,
      { marginLeft: 3 },
      KZ.default.createElement(
        U,
        { dimColor: !0 },
        G.pending
          ? KZ.default.createElement(
              KZ.default.Fragment,
              null,
              "Press ",
              G.keyName,
              " again to exit",
            )
          : KZ.default.createElement(KZ.default.Fragment, null, "Esc to exit"),
      ),
    ),
  );
}
var KZ;
var l10 = T(() => {
  nA();
  Z4();
  C0();
  R5();
  R9();
  s2();
  f2();
  iA0();
  kF();
  vK();
  KZ = IA(KA(), 1);
});
function PB1({
  serverToolsCount: A,
  serverPromptsCount: B,
  serverResourcesCount: Q,
}) {
  let I = [];
  if (A > 0) I.push("tools");
  if (Q > 0) I.push("resources");
  if (B > 0) I.push("prompts");
  return TB1.default.createElement(
    S,
    null,
    TB1.default.createElement(U, { bold: !0 }, "Capabilities: "),
    TB1.default.createElement(
      U,
      { color: "text" },
      I.length > 0 ? I.join("  ") : "none",
    ),
  );
}
var TB1;
var i10 = T(() => {
  nA();
  TB1 = IA(KA(), 1);
});
function jB1(A, B) {
  switch (A.client.type) {
    case "connected":
      return { message: `Reconnected to ${B}.`, success: !0 };
    case "needs-auth":
      return {
        message: `${B} requires authentication. Use the 'Authenticate' option.`,
        success: !1,
      };
    case "failed":
      return { message: `Failed to reconnect to ${B}.`, success: !1 };
    default:
      return {
        message: `Unknown result when reconnecting to ${B}.`,
        success: !1,
      };
  }
}
function SB1(A, B) {
  let Q = A instanceof Error ? A.message : String(A);
  return `Error reconnecting to ${B}: ${Q}`;
}
function n10({
  server: A,
  serverToolsCount: B,
  onViewTools: Q,
  onCancel: I,
  onComplete: G,
}) {
  let [Z] = HQ(),
    Y = IB(),
    [J] = lB(),
    X = gIA(),
    W = uIA(),
    [F, C] = X4.useState(!1),
    V = X4.default.useCallback(async () => {
      let H = A.client.type !== "disabled";
      try {
        if ((await W(A.name), !H))
          G(`MCP server '${A.name}' has been enabled.`);
        else G(`MCP server '${A.name}' has been disabled.`);
      } catch (w) {
        G(
          `Failed to ${H ? "disable" : "enable"} MCP server '${A.name}': ${w instanceof Error ? w.message : String(w)}`,
        );
      }
    }, [A.client.type, A.name, W, G]),
    K = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1),
    D = HrA(J.mcp.commands, A.name).length,
    E = [];
  if (A.client.type !== "disabled" && B > 0)
    E.push({ label: "View tools", value: "tools" });
  if (A.client.type !== "disabled")
    E.push({ label: "Reconnect", value: "reconnectMcpServer" });
  if (
    (E.push({
      label: A.client.type !== "disabled" ? "Disable" : "Enable",
      value: "toggle-enabled",
    }),
    E.length === 0)
  )
    E.push({ label: "Back", value: "back" });
  if (F)
    return X4.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1 },
      X4.default.createElement(
        U,
        { color: "text" },
        "Reconnecting to ",
        X4.default.createElement(U, { bold: !0 }, A.name),
      ),
      X4.default.createElement(
        S,
        null,
        X4.default.createElement(E8, null),
        X4.default.createElement(U, null, " Restarting MCP server process"),
      ),
      X4.default.createElement(
        U,
        { dimColor: !0 },
        "This may take a few moments.",
      ),
    );
  return X4.default.createElement(
    X4.default.Fragment,
    null,
    X4.default.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      X4.default.createElement(
        S,
        { marginBottom: 1 },
        X4.default.createElement(U, { bold: !0 }, K, " MCP Server"),
      ),
      X4.default.createElement(
        S,
        { flexDirection: "column", gap: 0 },
        X4.default.createElement(
          S,
          null,
          X4.default.createElement(U, { bold: !0 }, "Status: "),
          A.client.type === "disabled"
            ? X4.default.createElement(
                U,
                null,
                OB("inactive", Z)(E1.radioOff),
                " disabled",
              )
            : A.client.type === "connected"
              ? X4.default.createElement(
                  U,
                  null,
                  OB("success", Z)(E1.tick),
                  " connected",
                )
              : A.client.type === "pending"
                ? X4.default.createElement(
                    X4.default.Fragment,
                    null,
                    X4.default.createElement(U, { dimColor: !0 }, E1.radioOff),
                    X4.default.createElement(U, null, " connecting"),
                  )
                : X4.default.createElement(
                    U,
                    null,
                    OB("error", Z)(E1.cross),
                    " failed",
                  ),
        ),
        X4.default.createElement(
          S,
          null,
          X4.default.createElement(U, { bold: !0 }, "Command: "),
          X4.default.createElement(U, { dimColor: !0 }, A.config.command),
        ),
        A.config.args &&
          A.config.args.length > 0 &&
          X4.default.createElement(
            S,
            null,
            X4.default.createElement(U, { bold: !0 }, "Args: "),
            X4.default.createElement(
              U,
              { dimColor: !0 },
              A.config.args.join(" "),
            ),
          ),
        X4.default.createElement(
          S,
          null,
          X4.default.createElement(U, { bold: !0 }, "Config location: "),
          X4.default.createElement(
            U,
            { dimColor: !0 },
            Lw(d5A(A.name)?.scope ?? "dynamic"),
          ),
        ),
        A.client.type === "connected" &&
          X4.default.createElement(PB1, {
            serverToolsCount: B,
            serverPromptsCount: D,
            serverResourcesCount: J.mcp.resources[A.name]?.length || 0,
          }),
        A.client.type === "connected" &&
          B > 0 &&
          X4.default.createElement(
            S,
            null,
            X4.default.createElement(U, { bold: !0 }, "Tools: "),
            X4.default.createElement(U, { dimColor: !0 }, B, " tools"),
          ),
      ),
      E.length > 0 &&
        X4.default.createElement(
          S,
          { marginTop: 1 },
          X4.default.createElement($0, {
            options: E,
            onChange: async (H) => {
              if (H === "tools") Q();
              else if (H === "reconnectMcpServer") {
                C(!0);
                try {
                  let w = await X(A.name),
                    { message: L } = jB1(w, A.name);
                  G?.(L);
                } catch (w) {
                  G?.(SB1(w, A.name));
                } finally {
                  C(!1);
                }
              } else if (H === "toggle-enabled") await V();
              else if (H === "back") I();
            },
            onCancel: I,
          }),
        ),
    ),
    X4.default.createElement(
      S,
      { marginLeft: 3 },
      X4.default.createElement(
        U,
        { dimColor: !0 },
        Y.pending
          ? X4.default.createElement(
              X4.default.Fragment,
              null,
              "Press ",
              Y.keyName,
              " again to exit",
            )
          : X4.default.createElement(
              X4.default.Fragment,
              null,
              "Esc to go back",
            ),
      ),
    ),
  );
}
var X4;
var a10 = T(() => {
  nA();
  R5();
  R9();
  s2();
  c9();
  kF();
  aN();
  i10();
  Io();
  xX();
  X4 = IA(KA(), 1);
});
function s10({
  server: A,
  serverToolsCount: B,
  onViewTools: Q,
  onCancel: I,
  onComplete: G,
}) {
  let [Z] = HQ(),
    Y = IB(),
    [J, X] = Z2.default.useState(!1),
    [W, F] = Z2.default.useState(null),
    [C, V] = lB(),
    [K, D] = Z2.default.useState(null),
    [E, H] = Z2.useState(!1),
    [w, L] = Z2.useState(null);
  h1((m, o) => {
    if (o.escape && J) {
      if (w) w.abort();
      (X(!1), D(null), L(null));
    }
  });
  let N = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1),
    $ = HrA(C.mcp.commands, A.name).length,
    O = gIA(),
    P = uIA(),
    k = Z2.default.useCallback(async () => {
      let m = A.client.type !== "disabled";
      try {
        if ((await P(A.name), !m))
          G?.(`MCP server '${A.name}' has been enabled.`);
        else G?.(`MCP server '${A.name}' has been disabled.`);
      } catch (o) {
        G?.(
          `Failed to ${m ? "disable" : "enable"} MCP server '${A.name}': ${o instanceof Error ? o.message : String(o)}`,
        );
      }
    }, [A.client.type, A.name, P, G]),
    b = Z2.default.useCallback(async () => {
      (X(!0), F(null));
      let m = new AbortController();
      L(m);
      try {
        if (A.isAuthenticated && A.config) await c10(A.name, A.config);
        if (A.config) {
          (await xl2(A.name, A.config, D, m.signal),
            GA("tengu_mcp_auth_config_authenticate", {
              wasAuthenticated: A.isAuthenticated,
            }));
          let o = await O(A.name);
          if (o.client.type === "connected") {
            let l = A.isAuthenticated
              ? `Authentication successful. Reconnected to ${A.name}.`
              : `Authentication successful. Connected to ${A.name}.`;
            G?.(l);
          } else if (o.client.type === "needs-auth")
            G?.(
              "Authentication successful, but server still requires authentication. You may need to manually restart Claude Code.",
            );
          else
            (P0(A.name, "Reconnection failed after authentication"),
              G?.(
                "Authentication successful, but server reconnection failed. You may need to manually restart Claude Code for the changes to take effect.",
              ));
        }
      } catch (o) {
        if (o instanceof Error && !(o instanceof OB1)) F(o.message);
      } finally {
        (X(!1), L(null));
      }
    }, [A.isAuthenticated, A.config, A.name, G, O, D]),
    x = async () => {
      if (A.config)
        (await c10(A.name, A.config),
          GA("tengu_mcp_auth_config_clear", {}),
          await hIA(A.name, { ...A.config, scope: A.scope }),
          V((m) => {
            let o = m.mcp.clients.map((e) =>
                e.name === A.name ? { ...e, type: "failed" } : e,
              ),
              l = AaQ(m.mcp.tools, A.name),
              y = BaQ(m.mcp.commands, A.name),
              c = QaQ(m.mcp.resources, A.name);
            return {
              ...m,
              mcp: { clients: o, tools: l, commands: y, resources: c },
            };
          }),
          G?.(`Authentication cleared for ${A.name}.`));
    };
  if (J)
    return Z2.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1 },
      Z2.default.createElement(
        U,
        { color: "claude" },
        "Authenticating with ",
        A.name,
        "",
      ),
      Z2.default.createElement(
        S,
        null,
        Z2.default.createElement(E8, null),
        Z2.default.createElement(
          U,
          null,
          " A browser window will open for authentication",
        ),
      ),
      K &&
        Z2.default.createElement(
          S,
          { flexDirection: "column" },
          Z2.default.createElement(
            U,
            { dimColor: !0 },
            "If your browser doesn't open automatically, copy this URL manually:",
          ),
          Z2.default.createElement(R8, { url: K }),
        ),
      Z2.default.createElement(
        S,
        { marginLeft: 3 },
        Z2.default.createElement(
          U,
          { dimColor: !0 },
          "Return here after authenticating in your browser. Press Esc to go back.",
        ),
      ),
    );
  if (E)
    return Z2.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1 },
      Z2.default.createElement(
        U,
        { color: "text" },
        "Reconnecting to ",
        Z2.default.createElement(U, { bold: !0 }, A.name),
        "",
      ),
      Z2.default.createElement(
        S,
        null,
        Z2.default.createElement(E8, null),
        Z2.default.createElement(
          U,
          null,
          " Establishing connection to MCP server",
        ),
      ),
      Z2.default.createElement(
        U,
        { dimColor: !0 },
        "This may take a few moments.",
      ),
    );
  let n = [];
  if (A.client.type === "connected" && B > 0)
    n.push({ label: "View tools", value: "tools" });
  if (A.isAuthenticated)
    (n.push({ label: "Re-authenticate", value: "reauth" }),
      n.push({ label: "Clear authentication", value: "clear-auth" }));
  if (!A.isAuthenticated) n.push({ label: "Authenticate", value: "auth" });
  if (A.client.type !== "needs-auth" && A.client.type !== "disabled")
    n.push({ label: "Reconnect", value: "reconnectMcpServer" });
  if (
    (n.push({
      label: A.client.type !== "disabled" ? "Disable" : "Enable",
      value: "toggle-enabled",
    }),
    n.length === 0)
  )
    n.push({ label: "Back", value: "back" });
  return Z2.default.createElement(
    Z2.default.Fragment,
    null,
    Z2.default.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      Z2.default.createElement(
        S,
        { marginBottom: 1 },
        Z2.default.createElement(U, { bold: !0 }, N, " MCP Server"),
      ),
      Z2.default.createElement(
        S,
        { flexDirection: "column", gap: 0 },
        Z2.default.createElement(
          S,
          null,
          Z2.default.createElement(U, { bold: !0 }, "Status: "),
          A.client.type === "disabled"
            ? Z2.default.createElement(
                U,
                null,
                OB("inactive", Z)(E1.radioOff),
                " disabled",
              )
            : A.client.type === "connected"
              ? Z2.default.createElement(
                  Z2.default.Fragment,
                  null,
                  Z2.default.createElement(
                    U,
                    null,
                    OB("success", Z)(E1.tick),
                    " connected",
                  ),
                  A.isAuthenticated &&
                    Z2.default.createElement(
                      U,
                      null,
                      "  ",
                      OB("success", Z)(E1.tick),
                      " authenticated",
                    ),
                )
              : A.client.type === "pending"
                ? Z2.default.createElement(
                    Z2.default.Fragment,
                    null,
                    Z2.default.createElement(U, { dimColor: !0 }, E1.radioOff),
                    Z2.default.createElement(U, null, " connecting"),
                  )
                : A.client.type === "needs-auth"
                  ? Z2.default.createElement(
                      U,
                      null,
                      OB("warning", Z)(E1.triangleUpOutline),
                      " needs authentication",
                    )
                  : Z2.default.createElement(
                      U,
                      null,
                      OB("error", Z)(E1.cross),
                      " failed",
                    ),
        ),
        Z2.default.createElement(
          S,
          null,
          Z2.default.createElement(U, { bold: !0 }, "URL: "),
          Z2.default.createElement(U, { dimColor: !0 }, A.config.url),
        ),
        Z2.default.createElement(
          S,
          null,
          Z2.default.createElement(U, { bold: !0 }, "Config location: "),
          Z2.default.createElement(
            U,
            { dimColor: !0 },
            Lw(d5A(A.name)?.scope ?? "dynamic"),
          ),
        ),
        A.client.type === "connected" &&
          Z2.default.createElement(PB1, {
            serverToolsCount: B,
            serverPromptsCount: $,
            serverResourcesCount: C.mcp.resources[A.name]?.length || 0,
          }),
        A.client.type === "connected" &&
          B > 0 &&
          Z2.default.createElement(
            S,
            null,
            Z2.default.createElement(U, { bold: !0 }, "Tools: "),
            Z2.default.createElement(U, { dimColor: !0 }, B, " tools"),
          ),
      ),
      W &&
        Z2.default.createElement(
          S,
          { marginTop: 1 },
          Z2.default.createElement(U, { color: "error" }, "Error: ", W),
        ),
      n.length > 0 &&
        Z2.default.createElement(
          S,
          { marginTop: 1 },
          Z2.default.createElement($0, {
            options: n,
            onChange: async (m) => {
              switch (m) {
                case "tools":
                  Q();
                  break;
                case "auth":
                case "reauth":
                  await b();
                  break;
                case "clear-auth":
                  await x();
                  break;
                case "reconnectMcpServer":
                  H(!0);
                  try {
                    let o = await O(A.name),
                      { message: l } = jB1(o, A.name);
                    G?.(l);
                  } catch (o) {
                    G?.(SB1(o, A.name));
                  } finally {
                    H(!1);
                  }
                  break;
                case "toggle-enabled":
                  await k();
                  break;
                case "back":
                  I();
                  break;
              }
            },
            onCancel: I,
          }),
        ),
    ),
    Z2.default.createElement(
      S,
      { marginLeft: 3 },
      Z2.default.createElement(
        U,
        { dimColor: !0 },
        Y.pending
          ? Z2.default.createElement(
              Z2.default.Fragment,
              null,
              "Press ",
              Y.keyName,
              " again to exit",
            )
          : Z2.default.createElement(
              Z2.default.Fragment,
              null,
              "Esc to go back",
            ),
      ),
    ),
  );
}
var Z2;
var r10 = T(() => {
  nA();
  R5();
  H0();
  R9();
  s2();
  RB1();
  xX();
  gj();
  c9();
  c1();
  kF();
  aN();
  i10();
  vK();
  Io();
  Z2 = IA(KA(), 1);
});
function o10({ server: A, onSelectTool: B, onBack: Q }) {
  let I = IB(),
    [G] = lB(),
    Z = zE.default.useMemo(() => {
      if (A.client.type !== "connected") return [];
      return xHA(G.mcp.tools, A.name);
    }, [A, G.mcp.tools]),
    Y = Z.map((J, X) => {
      let W = zrA(J.name, A.name),
        F = J.userFacingName ? J.userFacingName({}) : W,
        C = UrA(F),
        V = J.isReadOnly?.({}) ?? !1,
        K = J.isDestructive?.({}) ?? !1,
        D = J.isOpenWorld?.({}) ?? !1,
        E = [];
      if (V) E.push("read-only");
      if (K) E.push("destructive");
      if (D) E.push("open-world");
      return {
        label: C,
        value: X.toString(),
        description: E.length > 0 ? E.join(", ") : void 0,
        descriptionColor: K ? "error" : V ? "success" : void 0,
      };
    });
  return zE.default.createElement(
    S,
    { flexDirection: "column" },
    zE.default.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      zE.default.createElement(
        S,
        { marginBottom: 1 },
        zE.default.createElement(U, { bold: !0 }, "Tools for ", A.name),
        zE.default.createElement(
          U,
          { dimColor: !0 },
          " (",
          Z.length,
          " tools)",
        ),
      ),
      Z.length === 0
        ? zE.default.createElement(U, { dimColor: !0 }, "No tools available")
        : zE.default.createElement($0, {
            options: Y,
            onChange: (J) => {
              let X = parseInt(J),
                W = Z[X];
              if (W) B(W, X);
            },
            onCancel: Q,
          }),
    ),
    zE.default.createElement(
      S,
      { marginLeft: 3 },
      zE.default.createElement(
        U,
        { dimColor: !0 },
        I.pending
          ? zE.default.createElement(
              zE.default.Fragment,
              null,
              "Press ",
              I.keyName,
              " again to exit",
            )
          : zE.default.createElement(
              zE.default.Fragment,
              null,
              "Esc to go back",
            ),
      ),
    ),
  );
}
var zE;
var t10 = T(() => {
  nA();
  R5();
  kF();
  c9();
  R9();
  zE = IA(KA(), 1);
});
function e10({ tool: A, server: B, onBack: Q }) {
  let I = IB(),
    [G, Z] = y5.default.useState("");
  h1((V, K) => {
    if (K.escape) Q();
  });
  let Y = zrA(A.name, B.name),
    J = A.userFacingName ? A.userFacingName({}) : Y,
    X = UrA(J),
    W = A.isReadOnly?.({}) ?? !1,
    F = A.isDestructive?.({}) ?? !1,
    C = A.isOpenWorld?.({}) ?? !1;
  return (
    y5.default.useEffect(() => {
      async function V() {
        try {
          let K = await A.description(
            {},
            {
              isNonInteractiveSession: !1,
              toolPermissionContext: {
                mode: "default",
                additionalWorkingDirectories: new Map(),
                alwaysAllowRules: {},
                alwaysDenyRules: {},
                alwaysAskRules: {},
                isBypassPermissionsModeAvailable: !1,
              },
              tools: [],
            },
          );
          Z(K);
        } catch {
          Z("Failed to load description");
        }
      }
      V();
    }, [A]),
    y5.default.createElement(
      S,
      { flexDirection: "column" },
      y5.default.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        y5.default.createElement(
          S,
          { marginBottom: 1 },
          y5.default.createElement(
            U,
            { bold: !0 },
            X,
            y5.default.createElement(U, { dimColor: !0 }, " (", B.name, ")"),
            W &&
              y5.default.createElement(U, { color: "success" }, " [read-only]"),
            F &&
              y5.default.createElement(U, { color: "error" }, " [destructive]"),
            C && y5.default.createElement(U, { dimColor: !0 }, " [open-world]"),
          ),
        ),
        y5.default.createElement(
          S,
          { flexDirection: "column" },
          y5.default.createElement(
            S,
            null,
            y5.default.createElement(U, { bold: !0 }, "Tool name: "),
            y5.default.createElement(U, { dimColor: !0 }, Y),
          ),
          y5.default.createElement(
            S,
            null,
            y5.default.createElement(U, { bold: !0 }, "Full name: "),
            y5.default.createElement(U, { dimColor: !0 }, A.name),
          ),
          G &&
            y5.default.createElement(
              S,
              { flexDirection: "column", marginTop: 1 },
              y5.default.createElement(U, { bold: !0 }, "Description:"),
              y5.default.createElement(U, { wrap: "wrap" }, G),
            ),
          A.inputJSONSchema &&
            A.inputJSONSchema.properties &&
            Object.keys(A.inputJSONSchema.properties).length > 0 &&
            y5.default.createElement(
              S,
              { flexDirection: "column", marginTop: 1 },
              y5.default.createElement(U, { bold: !0 }, "Parameters:"),
              y5.default.createElement(
                S,
                { marginLeft: 2, flexDirection: "column" },
                Object.entries(A.inputJSONSchema.properties).map(([V, K]) => {
                  let E = A.inputJSONSchema?.required?.includes(V);
                  return y5.default.createElement(
                    U,
                    { key: V },
                    " ",
                    V,
                    E &&
                      y5.default.createElement(
                        U,
                        { dimColor: !0 },
                        " (required)",
                      ),
                    ":",
                    " ",
                    y5.default.createElement(
                      U,
                      { dimColor: !0 },
                      typeof K === "object" && K && "type" in K
                        ? String(K.type)
                        : "unknown",
                    ),
                    typeof K === "object" &&
                      K &&
                      "description" in K &&
                      y5.default.createElement(
                        U,
                        { dimColor: !0 },
                        " ",
                        "- ",
                        String(K.description),
                      ),
                  );
                }),
              ),
            ),
        ),
      ),
      y5.default.createElement(
        S,
        { marginLeft: 3 },
        y5.default.createElement(
          U,
          { dimColor: !0 },
          I.pending
            ? y5.default.createElement(
                y5.default.Fragment,
                null,
                "Press ",
                I.keyName,
                " again to exit",
              )
            : y5.default.createElement(
                y5.default.Fragment,
                null,
                "Esc to go back",
              ),
        ),
      ),
    )
  );
}
var y5;
var A00 = T(() => {
  nA();
  nA();
  R9();
  kF();
  y5 = IA(KA(), 1);
});
function B00({ onComplete: A }) {
  let [B] = lB(),
    Q = B.mcp.clients,
    [I, G] = zL.default.useState({ type: "list" }),
    [Z, Y] = zL.default.useState([]),
    J = zL.default.useMemo(
      () =>
        Q.filter((X) => X.name !== "ide").sort((X, W) =>
          X.name.localeCompare(W.name),
        ),
      [Q],
    );
  switch (
    (zL.default.useEffect(() => {
      async function X() {
        let W = await Promise.all(
          J.map(async (F) => {
            let C = F.config.scope,
              V = F.config.type === "sse",
              K = F.config.type === "http",
              D = void 0;
            if (V || K) {
              let w = await new Kt(F.name, F.config).tokens();
              D = Boolean(w);
            }
            let E = { name: F.name, client: F, scope: C };
            if (V)
              return {
                ...E,
                transport: "sse",
                isAuthenticated: D,
                config: F.config,
              };
            else if (K)
              return {
                ...E,
                transport: "http",
                isAuthenticated: D,
                config: F.config,
              };
            else return { ...E, transport: "stdio", config: F.config };
          }),
        );
        Y(W);
      }
      X();
    }, [J]),
    zL.useEffect(() => {
      if (Z.length === 0 && J.length > 0) return;
      if (Z.length === 0)
        A(
          "No MCP servers configured. Please run /doctor if this is unexpected. Otherwise, run `claude mcp` or visit https://docs.claude.com/en/docs/claude-code/mcp to learn more.",
        );
    }, [Z.length, J.length, A]),
    I.type)
  ) {
    case "list":
      return zL.default.createElement(p10, {
        servers: Z,
        onSelectServer: (X) => G({ type: "server-menu", server: X }),
        onComplete: A,
      });
    case "server-menu": {
      let X = xHA(B.mcp.tools, I.server.name);
      if (I.server.transport === "stdio")
        return zL.default.createElement(n10, {
          server: I.server,
          serverToolsCount: X.length,
          onViewTools: () => G({ type: "server-tools", server: I.server }),
          onCancel: () => G({ type: "list" }),
          onComplete: A,
        });
      else
        return zL.default.createElement(s10, {
          server: I.server,
          serverToolsCount: X.length,
          onViewTools: () => G({ type: "server-tools", server: I.server }),
          onCancel: () => G({ type: "list" }),
          onComplete: A,
        });
    }
    case "server-tools":
      return zL.default.createElement(o10, {
        server: I.server,
        onSelectTool: (X, W) =>
          G({ type: "server-tool-detail", server: I.server, toolIndex: W }),
        onBack: () => G({ type: "server-menu", server: I.server }),
      });
    case "server-tool-detail": {
      let W = xHA(B.mcp.tools, I.server.name)[I.toolIndex];
      if (!W) return (G({ type: "server-tools", server: I.server }), null);
      return zL.default.createElement(e10, {
        tool: W,
        server: I.server,
        onBack: () => G({ type: "server-tools", server: I.server }),
      });
    }
  }
}
var zL;
var vl2 = T(() => {
  RB1();
  c9();
  kF();
  l10();
  a10();
  r10();
  t10();
  A00();
  zL = IA(KA(), 1);
});
function Q00({ serverName: A, onComplete: B }) {
  let [Q] = HQ(),
    [I] = lB(),
    G = gIA(),
    [Z, Y] = RV.useState(!0),
    [J, X] = RV.useState(null);
  if (
    (RV.useEffect(() => {
      async function W() {
        try {
          if (!I.mcp.clients.find((V) => V.name === A)) {
            (X(`MCP server "${A}" not found`), Y(!1));
            return;
          }
          switch ((await G(A)).client.type) {
            case "connected":
              B(`Successfully reconnected to ${A}`);
              break;
            case "needs-auth":
              (X(`${A} requires authentication`),
                Y(!1),
                B(`${A} requires authentication. Use /mcp to authenticate.`));
              break;
            case "pending":
            case "failed":
            case "disabled":
              (X(`Failed to reconnect to ${A}`),
                Y(!1),
                B(`Failed to reconnect to ${A}`));
              break;
          }
        } catch (F) {
          let C = F instanceof Error ? F.message : String(F);
          (X(C), Y(!1), B(`Error: ${C}`));
        }
      }
      W();
    }, [A, G, I.mcp.clients, B]),
    Z)
  )
    return RV.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1 },
      RV.default.createElement(
        U,
        { color: "text" },
        "Reconnecting to ",
        RV.default.createElement(U, { bold: !0 }, A),
      ),
      RV.default.createElement(
        S,
        null,
        RV.default.createElement(E8, null),
        RV.default.createElement(
          U,
          null,
          " Establishing connection to MCP server",
        ),
      ),
    );
  if (J)
    return RV.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1 },
      RV.default.createElement(
        S,
        null,
        RV.default.createElement(U, null, OB("error", Q)(E1.cross), " "),
        RV.default.createElement(
          U,
          { color: "error" },
          "Failed to reconnect to ",
          A,
        ),
      ),
      RV.default.createElement(U, { dimColor: !0 }, "Error: ", J),
    );
  return null;
}
var RV;
var I00 = T(() => {
  nA();
  xX();
  Io();
  c9();
  nA();
  s2();
  RV = IA(KA(), 1);
});
var bl2 = T(() => {
  vl2();
  l10();
  a10();
  r10();
  t10();
  A00();
  I00();
});
var G00, vAI, fl2;
var hl2 = T(() => {
  bl2();
  I00();
  ((G00 = IA(KA(), 1)),
    (vAI = {
      type: "local-jsx",
      name: "mcp",
      description: "Manage MCP servers",
      isEnabled: () => !0,
      isHidden: !1,
      argumentHint: "[reconnect <server-name>]",
      async call(A, B, Q) {
        if (Q) {
          let I = Q.trim().split(/\s+/);
          if (I[0] === "reconnect" && I[1]) {
            let G = I.slice(1).join(" ");
            return G00.default.createElement(Q00, {
              serverName: G,
              onComplete: A,
            });
          }
        }
        return G00.default.createElement(B00, { onComplete: A });
      },
      userFacingName() {
        return "mcp";
      },
    }),
    (fl2 = vAI));
});
var gl2 = () => {};
var ul2 = () => {};
var ml2;
var dl2 = T(() => {
  ml2 = {
    type: "prompt",
    name: "pr-comments",
    description: "Get comments from a GitHub pull request",
    progressMessage: "fetching PR comments",
    useSmallFastModel: !0,
    isEnabled: () => !0,
    isHidden: !1,
    userFacingName() {
      return "pr-comments";
    },
    source: "builtin",
    async getPromptForCommand(A) {
      return [
        {
          type: "text",
          text: `You are an AI assistant integrated into a git-based version control system. Your task is to fetch and display comments from a GitHub pull request.

Follow these steps:

1. Use \`gh pr view --json number,headRepository\` to get the PR number and repository info
2. Use \`gh api /repos/{owner}/{repo}/issues/{number}/comments\` to get PR-level comments
3. Use \`gh api /repos/{owner}/{repo}/pulls/{number}/comments\` to get review comments. Pay particular attention to the following fields: \`body\`, \`diff_hunk\`, \`path\`, \`line\`, etc. If the comment references some code, consider fetching it using eg \`gh api /repos/{owner}/{repo}/contents/{path}?ref={branch} | jq .content -r | base64 -d\`
4. Parse and format all comments in a readable way
5. Return ONLY the formatted comments, with no additional text

Format the comments as:

## Comments

[For each comment thread:]
- @author file.ts#line:
  \`\`\`diff
  [diff_hunk from the API response]
  \`\`\`
  > quoted comment text
  
  [any replies indented]

If there are no comments, return "No comments found."

Remember:
1. Only show the actual comments, no explanatory text
2. Include both PR-level and code review comments
3. Preserve the threading/nesting of comment replies
4. Show the file and line number context for code review comments
5. Use jq to parse the JSON responses from the GitHub API

${A ? "Additional user input: " + A : ""}
`,
        },
      ];
    },
  };
});
function cl2(A) {
  return A.map(([B, Q]) => {
    let I = `Version ${B}:`,
      G = Q.map((Z) => ` ${Z}`).join(`
`);
    return `${I}
${G}`;
  }).join(`

`);
}
var bAI, pl2;
var ll2 = T(() => {
  G7A();
  ((bAI = {
    description: "View release notes",
    isEnabled: () => !0,
    isHidden: !1,
    name: "release-notes",
    userFacingName() {
      return "release-notes";
    },
    type: "local",
    supportsNonInteractive: !0,
    async call() {
      let A = [];
      try {
        let Q = new Promise((I, G) => {
          setTimeout(() => G(Error("Timeout")), 500);
        });
        (await Promise.race([ke1(), Q]), (A = _e1(Bt())));
      } catch {}
      if (A.length > 0) return { type: "text", value: cl2(A) };
      let B = _e1();
      if (B.length > 0) return { type: "text", value: cl2(B) };
      return { type: "text", value: `See the full changelog at: ${GS2}` };
    },
  }),
    (pl2 = bAI));
});
var fAI, il2;
var nl2 = T(() => {
  E7();
  i0();
  ((fAI = {
    type: "local",
    name: "rename",
    description: "Rename the current conversation",
    isEnabled: () => !1,
    isHidden: !1,
    supportsNonInteractive: !1,
    argumentHint: "<name>",
    async call(A) {
      if (!A || A.trim() === "")
        return {
          type: "text",
          value: "Please provide a name for the session. Usage: /rename <name>",
        };
      let B = L0();
      return (
        await yB1(B, A.trim()),
        { type: "text", value: `Session renamed to: ${A.trim()}` }
      );
    },
    userFacingName() {
      return "rename";
    },
  }),
    (il2 = fAI));
});
var hAI;
var al2 = T(() => {
  Z5();
  nA();
  hAI = IA(KA(), 1);
});
var gAI;
var sl2 = T(() => {
  nA();
  C01();
  nO();
  gAI = IA(KA(), 1);
});
function rl2(A, B) {
  let Q = A.replace(/\s+/g, " ").trim();
  if (Q.length <= B) return Q;
  return Q.slice(0, B).trim() + "";
}
function Z00(A, B, Q) {
  let { isGroupHeader: I = !1, isChild: G = !1, forkCount: Z = 0 } = Q || {},
    Y = I && Z > 0 ? uAI : G ? mAI : 0,
    J = I && Z > 0 ? ` (+${Z} other ${Z === 1 ? "session" : "sessions"})` : "",
    X = A.isSidechain ? " (sidechain)" : "",
    W = B - Y - X.length - J.length;
  return `${rl2(P$A(A), W)}${X}${J}`;
}
function Y00(A, B) {
  let { isChild: Q = !1 } = B || {},
    I = [
      vh(A.modified, { style: "short" }),
      `${A.messageCount} messages`,
      A.gitBranch || "-",
    ].join("  ");
  return (Q ? "    " : "") + I;
}
function j$A({
  logs: A,
  maxHeight: B = 1 / 0,
  forceWidth: Q,
  onCancel: I,
  onSelect: G,
  onLogsChanged: Z,
}) {
  let Y = aB(),
    J = Q === void 0 ? Y.columns : Q,
    X = IB(I),
    { isFocused: W } = KbA(),
    F = !1,
    [C, V] = n4.default.useState(null),
    [K, D] = n4.default.useState(!1),
    [E, H] = n4.default.useState(""),
    [w, L] = n4.default.useState(""),
    [N, $] = n4.default.useState(0),
    [O, P] = n4.default.useState(new Set()),
    [k, b] = n4.default.useState(null),
    [x, n] = n4.default.useState("list"),
    [m, o] = n4.default.useState(null),
    l = n4.default.useRef(null);
  n4.default.useEffect(() => {
    T_().then((Z1) => V(Z1));
  }, []);
  let y = n4.default.useMemo(() => {
      let Z1 = A;
      if (K && C) Z1 = Z1.filter((XA) => XA.gitBranch === C);
      if (E) {
        let XA = E.toLowerCase();
        Z1 = Z1.filter((CA) => {
          let UA = P$A(CA).toLowerCase(),
            HA = (CA.gitBranch || "").toLowerCase();
          return UA.includes(XA) || HA.includes(XA);
        });
      }
      return Z1;
    }, [A, !1, K, C, E]),
    c = Math.max(30, J - 4),
    e = n4.default.useMemo(() => {
      return [];
    }, [!1, y, c]),
    QA = n4.default.useMemo(() => {
      return y.map((Z1, XA) => {
        let UA = P$A(Z1) + (Z1.isSidechain ? " (sidechain)" : "");
        return {
          label: rl2(UA, c),
          description: [
            vh(Z1.modified, { style: "short" }),
            `${Z1.messageCount} messages`,
            Z1.gitBranch || "-",
          ].join("  "),
          dimDescription: !0,
          value: XA.toString(),
        };
      });
    }, [!1, y, c]),
    WA = k?.value.log ?? null,
    JA = () => {
      return "";
    },
    wA = n4.default.useCallback(async () => {
      let Z1 = WA?.messages[0];
      if (!WA || !Z1) {
        (n("list"), L(""));
        return;
      }
      if (w.trim()) {
        let XA = Z1.sessionId;
        await yB1(XA, w.trim());
      }
      (n("list"), L(""));
    }, [WA, w, Z, !1]),
    xA = n4.default.useCallback(
      (Z1) => {
        let XA = parseInt(Z1, 10),
          CA = y[XA];
        if (!CA || l.current === XA.toString()) return;
        ((l.current = XA.toString()),
          b({
            id: XA.toString(),
            value: { log: CA, indexInFiltered: XA },
            label: "",
          }));
      },
      [y],
    ),
    rA = n4.default.useCallback((Z1) => {
      b(Z1);
    }, []);
  if (
    (h1(
      (Z1, XA) => {
        if (x === "preview") return;
        if (x === "rename") {
          if (XA.escape) (n("list"), L(""));
        } else if (x === "search") {
          if (XA.escape || XA.return)
            (n("list"), GA("tengu_session_search_toggled", { enabled: !1 }));
          else if (XA.backspace || XA.delete) H((CA) => CA.slice(0, -1));
          else if (Z1 && !XA.ctrl && !XA.meta) H((CA) => CA + Z1);
        } else {
          let CA = !XA.ctrl && !XA.meta,
            UA = Z1.toLowerCase();
          if (UA === "b" && CA) {
            let HA = !K;
            (D(HA), GA("tengu_session_branch_filter_toggled", { enabled: HA }));
          } else if (UA === "/" && CA)
            (n("search"), GA("tengu_session_search_toggled", { enabled: !0 }));
        }
      },
      { isActive: !0 },
    ),
    A.length === 0)
  )
    return null;
  let qA = [];
  if (K && C) qA.push(C);
  if (E && x !== "search") qA.push(`/${E}`);
  let SA = qA.length > 0 || x === "search",
    zA = 5 + (SA ? 1 : 0),
    kA = 2,
    sA = Math.max(1, Math.floor((B - zA - kA) / 3));
  return n4.default.createElement(
    S,
    { flexDirection: "column", height: B - 1 },
    n4.default.createElement(
      S,
      { flexShrink: 0 },
      n4.default.createElement(U, { color: "suggestion" }, "".repeat(J)),
    ),
    n4.default.createElement(
      S,
      { flexShrink: 0 },
      n4.default.createElement(U, null, " "),
    ),
    n4.default.createElement(
      S,
      { flexShrink: 0 },
      n4.default.createElement(
        U,
        { bold: !0, color: "suggestion" },
        "Resume Session",
      ),
    ),
    SA &&
      n4.default.createElement(
        S,
        { flexShrink: 0, paddingLeft: 2 },
        x === "search"
          ? n4.default.createElement(
              U,
              null,
              qA.length > 0 &&
                n4.default.createElement(
                  U,
                  { dimColor: !0 },
                  qA.join("  "),
                  "  ",
                ),
              "/",
              n4.default.createElement(U, { bold: !0 }, E),
              W && n4.default.createElement(U, { dimColor: !0 }, ""),
            )
          : n4.default.createElement(U, { dimColor: !0 }, qA.join("  ")),
      ),
    n4.default.createElement(
      S,
      { flexShrink: 0 },
      n4.default.createElement(U, null, " "),
    ),
    x === "rename" && WA
      ? n4.default.createElement(
          S,
          { paddingLeft: 2, flexDirection: "column" },
          n4.default.createElement(U, { bold: !0 }, "Rename session:"),
          n4.default.createElement(
            S,
            { paddingTop: 1 },
            n4.default.createElement(O4, {
              value: w,
              onChange: L,
              onSubmit: wA,
              placeholder: P$A(WA, "Enter new session name"),
              columns: J,
              cursorOffset: N,
              onChangeCursorOffset: $,
              showCursor: !0,
            }),
          ),
        )
      : n4.default.createElement($0, {
          options: QA,
          onChange: (Z1) => {
            let XA = parseInt(Z1, 10),
              CA = y[XA];
            if (CA) G(CA);
          },
          visibleOptionCount: sA,
          onCancel: I,
          onFocus: xA,
          focusValue: k?.id.toString(),
          layout: "expanded",
          isDisabled: x === "search",
        }),
    n4.default.createElement(
      S,
      { paddingLeft: 2 },
      X.pending
        ? n4.default.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            X.keyName,
            " again to exit",
          )
        : x === "rename"
          ? n4.default.createElement(
              U,
              { dimColor: !0 },
              "Enter to save  Esc to cancel",
            )
          : x === "search"
            ? n4.default.createElement(
                U,
                { dimColor: !0 },
                "Enter or Esc to finish  type to filter",
              )
            : n4.default.createElement(
                U,
                { dimColor: !0 },
                (C ? "B to toggle branch  " : "") +
                  "/ to search  Esc to exit" +
                  JA(),
              ),
    ),
  );
}
function dAI(A) {
  let B = A.reduce((Q, I) => {
    let G = I.messages[0]?.sessionId;
    if (G) {
      let Z = Q.get(G) || [];
      Q.set(G, [...Z, I]);
    }
    return Q;
  }, new Map());
  return (
    B.forEach((Q) =>
      Q.sort(
        (I, G) =>
          new Date(G.modified).getTime() - new Date(I.modified).getTime(),
      ),
    ),
    B
  );
}
var n4,
  uAI = 2,
  mAI = 4;
var kB1 = T(() => {
  nA();
  N8();
  Z5();
  al2();
  R9();
  vC();
  DbA();
  rG();
  E7();
  i0();
  H0();
  sl2();
  c1();
  n4 = IA(KA(), 1);
});
function cAI({ onDone: A, onResume: B }) {
  let [Q, I] = UL.useState([]),
    [G, Z] = UL.useState(!0),
    { rows: Y } = aB(),
    J = UL.useCallback(async () => {
      try {
        let C = await Wy();
        if (C.length === 0) A("No conversations found to resume");
        else I(C);
      } catch (C) {
        A("Failed to load conversations");
      } finally {
        Z(!1);
      }
    }, [A]);
  UL.useEffect(() => {
    (Z(!0), I([]), J());
  }, []);
  async function X(C) {
    let V = Vz(C.messages.find((K) => K.sessionId)?.sessionId);
    if (!V) {
      A("Failed to resume conversation");
      return;
    }
    B(V, C);
  }
  function W() {
    A("Resume cancelled", { display: "system" });
  }
  if (G) return null;
  let F = Q.filter((C) => !C.isSidechain);
  return UL.createElement(j$A, {
    logs: F,
    maxHeight: Y - 2,
    onCancel: W,
    onSelect: X,
    onLogsChanged: J,
  });
}
var UL, pAI, ol2;
var tl2 = T(() => {
  kB1();
  E7();
  Tv();
  N8();
  UL = IA(KA(), 1);
  ((pAI = {
    type: "local-jsx",
    name: "resume",
    description: "Resume a conversation",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, B) {
      let Q = async (I, G) => {
        (await B.resume?.(I, G), A(void 0, { display: "skip" }));
      };
      return UL.createElement(cAI, { key: Date.now(), onDone: A, onResume: Q });
    },
    userFacingName() {
      return "resume";
    },
  }),
    (ol2 = pAI));
});
var _B1;
var J00 = T(() => {
  EF();
  _B1 = {
    type: "prompt",
    name: "review",
    description: "Review a pull request",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "reviewing pull request",
    userFacingName() {
      return "review";
    },
    source: "builtin",
    async getPromptForCommand(A) {
      return [
        {
          type: "text",
          text: `
      You are an expert code reviewer. Follow these steps:

      1. If no PR number is provided in the args, use ${r2.name}("gh pr list") to show open PRs
      2. If a PR number is provided, use ${r2.name}("gh pr view <number>") to get PR details
      3. Use ${r2.name}("gh pr diff <number>") to get the diff
      4. Analyze the changes and provide a thorough code review that includes:
         - Overview of what the PR does
         - Analysis of code quality and style
         - Specific suggestions for improvements
         - Any potential issues or risks
      
      Keep your review concise but thorough. Focus on:
      - Code correctness
      - Following project conventions
      - Performance implications
      - Test coverage
      - Security considerations

      Format your review with clear sections and bullet points.

      PR number: ${A}
    `,
        },
      ];
    },
  };
});
var el2 = () => {};
var Ai2 = () => {};
var X00, lAI, Bi2;
var Qi2 = T(() => {
  l01();
  ((X00 = IA(KA(), 1)),
    (lAI = {
      type: "local-jsx",
      name: "status",
      description:
        "Show Claude Code status including version, model, account, API connectivity, and tool statuses",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        return X00.createElement(w7A, {
          onClose: A,
          context: B,
          defaultTab: "Status",
        });
      },
      userFacingName() {
        return "status";
      },
    }),
    (Bi2 = lAI));
});
var W00, iAI, Ii2;
var Gi2 = T(() => {
  Je1();
  ((W00 = IA(KA(), 1)),
    (iAI = {
      type: "local-jsx",
      name: "bashes",
      description: "List and manage background tasks",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        return W00.createElement(i11, { toolUseContext: B, onDone: A });
      },
      userFacingName() {
        return "bashes";
      },
    }),
    (Ii2 = iAI));
});
var Zi2 = () => {};
var Dt, nAI, Yi2;
var Ji2 = T(() => {
  _m();
  i0();
  nA();
  n01();
  S11();
  ((Dt = IA(KA(), 1)),
    (nAI = {
      type: "local",
      name: "todos",
      description: "List current todo items",
      isEnabled: () => !0,
      isHidden: !1,
      supportsNonInteractive: !0,
      async call(A, B) {
        let Q = L0(),
          I = xx(Q);
        if (I.length === 0)
          return { type: "text", value: "No todos currently tracked" };
        let G = Dt.default.createElement(
          S,
          { flexDirection: "column" },
          Dt.default.createElement(
            U,
            null,
            Dt.default.createElement(
              U,
              { bold: !0 },
              I.length,
              " ",
              I.length === 1 ? "todo" : "todos",
            ),
            Dt.default.createElement(U, null, ":"),
          ),
          Dt.default.createElement(
            S,
            { marginTop: 1 },
            Dt.default.createElement(s3A, { todos: I }),
          ),
        );
        return { type: "text", value: await $7A(G) };
      },
      userFacingName() {
        return "todos";
      },
    }),
    (Yi2 = nAI));
});
var aAI = `---
allowed-tools: Bash(git diff:*), Bash(git status:*), Bash(git log:*), Bash(git show:*), Bash(git remote show:*), Read, Glob, Grep, LS, Task
description: Complete a security review of the pending changes on the current branch
---

You are a senior security engineer conducting a focused security review of the changes on this branch.

GIT STATUS:

\`\`\`
!\`git status\`
\`\`\`

FILES MODIFIED:

\`\`\`
!\`git diff --name-only origin/HEAD...\`
\`\`\`

COMMITS:

\`\`\`
!\`git log --no-decorate origin/HEAD...\`
\`\`\`

DIFF CONTENT:

\`\`\`
!\`git diff --merge-base origin/HEAD\`
\`\`\`

Review the complete diff above. This contains all code changes in the PR.


OBJECTIVE:
Perform a security-focused code review to identify HIGH-CONFIDENCE security vulnerabilities that could have real exploitation potential. This is not a general code review - focus ONLY on security implications newly added by this PR. Do not comment on existing security concerns.

CRITICAL INSTRUCTIONS:
1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability
2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings
3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise
4. EXCLUSIONS: Do NOT report the following issue types:
   - Denial of Service (DOS) vulnerabilities, even if they allow service disruption
   - Secrets or sensitive data stored on disk (these are handled by other processes)
   - Rate limiting or resource exhaustion issues

SECURITY CATEGORIES TO EXAMINE:

**Input Validation Vulnerabilities:**
- SQL injection via unsanitized user input
- Command injection in system calls or subprocesses
- XXE injection in XML parsing
- Template injection in templating engines
- NoSQL injection in database queries
- Path traversal in file operations

**Authentication & Authorization Issues:**
- Authentication bypass logic
- Privilege escalation paths
- Session management flaws
- JWT token vulnerabilities
- Authorization logic bypasses

**Crypto & Secrets Management:**
- Hardcoded API keys, passwords, or tokens
- Weak cryptographic algorithms or implementations
- Improper key storage or management
- Cryptographic randomness issues
- Certificate validation bypasses

**Injection & Code Execution:**
- Remote code execution via deseralization
- Pickle injection in Python
- YAML deserialization vulnerabilities
- Eval injection in dynamic code execution
- XSS vulnerabilities in web applications (reflected, stored, DOM-based)

**Data Exposure:**
- Sensitive data logging or storage
- PII handling violations
- API endpoint data leakage
- Debug information exposure

Additional notes:
- Even if something is only exploitable from the local network, it can still be a HIGH severity issue

ANALYSIS METHODOLOGY:

Phase 1 - Repository Context Research (Use file search tools):
- Identify existing security frameworks and libraries in use
- Look for established secure coding patterns in the codebase
- Examine existing sanitization and validation patterns
- Understand the project's security model and threat model

Phase 2 - Comparative Analysis:
- Compare new code changes against existing security patterns
- Identify deviations from established secure practices
- Look for inconsistent security implementations
- Flag code that introduces new attack surfaces

Phase 3 - Vulnerability Assessment:
- Examine each modified file for security implications
- Trace data flow from user inputs to sensitive operations
- Look for privilege boundaries being crossed unsafely
- Identify injection points and unsafe deserialization

REQUIRED OUTPUT FORMAT:

You MUST output your findings in markdown. The markdown output should contain the file, line number, severity, category (e.g. \`sql_injection\` or \`xss\`), description, exploit scenario, and fix recommendation. 

For example:

# Vuln 1: XSS: \`foo.py:42\`

* Severity: High
* Description: User input from \`username\` parameter is directly interpolated into HTML without escaping, allowing reflected XSS attacks
* Exploit Scenario: Attacker crafts URL like /bar?q=<script>alert(document.cookie)</script> to execute JavaScript in victim's browser, enabling session hijacking or data theft
* Recommendation: Use Flask's escape() function or Jinja2 templates with auto-escaping enabled for all user inputs rendered in HTML

SEVERITY GUIDELINES:
- **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass
- **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact
- **LOW**: Defense-in-depth issues or lower-impact vulnerabilities

CONFIDENCE SCORING:
- 0.9-1.0: Certain exploit path identified, tested if possible
- 0.8-0.9: Clear vulnerability pattern with known exploitation methods
- 0.7-0.8: Suspicious pattern requiring specific conditions to exploit
- Below 0.7: Don't report (too speculative)

FINAL REMINDER:
Focus on HIGH and MEDIUM findings only. Better to miss some theoretical issues than flood the report with false positives. Each finding should be something a security engineer would confidently raise in a PR review.

FALSE POSITIVE FILTERING:

> You do not need to run commands to reproduce the vulnerability, just read the code to determine if it is a real vulnerability. Do not use the bash tool or write to any files.
>
> HARD EXCLUSIONS - Automatically exclude findings matching these patterns:
> 1. Denial of Service (DOS) vulnerabilities or resource exhaustion attacks.
> 2. Secrets or credentials stored on disk if they are otherwise secured.
> 3. Rate limiting concerns or service overload scenarios.
> 4. Memory consumption or CPU exhaustion issues.
> 5. Lack of input validation on non-security-critical fields without proven security impact.
> 6. Input sanitization concerns for GitHub Action workflows unless they are clearly triggerable via untrusted input.
> 7. A lack of hardening measures. Code is not expected to implement all security best practices, only flag concrete vulnerabilities.
> 8. Race conditions or timing attacks that are theoretical rather than practical issues. Only report a race condition if it is concretely problematic.
> 9. Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.
> 10. Memory safety issues such as buffer overflows or use-after-free-vulnerabilities are impossible in rust. Do not report memory safety issues in rust or any other memory safe languages.
> 11. Files that are only unit tests or only used as part of running tests.
> 12. Log spoofing concerns. Outputting un-sanitized user input to logs is not a vulnerability.
> 13. SSRF vulnerabilities that only control the path. SSRF is only a concern if it can control the host or protocol.
> 14. Including user-controlled content in AI system prompts is not a vulnerability.
> 15. Regex injection. Injecting untrusted content into a regex is not a vulnerability.
> 16. Regex DOS concerns.
> 16. Insecure documentation. Do not report any findings in documentation files such as markdown files.
> 17. A lack of audit logs is not a vulnerability.
> 
> PRECEDENTS -
> 1. Logging high value secrets in plaintext is a vulnerability. Logging URLs is assumed to be safe.
> 2. UUIDs can be assumed to be unguessable and do not need to be validated.
> 3. Environment variables and CLI flags are trusted values. Attackers are generally not able to modify them in a secure environment. Any attack that relies on controlling an environment variable is invalid.
> 4. Resource management issues such as memory or file descriptor leaks are not valid.
> 5. Subtle or low impact web vulnerabilities such as tabnabbing, XS-Leaks, prototype pollution, and open redirects should not be reported unless they are extremely high confidence.
> 6. React and Angular are generally secure against XSS. These frameworks do not need to sanitize or escape user input unless it is using dangerouslySetInnerHTML, bypassSecurityTrustHtml, or similar methods. Do not report XSS vulnerabilities in React or Angular components or tsx files unless they are using unsafe methods.
> 7. Most vulnerabilities in github action workflows are not exploitable in practice. Before validating a github action workflow vulnerability ensure it is concrete and has a very specific attack path.
> 8. A lack of permission checking or authentication in client-side JS/TS code is not a vulnerability. Client-side code is not trusted and does not need to implement these checks, they are handled on the server-side. The same applies to all flows that send untrusted data to the backend, the backend is responsible for validating and sanitizing all inputs.
> 9. Only include MEDIUM findings if they are obvious and concrete issues.
> 10. Most vulnerabilities in ipython notebooks (*.ipynb files) are not exploitable in practice. Before validating a notebook vulnerability ensure it is concrete and has a very specific attack path where untrusted input can trigger the vulnerability.
> 11. Logging non-PII data is not a vulnerability even if the data may be sensitive. Only report logging vulnerabilities if they expose sensitive information such as secrets, passwords, or personally identifiable information (PII).
> 12. Command injection vulnerabilities in shell scripts are generally not exploitable in practice since shell scripts generally do not run with untrusted user input. Only report command injection vulnerabilities in shell scripts if they are concrete and have a very specific attack path for untrusted input.
> 
> SIGNAL QUALITY CRITERIA - For remaining findings, assess:
> 1. Is there a concrete, exploitable vulnerability with a clear attack path?
> 2. Does this represent a real security risk vs theoretical best practice?
> 3. Are there specific code locations and reproduction steps?
> 4. Would this finding be actionable for a security team?
> 
> For each finding, assign a confidence score from 1-10:
> - 1-3: Low confidence, likely false positive or noise
> - 4-6: Medium confidence, needs investigation
> - 7-10: High confidence, likely true vulnerability

START ANALYSIS:

Begin your analysis now. Do this in 3 steps:

1. Use a sub-task to identify vulnerabilities. Use the repository exploration tools to understand the codebase context, then analyze the PR changes for security implications. In the prompt for this sub-task, include all of the above.
2. Then for each vulnerability identified by the above sub-task, create a new sub-task to filter out false-positives. Launch these sub-tasks as parallel sub-tasks. In the prompt for these sub-tasks, include everything in the "FALSE POSITIVE FILTERING" instructions.
3. Filter out any vulnerabilities where the sub-task reported a confidence less than 8.

Your final reply must contain the markdown report and nothing else.`,
  Xi2;
var Wi2 = T(() => {
  cwA();
  xS();
  Xi2 = {
    type: "prompt",
    name: "security-review",
    description:
      "Complete a security review of the pending changes on the current branch",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing code changes for security risks",
    userFacingName() {
      return "security-review";
    },
    source: "builtin",
    async getPromptForCommand(A, B) {
      let Q = GW(aAI),
        I = lc(Q.frontmatter["allowed-tools"]);
      return [
        {
          type: "text",
          text: await cc(
            Q.content,
            {
              ...B,
              async getAppState() {
                let Z = await B.getAppState();
                return {
                  ...Z,
                  toolPermissionContext: {
                    ...Z.toolPermissionContext,
                    alwaysAllowRules: {
                      ...Z.toolPermissionContext.alwaysAllowRules,
                      command: I,
                    },
                  },
                };
              },
            },
            "security-review",
          ),
        },
      ];
    },
  };
});
var F00, Fi2;
var Ci2 = T(() => {
  l01();
  ((F00 = IA(KA(), 1)),
    (Fi2 = {
      type: "local-jsx",
      name: "usage",
      description: "Show plan usage limits",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        return F00.createElement(w7A, {
          onClose: A,
          context: B,
          defaultTab: "Usage",
        });
      },
      userFacingName() {
        return "usage";
      },
    }));
});
function sAI() {
  let A = L1(),
    B = A.editorMode || "normal";
  if (B === "emacs") B = "normal";
  let Q = B === "normal" ? "vim" : "normal";
  return (
    n0({ ...A, editorMode: Q }),
    GA("tengu_editor_mode_changed", { mode: Q, source: "command" }),
    Promise.resolve({
      type: "text",
      value: `Editor mode set to ${Q}. ${Q === "vim" ? "Use Escape key to toggle between INSERT and NORMAL modes." : "Using standard (readline) keyboard bindings."}`,
    })
  );
}
var rAI, Vi2;
var Ki2 = T(() => {
  kB();
  H0();
  ((rAI = {
    name: "vim",
    description: "Toggle between Vim and Normal editing modes",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    type: "local",
    userFacingName: () => "vim",
    call: sAI,
  }),
    (Vi2 = rAI));
});
function Di2({ onCancel: A, onSubmit: B, ruleBehavior: Q }) {
  let [I, G] = C00.useState(""),
    [Z, Y] = C00.useState(0),
    J = IB();
  h1((C, V) => {
    if (V.escape) A();
  });
  let { columns: X } = aB(),
    W = X - 6,
    F = (C) => {
      let V = C.trim();
      if (V.length === 0) return;
      let K = jZ(V);
      B(K, Q);
    };
  return MI.createElement(
    MI.Fragment,
    null,
    MI.createElement(
      S,
      {
        flexDirection: "column",
        gap: 1,
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "permission",
      },
      MI.createElement(
        U,
        { bold: !0, color: "permission" },
        "Add ",
        Q,
        " permission rule",
      ),
      MI.createElement(
        S,
        { flexDirection: "column" },
        MI.createElement(
          U,
          null,
          "Permission rules are a tool name, optionally followed by a specifier in parentheses.",
          MI.createElement(AF, null),
          "e.g.,",
          " ",
          MI.createElement(U, { bold: !0 }, H5({ toolName: RJ.name })),
          MI.createElement(U, { bold: !1 }, " or "),
          MI.createElement(
            U,
            { bold: !0 },
            H5({ toolName: r2.name, ruleContent: "ls:*" }),
          ),
        ),
        MI.createElement(
          S,
          {
            borderDimColor: !0,
            borderStyle: "round",
            marginY: 1,
            paddingLeft: 1,
          },
          MI.createElement(O4, {
            showCursor: !0,
            value: I,
            onChange: G,
            onSubmit: F,
            placeholder: `Enter permission rule${E1.ellipsis}`,
            columns: W,
            cursorOffset: Z,
            onChangeCursorOffset: Y,
          }),
        ),
      ),
    ),
    MI.createElement(
      S,
      { marginLeft: 3 },
      J.pending
        ? MI.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            J.keyName,
            " again to exit",
          )
        : MI.createElement(
            U,
            { dimColor: !0 },
            "Enter to submit  Esc to cancel",
          ),
    ),
  );
}
var MI, C00;
var Ei2 = T(() => {
  nA();
  R9();
  f3();
  N8();
  gr();
  EF();
  rG();
  s2();
  ((MI = IA(KA(), 1)), (C00 = IA(KA(), 1)));
});
function zi2({
  onExit: A,
  getToolPermissionContext: B,
  onRequestAddDirectory: Q,
  onRequestRemoveDirectory: I,
}) {
  let G = B(),
    Z = xz.useMemo(() => {
      return Array.from(G.additionalWorkingDirectories.keys()).map((X) => ({
        path: X,
        isCurrent: !1,
        isDeletable: !0,
      }));
    }, [G.additionalWorkingDirectories]),
    Y = Hi2.useCallback(
      (X) => {
        if (X === "add-directory") {
          Q();
          return;
        }
        let W = Z.find((F) => F.path === X);
        if (W && W.isDeletable) I(W.path);
      },
      [Z, Q, I],
    ),
    J = xz.useMemo(() => {
      let X = Z.map((W) => ({ label: W.path, value: W.path }));
      return (
        X.push({
          label: `Add directory${E1.ellipsis}`,
          value: "add-directory",
        }),
        X
      );
    }, [Z]);
  return xz.createElement(
    S,
    { flexDirection: "column", marginBottom: 1 },
    xz.createElement(
      S,
      { flexDirection: "row", marginTop: 1, marginLeft: 2, gap: 1 },
      xz.createElement(U, null, `-  ${GQ()}`),
      xz.createElement(U, { dimColor: !0 }, "(Original working directory)"),
    ),
    xz.createElement($0, {
      options: J,
      onChange: Y,
      onCancel: () => A("Workspace dialog dismissed", { display: "system" }),
      visibleOptionCount: Math.min(10, J.length),
    }),
  );
}
var xz, Hi2;
var Ui2 = T(() => {
  nA();
  Z5();
  s2();
  i0();
  ((xz = IA(KA(), 1)), (Hi2 = IA(KA(), 1)));
});
function wi2({
  directoryPath: A,
  onRemove: B,
  onCancel: Q,
  permissionContext: I,
  setPermissionContext: G,
}) {
  let Z = IB();
  h1((X, W) => {
    if (W.escape) Q();
  });
  let Y = V00.useCallback(() => {
      let X = aF(I, {
        type: "removeDirectories",
        directories: [A],
        destination: "session",
      });
      (G(X), B());
    }, [A, I, G, B]),
    J = V00.useCallback(
      (X) => {
        if (X === "yes") Y();
        else Q();
      },
      [Y, Q],
    );
  return t7.createElement(
    t7.Fragment,
    null,
    t7.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "error",
      },
      t7.createElement(
        U,
        { bold: !0, color: "error" },
        "Remove directory from workspace?",
      ),
      t7.createElement(
        S,
        { marginY: 1, marginX: 2, flexDirection: "column" },
        t7.createElement(U, { bold: !0 }, A),
      ),
      t7.createElement(
        U,
        null,
        "Claude Code will no longer have access to files in this directory.",
      ),
      t7.createElement(
        S,
        { marginY: 1 },
        t7.createElement($0, {
          onChange: J,
          onCancel: Q,
          options: [
            { label: "Yes", value: "yes" },
            { label: "No", value: "no" },
          ],
        }),
      ),
    ),
    t7.createElement(
      S,
      { marginLeft: 3 },
      Z.pending
        ? t7.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            Z.keyName,
            " again to exit",
          )
        : t7.createElement(
            U,
            { dimColor: !0 },
            "/ to select  Enter to confirm  Esc to cancel",
          ),
    ),
  );
}
var t7, V00;
var $i2 = T(() => {
  nA();
  R9();
  Z5();
  aC();
  ((t7 = IA(KA(), 1)), (V00 = IA(KA(), 1)));
});
function oAI({ rule: A }) {
  return YB.createElement(U, { dimColor: !0 }, `From ${H00(A.source)}`);
}
function tAI(A) {
  switch (A) {
    case "allow":
      return "allowed";
    case "deny":
      return "denied";
    case "ask":
      return "ask";
  }
}
function eAI({ rule: A, onDelete: B, onCancel: Q }) {
  let I = IB();
  h1((Y, J) => {
    if (J.escape) Q();
  });
  let G = YB.createElement(
      S,
      { flexDirection: "column", marginX: 2 },
      YB.createElement(U, { bold: !0 }, H5(A.ruleValue)),
      YB.createElement(vB1, { ruleValue: A.ruleValue }),
      YB.createElement(oAI, { rule: A }),
    ),
    Z = YB.createElement(
      S,
      { marginLeft: 3 },
      I.pending
        ? YB.createElement(
            U,
            { dimColor: !0 },
            "Press ",
            I.keyName,
            " again to exit",
          )
        : YB.createElement(U, { dimColor: !0 }, "Esc to cancel"),
    );
  if (A.source === "policySettings")
    return YB.createElement(
      YB.Fragment,
      null,
      YB.createElement(
        S,
        {
          flexDirection: "column",
          gap: 1,
          borderStyle: "round",
          paddingLeft: 1,
          paddingRight: 1,
          borderColor: "permission",
        },
        YB.createElement(U, { bold: !0, color: "permission" }, "Rule details"),
        G,
        YB.createElement(
          U,
          { italic: !0 },
          "This rule is configured by managed settings and cannot be modified.",
          `
`,
          "Contact your system administrator for more information.",
        ),
      ),
      Z,
    );
  return YB.createElement(
    YB.Fragment,
    null,
    YB.createElement(
      S,
      {
        flexDirection: "column",
        gap: 1,
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "error",
      },
      YB.createElement(
        U,
        { bold: !0, color: "error" },
        "Delete ",
        tAI(A.ruleBehavior),
        " tool?",
      ),
      G,
      YB.createElement(
        U,
        null,
        "Are you sure you want to delete this permission rule?",
      ),
      YB.createElement($0, {
        onChange: (Y) => (Y === "yes" ? B() : Q()),
        onCancel: Q,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    Z,
  );
}
function xB1({ onExit: A, initialTab: B = "allow" }) {
  let [Q, I] = tF.useState([]),
    [{ toolPermissionContext: G }, Z] = lB(),
    [Y, J] = tF.useState(),
    [X, W] = tF.useState(null),
    [F, C] = tF.useState(null),
    [V, K] = tF.useState(!1),
    [D, E] = tF.useState(null),
    H = tF.useMemo(() => {
      let y = new Map();
      return (
        P7A(G).forEach((c) => {
          y.set(JSON.stringify(c), c);
        }),
        y
      );
    }, [G]),
    w = tF.useMemo(() => {
      let y = new Map();
      return (
        U7A(G).forEach((c) => {
          y.set(JSON.stringify(c), c);
        }),
        y
      );
    }, [G]),
    L = tF.useMemo(() => {
      let y = new Map();
      return (
        hB1(G).forEach((c) => {
          y.set(JSON.stringify(c), c);
        }),
        y
      );
    }, [G]),
    N = tF.useCallback(
      (y) => {
        let c = (() => {
            switch (y) {
              case "allow":
                return H;
              case "deny":
                return w;
              case "ask":
                return L;
              case "workspace":
                return new Map();
            }
          })(),
          e = [];
        if (y !== "workspace")
          e.push({
            label: `Add a new rule${E1.ellipsis}`,
            value: "add-new-rule",
          });
        let QA = Array.from(c.keys()).sort((WA, JA) => {
          let wA = c.get(WA),
            xA = c.get(JA);
          if (wA && xA) {
            let rA = H5(wA.ruleValue).toLowerCase(),
              qA = H5(xA.ruleValue).toLowerCase();
            return rA.localeCompare(qA);
          }
          return 0;
        });
        for (let WA of QA) {
          let JA = c.get(WA);
          if (JA) e.push({ label: H5(JA.ruleValue), value: WA });
        }
        return { options: e, rulesByKey: c };
      },
      [H, w, L],
    ),
    $ = IB(),
    O = tF.useCallback(
      (y, c) => {
        let { rulesByKey: e } = N(c);
        if (y === "add-new-rule") {
          W(c);
          return;
        } else {
          J(e.get(y));
          return;
        }
      },
      [N],
    ),
    P = tF.useCallback(() => {
      W(null);
    }, []),
    k = tF.useCallback((y, c) => {
      (C({ ruleValue: y, ruleBehavior: c }), W(null));
    }, []),
    b = tF.useCallback((y) => {
      C(null);
      for (let c of y)
        I((e) => [
          ...e,
          `Added ${c.ruleBehavior} rule ${iA.bold(H5(c.ruleValue))}`,
        ]);
    }, []),
    x = tF.useCallback(() => {
      C(null);
    }, []),
    n = () => {
      if (!Y) return;
      (Ni2({
        rule: Y,
        initialContext: G,
        setToolPermissionContext(y) {
          Z((c) => ({ ...c, toolPermissionContext: y }));
        },
      }),
        I((y) => [
          ...y,
          `Deleted ${Y.ruleBehavior} rule ${iA.bold(H5(Y.ruleValue))}`,
        ]),
        J(void 0));
    };
  if (Y)
    return YB.createElement(eAI, {
      rule: Y,
      onDelete: n,
      onCancel: () => J(void 0),
    });
  if (X && X !== "workspace")
    return YB.createElement(Di2, { onCancel: P, onSubmit: k, ruleBehavior: X });
  if (F)
    return YB.createElement(qi2, {
      onAddRules: b,
      onCancel: x,
      ruleValues: [F.ruleValue],
      ruleBehavior: F.ruleBehavior,
      initialContext: G,
      setToolPermissionContext: (y) => {
        Z((c) => ({ ...c, toolPermissionContext: y }));
      },
    });
  if (V)
    return YB.createElement(fB1, {
      onAddDirectory: (y, c) => {
        let QA = {
            type: "addDirectories",
            directories: [y],
            destination: c ? "localSettings" : "session",
          },
          WA = aF(G, QA);
        if ((Z((JA) => ({ ...JA, toolPermissionContext: WA })), c)) wb(QA);
        (I((JA) => [
          ...JA,
          `Added directory ${iA.bold(y)} to workspace${c ? " and saved to local settings" : " for this session"}`,
        ]),
          K(!1));
      },
      onCancel: () => K(!1),
      permissionContext: G,
    });
  if (D)
    return YB.createElement(wi2, {
      directoryPath: D,
      onRemove: () => {
        (I((y) => [...y, `Removed directory ${iA.bold(D)} from workspace`]),
          E(null));
      },
      onCancel: () => E(null),
      permissionContext: G,
      setPermissionContext: (y) => {
        Z((c) => ({ ...c, toolPermissionContext: y }));
      },
    });
  function m(y) {
    switch (y) {
      case "allow":
        return "Claude Code won't ask before using allowed tools.";
      case "deny":
        return "Claude Code will always reject requests to use denied tools.";
      case "ask":
        return "Claude Code will always ask for confirmation before using these tools.";
      case "workspace":
        return "Claude Code can read files in the workspace, and make edits when auto-accept edits is on.";
    }
  }
  function o(y) {
    if (y === "workspace")
      return YB.createElement(zi2, {
        onExit: A,
        getToolPermissionContext: () => G,
        onRequestAddDirectory: () => K(!0),
        onRequestRemoveDirectory: (e) => E(e),
      });
    let { options: c } = N(y);
    return YB.createElement(
      S,
      { marginY: 1 },
      YB.createElement($0, {
        options: c,
        onChange: (e) => O(e, y),
        onCancel: () => {
          if (Q.length > 0)
            A(
              Q.join(`
`),
            );
          else A("Permissions dialog dismissed", { display: "system" });
        },
        visibleOptionCount: Math.min(10, c.length),
      }),
    );
  }
  return YB.createElement(
    S,
    { flexDirection: "column" },
    YB.createElement(p5, { dividerColor: "permission" }),
    YB.createElement(
      S,
      { paddingX: 1, flexDirection: "column" },
      YB.createElement(
        tc,
        {
          title: "Permissions:",
          color: "permission",
          defaultTab: B,
          hidden: !!Y || !!X || !!F || V || !!D,
        },
        YB.createElement(
          LV,
          { id: "allow", title: "Allow" },
          YB.createElement(
            S,
            { flexDirection: "column" },
            YB.createElement(U, null, m("allow")),
            o("allow"),
          ),
        ),
        YB.createElement(
          LV,
          { id: "ask", title: "Ask" },
          YB.createElement(
            S,
            { flexDirection: "column" },
            YB.createElement(U, null, m("ask")),
            o("ask"),
          ),
        ),
        YB.createElement(
          LV,
          { id: "deny", title: "Deny" },
          YB.createElement(
            S,
            { flexDirection: "column" },
            YB.createElement(U, null, m("deny")),
            o("deny"),
          ),
        ),
        YB.createElement(
          LV,
          { id: "workspace", title: "Workspace" },
          YB.createElement(
            S,
            { flexDirection: "column" },
            YB.createElement(U, null, m("workspace")),
            o("workspace"),
          ),
        ),
      ),
      YB.createElement(
        S,
        { marginTop: 1 },
        YB.createElement(
          U,
          { dimColor: !0 },
          $.pending
            ? YB.createElement(
                YB.Fragment,
                null,
                "Press ",
                $.keyName,
                " again to exit",
              )
            : YB.createElement(
                YB.Fragment,
                null,
                "Press  to navigate  Enter to select  Esc to exit",
              ),
        ),
      ),
    ),
  );
}
var YB, tF;
var K00 = T(() => {
  nA();
  Z5();
  R9();
  f3();
  s2();
  D00();
  bB1();
  Ei2();
  f2();
  Ui2();
  E00();
  $i2();
  aC();
  c9();
  U$A();
  iC();
  ((YB = IA(KA(), 1)), (tF = IA(KA(), 1)));
});
var z00, A1I, Li2;
var Mi2 = T(() => {
  K00();
  ((z00 = IA(KA(), 1)),
    (A1I = {
      type: "local-jsx",
      name: "permissions",
      aliases: ["allowed-tools"],
      description: "Manage allow & deny tool permission rules",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A) {
        return z00.createElement(xB1, { onExit: A });
      },
      userFacingName() {
        return "permissions";
      },
    }),
    (Li2 = A1I));
});
function Oi2(A, B, Q) {
  if (A !== null && A.grove_enabled !== null) return !1;
  if (Q) return !0;
  if (B !== null && !B.notice_is_grace_period) return !0;
  let G = B?.notice_reminder_frequency;
  if (G !== null && G !== void 0 && A?.grove_notice_viewed_at)
    return (
      Math.floor(
        (Date.now() - new Date(A.grove_notice_viewed_at).getTime()) / 86400000,
      ) >= G
    );
  else {
    let Z = A?.grove_notice_viewed_at;
    return Z === null || Z === void 0;
  }
}
function Q1I() {
  return NB.default.createElement(
    NB.default.Fragment,
    null,
    NB.default.createElement(
      S,
      { flexDirection: "column" },
      NB.default.createElement(
        U,
        { bold: !0, color: "professionalBlue" },
        "Updates to Consumer Terms and Policies",
      ),
      NB.default.createElement(
        U,
        null,
        "An update to our Consumer Terms and Privacy Policy will take effect on",
        " ",
        NB.default.createElement(U, { bold: !0 }, "October 8, 2025"),
        ". You can accept the updated terms today.",
      ),
    ),
    NB.default.createElement(
      S,
      { flexDirection: "column" },
      NB.default.createElement(U, null, "What's changing?"),
      NB.default.createElement(
        S,
        { paddingLeft: 1 },
        NB.default.createElement(
          U,
          null,
          NB.default.createElement(U, null, " "),
          NB.default.createElement(
            U,
            { bold: !0 },
            "You can help improve Claude ",
          ),
          NB.default.createElement(
            U,
            null,
            " Allow the use of your chats and coding sessions to train and improve Anthropic AI models. Change anytime in your Privacy Settings (",
            NB.default.createElement(R8, {
              url: "https://claude.ai/settings/data-privacy-controls",
            }),
            ").",
          ),
        ),
      ),
      NB.default.createElement(
        S,
        { paddingLeft: 1 },
        NB.default.createElement(
          U,
          null,
          NB.default.createElement(U, null, " "),
          NB.default.createElement(
            U,
            { bold: !0 },
            "Updates to data retention ",
          ),
          NB.default.createElement(
            U,
            null,
            " To help us improve our AI models and safety protections, we're extending data retention to 5 years.",
          ),
        ),
      ),
    ),
    NB.default.createElement(
      U,
      null,
      "Learn more (",
      NB.default.createElement(R8, {
        url: "https://www.anthropic.com/news/updates-to-our-consumer-terms",
      }),
      ") or read the updated Consumer Terms (",
      NB.default.createElement(R8, {
        url: "https://anthropic.com/legal/terms",
      }),
      ") and Privacy Policy (",
      NB.default.createElement(R8, {
        url: "https://anthropic.com/legal/privacy",
      }),
      ")",
    ),
  );
}
function I1I() {
  return NB.default.createElement(
    NB.default.Fragment,
    null,
    NB.default.createElement(
      S,
      { flexDirection: "column" },
      NB.default.createElement(
        U,
        { bold: !0, color: "professionalBlue" },
        "Updates to Consumer Terms and Policies",
      ),
      NB.default.createElement(
        U,
        null,
        "We've updated our Consumer Terms and Privacy Policy.",
      ),
    ),
    NB.default.createElement(
      S,
      { flexDirection: "column", gap: 1 },
      NB.default.createElement(U, null, "What's changing?"),
      NB.default.createElement(
        S,
        { flexDirection: "column" },
        NB.default.createElement(U, { bold: !0 }, "Help improve Claude"),
        NB.default.createElement(
          U,
          null,
          "Allow the use of your chats and coding sessions to train and improve Anthropic AI models. You can change this anytime in Privacy Settings",
        ),
        NB.default.createElement(R8, {
          url: "https://claude.ai/settings/data-privacy-controls",
        }),
      ),
      NB.default.createElement(
        S,
        { flexDirection: "column" },
        NB.default.createElement(
          U,
          { bold: !0 },
          "How this affects data retention",
        ),
        NB.default.createElement(
          U,
          null,
          "Turning ON the improve Claude setting extends data retention from 30 days to 5 years. Turning it OFF keeps the default 30-day data retention. Delete data anytime.",
        ),
      ),
    ),
    NB.default.createElement(
      U,
      null,
      "Learn more (",
      NB.default.createElement(R8, {
        url: "https://www.anthropic.com/news/updates-to-our-consumer-terms",
      }),
      ") or read the updated Consumer Terms (",
      NB.default.createElement(R8, {
        url: "https://anthropic.com/legal/terms",
      }),
      ") and Privacy Policy (",
      NB.default.createElement(R8, {
        url: "https://anthropic.com/legal/privacy",
      }),
      ")",
    ),
  );
}
function gB1({ showIfAlreadyViewed: A, location: B, onDone: Q }) {
  let [I, G] = NB.useState(null),
    [Z, Y] = NB.useState(null),
    J = IB();
  if (
    (NB.useEffect(() => {
      async function F() {
        let [C, V] = await Promise.all([pIA(), Fc()]);
        Y(V);
        let K = Oi2(C, V, A);
        if ((G(K), !K)) {
          Q("skip_rendering");
          return;
        }
        (An1(),
          GA("tengu_grove_policy_viewed", {
            location: B,
            dismissable: V?.notice_is_grace_period,
          }));
      }
      F();
    }, [A, B, Q]),
    I === null)
  )
    return null;
  if (!I) return null;
  async function X(F) {
    switch (F) {
      case "accept_opt_in": {
        (await ctA(!0),
          GA("tengu_grove_policy_submitted", {
            state: !0,
            dismissable: Z?.notice_is_grace_period,
          }));
        break;
      }
      case "accept_opt_out": {
        (await ctA(!1),
          GA("tengu_grove_policy_submitted", {
            state: !1,
            dismissable: Z?.notice_is_grace_period,
          }));
        break;
      }
      case "defer":
        GA("tengu_grove_policy_dismissed", { state: !0 });
        break;
      case "escape":
        GA("tengu_grove_policy_escaped", {});
        break;
    }
    Q(F);
  }
  let W = Z?.domain_excluded
    ? [
        {
          label:
            "Accept terms  Help improve Claude: OFF (for emails with your domain)",
          value: "accept_opt_out",
        },
      ]
    : [
        {
          label: "Accept terms  Help improve Claude: ON",
          value: "accept_opt_in",
        },
        {
          label: "Accept terms  Help improve Claude: OFF",
          value: "accept_opt_out",
        },
      ];
  return NB.default.createElement(
    NB.default.Fragment,
    null,
    NB.default.createElement(
      S,
      {
        flexDirection: "column",
        width: 100,
        gap: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        borderStyle: "round",
        borderColor: "professionalBlue",
      },
      NB.default.createElement(
        S,
        { flexDirection: "row" },
        NB.default.createElement(
          S,
          { flexDirection: "column", gap: 1, flexGrow: 1 },
          Z?.notice_is_grace_period
            ? NB.default.createElement(Q1I, null)
            : NB.default.createElement(I1I, null),
        ),
        NB.default.createElement(
          S,
          { flexShrink: 0 },
          NB.default.createElement(U, { color: "professionalBlue" }, B1I),
        ),
      ),
      NB.default.createElement(
        S,
        {
          flexDirection: "column",
          gap: 1,
          padding: 1,
          borderStyle: "round",
          borderColor: "professionalBlue",
        },
        NB.default.createElement(
          S,
          { flexDirection: "column" },
          NB.default.createElement(
            U,
            { bold: !0 },
            "Please select how you'd like to continue",
          ),
          NB.default.createElement(
            U,
            null,
            "Your choice takes effect immediately upon confirmation.",
          ),
        ),
        NB.default.createElement($0, {
          options: [
            ...W,
            ...(Z?.notice_is_grace_period
              ? [{ label: "Not now", value: "defer" }]
              : []),
          ],
          onChange: (F) => X(F),
          onCancel: () => {
            if (Z?.notice_is_grace_period) {
              X("defer");
              return;
            }
            X("escape");
          },
        }),
      ),
    ),
    NB.default.createElement(
      S,
      { marginLeft: 1 },
      NB.default.createElement(
        U,
        { dimColor: !0 },
        J.pending
          ? NB.default.createElement(
              NB.default.Fragment,
              null,
              "Press ",
              J.keyName,
              " again to exit",
            )
          : NB.default.createElement(
              NB.default.Fragment,
              null,
              "Enter to confirm  Esc to exit",
            ),
      ),
    ),
  );
}
function Ri2({ settings: A, domainExcluded: B, onDone: Q }) {
  let I = IB(),
    [G, Z] = NB.useState(A.grove_enabled);
  (NB.default.useEffect(() => {
    GA("tengu_grove_privacy_settings_viewed", {});
  }, []),
    h1(async (J, X) => {
      if (X.escape) Q();
      if (!B && (X.tab || X.return || J === " ")) {
        let W = !G;
        (Z(W), await ctA(W));
      }
    }));
  let Y = NB.default.createElement(U, { color: "error" }, "false");
  if (B)
    Y = NB.default.createElement(
      U,
      { color: "error" },
      "false (for emails with your domain)",
    );
  else if (G) Y = NB.default.createElement(U, { color: "success" }, "true");
  return NB.default.createElement(
    NB.default.Fragment,
    null,
    NB.default.createElement(
      S,
      {
        flexDirection: "column",
        gap: 1,
        padding: 1,
        borderStyle: "round",
        borderColor: "professionalBlue",
      },
      NB.default.createElement(
        S,
        { flexDirection: "column", gap: 1 },
        NB.default.createElement(
          U,
          { bold: !0, color: "professionalBlue" },
          "Data Privacy",
        ),
        NB.default.createElement(
          U,
          null,
          "Review and manage your privacy settings at",
          " ",
          NB.default.createElement(R8, {
            url: "https://claude.ai/settings/data-privacy-controls",
          }),
        ),
        NB.default.createElement(
          S,
          null,
          NB.default.createElement(
            S,
            { width: 44 },
            NB.default.createElement(U, { bold: !0 }, "Help improve Claude"),
          ),
          NB.default.createElement(S, null, Y),
        ),
      ),
    ),
    NB.default.createElement(
      S,
      { marginLeft: 1 },
      B
        ? NB.default.createElement(
            U,
            { dimColor: !0 },
            I.pending
              ? NB.default.createElement(
                  NB.default.Fragment,
                  null,
                  "Press ",
                  I.keyName,
                  " again to exit",
                )
              : NB.default.createElement(
                  NB.default.Fragment,
                  null,
                  "Esc to exit",
                ),
          )
        : NB.default.createElement(
            U,
            { dimColor: !0 },
            I.pending
              ? NB.default.createElement(
                  NB.default.Fragment,
                  null,
                  "Press ",
                  I.keyName,
                  " again to exit",
                )
              : NB.default.createElement(
                  NB.default.Fragment,
                  null,
                  "Enter/Tab/Space to toggle  Esc to exit",
                ),
          ),
    ),
  );
}
async function Ti2() {
  let [A, B] = await Promise.all([pIA(), Fc()]);
  if (Oi2(A, B, !1))
    if (
      (GA("tengu_grove_print_viewed", {
        dismissable: B?.notice_is_grace_period,
      }),
      B === null || B.notice_is_grace_period)
    )
      (JT(`
An update to our Consumer Terms and Privacy Policy will take effect on October 8, 2025. Run \`claude\` to review the updated terms.

`),
        await An1());
    else
      (JT(`
[ACTION REQUIRED] An update to our Consumer Terms and Privacy Policy has taken effect on October 8, 2025. You must run \`claude\` to review the updated terms.

`),
        await P6(1));
}
var NB,
  B1I = ` _____________
 |          \\  \\
 | NEW TERMS \\__\\
 |              |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |              |
 |______________|`;
var uB1 = T(() => {
  nA();
  R5();
  H0();
  R9();
  iIA();
  xY();
  vK();
  NB = IA(KA(), 1);
});
var S$A,
  Pi2 =
    "Review and manage your privacy settings at https://claude.ai/settings/data-privacy-controls",
  G1I,
  ji2;
var Si2 = T(() => {
  uB1();
  iIA();
  H0();
  F2();
  ((S$A = IA(KA(), 1)),
    (G1I = {
      type: "local-jsx",
      name: "privacy-settings",
      description: "View and update your privacy settings",
      isEnabled: () => {
        return ptA();
      },
      isHidden: !1,
      async call(A) {
        if (!(await lIA())) return (A(Pi2), null);
        let [Q, I] = await Promise.all([pIA(), Fc()]);
        if (Q === null) return (A(Pi2), null);
        async function G(Y) {
          if (Y === "escape" || Y === "defer") {
            A("Privacy settings dialog dismissed", { display: "system" });
            return;
          }
          await Z();
        }
        async function Z() {
          let Y = await pIA();
          if (Y === null) {
            A("Unable to retrieve updated privacy settings", {
              display: "system",
            });
            return;
          }
          let J = Y.grove_enabled ? "true" : "false";
          if (
            (A(`"Help improve Claude" set to ${J}.`),
            Q !== null &&
              Q.grove_enabled !== null &&
              Q.grove_enabled !== Y.grove_enabled)
          )
            GA("tengu_grove_policy_toggled", {
              state: Y.grove_enabled,
              location: "settings",
            });
        }
        if (Q.grove_enabled !== null)
          return S$A.createElement(Ri2, {
            settings: Q,
            domainExcluded: I?.domain_excluded,
            onDone: Z,
          });
        return S$A.createElement(gB1, {
          showIfAlreadyViewed: !0,
          onDone: G,
          location: "settings",
        });
      },
      userFacingName() {
        return "privacy-settings";
      },
    }),
    (ji2 = G1I));
});
function yi2({
  event: A,
  eventSummary: B,
  config: Q,
  matcher: I,
  onSuccess: G,
  onCancel: Z,
}) {
  let [Y, J] = U00.useState(!1),
    [X, W] = U00.useState(null),
    F = j7A.map(w00),
    C = async (V) => {
      (J(!0), W(null));
      try {
        (await _i2(A, Q, I, V), G());
      } catch (K) {
        (W(K instanceof Error ? K.message : "Failed to add hook"), J(!1));
      }
    };
  if (Y)
    return t5.createElement(
      S,
      { flexDirection: "column", gap: 1 },
      t5.createElement(
        S,
        { flexDirection: "row", gap: 1 },
        t5.createElement(E8, null),
        t5.createElement(U, null, "Adding hook configuration..."),
      ),
    );
  if (X)
    return t5.createElement(
      S,
      {
        flexDirection: "column",
        gap: 1,
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "error",
      },
      t5.createElement(U, { bold: !0, color: "error" }, "Failed to add hook"),
      t5.createElement(U, null, X),
      t5.createElement($0, {
        options: [{ label: "OK", value: "ok" }],
        onChange: Z,
        onCancel: Z,
      }),
    );
  return t5.createElement(
    S,
    {
      flexDirection: "column",
      gap: 1,
      borderStyle: "round",
      paddingLeft: 1,
      paddingRight: 1,
      borderColor: "success",
    },
    t5.createElement(
      U,
      { bold: !0, color: "success" },
      "Save hook configuration",
    ),
    t5.createElement(
      S,
      { flexDirection: "column", marginX: 2 },
      t5.createElement(U, null, "Event: ", A, " - ", B),
      t5.createElement(U, null, "Matcher: ", I),
      t5.createElement(
        U,
        null,
        Q.type === "command" ? "Command" : "Prompt",
        ":",
        " ",
        vz(Q),
      ),
    ),
    t5.createElement(U, null, "Where should this hook be saved?"),
    t5.createElement($0, {
      options: F,
      onChange: (V) => C(V),
      onCancel: Z,
      visibleOptionCount: 3,
    }),
  );
}
var t5, U00;
var ki2 = T(() => {
  nA();
  zy();
  Z5();
  xX();
  bB1();
  ((t5 = IA(KA(), 1)), (U00 = IA(KA(), 1)));
});
function xi2({
  hookEventMetadata: A,
  exitStatePending: B,
  exitStateKeyName: Q,
  configDifference: I,
  onSelectEvent: G,
}) {
  return q2.createElement(
    q2.Fragment,
    null,
    q2.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "warning",
      },
      q2.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        q2.createElement(
          S,
          null,
          q2.createElement(
            U,
            { bold: !0, color: "warning" },
            "Hook Configuration",
          ),
        ),
        q2.createElement(
          S,
          { flexDirection: "column" },
          q2.createElement(
            S,
            { marginY: 1 },
            q2.createElement(
              U,
              null,
              iA.bold("Hooks"),
              " are shell commands you can register to run during Claude Code processing.",
              " ",
              q2.createElement(
                R8,
                { url: "https://docs.claude.com/en/docs/claude-code/hooks" },
                "Docs",
              ),
            ),
          ),
          q2.createElement(
            S,
            { flexDirection: "column", paddingTop: 1 },
            q2.createElement(
              U,
              null,
              " Each hook event has its own input and output behavior",
            ),
            q2.createElement(
              U,
              null,
              " Multiple hooks can be registered per event, executed in parallel",
            ),
            q2.createElement(
              U,
              null,
              " Any changes to hooks outside of /hooks require a restart",
            ),
            q2.createElement(U, null, " Timeout: 60 seconds"),
          ),
        ),
        q2.createElement(
          S,
          { flexDirection: "column", marginY: 1 },
          q2.createElement(
            U,
            null,
            E1.warning,
            " Hooks execute shell commands with your full user permissions. This can pose security risks, so only use hooks from trusted sources.",
          ),
          q2.createElement(
            U,
            { dimColor: !0 },
            "Learn more:",
            " ",
            q2.createElement(
              R8,
              { url: "https://docs.claude.com/en/docs/claude-code/hooks" },
              "https://docs.claude.com/en/docs/claude-code/hooks",
            ),
          ),
        ),
        I &&
          q2.createElement(
            S,
            {
              borderStyle: "round",
              borderColor: "warning",
              paddingX: 1,
              marginY: 1,
            },
            q2.createElement(
              S,
              { flexDirection: "column" },
              q2.createElement(
                U,
                { bold: !0, color: "warning" },
                E1.warning,
                " Settings Changed",
              ),
              q2.createElement(
                U,
                null,
                "Hook settings have been modified outside of this menu. Review the following changes carefully:",
              ),
              q2.createElement(U, { dimColor: !0 }, I),
            ),
          ),
      ),
      q2.createElement(
        S,
        { flexDirection: "column" },
        q2.createElement(U, { bold: !0 }, "Select hook event:"),
        q2.createElement($0, {
          onChange: (Z) => {
            if (Z === "disable-all") G("disable-all");
            else G(Z);
          },
          onCancel: () => {},
          options: [
            ...Object.entries(A).map(([Z, Y]) => ({
              label: `${Z} - ${Y.summary}`,
              value: Z,
            })),
            { label: iA.red("Disable all hooks"), value: "disable-all" },
          ],
        }),
      ),
    ),
    q2.createElement(
      S,
      { marginLeft: 3 },
      B
        ? q2.createElement(U, { dimColor: !0 }, "Press ", Q, " again to exit")
        : q2.createElement(
            U,
            { dimColor: !0 },
            "Enter to select  Esc to exit",
          ),
    ),
  );
}
var q2;
var vi2 = T(() => {
  nA();
  Z5();
  f2();
  s2();
  vK();
  q2 = IA(KA(), 1);
});
function bi2({
  selectedEvent: A,
  matchersForSelectedEvent: B,
  hooksByEventAndMatcher: Q,
  eventDescription: I,
  onSelect: G,
  onCancel: Z,
}) {
  let Y = A7.useMemo(() => {
    return B.map((J) => {
      let X = Q[A]?.[J] || [],
        W = Array.from(new Set(X.map((F) => F.source)));
      return { matcher: J, sources: W, hookCount: X.length };
    });
  }, [B, Q, A]);
  return A7.createElement(
    A7.Fragment,
    null,
    A7.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "suggestion",
      },
      A7.createElement(
        U,
        { bold: !0, color: "suggestion" },
        A,
        " - Tool Matchers",
      ),
      I &&
        A7.createElement(
          S,
          { marginTop: 1 },
          A7.createElement(U, { dimColor: !0 }, I),
        ),
      A7.createElement(
        S,
        { marginY: 1 },
        A7.createElement($0, {
          options: [
            { label: `+ Add new matcher${E1.ellipsis}`, value: "add-new" },
            ...Y.map((J) => {
              return {
                label: `[${J.sources.map(hi2).join(", ")}] ${J.matcher}`,
                value: J.matcher,
                description: `${J.hookCount} hook${J.hookCount !== 1 ? "s" : ""}`,
              };
            }),
          ],
          onChange: (J) => {
            if (J === "add-new") G(null);
            else G(J);
          },
          onCancel: Z,
        }),
        B.length === 0 &&
          A7.createElement(
            S,
            { marginLeft: 2 },
            A7.createElement(U, { dimColor: !0 }, "No matchers configured yet"),
          ),
      ),
    ),
    A7.createElement(
      S,
      { marginLeft: 3 },
      A7.createElement(U, { dimColor: !0 }, "Enter to select  Esc to go back"),
    ),
  );
}
var A7;
var fi2 = T(() => {
  nA();
  s2();
  zy();
  Z5();
  A7 = IA(KA(), 1);
});
function gi2({
  selectedEvent: A,
  newMatcher: B,
  onChangeNewMatcher: Q,
  eventDescription: I,
  matcherMetadata: G,
}) {
  let [Z, Y] = B6.useState(B.length);
  return B6.createElement(
    B6.Fragment,
    null,
    B6.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "success",
        gap: 1,
      },
      B6.createElement(
        U,
        { bold: !0, color: "success" },
        "Add new matcher for ",
        A,
      ),
      I &&
        B6.createElement(
          S,
          { marginBottom: 1 },
          B6.createElement(U, { dimColor: !0 }, I),
        ),
      B6.createElement(
        S,
        { flexDirection: "column", gap: 1 },
        B6.createElement(
          U,
          null,
          "Possible matcher values for field ",
          G.fieldToMatch,
          ":",
        ),
        B6.createElement(U, { dimColor: !0 }, G.values.join(", ")),
      ),
      B6.createElement(
        S,
        { flexDirection: "column" },
        B6.createElement(U, null, "Tool matcher:"),
        B6.createElement(
          S,
          {
            borderStyle: "round",
            borderDimColor: !0,
            paddingLeft: 1,
            paddingRight: 1,
          },
          B6.createElement(O4, {
            value: B,
            onChange: Q,
            columns: 78,
            showCursor: !0,
            cursorOffset: Z,
            onChangeCursorOffset: Y,
          }),
        ),
      ),
      B6.createElement(
        S,
        { flexDirection: "column", gap: 1 },
        B6.createElement(
          U,
          { dimColor: !0 },
          "Example Matchers:",
          `
`,
          " Write (single tool)",
          `
`,
          " Write|Edit (multiple tools)",
          `
`,
          " Web.* (regex pattern)",
        ),
      ),
    ),
    B6.createElement(
      S,
      { marginLeft: 3 },
      B6.createElement(U, { dimColor: !0 }, "Enter to confirm  Esc to cancel"),
    ),
  );
}
var B6;
var ui2 = T(() => {
  nA();
  rG();
  B6 = IA(KA(), 1);
});
function mi2({
  selectedEvent: A,
  selectedMatcher: B,
  eventDescription: Q,
  fullDescription: I,
  supportsMatcher: G,
  command: Z,
  onChangeCommand: Y,
}) {
  let [J, X] = c2.useState(Z.length),
    { columns: W } = aB(),
    F = Z.trim().split(/\s+/)[0] || "",
    C = F && !F.startsWith("/") && !F.startsWith("~") && F.includes("/"),
    V = /\bsudo\b/.test(Z);
  return c2.createElement(
    c2.Fragment,
    null,
    c2.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "success",
        gap: 1,
      },
      c2.createElement(U, { bold: !0, color: "success" }, "Add new hook"),
      c2.createElement(
        S,
        { flexDirection: "column" },
        c2.createElement(
          U,
          null,
          E1.warning,
          " Hooks execute shell commands with your full user permissions. This can pose security risks, so only use hooks from trusted sources.",
        ),
        c2.createElement(
          U,
          { dimColor: !0 },
          "Learn more:",
          " ",
          c2.createElement(
            R8,
            { url: "https://docs.claude.com/en/docs/claude-code/hooks" },
            "https://docs.claude.com/en/docs/claude-code/hooks",
          ),
        ),
      ),
      c2.createElement(
        U,
        null,
        "Event: ",
        c2.createElement(U, { bold: !0 }, A),
        " - ",
        Q,
      ),
      I && c2.createElement(S, null, c2.createElement(U, { dimColor: !0 }, I)),
      G &&
        c2.createElement(
          U,
          null,
          "Matcher: ",
          c2.createElement(U, { bold: !0 }, B),
        ),
      c2.createElement(U, null, "Command:"),
      c2.createElement(
        S,
        {
          borderStyle: "round",
          borderDimColor: !0,
          paddingLeft: 1,
          paddingRight: 1,
        },
        c2.createElement(O4, {
          value: Z,
          onChange: Y,
          columns: W - 8,
          showCursor: !0,
          cursorOffset: J,
          onChangeCursorOffset: X,
          multiline: !0,
        }),
      ),
      (C || V) &&
        c2.createElement(
          S,
          { flexDirection: "column", gap: 0 },
          C &&
            c2.createElement(
              U,
              { color: "warning" },
              E1.warning,
              " Warning: Using a relative path for the executable may be insecure. Consider using an absolute path instead.",
            ),
          V &&
            c2.createElement(
              U,
              { color: "warning" },
              E1.warning,
              " Warning: Using sudo in hooks can be dangerous and may expose your system to security risks.",
            ),
        ),
      c2.createElement(
        U,
        { dimColor: !0 },
        "Examples:",
        c2.createElement(AF, null),
        ` jq -r '.tool_input.file_path | select(endswith(".go"))' | xargs -r gofmt -w`,
        c2.createElement(AF, null),
        ` jq -r '"\\(.tool_input.command) - \\(.tool_input.description // "No description")"' >> ~/.claude/bash-command-log.txt`,
        c2.createElement(AF, null),
        " /usr/local/bin/security_check.sh",
        c2.createElement(AF, null),
        " python3 ~/hooks/validate_changes.py",
      ),
    ),
    c2.createElement(
      S,
      { marginLeft: 3 },
      c2.createElement(U, { dimColor: !0 }, "Enter to confirm  Esc to cancel"),
    ),
  );
}
var c2;
var di2 = T(() => {
  nA();
  rG();
  s2();
  vK();
  N8();
  c2 = IA(KA(), 1);
});
function ci2({
  selectedMatcher: A,
  selectedEvent: B,
  onDelete: Q,
  onCancel: I,
}) {
  return DZ.createElement(
    DZ.Fragment,
    null,
    DZ.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "error",
        gap: 1,
      },
      DZ.createElement(U, { bold: !0, color: "error" }, "Delete matcher?"),
      DZ.createElement(
        S,
        { flexDirection: "column", marginX: 2 },
        DZ.createElement(U, { bold: !0 }, A),
        DZ.createElement(U, { color: "text" }, "Event: ", B),
      ),
      DZ.createElement(
        U,
        null,
        "This matcher has no hooks configured. Delete it?",
      ),
      DZ.createElement($0, {
        onChange: (G) => (G === "yes" ? Q() : I()),
        onCancel: I,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    DZ.createElement(
      S,
      { marginLeft: 3 },
      DZ.createElement(U, { dimColor: !0 }, "Enter to confirm  Esc to cancel"),
    ),
  );
}
var DZ;
var pi2 = T(() => {
  nA();
  Z5();
  DZ = IA(KA(), 1);
});
function li2({
  selectedEvent: A,
  selectedMatcher: B,
  hooksForSelectedMatcher: Q,
  hookEventMetadata: I,
  onSelect: G,
  onCancel: Z,
}) {
  return e7.createElement(
    e7.Fragment,
    null,
    e7.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "success",
      },
      e7.createElement(
        U,
        { bold: !0, color: "success" },
        A,
        I.matcherMetadata !== void 0 ? ` - Matcher: ${B}` : "",
      ),
      I.description &&
        e7.createElement(
          S,
          { marginTop: 1 },
          e7.createElement(U, { dimColor: !0 }, I.description),
        ),
      e7.createElement(
        S,
        { marginY: 1 },
        e7.createElement($0, {
          options: [
            { label: `+ Add new hook${E1.ellipsis}`, value: "add-new" },
            ...Q.map((Y, J) => ({
              label: vz(Y.config),
              value: J.toString(),
              description: ni2(Y.source),
            })),
          ],
          onChange: (Y) => {
            if (Y === "add-new") G(null);
            else {
              let J = parseInt(Y, 10),
                X = Q[J];
              if (X) G(X);
            }
          },
          onCancel: Z,
        }),
        Q.length === 0 &&
          e7.createElement(
            S,
            { marginLeft: 2 },
            e7.createElement(U, { dimColor: !0 }, "No hooks configured yet"),
          ),
      ),
    ),
    e7.createElement(
      S,
      { marginLeft: 3 },
      e7.createElement(U, { dimColor: !0 }, "Enter to select  Esc to go back"),
    ),
  );
}
var e7;
var ii2 = T(() => {
  s2();
  nA();
  zy();
  Z5();
  e7 = IA(KA(), 1);
});
function ai2({
  selectedHook: A,
  eventSupportsMatcher: B,
  onDelete: Q,
  onCancel: I,
}) {
  return B7.createElement(
    B7.Fragment,
    null,
    B7.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "error",
        gap: 1,
      },
      B7.createElement(U, { bold: !0, color: "error" }, "Delete hook?"),
      B7.createElement(
        S,
        { flexDirection: "column", marginX: 2 },
        B7.createElement(U, { bold: !0 }, vz(A.config)),
        B7.createElement(U, { dimColor: !0 }, "Event: ", A.event),
        B && B7.createElement(U, { dimColor: !0 }, "Matcher: ", A.matcher),
        B7.createElement(U, { dimColor: !0 }, ri2(A.source)),
      ),
      B7.createElement(
        U,
        null,
        "This will remove the hook configuration from your settings.",
      ),
      B7.createElement($0, {
        onChange: (G) => (G === "yes" ? Q() : I()),
        onCancel: I,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    B7.createElement(
      S,
      { marginLeft: 3 },
      B7.createElement(U, { dimColor: !0 }, "Enter to confirm  Esc to cancel"),
    ),
  );
}
var B7;
var si2 = T(() => {
  nA();
  zy();
  Z5();
  B7 = IA(KA(), 1);
});
function oi2(A, B) {
  let Q = {
      PreToolUse: {},
      PostToolUse: {},
      Notification: {},
      UserPromptSubmit: {},
      SessionStart: {},
      SessionEnd: {},
      Stop: {},
      SubagentStop: {},
      PreCompact: {},
    },
    I = y$A(B);
  Qn2(A).forEach((Z) => {
    let Y = Q[Z.event];
    if (Y) {
      let J = I[Z.event].matcherMetadata !== void 0 ? Z.matcher || "" : "";
      if (!Y[J]) Y[J] = [];
      Y[J].push(Z);
    }
  });
  let G = mB1();
  if (G)
    for (let [Z, Y] of Object.entries(G)) {
      let J = Z,
        X = Q[J];
      if (!X) continue;
      for (let W of Y) {
        let F = W.matcher || "";
        if (!X[F]) X[F] = [];
        for (let C of W.hooks)
          if (C.type === "callback")
            X[F].push({
              event: J,
              config: { type: "command", command: "[Plugin Hook]" },
              matcher: W.matcher,
              source: "pluginHook",
            });
      }
    }
  return Q;
}
function ti2(A, B) {
  let Q = Object.keys(A[B] || {});
  return In2(Q, A, B);
}
function ei2(A, B, Q) {
  let I = Q ?? "";
  return A[B]?.[I] ?? [];
}
function Mb(A, B) {
  return y$A(B)[A].matcherMetadata;
}
function An2(A, B) {
  return y$A(B)[A].summary;
}
var y$A;
var Bn2 = T(() => {
  a2();
  zy();
  fm();
  y$A = I0(function (A) {
    return {
      PreToolUse: {
        summary: "Before tool execution",
        description: `Input to command is JSON of tool call arguments.
Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and block tool call
Other exit codes - show stderr to user only but continue with tool call`,
        matcherMetadata: { fieldToMatch: "tool_name", values: A },
      },
      PostToolUse: {
        summary: "After tool execution",
        description: `Input to command is JSON with fields "inputs" (tool call arguments) and "response" (tool call response).
Exit code 0 - stdout shown in transcript mode (ctrl+o)
Exit code 2 - show stderr to model immediately
Other exit codes - show stderr to user only`,
        matcherMetadata: { fieldToMatch: "tool_name", values: A },
      },
      Notification: {
        summary: "When notifications are sent",
        description: `Input to command is JSON with notification message and type.
Exit code 0 - stdout/stderr not shown
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "notification_type",
          values: [
            "permission_prompt",
            "idle_prompt",
            "auth_success",
            "elicitation_dialog",
          ],
        },
      },
      UserPromptSubmit: {
        summary: "When the user submits a prompt",
        description: `Input to command is JSON with original user prompt text.
Exit code 0 - stdout shown to Claude
Exit code 2 - block processing, erase original prompt, and show stderr to user only
Other exit codes - show stderr to user only`,
      },
      SessionStart: {
        summary: "When a new session is started",
        description: `Input to command is JSON with session start source.
Exit code 0 - stdout shown to Claude
Blocking errors are ignored
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "source",
          values: ["startup", "resume", "clear", "compact"],
        },
      },
      Stop: {
        summary: "Right before Claude concludes its response",
        description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and continue conversation
Other exit codes - show stderr to user only`,
      },
      SubagentStop: {
        summary:
          "Right before a subagent (Task tool call) concludes its response",
        description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to subagent and continue having it run
Other exit codes - show stderr to user only`,
      },
      PreCompact: {
        summary: "Before conversation compaction",
        description: `Input to command is JSON with compaction details.
Exit code 0 - stdout appended as custom compact instructions
Exit code 2 - block compaction
Other exit codes - show stderr to user only but continue with compaction`,
        matcherMetadata: {
          fieldToMatch: "trigger",
          values: ["manual", "auto"],
        },
      },
      SessionEnd: {
        summary: "When a session is ending",
        description: `Input to command is JSON with session end reason.
Exit code 0 - command completes successfully
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "reason",
          values: ["clear", "logout", "prompt_input_exit", "other"],
        },
      },
    };
  });
});
function Gn2({ toolNames: A, onExit: B }) {
  let [Q, I] = vJ.useState([]),
    [G, Z] = vJ.useState({ mode: "select-event" }),
    [Y, J] = vJ.useState(0),
    [X, W] = vJ.useState(() => {
      return (
        N0()?.disableAllHooks === !0 &&
        cQ("policySettings")?.disableAllHooks === !0
      );
    });
  b0A((WA) => {
    if (WA === "policySettings") {
      let wA = N0()?.disableAllHooks === !0;
      W(wA && cQ("policySettings")?.disableAllHooks === !0);
    }
  });
  let [F, C] = vJ.useState(""),
    [V, K] = vJ.useState(""),
    D = G.mode,
    E = "event" in G ? G.event : "PreToolUse",
    H = "matcher" in G ? G.matcher : null,
    [w] = lB(),
    { mcp: L } = w,
    N = vJ.useMemo(() => [...A, ...L.tools.map((WA) => WA.name)], [A, L.tools]),
    $ = vJ.useMemo(() => oi2(w, N), [N, Y, w]),
    O = vJ.useMemo(() => ti2($, E), [$, E]),
    P = vJ.useMemo(() => ei2($, E, H), [$, E, H]),
    k = IB();
  h1((WA, JA) => {
    if (D === "save-hook") return;
    if (JA.escape) {
      switch (D) {
        case "select-event":
          if (Q.length > 0)
            B(
              Q.join(`
`),
            );
          else B("Hooks dialog dismissed", { display: "system" });
          break;
        case "select-matcher":
          Z({ mode: "select-event" });
          break;
        case "add-matcher":
          if ("event" in G)
            Z({
              mode: "select-matcher",
              event: G.event,
              matcherMetadata: G.matcherMetadata,
            });
          K("");
          break;
        case "delete-matcher":
          if ("event" in G)
            Z({
              mode: "select-matcher",
              event: G.event,
              matcherMetadata: G.matcherMetadata,
            });
          break;
        case "select-hook":
          if ("event" in G) {
            let wA = Mb(G.event, N);
            if (wA !== void 0)
              Z({
                mode: "select-matcher",
                event: G.event,
                matcherMetadata: wA,
              });
            else Z({ mode: "select-event" });
          }
          break;
        case "add-hook":
          if ("event" in G && "matcher" in G)
            Z({ mode: "select-hook", event: G.event, matcher: G.matcher });
          C("");
          break;
        case "delete-hook":
          if ("event" in G && G.mode === "delete-hook") {
            let { hook: wA } = G;
            Z({
              mode: "select-hook",
              event: G.event,
              matcher: wA.matcher || "",
            });
          }
          break;
      }
      return;
    }
    switch (D) {
      case "select-event":
        if (JA.return) {
          let wA = E,
            xA = Mb(wA, N);
          if (xA !== void 0)
            Z({ mode: "select-matcher", event: wA, matcherMetadata: xA });
          else Z({ mode: "select-hook", event: wA, matcher: "" });
        }
        break;
      case "add-matcher":
        if (JA.return && V.trim() && "event" in G)
          Z({ mode: "select-hook", event: G.event, matcher: V.trim() });
        break;
      case "add-hook":
        if (JA.return && F.trim() && "event" in G && "matcher" in G) {
          let wA = {
            event: G.event,
            config: { type: "command", command: F.trim() },
            matcher: Mb(G.event, N) !== void 0 ? G.matcher : "",
          };
          Z({ mode: "save-hook", event: G.event, hookToSave: wA });
        }
        break;
      case "delete-matcher":
      case "delete-hook":
      case "select-matcher":
      case "select-hook":
        break;
    }
  });
  let b = vJ.useCallback(() => {
      if (G.mode === "save-hook") {
        let { hookToSave: WA } = G;
        (I((JA) => [
          ...JA,
          `Added ${WA.event} hook: ${iA.bold(vz(WA.config))}`,
        ]),
          Z({ mode: "select-hook", event: WA.event, matcher: WA.matcher }));
      }
      (C(""), J((WA) => WA + 1));
    }, [G]),
    x = vJ.useCallback(() => {
      if (G.mode === "save-hook") {
        let { hookToSave: WA } = G;
        Z({ mode: "select-hook", event: WA.event, matcher: WA.matcher });
      }
      C("");
    }, [G]),
    n = vJ.useCallback(async () => {
      if (G.mode !== "delete-hook") return;
      let { hook: WA, event: JA } = G;
      (await Yn2(WA),
        I((rA) => [
          ...rA,
          `Deleted ${WA.event} hook: ${iA.bold(vz(WA.config))}`,
        ]),
        J((rA) => rA + 1));
      let wA = WA.matcher || "",
        xA = $[JA]?.[wA]?.filter((rA) => !k$A(rA.config, WA.config));
      if (!xA || xA.length === 0) {
        let rA = Mb(JA, N);
        if (rA !== void 0)
          Z({ mode: "select-matcher", event: JA, matcherMetadata: rA });
        else Z({ mode: "select-event" });
      } else Z({ mode: "select-hook", event: JA, matcher: wA });
    }, [G, $, N]),
    m = vJ.useCallback(() => {
      if (G.mode === "delete-matcher") {
        let { matcher: WA, event: JA } = G;
        (I((wA) => [...wA, `Deleted matcher: ${iA.bold(WA)}`]),
          Z({
            mode: "select-matcher",
            event: JA,
            matcherMetadata: G.matcherMetadata,
          }));
      }
    }, [G]),
    o = y$A(N),
    l = Jn2();
  vJ.useEffect(() => {
    _$A();
  }, []);
  let c = N0()?.disableAllHooks === !0,
    e = vJ.useCallback(() => {
      B(
        Q.length > 0
          ? Q.join(`
`)
          : "Hooks dialog dismissed",
        { display: Q.length === 0 ? "system" : void 0 },
      );
    }, [Q, B]),
    QA = vJ.useMemo(
      () =>
        Object.values($).reduce((WA, JA) => {
          return WA + Object.values(JA).reduce((wA, xA) => wA + xA.length, 0);
        }, 0),
      [$],
    );
  if (c)
    return H9.createElement(
      H9.Fragment,
      null,
      H9.createElement(
        S,
        {
          flexDirection: "column",
          borderStyle: "round",
          paddingLeft: 1,
          paddingRight: 1,
          borderColor: "warning",
        },
        H9.createElement(
          S,
          { flexDirection: "column", marginBottom: 1 },
          H9.createElement(
            S,
            null,
            H9.createElement(
              U,
              { bold: !0, color: "warning" },
              "Hook Configuration - Disabled",
            ),
          ),
          H9.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            H9.createElement(
              U,
              null,
              "All hooks are currently ",
              iA.red("disabled"),
              X && " by a managed settings file",
              ". You have",
              " ",
              iA.bold(QA),
              " configured hook",
              QA !== 1 ? "s" : "",
              " that",
              " ",
              QA !== 1 ? "are" : "is",
              " not running.",
            ),
            H9.createElement(
              S,
              { marginTop: 1 },
              H9.createElement(U, null, "When hooks are disabled:"),
            ),
            H9.createElement(U, null, " No hook commands will execute"),
            H9.createElement(U, null, " StatusLine will not be displayed"),
            H9.createElement(
              U,
              null,
              " Tool operations will proceed without hook validation",
            ),
          ),
        ),
        !X &&
          H9.createElement(
            S,
            { flexDirection: "column" },
            H9.createElement(U, { bold: !0 }, "Options:"),
            H9.createElement($0, {
              options: [
                { label: "Re-enable all hooks", value: "enable" },
                { label: "Exit", value: "exit" },
              ],
              onChange: (WA) => {
                if (WA === "enable")
                  (B2("localSettings", { disableAllHooks: !1 }),
                    B("Re-enabled all hooks"));
                else e();
              },
              onCancel: e,
            }),
          ),
      ),
      H9.createElement(
        S,
        { marginLeft: 3 },
        H9.createElement(
          U,
          { dimColor: !0 },
          X ? "Esc to exit" : "Enter to select  Esc to exit",
        ),
      ),
    );
  switch (G.mode) {
    case "save-hook":
      return H9.createElement(yi2, {
        event: G.hookToSave.event,
        eventSummary: o[G.hookToSave.event].summary,
        config: G.hookToSave.config,
        matcher: G.hookToSave.matcher,
        onSuccess: b,
        onCancel: x,
      });
    case "select-event":
      return H9.createElement(xi2, {
        hookEventMetadata: o,
        exitStatePending: k.pending,
        exitStateKeyName: k.keyName || void 0,
        configDifference: l,
        onSelectEvent: (WA) => {
          if (WA === "disable-all")
            (B2("localSettings", { disableAllHooks: !0 }),
              B("All hooks have been disabled"));
          else {
            let JA = Mb(WA, N);
            if (JA !== void 0)
              Z({ mode: "select-matcher", event: WA, matcherMetadata: JA });
            else Z({ mode: "select-hook", event: WA, matcher: "" });
          }
        },
      });
    case "select-matcher":
      return H9.createElement(bi2, {
        selectedEvent: G.event,
        matchersForSelectedEvent: O,
        hooksByEventAndMatcher: $,
        eventDescription: o[G.event].description,
        onSelect: (WA) => {
          if (WA === null)
            Z({
              mode: "add-matcher",
              event: G.event,
              matcherMetadata: G.matcherMetadata,
            });
          else if (($[G.event]?.[WA] || []).length === 0)
            Z({
              mode: "delete-matcher",
              event: G.event,
              matcher: WA,
              matcherMetadata: G.matcherMetadata,
            });
          else Z({ mode: "select-hook", event: G.event, matcher: WA });
        },
        onCancel: () => {
          Z({ mode: "select-event" });
        },
      });
    case "add-matcher":
      return H9.createElement(gi2, {
        selectedEvent: G.event,
        newMatcher: V,
        onChangeNewMatcher: K,
        eventDescription: o[G.event].description,
        matcherMetadata: G.matcherMetadata,
      });
    case "delete-matcher":
      return H9.createElement(ci2, {
        selectedMatcher: G.matcher,
        selectedEvent: G.event,
        onDelete: m,
        onCancel: () =>
          Z({
            mode: "select-matcher",
            event: G.event,
            matcherMetadata: G.matcherMetadata,
          }),
      });
    case "select-hook":
      return H9.createElement(li2, {
        selectedEvent: G.event,
        selectedMatcher: G.matcher,
        hooksForSelectedMatcher: P,
        hookEventMetadata: o[G.event],
        onSelect: (WA) => {
          if (WA === null)
            Z({ mode: "add-hook", event: G.event, matcher: G.matcher });
          else Z({ mode: "delete-hook", event: G.event, hook: WA });
        },
        onCancel: () => {
          let WA = Mb(G.event, N);
          if (WA !== void 0)
            Z({ mode: "select-matcher", event: G.event, matcherMetadata: WA });
          else Z({ mode: "select-event" });
        },
      });
    case "add-hook":
      return H9.createElement(mi2, {
        selectedEvent: G.event,
        selectedMatcher: G.matcher,
        eventDescription: An2(G.event, N),
        fullDescription: o[G.event].description,
        supportsMatcher: Mb(G.event, N) !== void 0,
        command: F,
        onChangeCommand: C,
      });
    case "delete-hook":
      return H9.createElement(ai2, {
        selectedHook: G.hook,
        eventSupportsMatcher: Mb(G.event, N) !== void 0,
        onDelete: n,
        onCancel: () => {
          let { event: WA, hook: JA } = G;
          Z({ mode: "select-hook", event: WA, matcher: JA.matcher || "" });
        },
      });
  }
}
var H9, vJ;
var Zn2 = T(() => {
  f2();
  nA();
  R9();
  zy();
  ki2();
  vi2();
  fi2();
  ui2();
  di2();
  pi2();
  ii2();
  si2();
  R5();
  Bn2();
  fm();
  c9();
  OQ();
  fjA();
  ((H9 = IA(KA(), 1)), (vJ = IA(KA(), 1)));
});
var $00, Z1I, Xn2;
var Wn2 = T(() => {
  Zn2();
  nO();
  (($00 = IA(KA(), 1)),
    (Z1I = {
      type: "local-jsx",
      name: "hooks",
      description: "Manage hook configurations for tool events",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        let I = (await B.getAppState()).toolPermissionContext,
          G = Yz(I).map((Z) => Z.name);
        return $00.createElement(Gn2, { toolNames: G, onExit: A });
      },
      userFacingName() {
        return "hooks";
      },
    }),
    (Xn2 = Z1I));
});
import { relative as Y1I } from "path";
var J1I, Fn2;
var Cn2 = T(() => {
  V2();
  zN();
  ((J1I = {
    type: "local",
    name: "files",
    description: "List all files currently in context",
    isEnabled: () => !1,
    isHidden: !1,
    supportsNonInteractive: !0,
    async call(A, B) {
      let Q = B.readFileState ? ym(B.readFileState) : [];
      if (Q.length === 0) return { type: "text", value: "No files in context" };
      return {
        type: "text",
        value: `Files in context:
${Q.map((G) => Y1I(G0(), G)).join(`
`)}`,
      };
    },
    userFacingName() {
      return "files";
    },
  }),
    (Fn2 = J1I));
});
var Vn2;
var Kn2 = T(() => {
  Vn2 = {
    agentType: "statusline-setup",
    whenToUse:
      "Use this agent to configure the user's Claude Code status line setting.",
    tools: ["Read", "Edit"],
    systemPrompt: `You are a status line setup agent for Claude Code. Your job is to create or update the statusLine command in the user's Claude Code settings.

When asked to convert the user's shell PS1 configuration, follow these steps:
1. Read the user's shell configuration files in this order of preference:
   - ~/.zshrc
   - ~/.bashrc  
   - ~/.bash_profile
   - ~/.profile

2. Extract the PS1 value using this regex pattern: /(?:^|\\n)\\s*(?:export\\s+)?PS1\\s*=\\s*["']([^"']+)["']/m

3. Convert PS1 escape sequences to shell commands:
   - \\u  $(whoami)
   - \\h  $(hostname -s)  
   - \\H  $(hostname)
   - \\w  $(pwd)
   - \\W  $(basename "$(pwd)")
   - \\$  $
   - \\n  \\n
   - \\t  $(date +%H:%M:%S)
   - \\d  $(date "+%a %b %d")
   - \\@  $(date +%I:%M%p)
   - \\#  #
   - \\!  !

4. When using ANSI color codes, be sure to use \`printf\`. Do not remove colors. Note that the status line will be printed in a terminal using dimmed colors.

5. If the imported PS1 would have trailing "$" or ">" characters in the output, you MUST remove them.

6. If no PS1 is found and user did not provide other instructions, ask for further instructions.

How to use the statusLine command:
1. The statusLine command will receive the following JSON input via stdin:
   {
     "session_id": "string", // Unique session ID
     "transcript_path": "string", // Path to the conversation transcript
     "cwd": "string",         // Current working directory
     "model": {
       "id": "string",           // Model ID (e.g., "claude-3-5-sonnet-20241022")
       "display_name": "string"  // Display name (e.g., "Claude 3.5 Sonnet")
     },
     "workspace": {
       "current_dir": "string",  // Current working directory path
       "project_dir": "string"   // Project root directory path
     },
     "version": "string",        // Claude Code app version (e.g., "1.0.71")
     "output_style": {
       "name": "string",         // Output style name (e.g., "default", "Explanatory", "Learning")
     }
   }
   
   You can use this JSON data in your command like:
   - $(cat | jq -r '.model.display_name')
   - $(cat | jq -r '.workspace.current_dir')
   - $(cat | jq -r '.output_style.name')
   
   Or store it in a variable first:
   - input=$(cat); echo "$(echo "$input" | jq -r '.model.display_name') in $(echo "$input" | jq -r '.workspace.current_dir')"

2. For longer commands, you can save a new file in the user's ~/.claude directory, e.g.:
   - ~/.claude/statusline-command.sh and reference that file in the settings.

3. Update the user's ~/.claude/settings.json with:
   {
     "statusLine": {
       "type": "command", 
       "command": "your_command_here"
     }
   }

4. If ~/.claude/settings.json is a symlink, update the target file instead.

Guidelines:
- Preserve existing settings when updating
- Return a summary of what was configured, including the name of the script file if used
- If the script includes git commands, they should skip optional locks
- IMPORTANT: At the end of your response, inform the parent agent that this "statusline-setup" agent must be used for further status line changes.
  Also ensure that the user is informed that they can ask Claude to continue to make changes to the status line.
`,
    source: "built-in",
    baseDir: "built-in",
    model: "sonnet",
    color: "orange",
  };
});
var eK;
var S7A = T(() => {
  WK();
  R_();
  Bu();
  eK = {
    agentType: "Explore",
    whenToUse:
      'Fast agent specialized for exploring codebases. Use this when you need to quickly find files by patterns (eg. "src/components/**/*.tsx"), search code for keywords (eg. "API endpoints"), or answer questions about the codebase (eg. "how do API endpoints work?"). When calling this agent, specify the desired thoroughness level: "quick" for basic searches, "medium" for moderate exploration, or "very thorough" for comprehensive analysis across multiple locations and naming conventions.',
    disallowedTools: [x8, noA, g5, WF, Qu, kbA, Zz, vN],
    systemPrompt: `You are a file search specialist for Claude Code, Anthropic's official CLI for Claude. You excel at thoroughly navigating and exploring codebases.

CRITICAL: This is a READ-ONLY exploration task. You MUST NOT create, write, or modify any files under any circumstances. Your role is strictly to search and analyze existing code.

Your strengths:
- Rapidly finding files using glob patterns
- Searching code and text with powerful regex patterns
- Reading and analyzing file contents

Guidelines:
- Use ${xH} for broad file pattern matching
- Use ${XK} for searching file contents with regex
- Use ${z3} when you know the specific file path you need to read
- Use ${E4} ONLY for read-only operations (ls, git status, git log, git diff, find, cat, head, tail). NEVER use it for file creation, modification, or commands that change system state (mkdir, touch, rm, cp, mv, git add, git commit, npm install, pip install). NEVER use redirect operators (>, >>, |) or heredocs to create files
- Adapt your search approach based on the thoroughness level specified by the caller
- Return file paths as absolute paths in your final response
- For clear communication, avoid using emojis
- Do not create any files, or run bash commands that modify the user's system state in any way (This includes temporary files in the /tmp folder. Never create these files, instead communicate your final report directly as a regular message)

Complete the user's search request efficiently and report your findings clearly.`,
    source: "built-in",
    baseDir: "built-in",
    model: "haiku",
  };
});
var X1I, Ip;
var dB1 = T(() => {
  S7A();
  Bu();
  WK();
  ((X1I = `You are a software architect and planning specialist for Claude Code. Your role is to explore the codebase and design implementation plans.

CRITICAL: This is a READ-ONLY planning task. Your role is strictly to explore and design implementation plans.
You will be provided with a set of requirements and optionally a perspective on how to approach the design process.

## Your Process

1. **Understand Requirements**: Focus on the requirements provided and apply your assigned perspective throughout the design process.

2. **Explore Thoroughly**:
   - Find existing patterns and conventions using ${xH}, ${XK}, and ${z3}
   - Understand the current architecture
   - Identify similar features as reference
   - Trace through relevant code paths
   - Use ${E4} ONLY for read-only operations (ls, git status, git log, git diff, find, cat, head, tail). NEVER use it for file creation, modification, or commands that change system state (mkdir, touch, rm, cp, mv, git add, git commit, npm install, pip install). NEVER use redirect operators (>, >>, |) or heredocs to create files

3. **Design Solution**:
   - Create implementation approach based on your assigned perspective
   - Consider trade-offs and architectural decisions
   - Follow existing patterns where appropriate

4. **Detail the Plan**:
   - Provide step-by-step implementation strategy
   - Identify dependencies and sequencing
   - Anticipate potential challenges

## Required Output

End your response with:

### Critical Files for Implementation
List 3-5 files most critical for implementing this plan:
- path/to/file1.ts - [Brief reason: e.g., "Core logic to modify"]
- path/to/file2.ts - [Brief reason: e.g., "Interfaces to implement"]
- path/to/file3.ts - [Brief reason: e.g., "Pattern to follow"]

Remember: You explore and plan. Do NOT write or edit files. Do NOT run system-modifying commands.`),
    (Ip = {
      agentType: "Plan",
      whenToUse: eK.whenToUse,
      disallowedTools: eK.disallowedTools,
      systemPrompt: ac() ? X1I : eK.systemPrompt,
      source: "built-in",
      tools: eK.tools,
      baseDir: "built-in",
    }));
});
function q00() {
  return [S01, Vn2, eK, Ip];
}
var Dn2 = T(() => {
  HA0();
  Kn2();
  S7A();
  dB1();
});
import { basename as W1I } from "path";
function Uy(A) {
  let B = A.filter((W) => W.source === "built-in"),
    Q = A.filter((W) => W.source === "plugin"),
    I = A.filter((W) => W.source === "userSettings"),
    G = A.filter((W) => W.source === "projectSettings"),
    Z = A.filter((W) => W.source === "policySettings"),
    Y = A.filter((W) => W.source === "flagSettings"),
    J = [B, Q, I, G, Y, Z],
    X = new Map();
  for (let W of J) for (let F of W) X.set(F.agentType, F);
  return Array.from(X.values());
}
function C1I(A) {
  let { name: B, description: Q, model: I } = A;
  if (!B || typeof B !== "string")
    return 'Missing required "name" field in frontmatter';
  if (!Q || typeof Q !== "string")
    return 'Missing required "description" field in frontmatter';
  if (I && typeof I === "string" && !K2A.includes(I))
    return `Invalid model "${I}". Valid options: ${K2A.join(", ")}`;
  return "Unknown parsing error";
}
function V1I(A, B, Q = "flagSettings") {
  try {
    let I = En2.parse(B),
      G = eo(I.tools),
      Z = I.disallowedTools !== void 0 ? eo(I.disallowedTools) : void 0;
    return {
      agentType: A,
      whenToUse: I.description,
      ...(G !== void 0 ? { tools: G } : {}),
      ...(Z !== void 0 ? { disallowedTools: Z } : {}),
      systemPrompt: I.prompt,
      source: Q,
      ...(I.model ? { model: I.model } : {}),
    };
  } catch (I) {
    let G = I instanceof Error ? I.message : String(I);
    return (
      g(`Error parsing agent '${A}' from JSON: ${G}`),
      BA(I instanceof Error ? I : Error(String(I)), J61),
      null
    );
  }
}
function zn2(A, B = "flagSettings") {
  try {
    let Q = F1I.parse(A);
    return Object.entries(Q)
      .map(([I, G]) => V1I(I, G, B))
      .filter((I) => I !== null);
  } catch (Q) {
    let I = Q instanceof Error ? Q.message : String(Q);
    return (
      g(`Error parsing agents from JSON: ${I}`),
      BA(Q instanceof Error ? Q : Error(String(Q)), J61),
      []
    );
  }
}
function K1I(A, B, Q, I, G) {
  try {
    let { name: Z, description: Y } = Q;
    if (!Z || typeof Z !== "string" || !Y || typeof Y !== "string") {
      let L = `Agent file ${A} is missing required '${!Z || typeof Z !== "string" ? "name" : "description"}' in frontmatter`;
      return (g(L), null);
    }
    Y = Y.replace(
      /\\n/g,
      `
`,
    );
    let { color: J, model: X, forkContext: W } = Q;
    if (W !== void 0 && W !== "true" && W !== "false") {
      let w = `Agent file ${A} has invalid forkContext value '${W}'. Must be 'true', 'false', or omitted.`;
      g(w);
    }
    let F = W === "true";
    if (F && X !== "inherit") {
      let w = `Agent file ${A} has forkContext: true but model is not 'inherit'. Overriding to 'inherit'. Agents with forkContext must use model: inherit to avoid context length mismatch.`;
      (g(w), (X = "inherit"));
    }
    let C = X && typeof X === "string" && K2A.includes(X);
    if (X && typeof X === "string" && !C) {
      let w = `Agent file ${A} has invalid model '${X}'. Valid options: ${K2A.join(", ")}`;
      g(w);
    }
    let V = W1I(A, ".md"),
      K = eo(Q.tools),
      D = Q.disallowedTools,
      E = D !== void 0 ? eo(D) : void 0;
    return {
      baseDir: B,
      agentType: Z,
      whenToUse: Y,
      ...(K !== void 0 ? { tools: K } : {}),
      ...(E !== void 0 ? { disallowedTools: E } : {}),
      systemPrompt: I.trim(),
      source: G,
      filename: V,
      ...(J && typeof J === "string" && z6A.includes(J) ? { color: J } : {}),
      ...(C ? { model: X } : {}),
      ...(F ? { forkContext: F } : {}),
    };
  } catch (Z) {
    let Y = Z instanceof Error ? Z.message : String(Z);
    return (
      g(`Error parsing agent from ${A}: ${Y}`),
      BA(Z instanceof Error ? Z : Error(String(Z)), dG0),
      null
    );
  }
}
var En2, F1I, Hn2;
var x$A = T(() => {
  a2();
  e2();
  H0();
  C0();
  c1();
  xS();
  Y9();
  cm();
  Dn2();
  iwA();
  ((En2 = _.object({
    description: _.string().min(1, "Description cannot be empty"),
    tools: _.array(_.string()).optional(),
    disallowedTools: _.array(_.string()).optional(),
    prompt: _.string().min(1, "Prompt cannot be empty"),
    model: _.enum(K2A).optional(),
  })),
    (F1I = _.record(_.string(), En2)));
  Hn2 = I0(async () => {
    try {
      let A = await Zc("agents"),
        B = [],
        Q = A.map(
          ({
            filePath: J,
            baseDir: X,
            frontmatter: W,
            content: F,
            source: C,
          }) => {
            let V = K1I(J, X, W, F, C);
            if (!V) {
              let K = C1I(W);
              return (
                B.push({ path: J, error: K }),
                g(`Failed to parse agent from ${J}: ${K}`),
                GA("tengu_agent_parse_error", { error: K, location: C }),
                null
              );
            }
            return V;
          },
        ).filter((J) => J !== null),
        I = await to(),
        Z = [...q00(), ...I, ...Q],
        Y = Uy(Z);
      for (let J of Y) if (J.color) w6A(J.agentType, J.color);
      return {
        activeAgents: Y,
        allAgents: Z,
        failedFiles: B.length > 0 ? B : void 0,
      };
    } catch (A) {
      let B = A instanceof Error ? A.message : String(A);
      (g(`Error loading agent definitions: ${B}`),
        BA(A instanceof Error ? A : Error(String(A)), mG0));
      let Q = q00();
      return {
        activeAgents: Q,
        allAgents: Q,
        failedFiles: [{ path: "unknown", error: B }],
      };
    }
  });
});
var wy;
var Un2 = T(() => {
  wy = { FOLDER_NAME: ".claude", AGENTS_DIR: "agents" };
});
import { join as Ob } from "path";
function wn2(A, B, Q, I, G, Z) {
  let Y = B.replace(/\n/g, "\\n"),
    X =
      Q === void 0 || (Q.length === 1 && Q[0] === "*")
        ? ""
        : `
tools: ${Q.join(", ")}`,
    W = Z
      ? `
model: ${Z}`
      : "",
    F = G
      ? `
color: ${G}`
      : "";
  return `---
name: ${A}
description: ${Y}${X}${W}${F}
---

${I}
`;
}
function cB1(A) {
  switch (A) {
    case "flagSettings":
      throw Error(`Cannot get directory path for ${A} agents`);
    case "userSettings":
      return Ob(mB(), wy.AGENTS_DIR);
    case "projectSettings":
      return Ob(G0(), wy.FOLDER_NAME, wy.AGENTS_DIR);
    case "policySettings":
      return Ob(Nw(), wy.FOLDER_NAME, wy.AGENTS_DIR);
    case "localSettings":
      return Ob(G0(), wy.FOLDER_NAME, wy.AGENTS_DIR);
  }
}
function $n2(A) {
  switch (A) {
    case "projectSettings":
      return Ob(".", wy.FOLDER_NAME, wy.AGENTS_DIR);
    default:
      return cB1(A);
  }
}
function N00(A) {
  let B = cB1(A.source);
  return Ob(B, `${A.agentType}.md`);
}
function pB1(A) {
  if (A.source === "built-in") return "Built-in";
  if (A.source === "plugin")
    throw Error("Cannot get file path for plugin agents");
  let B = cB1(A.source),
    Q = A.filename || A.agentType;
  return Ob(B, `${Q}.md`);
}
function qn2(A) {
  if (A.source === "built-in") return "Built-in";
  let B = $n2(A.source);
  return Ob(B, `${A.agentType}.md`);
}
function Nn2(A) {
  if (A.source === "built-in") return "Built-in";
  if (A.source === "plugin") return `Plugin: ${A.plugin || "Unknown"}`;
  let B = $n2(A.source),
    Q = A.filename || A.agentType;
  return Ob(B, `${Q}.md`);
}
function D1I(A) {
  let B = cB1(A),
    Q = NA();
  if (!Q.existsSync(B)) Q.mkdirSync(B);
  return B;
}
async function L00(A, B, Q, I, G, Z = !0, Y, J) {
  if (A === "built-in") throw Error("Cannot save built-in agents");
  D1I(A);
  let X = N00({ source: A, agentType: B }),
    W = NA();
  if (Z && W.existsSync(X)) throw Error(`Agent file already exists: ${X}`);
  let F = wn2(B, Q, I, G, Y, J);
  W.writeFileSync(X, F, { encoding: "utf-8", flush: !0 });
}
async function Ln2(A, B, Q, I, G, Z) {
  if (A.source === "built-in") throw Error("Cannot update built-in agents");
  let Y = NA(),
    J = pB1(A),
    X = wn2(A.agentType, B, Q, I, G, Z);
  Y.writeFileSync(J, X, { encoding: "utf-8", flush: !0 });
}
async function Mn2(A) {
  if (A.source === "built-in") throw Error("Cannot delete built-in agents");
  let B = NA(),
    Q = pB1(A);
  if (B.existsSync(Q)) B.unlinkSync(Q);
}
var y7A = T(() => {
  m0();
  V2();
  vB();
  Un2();
  OQ();
});
function Gp({
  title: A,
  titleColor: B = "text",
  borderColor: Q = "suggestion",
  children: I,
  subtitle: G,
}) {
  return vR.createElement(
    S,
    { borderStyle: "round", borderColor: Q, flexDirection: "column" },
    vR.createElement(
      S,
      { flexDirection: "column", paddingX: 1 },
      vR.createElement(U, { bold: !0, color: B }, A),
      G && vR.createElement(U, { dimColor: !0 }, G),
    ),
    vR.createElement(S, { paddingX: 1, flexDirection: "column" }, I),
  );
}
var vR;
var M00 = T(() => {
  nA();
  vR = IA(KA(), 1);
});
function k7A(A) {
  if (A === "all") return "Agents";
  if (A === "built-in") return "Built-in agents";
  if (A === "plugin") return "Plugin agents";
  return NiA(o1A(A));
}
var lB1 = T(() => {
  ix1();
  NC();
});
function On2({
  source: A,
  agents: B,
  onBack: Q,
  onSelect: I,
  onCreateNew: G,
  changes: Z,
}) {
  let [Y, J] = UB.useState(null),
    [X, W] = UB.useState(!0),
    F = (L) => {
      return {
        isOverridden: !!L.overriddenBy,
        overriddenBy: L.overriddenBy || null,
      };
    },
    C = () => {
      return UB.createElement(
        S,
        null,
        UB.createElement(
          U,
          { color: X ? "suggestion" : void 0 },
          X ? `${E1.pointer} ` : "  ",
        ),
        UB.createElement(
          U,
          { color: X ? "suggestion" : void 0 },
          "Create new agent",
        ),
      );
    },
    V = (L) => {
      let N = L.source === "built-in",
        $ = !N && !X && Y?.agentType === L.agentType && Y?.source === L.source,
        { isOverridden: O, overriddenBy: P } = F(L),
        k = N || O,
        b = !N && $ ? "suggestion" : void 0,
        x = L.model || WU1;
      return UB.createElement(
        S,
        { key: `${L.agentType}-${L.source}` },
        UB.createElement(
          U,
          { dimColor: k && !$, color: b },
          N ? "" : $ ? `${E1.pointer} ` : "  ",
        ),
        UB.createElement(U, { dimColor: k && !$, color: b }, L.agentType),
        x &&
          UB.createElement(
            U,
            { dimColor: !0, color: b },
            "  ",
            x === "inherit" ? "inherit" : x,
          ),
        P &&
          UB.createElement(
            U,
            { dimColor: !$, color: $ ? "warning" : void 0 },
            " ",
            E1.warning,
            " overridden by ",
            P,
          ),
      );
    },
    K = UB.useMemo(() => {
      let L = B.filter((N) => N.source !== "built-in");
      if (A === "all")
        return [
          ...L.filter((N) => N.source === "userSettings"),
          ...L.filter((N) => N.source === "projectSettings"),
          ...L.filter((N) => N.source === "policySettings"),
        ];
      return L;
    }, [B, A]);
  (UB.useEffect(() => {
    if (!Y && !X && K.length > 0)
      if (G) W(!0);
      else J(K[0] || null);
  }, [K, Y, X, G]),
    h1((L, N) => {
      if (N.escape) {
        Q();
        return;
      }
      if (N.return) {
        if (X && G) G();
        else if (Y) I(Y);
        return;
      }
      if (!N.upArrow && !N.downArrow) return;
      let $ = !!G,
        O = K.length + ($ ? 1 : 0);
      if (O === 0) return;
      let P = 0;
      if (!X && Y) {
        let b = K.findIndex(
          (x) => x.agentType === Y.agentType && x.source === Y.source,
        );
        if (b >= 0) P = $ ? b + 1 : b;
      }
      let k = N.upArrow ? (P === 0 ? O - 1 : P - 1) : P === O - 1 ? 0 : P + 1;
      if ($ && k === 0) (W(!0), J(null));
      else {
        let b = $ ? k - 1 : k,
          x = K[b];
        if (x) (W(!1), J(x));
      }
    }));
  let D = (L = "Built-in (always available):") => {
      let N = B.filter(($) => $.source === "built-in");
      return UB.createElement(
        S,
        { flexDirection: "column", marginBottom: 1, paddingLeft: 2 },
        UB.createElement(U, { bold: !0, dimColor: !0 }, L),
        N.map(V),
      );
    },
    E = (L, N) => {
      if (!N.length) return null;
      let $ = N[0]?.baseDir;
      return UB.createElement(
        S,
        { flexDirection: "column", marginBottom: 1 },
        UB.createElement(
          S,
          { paddingLeft: 2 },
          UB.createElement(U, { bold: !0, dimColor: !0 }, L),
          $ && UB.createElement(U, { dimColor: !0 }, " (", $, ")"),
        ),
        N.map((O) => V(O)),
      );
    },
    H = k7A(A);
  if (
    !B.length ||
    (A !== "built-in" && !B.some((L) => L.source !== "built-in"))
  )
    return UB.createElement(
      Gp,
      { title: H, subtitle: "No agents found" },
      G && UB.createElement(S, { marginY: 1 }, C()),
      UB.createElement(
        U,
        { dimColor: !0 },
        "No agents found. Create specialized subagents that Claude can delegate to.",
      ),
      UB.createElement(
        U,
        { dimColor: !0 },
        "Each subagent has its own context window, custom system prompt, and specific tools.",
      ),
      UB.createElement(
        U,
        { dimColor: !0 },
        "Try creating: Code Reviewer, Code Simplifier, Security Reviewer, Tech Lead, or UX Reviewer.",
      ),
      A !== "built-in" &&
        B.some((L) => L.source === "built-in") &&
        UB.createElement(
          UB.Fragment,
          null,
          UB.createElement(S, { marginTop: 1 }, UB.createElement(p5, null)),
          D(),
        ),
    );
  return UB.createElement(
    Gp,
    { title: H, subtitle: `${B.filter((L) => !L.overriddenBy).length} agents` },
    Z &&
      Z.length > 0 &&
      UB.createElement(
        S,
        { marginTop: 1 },
        UB.createElement(U, { dimColor: !0 }, Z[Z.length - 1]),
      ),
    UB.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      G && UB.createElement(S, { marginBottom: 1 }, C()),
      A === "all"
        ? UB.createElement(
            UB.Fragment,
            null,
            E(
              "User agents",
              B.filter((L) => L.source === "userSettings"),
            ),
            E(
              "Project agents",
              B.filter((L) => L.source === "projectSettings"),
            ),
            E(
              "Managed agents",
              B.filter((L) => L.source === "policySettings"),
            ),
            E(
              "Plugin agents",
              B.filter((L) => L.source === "plugin"),
            ),
            E(
              "CLI arg agents",
              B.filter((L) => L.source === "flagSettings"),
            ),
            (() => {
              let L = B.filter((N) => N.source === "built-in");
              return L.length > 0
                ? UB.createElement(
                    S,
                    {
                      flexDirection: "column",
                      marginBottom: 1,
                      paddingLeft: 2,
                    },
                    UB.createElement(
                      U,
                      { dimColor: !0 },
                      UB.createElement(U, { bold: !0 }, "Built-in agents"),
                      " (always available)",
                    ),
                    L.map(V),
                  )
                : null;
            })(),
          )
        : A === "built-in"
          ? UB.createElement(
              UB.Fragment,
              null,
              UB.createElement(
                U,
                { dimColor: !0, italic: !0 },
                "Built-in agents are provided by default and cannot be modified.",
              ),
              UB.createElement(
                S,
                { marginTop: 1, flexDirection: "column" },
                B.map((L) => V(L)),
              ),
            )
          : UB.createElement(
              UB.Fragment,
              null,
              B.filter((L) => L.source !== "built-in").map((L) => V(L)),
              B.some((L) => L.source === "built-in") &&
                UB.createElement(
                  UB.Fragment,
                  null,
                  UB.createElement(
                    S,
                    { marginTop: 1 },
                    UB.createElement(p5, null),
                  ),
                  D(),
                ),
            ),
    ),
  );
}
var UB;
var Rn2 = T(() => {
  nA();
  nA();
  s2();
  iC();
  M00();
  Y9();
  lB1();
  UB = IA(KA(), 1);
});
function R00({
  steps: A,
  initialData: B = {},
  onComplete: Q,
  onCancel: I,
  children: G,
  title: Z,
  showStepCounter: Y = !0,
}) {
  let [J, X] = mX.useState(0),
    [W, F] = mX.useState(B),
    [C, V] = mX.useState(!1),
    [K, D] = mX.useState([]);
  (IB(),
    mX.useEffect(() => {
      if (C) (D([]), Q(W));
    }, [C, W, Q]));
  let E = mX.useCallback(() => {
      if (J < A.length - 1) {
        if (K.length > 0) D((P) => [...P, J]);
        X((P) => P + 1);
      } else V(!0);
    }, [J, A.length, K]),
    H = mX.useCallback(() => {
      if (K.length > 0) {
        let P = K[K.length - 1];
        if (P !== void 0) (D((k) => k.slice(0, -1)), X(P));
      } else if (J > 0) X((P) => P - 1);
      else if (I) I();
    }, [J, K, I]),
    w = mX.useCallback(
      (P) => {
        if (P >= 0 && P < A.length) (D((k) => [...k, J]), X(P));
      },
      [J, A.length],
    ),
    L = mX.useCallback(() => {
      if ((D([]), I)) I();
    }, [I]),
    N = mX.useCallback((P) => {
      F((k) => ({ ...k, ...P }));
    }, []),
    $ = mX.useMemo(
      () => ({
        currentStepIndex: J,
        totalSteps: A.length,
        wizardData: W,
        setWizardData: F,
        updateWizardData: N,
        goNext: E,
        goBack: H,
        goToStep: w,
        cancel: L,
        title: Z,
        showStepCounter: Y,
      }),
      [J, A.length, W, N, E, H, w, L, Z, Y],
    ),
    O = A[J];
  if (!O || C) return null;
  return mX.default.createElement(
    O00.Provider,
    { value: $ },
    G || mX.default.createElement(O, null),
  );
}
var mX, O00;
var T00 = T(() => {
  R9();
  ((mX = IA(KA(), 1)), (O00 = mX.createContext(null)));
});
function PG() {
  let A = Tn2.useContext(O00);
  if (!A) throw Error("useWizard must be used within a WizardProvider");
  return A;
}
var Tn2;
var P00 = T(() => {
  T00();
  Tn2 = IA(KA(), 1);
});
function S00({
  instructions: A = "Press  to navigate  Enter to select  Esc to go back",
}) {
  let B = IB();
  return j00.default.createElement(
    S,
    { marginLeft: 3 },
    j00.default.createElement(
      U,
      { dimColor: !0 },
      B.pending ? `Press ${B.keyName} again to exit` : A,
    ),
  );
}
var j00;
var y00 = T(() => {
  nA();
  R9();
  j00 = IA(KA(), 1);
});
function uY({
  title: A,
  titleColor: B = "text",
  borderColor: Q = "suggestion",
  children: I,
  subtitle: G,
  footerText: Z,
}) {
  let {
    currentStepIndex: Y,
    totalSteps: J,
    title: X,
    showStepCounter: W,
  } = PG();
  return Rb.default.createElement(
    Rb.default.Fragment,
    null,
    Rb.default.createElement(
      S,
      { borderStyle: "round", borderColor: Q, flexDirection: "column" },
      Rb.default.createElement(
        S,
        { flexDirection: "column", paddingX: 1 },
        Rb.default.createElement(
          U,
          { bold: !0, color: B },
          A || X || "Wizard",
          W !== !1 && ` (${Y + 1}/${J})`,
        ),
        G && Rb.default.createElement(U, { dimColor: !0 }, G),
      ),
      Rb.default.createElement(S, { paddingX: 1, flexDirection: "column" }, I),
    ),
    Rb.default.createElement(S00, { instructions: Z }),
  );
}
var Rb;
var wL = T(() => {
  nA();
  P00();
  y00();
  Rb = IA(KA(), 1);
});
var aw = T(() => {
  T00();
  P00();
  wL();
  y00();
});
function Pn2() {
  let { goNext: A, updateWizardData: B, cancel: Q } = PG();
  return iB1.default.createElement(
    uY,
    {
      subtitle: "Choose location",
      footerText: "Press  to navigate  Enter to select  Esc to cancel",
    },
    iB1.default.createElement(
      S,
      { marginTop: 1 },
      iB1.default.createElement($0, {
        key: "location-select",
        options: [
          { label: "Project (.claude/agents/)", value: "projectSettings" },
          { label: "Personal (~/.claude/agents/)", value: "userSettings" },
        ],
        onChange: (G) => {
          (B({ location: G }), A());
        },
        onCancel: () => Q(),
      }),
    ),
  );
}
var iB1;
var jn2 = T(() => {
  nA();
  Z5();
  wL();
  aw();
  iB1 = IA(KA(), 1);
});
function Sn2() {
  let { goNext: A, goBack: B, updateWizardData: Q, goToStep: I } = PG();
  return nB1.default.createElement(
    uY,
    {
      subtitle: "Creation method",
      footerText: "Press  to navigate  Enter to select  Esc to go back",
    },
    nB1.default.createElement(
      S,
      { marginTop: 1 },
      nB1.default.createElement($0, {
        key: "method-select",
        options: [
          { label: "Generate with Claude (recommended)", value: "generate" },
          { label: "Manual configuration", value: "manual" },
        ],
        onChange: (Z) => {
          let Y = Z;
          if (
            (Q({ method: Y, wasGenerated: Y === "generate" }), Y === "generate")
          )
            A();
          else I(3);
        },
        onCancel: () => B(),
      }),
    ),
  );
}
var nB1;
var yn2 = T(() => {
  nA();
  Z5();
  wL();
  aw();
  nB1 = IA(KA(), 1);
});
async function kn2(A, B, Q, I) {
  let G =
      Q.length > 0
        ? `

IMPORTANT: The following identifiers already exist and must NOT be used: ${Q.join(", ")}`
        : "",
    Z = `Create an agent configuration based on this request: "${A}".${G}
  Return ONLY the JSON object, no other text.`,
    Y = T0({ content: Z }),
    J = await FV(),
    X = Ir([Y], J),
    C = (
      await YS({
        messages: D7(X),
        systemPrompt: [E1I],
        maxThinkingTokens: 0,
        tools: [],
        signal: I,
        options: {
          getToolPermissionContext: async () => kM(),
          model: B,
          toolChoice: void 0,
          agents: [],
          isNonInteractiveSession: !1,
          hasAppendSystemPrompt: !1,
          querySource: "agent_creation",
          mcpTools: [],
        },
      })
    ).message.content
      .filter((K) => K.type === "text")
      .map((K) => K.text).join(`
`),
    V;
  try {
    V = JSON.parse(C.trim());
  } catch {
    let K = C.match(/\{[\s\S]*\}/);
    if (!K) throw Error("No JSON object found in response");
    V = JSON.parse(K[0]);
  }
  if (!V.identifier || !V.whenToUse || !V.systemPrompt)
    throw Error("Invalid agent configuration generated");
  return (
    GA("tengu_agent_definition_generated", { agent_identifier: V.identifier }),
    {
      identifier: V.identifier,
      whenToUse: V.whenToUse,
      systemPrompt: V.systemPrompt,
    }
  );
}
var E1I;
var _n2 = T(() => {
  zG();
  iB();
  ZS();
  H0();
  wv();
  E1I = `You are an elite AI agent architect specializing in crafting high-performance agent configurations. Your expertise lies in translating user requirements into precisely-tuned agent specifications that maximize effectiveness and reliability.

**Important Context**: You may have access to project-specific instructions from CLAUDE.md files and other context that may include coding standards, project structure, and custom requirements. Consider this context when creating agents to ensure they align with the project's established patterns and practices.

When a user describes what they want an agent to do, you will:

1. **Extract Core Intent**: Identify the fundamental purpose, key responsibilities, and success criteria for the agent. Look for both explicit requirements and implicit needs. Consider any project-specific context from CLAUDE.md files. For agents that are meant to review code, you should assume that the user is asking to review recently written code and not the whole codebase, unless the user has explicitly instructed you otherwise.

2. **Design Expert Persona**: Create a compelling expert identity that embodies deep domain knowledge relevant to the task. The persona should inspire confidence and guide the agent's decision-making approach.

3. **Architect Comprehensive Instructions**: Develop a system prompt that:
   - Establishes clear behavioral boundaries and operational parameters
   - Provides specific methodologies and best practices for task execution
   - Anticipates edge cases and provides guidance for handling them
   - Incorporates any specific requirements or preferences mentioned by the user
   - Defines output format expectations when relevant
   - Aligns with project-specific coding standards and patterns from CLAUDE.md

4. **Optimize for Performance**: Include:
   - Decision-making frameworks appropriate to the domain
   - Quality control mechanisms and self-verification steps
   - Efficient workflow patterns
   - Clear escalation or fallback strategies

5. **Create Identifier**: Design a concise, descriptive identifier that:
   - Uses lowercase letters, numbers, and hyphens only
   - Is typically 2-4 words joined by hyphens
   - Clearly indicates the agent's primary function
   - Is memorable and easy to type
   - Avoids generic terms like "helper" or "assistant"

6 **Example agent descriptions**:
  - in the 'whenToUse' field of the JSON object, you should include examples of when this agent should be used.
  - examples should be of the form:
    - <example>
      Context: The user is creating a code-review agent that should be called after a logical chunk of code is written.
      user: "Please write a function that checks if a number is prime"
      assistant: "Here is the relevant function: "
      <function call omitted for brevity only for this example>
      <commentary>
      Since the user is greeting, use the ${x8} tool to launch the greeting-responder agent to respond with a friendly joke. 
      </commentary>
      assistant: "Now let me use the code-reviewer agent to review the code"
    </example>
    - <example>
      Context: User is creating an agent to respond to the word "hello" with a friendly jok.
      user: "Hello"
      assistant: "I'm going to use the ${x8} tool to launch the greeting-responder agent to respond with a friendly joke"
      <commentary>
      Since the user is greeting, use the greeting-responder agent to respond with a friendly joke. 
      </commentary>
    </example>
  - If the user mentioned or implied that the agent should be used proactively, you should include examples of this.
- NOTE: Ensure that in the examples, you are making the assistant use the Agent tool and not simply respond directly to the task.

Your output must be a valid JSON object with exactly these fields:
{
  "identifier": "A unique, descriptive identifier using lowercase letters, numbers, and hyphens (e.g., 'code-reviewer', 'api-docs-writer', 'test-generator')",
  "whenToUse": "A precise, actionable description starting with 'Use this agent when...' that clearly defines the triggering conditions and use cases. Ensure you include examples as described above.",
  "systemPrompt": "The complete system prompt that will govern the agent's behavior, written in second person ('You are...', 'You will...') and structured for maximum clarity and effectiveness"
}

Key principles for your system prompts:
- Be specific rather than generic - avoid vague instructions
- Include concrete examples when they would clarify behavior
- Balance comprehensiveness with clarity - every instruction should add value
- Ensure the agent has enough context to handle variations of the core task
- Make the agent proactive in seeking clarification when needed
- Build in quality assurance and self-correction mechanisms

Remember: The agents you create should be autonomous experts capable of handling their designated tasks with minimal additional guidance. Your system prompts are their complete operational manual.
`;
});
function xn2() {
  let { updateWizardData: A, goBack: B, goToStep: Q, wizardData: I } = PG(),
    [G, Z] = TV.useState(I.generationPrompt || ""),
    [Y, J] = TV.useState(!1),
    [X, W] = TV.useState(null),
    [F, C] = TV.useState(G.length),
    V = Jc(),
    K = TV.useRef(null);
  h1((H, w) => {
    if (w.escape) {
      if (Y && K.current)
        (K.current.abort(),
          (K.current = null),
          J(!1),
          W("Generation cancelled"));
      else if (!Y)
        (A({
          generationPrompt: "",
          agentType: "",
          systemPrompt: "",
          whenToUse: "",
          generatedAgent: void 0,
          wasGenerated: !1,
        }),
          Z(""),
          W(null),
          B());
    }
  });
  let D = async () => {
      let H = G.trim();
      if (!H) {
        W("Please describe what the agent should do");
        return;
      }
      (W(null), J(!0), A({ generationPrompt: H, isGenerating: !0 }));
      let w = a9();
      K.current = w;
      try {
        let L = await kn2(H, V, [], w.signal);
        (A({
          agentType: L.identifier,
          whenToUse: L.whenToUse,
          systemPrompt: L.systemPrompt,
          generatedAgent: L,
          isGenerating: !1,
          wasGenerated: !0,
        }),
          Q(6));
      } catch (L) {
        if (
          L instanceof Error &&
          !L.message.includes("No assistant message found")
        )
          W(L.message || "Failed to generate agent");
        A({ isGenerating: !1 });
      } finally {
        (J(!1), (K.current = null));
      }
    },
    E =
      "Describe what this agent should do and when it should be used (be comprehensive for best results)";
  if (Y)
    return TV.default.createElement(
      uY,
      { subtitle: E, footerText: "Esc to cancel" },
      TV.default.createElement(
        S,
        { marginTop: 1, flexDirection: "row", alignItems: "center" },
        TV.default.createElement(E8, null),
        TV.default.createElement(
          U,
          { color: "suggestion" },
          " Generating agent from description...",
        ),
      ),
    );
  return TV.default.createElement(
    uY,
    { subtitle: E, footerText: "Press Enter to submit  Esc to go back" },
    TV.default.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      X &&
        TV.default.createElement(
          S,
          { marginBottom: 1 },
          TV.default.createElement(U, { color: "error" }, X),
        ),
      TV.default.createElement(O4, {
        value: G,
        onChange: Z,
        onSubmit: D,
        placeholder: "e.g., Help me write unit tests for my code...",
        columns: 80,
        cursorOffset: F,
        onChangeCursorOffset: C,
        focus: !0,
        showCursor: !0,
      }),
    ),
  );
}
var TV;
var vn2 = T(() => {
  nA();
  nA();
  rG();
  wL();
  aw();
  xX();
  _n2();
  czA();
  vG();
  TV = IA(KA(), 1);
});
function k00(A) {
  if (!A) return "Agent type is required";
  if (!/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/.test(A))
    return "Agent type must start and end with alphanumeric characters and contain only letters, numbers, and hyphens";
  if (A.length < 3) return "Agent type must be at least 3 characters long";
  if (A.length > 50) return "Agent type must be less than 50 characters";
  return null;
}
function bn2(A, B, Q) {
  let I = [],
    G = [];
  if (!A.agentType) I.push("Agent type is required");
  else {
    let Z = k00(A.agentType);
    if (Z) I.push(Z);
    let Y = Q.find((J) => J.agentType === A.agentType && J.source !== A.source);
    if (Y)
      I.push(`Agent type "${A.agentType}" already exists in ${k7A(Y.source)}`);
  }
  if (!A.whenToUse) I.push("Description (description) is required");
  else if (A.whenToUse.length < 10)
    G.push("Description should be more descriptive (at least 10 characters)");
  else if (A.whenToUse.length > 5000)
    G.push("Description is very long (over 5000 characters)");
  if (A.tools !== void 0 && !Array.isArray(A.tools))
    I.push("Tools must be an array");
  else {
    if (A.tools === void 0) G.push("Agent has access to all tools");
    else if (A.tools.length === 0)
      G.push("No tools selected - agent will have very limited capabilities");
    let Z = p5A(A, B, !1);
    if (Z.invalidTools.length > 0)
      I.push(`Invalid tools: ${Z.invalidTools.join(", ")}`);
  }
  if (!A.systemPrompt) I.push("System prompt is required");
  else if (A.systemPrompt.length < 20)
    I.push("System prompt is too short (minimum 20 characters)");
  else if (A.systemPrompt.length > 1e4)
    G.push("System prompt is very long (over 10,000 characters)");
  return { isValid: I.length === 0, errors: I, warnings: G };
}
var _00 = T(() => {
  l5A();
  lB1();
});
function fn2(A) {
  let { goNext: B, goBack: Q, updateWizardData: I, wizardData: G } = PG(),
    [Z, Y] = $L.useState(G.agentType || ""),
    [J, X] = $L.useState(null),
    [W, F] = $L.useState(Z.length);
  return (
    h1((V, K) => {
      if (K.escape) Q();
    }),
    $L.default.createElement(
      uY,
      {
        subtitle: "Agent type (identifier)",
        footerText: "Type to enter text  Enter to continue  Esc to go back",
      },
      $L.default.createElement(
        S,
        { flexDirection: "column", marginTop: 1 },
        $L.default.createElement(
          U,
          null,
          "Enter a unique identifier for your agent:",
        ),
        $L.default.createElement(
          S,
          { marginTop: 1 },
          $L.default.createElement(O4, {
            value: Z,
            onChange: Y,
            onSubmit: (V) => {
              let K = V.trim(),
                D = k00(K);
              if (D) {
                X(D);
                return;
              }
              (X(null), I({ agentType: K }), B());
            },
            placeholder: "e.g., code-reviewer, tech-lead, etc",
            columns: 60,
            cursorOffset: W,
            onChangeCursorOffset: F,
            focus: !0,
            showCursor: !0,
          }),
        ),
        J &&
          $L.default.createElement(
            S,
            { marginTop: 1 },
            $L.default.createElement(U, { color: "error" }, J),
          ),
      ),
    )
  );
}
var $L;
var hn2 = T(() => {
  nA();
  nA();
  rG();
  wL();
  aw();
  _00();
  $L = IA(KA(), 1);
});
function gn2() {
  let { goNext: A, goBack: B, updateWizardData: Q, wizardData: I } = PG(),
    [G, Z] = sw.useState(I.systemPrompt || ""),
    [Y, J] = sw.useState(G.length),
    [X, W] = sw.useState(null);
  return (
    h1((C, V) => {
      if (V.escape) B();
    }),
    sw.default.createElement(
      uY,
      {
        subtitle: "System prompt",
        footerText: "Type to enter text  Enter to continue  Esc to go back",
      },
      sw.default.createElement(
        S,
        { flexDirection: "column", marginTop: 1 },
        sw.default.createElement(
          U,
          null,
          "Enter the system prompt for your agent:",
        ),
        sw.default.createElement(
          U,
          { dimColor: !0 },
          "Be comprehensive for best results",
        ),
        sw.default.createElement(
          S,
          { marginTop: 1 },
          sw.default.createElement(O4, {
            value: G,
            onChange: Z,
            onSubmit: () => {
              let C = G.trim();
              if (!C) {
                W("System prompt is required");
                return;
              }
              (W(null), Q({ systemPrompt: C }), A());
            },
            placeholder: "You are a helpful code reviewer who...",
            columns: 80,
            cursorOffset: Y,
            onChangeCursorOffset: J,
            focus: !0,
            showCursor: !0,
          }),
        ),
        X &&
          sw.default.createElement(
            S,
            { marginTop: 1 },
            sw.default.createElement(U, { color: "error" }, X),
          ),
      ),
    )
  );
}
var sw;
var un2 = T(() => {
  nA();
  nA();
  rG();
  wL();
  aw();
  sw = IA(KA(), 1);
});
function mn2() {
  let { goNext: A, goBack: B, updateWizardData: Q, wizardData: I } = PG(),
    [G, Z] = qL.useState(I.whenToUse || ""),
    [Y, J] = qL.useState(G.length),
    [X, W] = qL.useState(null);
  return (
    h1((C, V) => {
      if (V.escape) B();
    }),
    qL.default.createElement(
      uY,
      {
        subtitle: "Description (tell Claude when to use this agent)",
        footerText: "Type to enter text  Enter to continue  Esc to go back",
      },
      qL.default.createElement(
        S,
        { flexDirection: "column", marginTop: 1 },
        qL.default.createElement(U, null, "When should Claude use this agent?"),
        qL.default.createElement(
          S,
          { marginTop: 1 },
          qL.default.createElement(O4, {
            value: G,
            onChange: Z,
            onSubmit: (C) => {
              let V = C.trim();
              if (!V) {
                W("Description is required");
                return;
              }
              (W(null), Q({ whenToUse: V }), A());
            },
            placeholder:
              "e.g., use this agent after you're done writing code...",
            columns: 80,
            cursorOffset: Y,
            onChangeCursorOffset: J,
            focus: !0,
            showCursor: !0,
          }),
        ),
        X &&
          qL.default.createElement(
            S,
            { marginTop: 1 },
            qL.default.createElement(U, { color: "error" }, X),
          ),
      ),
    )
  );
}
var qL;
var dn2 = T(() => {
  nA();
  nA();
  rG();
  wL();
  aw();
  qL = IA(KA(), 1);
});
function H1I(A) {
  let B = new Map();
  return (
    A.forEach((Q) => {
      if (Rv(Q)) {
        let I = ZE(Q.name);
        if (I?.serverName) {
          let G = B.get(I.serverName) || [];
          (G.push(Q), B.set(I.serverName, G));
        }
      }
    }),
    Array.from(B.entries())
      .map(([Q, I]) => ({ serverName: Q, tools: I }))
      .sort((Q, I) => Q.serverName.localeCompare(I.serverName))
  );
}
function aB1({ tools: A, initialTools: B, onComplete: Q, onCancel: I }) {
  let G = dX.useMemo(() => mc1({ tools: A, isBuiltIn: !1, isAsync: !1 }), [A]),
    Z = !B || B.includes("*") ? G.map((x) => x.name) : B,
    [Y, J] = dX.useState(Z),
    [X, W] = dX.useState(0),
    [F, C] = dX.useState(!1),
    V = dX.useMemo(() => {
      let x = new Set(G.map((n) => n.name));
      return Y.filter((n) => x.has(n));
    }, [Y, G]),
    K = new Set(V),
    D = V.length === G.length && G.length > 0,
    E = (x) => {
      if (!x) return;
      J((n) => (n.includes(x) ? n.filter((m) => m !== x) : [...n, x]));
    },
    H = (x, n) => {
      J((m) => {
        if (n) {
          let o = x.filter((l) => !m.includes(l));
          return [...m, ...o];
        } else return m.filter((o) => !x.includes(o));
      });
    },
    w = () => {
      let x = G.map((o) => o.name),
        m = V.length === x.length && x.every((o) => V.includes(o)) ? void 0 : V;
      Q(m);
    },
    L = dX.useMemo(() => {
      let x = cn2(),
        n = { readOnly: [], edit: [], execution: [], mcp: [], other: [] };
      return (
        G.forEach((m) => {
          if (Rv(m)) n.mcp.push(m);
          else if (x.READ_ONLY.toolNames.has(m.name)) n.readOnly.push(m);
          else if (x.EDIT.toolNames.has(m.name)) n.edit.push(m);
          else if (x.EXECUTION.toolNames.has(m.name)) n.execution.push(m);
          else if (m.name !== x8) n.other.push(m);
        }),
        n
      );
    }, [G]),
    N = (x) => {
      let m = x.filter((o) => K.has(o.name)).length < x.length;
      return () => {
        let o = x.map((l) => l.name);
        H(o, m);
      };
    },
    $ = [];
  ($.push({ id: "continue", label: "Continue", action: w, isContinue: !0 }),
    $.push({
      id: "bucket-all",
      label: `${D ? E1.checkboxOn : E1.checkboxOff} All tools`,
      action: () => {
        let x = G.map((n) => n.name);
        H(x, !D);
      },
    }));
  let O = cn2();
  [
    { id: "bucket-readonly", name: O.READ_ONLY.name, tools: L.readOnly },
    { id: "bucket-edit", name: O.EDIT.name, tools: L.edit },
    { id: "bucket-execution", name: O.EXECUTION.name, tools: L.execution },
    { id: "bucket-mcp", name: O.MCP.name, tools: L.mcp },
    { id: "bucket-other", name: O.OTHER.name, tools: L.other },
  ].forEach(({ id: x, name: n, tools: m }) => {
    if (m.length === 0) return;
    let l = m.filter((y) => K.has(y.name)).length === m.length;
    $.push({
      id: x,
      label: `${l ? E1.checkboxOn : E1.checkboxOff} ${n}`,
      action: N(m),
    });
  });
  let k = $.length;
  $.push({
    id: "toggle-individual",
    label: F ? "Hide advanced options" : "Show advanced options",
    action: () => {
      if ((C(!F), F && X > k)) W(k);
    },
    isToggle: !0,
  });
  let b = dX.useMemo(() => H1I(G), [G]);
  if (F) {
    if (b.length > 0)
      ($.push({
        id: "mcp-servers-header",
        label: "MCP Servers:",
        action: () => {},
        isHeader: !0,
      }),
        b.forEach(({ serverName: x, tools: n }) => {
          let o = n.filter((l) => K.has(l.name)).length === n.length;
          $.push({
            id: `mcp-server-${x}`,
            label: `${o ? E1.checkboxOn : E1.checkboxOff} ${x} (${n.length} tool${n.length === 1 ? "" : "s"})`,
            action: () => {
              let l = n.map((y) => y.name);
              H(l, !o);
            },
          });
        }),
        $.push({
          id: "tools-header",
          label: "Individual Tools:",
          action: () => {},
          isHeader: !0,
        }));
    G.forEach((x) => {
      let n = x.name;
      if (x.name.startsWith("mcp__")) {
        let m = ZE(x.name);
        n = m ? `${m.toolName} (${m.serverName})` : x.name;
      }
      $.push({
        id: `tool-${x.name}`,
        label: `${K.has(x.name) ? E1.checkboxOn : E1.checkboxOff} ${n}`,
        action: () => E(x.name),
      });
    });
  }
  return (
    h1((x, n) => {
      if (n.return) {
        let m = $[X];
        if (m && !m.isHeader) m.action();
      } else if (n.escape)
        if (I) I();
        else Q(B);
      else if (n.upArrow) {
        let m = X - 1;
        while (m > 0 && $[m]?.isHeader) m--;
        W(Math.max(0, m));
      } else if (n.downArrow) {
        let m = X + 1;
        while (m < $.length - 1 && $[m]?.isHeader) m++;
        W(Math.min($.length - 1, m));
      }
    }),
    dX.default.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      dX.default.createElement(
        U,
        { color: X === 0 ? "suggestion" : void 0, bold: X === 0 },
        X === 0 ? `${E1.pointer} ` : "  ",
        "[ Continue ]",
      ),
      dX.default.createElement(U, { dimColor: !0 }, "".repeat(40)),
      $.slice(1).map((x, n) => {
        let m = n + 1 === X,
          o = x.isToggle,
          l = x.isHeader;
        return dX.default.createElement(
          dX.default.Fragment,
          { key: x.id },
          o && dX.default.createElement(U, { dimColor: !0 }, "".repeat(40)),
          l && n > 0 && dX.default.createElement(S, { marginTop: 1 }),
          dX.default.createElement(
            U,
            {
              color: l ? void 0 : m ? "suggestion" : void 0,
              dimColor: l,
              bold: o && m,
            },
            l ? "" : m ? `${E1.pointer} ` : "  ",
            o ? `[ ${x.label} ]` : x.label,
          ),
        );
      }),
      dX.default.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        dX.default.createElement(
          U,
          { dimColor: !0 },
          D ? "All tools selected" : `${K.size} of ${G.length} tools selected`,
        ),
      ),
    )
  );
}
var dX,
  cn2 = () => ({
    READ_ONLY: {
      name: "Read-only tools",
      toolNames: new Set([
        $N.name,
        pj.name,
        JR.name,
        t4.name,
        RJ.name,
        oG.name,
        z$A.name,
        _01.name,
        x01.name,
        $b.name,
        qb.name,
      ]),
    },
    EDIT: {
      name: "Edit tools",
      toolNames: new Set([Qz.name, QV.name, dO.name]),
    },
    EXECUTION: {
      name: "Execution tools",
      toolNames: new Set([r2.name, void 0].filter(Boolean)),
    },
    MCP: { name: "MCP tools", toolNames: new Set(), isMcp: !0 },
    OTHER: { name: "Other tools", toolNames: new Set() },
  });
var x00 = T(() => {
  nA();
  nA();
  s2();
  kF();
  WEA();
  JEA();
  RzA();
  Ww();
  gr();
  vn();
  RA0();
  LA0();
  OA0();
  b01();
  f01();
  os();
  mm();
  X5A();
  EF();
  l5A();
  dX = IA(KA(), 1);
});
function pn2({ tools: A }) {
  let { goNext: B, goBack: Q, updateWizardData: I, wizardData: G } = PG(),
    Z = (J) => {
      (I({ selectedTools: J }), B());
    },
    Y = G.selectedTools;
  return v00.default.createElement(
    uY,
    {
      subtitle: "Select tools",
      footerText:
        "Press Enter to toggle selection   to navigate  Esc to go back",
    },
    v00.default.createElement(aB1, {
      tools: A,
      initialTools: Y,
      onComplete: Z,
      onCancel: Q,
    }),
  );
}
var v00;
var ln2 = T(() => {
  x00();
  wL();
  aw();
  v00 = IA(KA(), 1);
});
function sB1({ initialModel: A, onComplete: B, onCancel: Q }) {
  let I = NL.useMemo(() => zzB(), []),
    G = NL.useMemo(() => {
      if (A && I.some((Z) => Z.value === A)) return A;
      return "sonnet";
    }, [A, I]);
  return NL.createElement(
    S,
    { flexDirection: "column" },
    NL.createElement(
      S,
      { marginBottom: 1 },
      NL.createElement(
        U,
        { dimColor: !0 },
        "Model determines the agent's reasoning capabilities and speed.",
      ),
    ),
    NL.createElement($0, {
      options: I,
      defaultValue: G,
      onChange: (Z) => {
        B(Z);
      },
      onCancel: () => (Q ? Q() : B(A)),
    }),
  );
}
var NL;
var b00 = T(() => {
  nA();
  Z5();
  Y9();
  NL = IA(KA(), 1);
});
function in2() {
  let { goNext: A, goBack: B, updateWizardData: Q, wizardData: I } = PG(),
    G = (Z) => {
      (Q({ selectedModel: Z }), A());
    };
  return f00.default.createElement(
    uY,
    {
      subtitle: "Select model",
      footerText: "Press  to navigate  Enter to select  Esc to go back",
    },
    f00.default.createElement(sB1, {
      initialModel: I.selectedModel,
      onComplete: G,
      onCancel: B,
    }),
  );
}
var f00;
var nn2 = T(() => {
  b00();
  wL();
  aw();
  f00 = IA(KA(), 1);
});
function rB1({ agentName: A, currentColor: B = "automatic", onConfirm: Q }) {
  let [I, G] = UE.useState(
    Math.max(
      0,
      _7A.findIndex((Y) => Y === B),
    ),
  );
  h1((Y, J) => {
    if (J.upArrow) G((X) => (X > 0 ? X - 1 : _7A.length - 1));
    else if (J.downArrow) G((X) => (X < _7A.length - 1 ? X + 1 : 0));
    else if (J.return) {
      let X = _7A[I];
      Q(X === "automatic" ? void 0 : X);
    }
  });
  let Z = _7A[I];
  return UE.default.createElement(
    S,
    { flexDirection: "column", gap: 1 },
    UE.default.createElement(
      S,
      { flexDirection: "column" },
      _7A.map((Y, J) => {
        let X = J === I;
        return UE.default.createElement(
          S,
          { key: Y, flexDirection: "row", gap: 1 },
          UE.default.createElement(
            U,
            { color: X ? "suggestion" : void 0 },
            X ? E1.pointer : " ",
          ),
          Y === "automatic"
            ? UE.default.createElement(U, { bold: X }, "Automatic color")
            : UE.default.createElement(
                S,
                { gap: 1 },
                UE.default.createElement(
                  U,
                  { backgroundColor: QnA[Y], color: "inverseText" },
                  " ",
                ),
                UE.default.createElement(
                  U,
                  { bold: X },
                  Y.charAt(0).toUpperCase() + Y.slice(1),
                ),
              ),
        );
      }),
    ),
    UE.default.createElement(
      S,
      { marginTop: 1 },
      UE.default.createElement(U, null, "Preview: "),
      Z === void 0 || Z === "automatic"
        ? UE.default.createElement(U, { inverse: !0, bold: !0 }, " ", A, " ")
        : UE.default.createElement(
            U,
            { backgroundColor: QnA[Z], color: "inverseText", bold: !0 },
            " ",
            A,
            " ",
          ),
    ),
  );
}
var UE, _7A;
var h00 = T(() => {
  nA();
  cm();
  s2();
  ((UE = IA(KA(), 1)), (_7A = ["automatic", ...z6A]));
});
function an2() {
  let { goNext: A, goBack: B, updateWizardData: Q, wizardData: I } = PG();
  h1((Z, Y) => {
    if (Y.escape) B();
  });
  let G = (Z) => {
    (Q({
      selectedColor: Z,
      finalAgent: {
        agentType: I.agentType,
        whenToUse: I.whenToUse,
        systemPrompt: I.systemPrompt,
        tools: I.selectedTools,
        ...(I.selectedModel ? { model: I.selectedModel } : {}),
        ...(Z ? { color: Z } : {}),
        source: I.location,
      },
    }),
      A());
  };
  return oB1.default.createElement(
    uY,
    {
      subtitle: "Choose background color",
      footerText: "Press  to navigate  Enter to select  Esc to go back",
    },
    oB1.default.createElement(
      S,
      { marginTop: 1 },
      oB1.default.createElement(rB1, {
        agentName: I.agentType || "agent",
        currentColor: "automatic",
        onConfirm: G,
      }),
    ),
  );
}
var oB1;
var sn2 = T(() => {
  nA();
  nA();
  h00();
  wL();
  aw();
  oB1 = IA(KA(), 1);
});
function rn2({
  tools: A,
  existingAgents: B,
  onSave: Q,
  onSaveAndEdit: I,
  error: G,
}) {
  let { goBack: Z, wizardData: Y } = PG();
  h1((F, C) => {
    if (C.escape) Z();
    else if (F === "s" || C.return) Q();
    else if (F === "e") I();
  });
  let J = Y.finalAgent,
    X = bn2(J, A, B),
    W = (F) => {
      if (F === void 0) return "All tools";
      if (F.length === 0) return "None";
      if (F.length === 1) return F[0] || "None";
      if (F.length === 2) return F.join(" and ");
      return `${F.slice(0, -1).join(", ")}, and ${F[F.length - 1]}`;
    };
  return k5.default.createElement(
    uY,
    {
      subtitle: "Confirm and save",
      footerText:
        "Press s/Enter to save  e to edit in your editor  Esc to cancel",
    },
    k5.default.createElement(
      S,
      { flexDirection: "column", marginTop: 1 },
      k5.default.createElement(
        U,
        null,
        k5.default.createElement(U, { bold: !0 }, "Name"),
        ": ",
        J.agentType,
      ),
      k5.default.createElement(
        U,
        null,
        k5.default.createElement(U, { bold: !0 }, "Location"),
        ":",
        " ",
        qn2({ source: Y.location, agentType: J.agentType }),
      ),
      k5.default.createElement(
        U,
        null,
        k5.default.createElement(U, { bold: !0 }, "Tools"),
        ": ",
        W(J.tools),
      ),
      k5.default.createElement(
        U,
        null,
        k5.default.createElement(U, { bold: !0 }, "Model"),
        ": ",
        ZbA(J.model),
      ),
      k5.default.createElement(
        S,
        { marginTop: 1 },
        k5.default.createElement(
          U,
          null,
          k5.default.createElement(U, { bold: !0 }, "Description"),
          " (tells Claude when to use this agent):",
        ),
      ),
      k5.default.createElement(
        S,
        { marginLeft: 2, marginTop: 1 },
        k5.default.createElement(
          U,
          null,
          J.whenToUse.length > 240
            ? J.whenToUse.slice(0, 240) + ""
            : J.whenToUse,
        ),
      ),
      k5.default.createElement(
        S,
        { marginTop: 1 },
        k5.default.createElement(
          U,
          null,
          k5.default.createElement(U, { bold: !0 }, "System prompt"),
          ":",
        ),
      ),
      k5.default.createElement(
        S,
        { marginLeft: 2, marginTop: 1 },
        k5.default.createElement(
          U,
          null,
          J.systemPrompt.length > 240
            ? J.systemPrompt.slice(0, 240) + ""
            : J.systemPrompt,
        ),
      ),
      X.warnings.length > 0 &&
        k5.default.createElement(
          S,
          { marginTop: 1, flexDirection: "column" },
          k5.default.createElement(U, { color: "warning" }, "Warnings:"),
          X.warnings.map((F, C) =>
            k5.default.createElement(U, { key: C, dimColor: !0 }, " ", " ", F),
          ),
        ),
      X.errors.length > 0 &&
        k5.default.createElement(
          S,
          { marginTop: 1, flexDirection: "column" },
          k5.default.createElement(U, { color: "error" }, "Errors:"),
          X.errors.map((F, C) =>
            k5.default.createElement(
              U,
              { key: C, color: "error" },
              " ",
              " ",
              F,
            ),
          ),
        ),
      G &&
        k5.default.createElement(
          S,
          { marginTop: 1 },
          k5.default.createElement(U, { color: "error" }, G),
        ),
      k5.default.createElement(
        S,
        { marginTop: 2 },
        k5.default.createElement(
          U,
          { color: "success" },
          "Press ",
          k5.default.createElement(U, { bold: !0 }, "s"),
          " or ",
          k5.default.createElement(U, { bold: !0 }, "Enter"),
          " to save,",
          " ",
          k5.default.createElement(U, { bold: !0 }, "e"),
          " to save and edit",
        ),
      ),
    ),
  );
}
var k5;
var on2 = T(() => {
  nA();
  nA();
  wL();
  aw();
  _00();
  y7A();
  Y9();
  k5 = IA(KA(), 1);
});
function tn2({ tools: A, existingAgents: B, onComplete: Q }) {
  let { wizardData: I } = PG(),
    [G, Z] = Et.useState(null),
    [, Y] = lB(),
    J = Et.useCallback(async () => {
      if (!I?.finalAgent) return;
      try {
        (await L00(
          I.location,
          I.finalAgent.agentType,
          I.finalAgent.whenToUse,
          I.finalAgent.tools,
          I.finalAgent.systemPrompt,
          !0,
          I.finalAgent.color,
          I.finalAgent.model,
        ),
          Y((W) => {
            if (!I.finalAgent) return W;
            let F = W.agentDefinitions.allAgents.concat(I.finalAgent);
            return {
              ...W,
              agentDefinitions: {
                ...W.agentDefinitions,
                activeAgents: Uy(F),
                allAgents: F,
              },
            };
          }),
          GA("tengu_agent_created", {
            agent_type: I.finalAgent.agentType,
            generation_method: I.wasGenerated ? "generated" : "manual",
            source: I.location,
            tool_count: I.finalAgent.tools?.length ?? "all",
            has_custom_model: !!I.finalAgent.model,
            has_custom_color: !!I.finalAgent.color,
          }),
          Q(`Created agent: ${iA.bold(I.finalAgent.agentType)}`));
      } catch (W) {
        Z(W instanceof Error ? W.message : "Failed to save agent");
      }
    }, [I, Q, Y]),
    X = Et.useCallback(async () => {
      if (!I?.finalAgent) return;
      try {
        (await L00(
          I.location,
          I.finalAgent.agentType,
          I.finalAgent.whenToUse,
          I.finalAgent.tools,
          I.finalAgent.systemPrompt,
          !0,
          I.finalAgent.color,
          I.finalAgent.model,
        ),
          Y((F) => {
            if (!I.finalAgent) return F;
            let C = F.agentDefinitions.allAgents.concat(I.finalAgent);
            return {
              ...F,
              agentDefinitions: {
                ...F.agentDefinitions,
                activeAgents: Uy(C),
                allAgents: C,
              },
            };
          }));
        let W = N00({ source: I.location, agentType: I.finalAgent.agentType });
        (await LIA(W),
          GA("tengu_agent_created", {
            agent_type: I.finalAgent.agentType,
            generation_method: I.wasGenerated ? "generated" : "manual",
            source: I.location,
            tool_count: I.finalAgent.tools?.length ?? "all",
            has_custom_model: !!I.finalAgent.model,
            has_custom_color: !!I.finalAgent.color,
            opened_in_editor: !0,
          }),
          Q(
            `Created agent: ${iA.bold(I.finalAgent.agentType)} and opened in editor. If you made edits, restart to load the latest version.`,
          ));
      } catch (W) {
        Z(W instanceof Error ? W.message : "Failed to save agent");
      }
    }, [I, Q, Y]);
  return Et.default.createElement(rn2, {
    tools: A,
    existingAgents: B,
    onSave: J,
    onSaveAndEdit: X,
    error: G,
  });
}
var Et;
var en2 = T(() => {
  f2();
  aw();
  on2();
  y7A();
  x$A();
  mr();
  H0();
  c9();
  Et = IA(KA(), 1);
});
function Aa2({ tools: A, existingAgents: B, onComplete: Q, onCancel: I }) {
  return v$A.default.createElement(R00, {
    steps: [
      Pn2,
      Sn2,
      xn2,
      () => v$A.default.createElement(fn2, { existingAgents: B }),
      gn2,
      mn2,
      () => v$A.default.createElement(pn2, { tools: A }),
      in2,
      an2,
      () =>
        v$A.default.createElement(tn2, {
          tools: A,
          existingAgents: B,
          onComplete: Q,
        }),
    ],
    initialData: {},
    onComplete: () => {},
    onCancel: I,
    title: "Create new agent",
    showStepCounter: !1,
  });
}
var v$A;
var Ba2 = T(() => {
  aw();
  jn2();
  yn2();
  vn2();
  hn2();
  un2();
  dn2();
  ln2();
  nn2();
  sn2();
  en2();
  v$A = IA(KA(), 1);
});
function Qa2({ agent: A, tools: B, onSaved: Q, onBack: I }) {
  let [, G] = lB(),
    [Z, Y] = LL.useState("menu"),
    [J, X] = LL.useState(0),
    [W, F] = LL.useState(null),
    [C, V] = LL.useState(A.color),
    K = LL.useCallback(async () => {
      try {
        let N = pB1(A);
        (await LIA(N),
          Q(
            `Opened ${A.agentType} in editor. If you made edits, restart to load the latest version.`,
          ));
      } catch (N) {
        F(N instanceof Error ? N.message : "Failed to open editor");
      }
    }, [A, Q]),
    D = LL.useCallback(
      async (N = {}) => {
        let { tools: $, color: O, model: P } = N,
          k = O ?? C,
          b = $ !== void 0,
          x = P !== void 0,
          n = k !== A.color;
        if (!b && !x && !n) return !1;
        try {
          if (
            (await Ln2(
              A,
              A.whenToUse,
              $ ?? A.tools,
              A.systemPrompt,
              k,
              P ?? A.model,
            ),
            n && k)
          )
            w6A(A.agentType, k);
          return (
            G((m) => {
              let o = m.agentDefinitions.allAgents.map((l) =>
                l.agentType === A.agentType
                  ? { ...l, tools: $ ?? l.tools, color: k, model: P ?? l.model }
                  : l,
              );
              return {
                ...m,
                agentDefinitions: {
                  ...m.agentDefinitions,
                  activeAgents: Uy(o),
                  allAgents: o,
                },
              };
            }),
            Q(`Updated agent: ${iA.bold(A.agentType)}`),
            !0
          );
        } catch (m) {
          return (
            F(m instanceof Error ? m.message : "Failed to save agent"),
            !1
          );
        }
      },
      [A, C, Q, G],
    ),
    E = LL.useMemo(
      () => [
        { label: "Open in editor", action: K },
        { label: "Edit tools", action: () => Y("edit-tools") },
        { label: "Edit model", action: () => Y("edit-model") },
        { label: "Edit color", action: () => Y("edit-color") },
      ],
      [K],
    ),
    H = LL.useCallback(() => {
      if ((F(null), Z === "menu")) I();
      else Y("menu");
    }, [Z, I]),
    w = LL.useCallback(
      (N) => {
        if (N.upArrow) X(($) => Math.max(0, $ - 1));
        else if (N.downArrow) X(($) => Math.min(E.length - 1, $ + 1));
        else if (N.return) {
          let $ = E[J];
          if ($) $.action();
        }
      },
      [E, J],
    );
  h1((N, $) => {
    if ($.escape) {
      H();
      return;
    }
    if (Z === "menu") w($);
  });
  let L = () =>
    SW.createElement(
      S,
      { flexDirection: "column" },
      SW.createElement(U, { dimColor: !0 }, "Source: ", k7A(A.source)),
      SW.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        E.map((N, $) =>
          SW.createElement(
            U,
            { key: N.label, color: $ === J ? "suggestion" : void 0 },
            $ === J ? `${E1.pointer} ` : "  ",
            N.label,
          ),
        ),
      ),
      W &&
        SW.createElement(
          S,
          { marginTop: 1 },
          SW.createElement(U, { color: "error" }, W),
        ),
    );
  switch (Z) {
    case "menu":
      return L();
    case "edit-tools":
      return SW.createElement(aB1, {
        tools: B,
        initialTools: A.tools,
        onComplete: async (N) => {
          (Y("menu"), await D({ tools: N }));
        },
      });
    case "edit-color":
      return SW.createElement(rB1, {
        agentName: A.agentType,
        currentColor: C || A.color || "automatic",
        onConfirm: async (N) => {
          (V(N), Y("menu"), await D({ color: N }));
        },
      });
    case "edit-model":
      return SW.createElement(sB1, {
        initialModel: A.model,
        onComplete: async (N) => {
          (Y("menu"), await D({ model: N }));
        },
      });
    default:
      return null;
  }
}
var SW, LL;
var Ia2 = T(() => {
  nA();
  f2();
  x$A();
  x00();
  h00();
  b00();
  y7A();
  mr();
  cm();
  s2();
  lB1();
  c9();
  ((SW = IA(KA(), 1)), (LL = IA(KA(), 1)));
});
function Ga2({ agent: A, tools: B, onBack: Q }) {
  let [I] = HQ(),
    G = p5A(A, B, !1),
    Z = Nn2(A),
    Y = U6A(A.agentType);
  h1((X, W) => {
    if (W.escape || W.return) Q();
  });
  function J() {
    if (G.hasWildcard) return Q9.createElement(U, null, "All tools");
    if (!A.tools || A.tools.length === 0)
      return Q9.createElement(U, null, "None");
    return Q9.createElement(
      Q9.Fragment,
      null,
      G.validTools.length > 0 &&
        Q9.createElement(U, null, G.validTools.join(", ")),
      G.invalidTools.length > 0 &&
        Q9.createElement(
          U,
          { color: "warning" },
          E1.warning,
          " Unrecognized:",
          " ",
          G.invalidTools.join(", "),
        ),
    );
  }
  return Q9.createElement(
    S,
    { flexDirection: "column", gap: 1 },
    Q9.createElement(U, { dimColor: !0 }, Z),
    Q9.createElement(
      S,
      { flexDirection: "column" },
      Q9.createElement(
        U,
        null,
        Q9.createElement(U, { bold: !0 }, "Description"),
        " (tells Claude when to use this agent):",
      ),
      Q9.createElement(
        S,
        { marginLeft: 2 },
        Q9.createElement(U, null, A.whenToUse),
      ),
    ),
    Q9.createElement(
      S,
      null,
      Q9.createElement(
        U,
        null,
        Q9.createElement(U, { bold: !0 }, "Tools"),
        ":",
        " ",
      ),
      J(),
    ),
    Q9.createElement(
      U,
      null,
      Q9.createElement(U, { bold: !0 }, "Model"),
      ": ",
      ZbA(A.model),
    ),
    Y &&
      Q9.createElement(
        S,
        null,
        Q9.createElement(
          U,
          null,
          Q9.createElement(U, { bold: !0 }, "Color"),
          ":",
          " ",
          Q9.createElement(
            U,
            { backgroundColor: Y, color: "inverseText" },
            " ",
            A.agentType,
            " ",
          ),
        ),
      ),
    Q9.createElement(
      S,
      null,
      Q9.createElement(
        U,
        null,
        Q9.createElement(U, { bold: !0 }, "System prompt"),
        ":",
      ),
    ),
    Q9.createElement(
      S,
      { marginLeft: 2, marginRight: 2 },
      Q9.createElement(U, null, tC(A.systemPrompt, I)),
    ),
  );
}
var Q9;
var Za2 = T(() => {
  nA();
  s2();
  l5A();
  Kx();
  y7A();
  cm();
  Y9();
  Q9 = IA(KA(), 1);
});
function x7A({
  instructions: A = "Press  to navigate  Enter to select  Esc to go back",
}) {
  let B = IB();
  return b$A.createElement(
    S,
    { marginLeft: 3 },
    b$A.createElement(
      U,
      { dimColor: !0 },
      B.pending ? `Press ${B.keyName} again to exit` : A,
    ),
  );
}
var b$A;
var Ya2 = T(() => {
  nA();
  R9();
  b$A = IA(KA(), 1);
});
function Ja2({ tools: A, onExit: B }) {
  let [Q, I] = Zp.useState({ mode: "list-agents", source: "all" }),
    [G, Z] = lB(),
    { allAgents: Y, activeAgents: J } = G.agentDefinitions,
    [X, W] = Zp.useState([]),
    F = o11(A, G.mcp.tools);
  IB();
  let C = Zp.useMemo(
    () => ({
      "built-in": Y.filter((D) => D.source === "built-in"),
      userSettings: Y.filter((D) => D.source === "userSettings"),
      projectSettings: Y.filter((D) => D.source === "projectSettings"),
      policySettings: Y.filter((D) => D.source === "policySettings"),
      localSettings: Y.filter((D) => D.source === "localSettings"),
      flagSettings: Y.filter((D) => D.source === "flagSettings"),
      plugin: Y.filter((D) => D.source === "plugin"),
      all: Y,
    }),
    [Y],
  );
  h1((D, E) => {
    if (!E.escape) return;
    let H =
      X.length > 0
        ? `Agent changes:
${X.join(`
`)}`
        : void 0;
    switch (Q.mode) {
      case "list-agents":
        B(H ?? "Agents dialog dismissed", {
          display: X.length === 0 ? "system" : void 0,
        });
        break;
      case "create-agent":
        return;
      case "view-agent":
        return;
      default:
        if ("previousMode" in Q) I(Q.previousMode);
    }
  });
  let V = Zp.useCallback((D) => {
      (W((E) => [...E, D]), I({ mode: "list-agents", source: "all" }));
    }, []),
    K = Zp.useCallback(async (D) => {
      try {
        (await Mn2(D),
          Z((E) => {
            let H = E.agentDefinitions.allAgents.filter(
              (w) => !(w.agentType === D.agentType && w.source === D.source),
            );
            return {
              ...E,
              agentDefinitions: {
                ...E.agentDefinitions,
                allAgents: H,
                activeAgents: Uy(H),
              },
            };
          }),
          W((E) => [...E, `Deleted agent: ${iA.bold(D.agentType)}`]),
          I({ mode: "list-agents", source: "all" }));
      } catch (E) {
        BA(E instanceof Error ? E : Error("Failed to delete agent"), cG0);
      }
    }, []);
  switch (Q.mode) {
    case "list-agents": {
      let D =
          Q.source === "all"
            ? [
                ...C["built-in"],
                ...C.userSettings,
                ...C.projectSettings,
                ...C.policySettings,
                ...C.flagSettings,
                ...C.plugin,
              ]
            : C[Q.source],
        E = new Map();
      J.forEach((w) => E.set(w.agentType, w));
      let H = D.map((w) => {
        let L = E.get(w.agentType),
          N = L && L.source !== w.source ? L.source : void 0;
        return { ...w, overriddenBy: N };
      });
      return kQ.createElement(
        kQ.Fragment,
        null,
        kQ.createElement(On2, {
          source: Q.source,
          agents: H,
          onBack: () => {
            let w =
              X.length > 0
                ? `Agent changes:
${X.join(`
`)}`
                : void 0;
            B(w ?? "Agents dialog dismissed", {
              display: X.length === 0 ? "system" : void 0,
            });
          },
          onSelect: (w) => I({ mode: "agent-menu", agent: w, previousMode: Q }),
          onCreateNew: () => I({ mode: "create-agent" }),
          changes: X,
        }),
        kQ.createElement(x7A, null),
      );
    }
    case "create-agent":
      return kQ.createElement(Aa2, {
        tools: F,
        existingAgents: J,
        onComplete: V,
        onCancel: () => I({ mode: "list-agents", source: "all" }),
      });
    case "agent-menu": {
      let E =
          Y.find(
            (N) =>
              N.agentType === Q.agent.agentType && N.source === Q.agent.source,
          ) || Q.agent,
        H = E.source === "built-in",
        w = [
          { label: "View agent", value: "view" },
          ...(!H
            ? [
                { label: "Edit agent", value: "edit" },
                { label: "Delete agent", value: "delete" },
              ]
            : []),
          { label: "Back", value: "back" },
        ],
        L = (N) => {
          switch (N) {
            case "view":
              I({ mode: "view-agent", agent: E, previousMode: Q.previousMode });
              break;
            case "edit":
              I({ mode: "edit-agent", agent: E, previousMode: Q });
              break;
            case "delete":
              I({ mode: "delete-confirm", agent: E, previousMode: Q });
              break;
            case "back":
              I(Q.previousMode);
              break;
          }
        };
      return kQ.createElement(
        kQ.Fragment,
        null,
        kQ.createElement(
          Gp,
          { title: Q.agent.agentType },
          kQ.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            kQ.createElement($0, {
              options: w,
              onChange: L,
              onCancel: () => I(Q.previousMode),
            }),
            X.length > 0 &&
              kQ.createElement(
                S,
                { marginTop: 1 },
                kQ.createElement(U, { dimColor: !0 }, X[X.length - 1]),
              ),
          ),
        ),
        kQ.createElement(x7A, null),
      );
    }
    case "view-agent": {
      let E =
        Y.find(
          (H) =>
            H.agentType === Q.agent.agentType && H.source === Q.agent.source,
        ) || Q.agent;
      return kQ.createElement(
        kQ.Fragment,
        null,
        kQ.createElement(
          Gp,
          { title: E.agentType },
          kQ.createElement(Ga2, {
            agent: E,
            tools: F,
            allAgents: Y,
            onBack: () =>
              I({ mode: "agent-menu", agent: E, previousMode: Q.previousMode }),
          }),
        ),
        kQ.createElement(x7A, {
          instructions: "Press Enter or Esc to go back",
        }),
      );
    }
    case "delete-confirm": {
      let D = [
        { label: "Yes, delete", value: "yes" },
        { label: "No, cancel", value: "no" },
      ];
      return kQ.createElement(
        kQ.Fragment,
        null,
        kQ.createElement(
          Gp,
          { title: "Delete agent", titleColor: "error", borderColor: "error" },
          kQ.createElement(
            U,
            null,
            "Are you sure you want to delete the agent",
            " ",
            kQ.createElement(U, { bold: !0 }, Q.agent.agentType),
            "?",
          ),
          kQ.createElement(
            S,
            { marginTop: 1 },
            kQ.createElement(U, { dimColor: !0 }, "Source: ", Q.agent.source),
          ),
          kQ.createElement(
            S,
            { marginTop: 1 },
            kQ.createElement($0, {
              options: D,
              onChange: (E) => {
                if (E === "yes") K(Q.agent);
                else if ("previousMode" in Q) I(Q.previousMode);
              },
              onCancel: () => {
                if ("previousMode" in Q) I(Q.previousMode);
              },
            }),
          ),
        ),
        kQ.createElement(x7A, {
          instructions: "Press  to navigate, Enter to select, Esc to cancel",
        }),
      );
    }
    case "edit-agent": {
      let E =
        Y.find(
          (H) =>
            H.agentType === Q.agent.agentType && H.source === Q.agent.source,
        ) || Q.agent;
      return kQ.createElement(
        kQ.Fragment,
        null,
        kQ.createElement(
          Gp,
          { title: `Edit agent: ${E.agentType}` },
          kQ.createElement(Qa2, {
            agent: E,
            tools: F,
            onSaved: (H) => {
              (V(H), I(Q.previousMode));
            },
            onBack: () => I(Q.previousMode),
          }),
        ),
        kQ.createElement(x7A, null),
      );
    }
    default:
      return null;
  }
}
var kQ, Zp;
var Xa2 = T(() => {
  nA();
  nA();
  f2();
  R9();
  x$A();
  y7A();
  Z5();
  Rn2();
  Ba2();
  Ia2();
  Za2();
  c1();
  Ya2();
  M00();
  c9();
  Oe1();
  ((kQ = IA(KA(), 1)), (Zp = IA(KA(), 1)));
});
var g00, z1I, Wa2;
var Fa2 = T(() => {
  Xa2();
  nO();
  ((g00 = IA(KA(), 1)),
    (z1I = {
      type: "local-jsx",
      name: "agents",
      description: "Manage agent configurations",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B) {
        let I = (await B.getAppState()).toolPermissionContext,
          G = Yz(I);
        return g00.createElement(Ja2, { tools: G, onExit: A });
      },
      userFacingName() {
        return "agents";
      },
    }),
    (Wa2 = z1I));
});
function Ca2({ setViewState: A, onComplete: B, exitState: Q }) {
  let [I] = lB(),
    { installationStatus: G, errors: Z } = I.plugins,
    Y = G.marketplaces.length > 0 || G.plugins.length > 0,
    J =
      G.marketplaces.some((C) => C.status === "failed") ||
      G.plugins.some((C) => C.status === "failed"),
    X = Z.length > 0,
    F = [
      { value: "browse-marketplace", label: "Browse and install plugins" },
      { value: "manage-plugins", label: "Manage and uninstall plugins" },
      { value: "add-marketplace", label: "Add marketplace" },
      { value: "manage-marketplaces", label: "Manage marketplaces" },
      ...(Y || X
        ? [
            {
              value: "installation-status",
              label: `View installation status${J || X ? " (errors)" : ""}`,
            },
          ]
        : []),
    ];
  return EZ.createElement(
    S,
    { flexDirection: "column" },
    EZ.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      EZ.createElement(
        S,
        { marginBottom: 1 },
        EZ.createElement(U, { bold: !0 }, "Plugins"),
      ),
      EZ.createElement($0, {
        options: F,
        onChange: (C) => {
          if (C === "add-marketplace") A({ type: "add-marketplace" });
          else if (C === "manage-marketplaces")
            A({ type: "manage-marketplaces" });
          else if (C === "browse-marketplace")
            A({ type: "browse-marketplace" });
          else if (C === "manage-plugins") A({ type: "manage-plugins" });
          else if (C === "installation-status")
            A({ type: "installation-status" });
        },
        onCancel: () => B(),
      }),
    ),
    EZ.createElement(
      S,
      { marginLeft: 3 },
      EZ.createElement(
        U,
        { dimColor: !0, italic: !0 },
        Q.pending
          ? EZ.createElement(
              EZ.Fragment,
              null,
              "Press ",
              Q.keyName,
              " again to exit",
            )
          : EZ.createElement(
              EZ.Fragment,
              null,
              "Press  to navigate  Enter to select  Esc to exit",
            ),
      ),
    ),
  );
}
var EZ;
var Va2 = T(() => {
  nA();
  Z5();
  c9();
  EZ = IA(KA(), 1);
});
import { join as U1I, basename as w1I } from "path";
function Ka2(A, B) {
  let Q = [],
    I = NA();
  function G(Z) {
    try {
      let Y = I.readdirSync(Z);
      for (let J of Y) {
        let X = U1I(Z, J.name);
        if (J.isDirectory()) G(X);
        else if (J.isFile() && J.name.endsWith(".md")) {
          let W = Da2(X, B);
          if (W) Q.push(W);
        }
      }
    } catch (Y) {
      g(`Failed to scan output-styles directory ${Z}: ${Y}`, {
        level: "error",
      });
    }
  }
  return (G(A), Q);
}
function Da2(A, B) {
  let Q = NA();
  try {
    let I = Q.readFileSync(A, { encoding: "utf-8" }),
      { frontmatter: G, content: Z } = GW(I),
      Y = w1I(A, ".md"),
      J = G.name || Y,
      X = `${B}:${J}`,
      W = G.description || Xy(Z, `Output style from ${B} plugin`);
    return { name: X, description: W, prompt: Z.trim(), source: "plugin" };
  } catch (I) {
    return (
      g(`Failed to load output style from ${A}: ${I}`, { level: "error" }),
      null
    );
  }
}
function m00() {
  u00.cache?.clear?.();
}
var u00;
var tB1 = T(() => {
  a2();
  m0();
  NF();
  C0();
  xS();
  u00 = I0(async () => {
    let { enabled: A, errors: B } = await Z3(),
      Q = [];
    if (B.length > 0)
      g(`Plugin loading errors: ${B.map((I) => nN(I)).join(", ")}`);
    for (let I of A) {
      if (I.outputStylesPath)
        try {
          let G = Ka2(I.outputStylesPath, I.name);
          if ((Q.push(...G), G.length > 0))
            g(
              `Loaded ${G.length} output styles from plugin ${I.name} default directory`,
            );
        } catch (G) {
          g(
            `Failed to load output styles from plugin ${I.name} default directory: ${G}`,
            { level: "error" },
          );
        }
      if (I.outputStylesPaths)
        for (let G of I.outputStylesPaths)
          try {
            let Y = NA().statSync(G);
            if (Y.isDirectory()) {
              let J = Ka2(G, I.name);
              if ((Q.push(...J), J.length > 0))
                g(
                  `Loaded ${J.length} output styles from plugin ${I.name} custom path: ${G}`,
                );
            } else if (Y.isFile() && G.endsWith(".md")) {
              let J = Da2(G, I.name);
              if (J)
                (Q.push(J),
                  g(
                    `Loaded output style from plugin ${I.name} custom file: ${G}`,
                  ));
            }
          } catch (Z) {
            g(
              `Failed to load output styles from plugin ${I.name} custom path ${G}: ${Z}`,
              { level: "error" },
            );
          }
    }
    return (g(`Total plugin output styles loaded: ${Q.length}`), Q);
  });
});
function $1I() {
  (XiA(), e11(), lj2(), CLQ(), m00());
}
function yW() {
  ($1I(), Ea2());
}
var Ht = T(() => {
  NF();
  lwA();
  iwA();
  tDA();
  tB1();
  Gz();
});
import { resolve as q1I } from "path";
import { homedir as N1I } from "os";
function eB1(A) {
  let B = A.trim(),
    Q = NA(),
    I = B.match(/^(git@[^:]+:.+\.git)(#(.+))?$/);
  if (I?.[1]) {
    let G = I[1],
      Z = I[3];
    return Z ? { source: "git", url: G, ref: Z } : { source: "git", url: G };
  }
  if (B.startsWith("http://") || B.startsWith("https://")) {
    let G = B.match(/^([^#]+)(#(.+))?$/),
      Z = G?.[1] || B,
      Y = G?.[3];
    if (Z.endsWith(".git"))
      return Y ? { source: "git", url: Z, ref: Y } : { source: "git", url: Z };
    let J;
    try {
      J = new URL(Z);
    } catch (X) {
      return { source: "url", url: Z };
    }
    if (J.hostname === "github.com" || J.hostname === "www.github.com") {
      if (J.pathname.match(/^\/([^/]+\/[^/]+?)(\/|\.git|$)/)?.[1]) {
        let W = Z.endsWith(".git") ? Z : `${Z}.git`;
        return Y
          ? { source: "git", url: W, ref: Y }
          : { source: "git", url: W };
      }
    }
    return { source: "url", url: Z };
  }
  if (
    B.startsWith("./") ||
    B.startsWith("../") ||
    B.startsWith("/") ||
    B.startsWith("~")
  ) {
    let G = q1I(B.startsWith("~") ? B.replace(/^~/, N1I()) : B);
    if (!Q.existsSync(G)) return { error: `Path does not exist: ${G}` };
    let Z = Q.statSync(G);
    if (Z.isFile())
      if (G.endsWith(".json")) return { source: "file", path: G };
      else
        return {
          error: `File path must point to a .json file (marketplace.json), but got: ${G}`,
        };
    else if (Z.isDirectory()) return { source: "directory", path: G };
    else return { error: `Path is neither a file nor a directory: ${G}` };
  }
  if (B.includes("/") && !B.startsWith("@")) {
    if (B.includes(":")) return null;
    let G = B.match(/^([^#]+)(#(.+))?$/),
      Z = G?.[1] || B,
      Y = G?.[3];
    return Y
      ? { source: "github", repo: Z, ref: Y }
      : { source: "github", repo: Z };
  }
  return null;
}
var d00 = T(() => {
  m0();
});
function Ha2({
  inputValue: A,
  setInputValue: B,
  cursorOffset: Q,
  setCursorOffset: I,
  error: G,
  setError: Z,
  result: Y,
  setResult: J,
  setViewState: X,
  onAddComplete: W,
  cliMode: F = !1,
}) {
  let C = zt.useRef(!1),
    [V, K] = zt.useState(!1),
    [D, E] = zt.useState(""),
    H = async () => {
      let w = A.trim();
      if (!w) {
        Z("Please enter a marketplace source");
        return;
      }
      let L = eB1(w);
      if (!L) {
        Z(
          "Invalid marketplace source format. Try: owner/repo, https://..., or ./path",
        );
        return;
      }
      if ("error" in L) {
        Z(L.error);
        return;
      }
      Z(null);
      try {
        (K(!0), E(""));
        let { name: N } = await Ds(L, (O) => {
          E(O);
        });
        yW();
        let $ = L.source;
        if (L.source === "github") $ = L.repo;
        if ((GA("tengu_marketplace_added", { source_type: $ }), W)) await W();
        if ((E(""), K(!1), F)) J(`Successfully added marketplace: ${N}`);
        else X({ type: "browse-marketplace", targetMarketplace: N });
      } catch (N) {
        let $ = N instanceof Error ? N : Error(String(N));
        if ((BA($, IH), Z($.message), E(""), K(!1), F))
          J(`Error: ${$.message}`);
        else J(null);
      }
    };
  return (
    zt.useEffect(() => {
      if (A && !C.current && !G && !Y) ((C.current = !0), H());
    }, []),
    P4.createElement(
      S,
      { flexDirection: "column" },
      P4.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        P4.createElement(
          S,
          { marginBottom: 1 },
          P4.createElement(U, { bold: !0 }, "Add Marketplace"),
        ),
        P4.createElement(
          S,
          { flexDirection: "column" },
          P4.createElement(U, null, "Enter marketplace source:"),
          P4.createElement(U, { dimColor: !0 }, "Examples:"),
          P4.createElement(U, { dimColor: !0 }, "  owner/repo (GitHub)"),
          P4.createElement(
            U,
            { dimColor: !0 },
            "  git@github.com:owner/repo.git (SSH)",
          ),
          P4.createElement(
            U,
            { dimColor: !0 },
            "  https://example.com/marketplace.json",
          ),
          P4.createElement(U, { dimColor: !0 }, "  ./path/to/marketplace"),
          P4.createElement(
            S,
            { marginTop: 1 },
            P4.createElement(O4, {
              value: A,
              onChange: B,
              onSubmit: H,
              columns: 80,
              cursorOffset: Q,
              onChangeCursorOffset: I,
              focus: !0,
              showCursor: !0,
            }),
          ),
        ),
        V &&
          P4.createElement(
            S,
            { marginTop: 1 },
            P4.createElement(E8, null),
            P4.createElement(
              U,
              null,
              D || "Adding marketplace to configuration",
            ),
          ),
        G &&
          P4.createElement(
            S,
            { marginTop: 1 },
            P4.createElement(U, { color: "error" }, G),
          ),
        Y &&
          P4.createElement(S, { marginTop: 1 }, P4.createElement(U, null, Y)),
      ),
      P4.createElement(
        S,
        { marginLeft: 3 },
        P4.createElement(
          U,
          { dimColor: !0, italic: !0 },
          "Enter to add  Esc to cancel",
        ),
      ),
    )
  );
}
var P4, zt;
var za2 = T(() => {
  nA();
  rG();
  pD();
  Ht();
  H0();
  d00();
  xX();
  c1();
  ((P4 = IA(KA(), 1)), (zt = IA(KA(), 1)));
});
function c00(A, B) {
  let I = A.slice(0, 2)
      .map((Y) => {
        let J = Y.reason || Y.error || "unknown error";
        return B ? `${Y.name} (${J})` : Y.name;
      })
      .join(B ? "; " : ", "),
    G = A.length - 2,
    Z = G > 0 ? ` and ${G} more` : "";
  return `${I}${Z}`;
}
function f$A(A) {
  switch (A.source) {
    case "github":
      return A.repo;
    case "url":
      return A.url;
    case "git":
      return A.url;
    case "directory":
      return A.path;
    case "file":
      return A.path;
    default:
      return "Unknown source";
  }
}
function v7A(A, B) {
  return `${A}@${B}`;
}
async function h$A(A) {
  let B = [],
    Q = [];
  for (let [I, G] of Object.entries(A)) {
    let Z = null;
    try {
      Z = await AV(I);
    } catch (Y) {
      let J = Y instanceof Error ? Y.message : String(Y);
      (Q.push({ name: I, error: J }),
        BA(
          Y instanceof Error
            ? Y
            : Error(`Failed to load marketplace ${I}: ${Y}`),
          IH,
        ));
    }
    B.push({ name: I, config: G, data: Z });
  }
  return { marketplaces: B, failures: Q };
}
function AQ1(A, B) {
  if (A.length === 0) return null;
  if (B > 0)
    return {
      type: "warning",
      message:
        A.length === 1
          ? `Warning: Failed to load marketplace '${A[0].name}': ${A[0].error}`
          : `Warning: Failed to load ${A.length} marketplaces: ${A.map((I) => I.name).join(", ")}`,
    };
  return {
    type: "error",
    message: `Failed to load all marketplaces. Errors: ${A.map((Q) => `${Q.name}: ${Q.error}`).join("; ")}`,
  };
}
var p00 = T(() => {
  pD();
  c1();
});
function Ua2({
  setViewState: A,
  error: B,
  setError: Q,
  setResult: I,
  exitState: G,
  onManageComplete: Z,
  targetMarketplace: Y,
  action: J,
}) {
  let [X, W] = wE.useState([]),
    [F, C] = wE.useState(!0),
    [V, K] = wE.useState(0),
    [D, E] = wE.useState(!1),
    [H, w] = wE.useState(null),
    [L, N] = wE.useState(null),
    [$, O] = wE.useState(null),
    [P, k] = wE.useState("list"),
    [b, x] = wE.useState(null),
    [n, m] = wE.useState(0),
    o = wE.useRef(!1);
  wE.useEffect(() => {
    async function JA() {
      try {
        let wA = await PY(),
          { enabled: xA, disabled: rA } = await Z3(),
          qA = [...xA, ...rA],
          { marketplaces: SA, failures: zA } = await h$A(wA),
          kA = [];
        for (let { name: XA, config: CA, data: UA } of SA) {
          let HA = qA.filter((LA) => LA.source.endsWith(`@${XA}`));
          kA.push({
            name: XA,
            source: f$A(CA.source),
            lastUpdated: CA.lastUpdated,
            pluginCount: UA?.plugins.length,
            installedPlugins: HA,
            pendingUpdate: !1,
            pendingRemove: !1,
          });
        }
        (kA.sort((XA, CA) => XA.name.localeCompare(CA.name)), W(kA));
        let sA = SA.filter((XA) => XA.data !== null).length,
          Z1 = AQ1(zA, sA);
        if (Z1)
          if (Z1.type === "warning") w(Z1.message);
          else throw Error(Z1.message);
        if (Y && J && !o.current && !B) {
          o.current = !0;
          let XA = kA.findIndex((CA) => CA.name === Y);
          if (XA >= 0) {
            K(XA);
            let CA = [...kA];
            if (J === "update") CA[XA].pendingUpdate = !0;
            else if (J === "remove") CA[XA].pendingRemove = !0;
            (W(CA),
              setTimeout(() => {
                c(CA);
              }, 100));
          } else if (Q) Q(`Marketplace not found: ${Y}`);
        }
      } catch (wA) {
        if (Q)
          Q(wA instanceof Error ? wA.message : "Failed to load marketplaces");
        w(wA instanceof Error ? wA.message : "Failed to load marketplaces");
      } finally {
        C(!1);
      }
    }
    JA();
  }, [Y, J, B]);
  let l = () => {
      return X.some((JA) => JA.pendingUpdate || JA.pendingRemove);
    },
    y = () => {
      let JA = X.filter((xA) => xA.pendingUpdate).length,
        wA = X.filter((xA) => xA.pendingRemove).length;
      return { updateCount: JA, removeCount: wA };
    },
    c = async (JA) => {
      let wA = JA || X,
        xA = P === "details";
      (E(!0), w(null), N(null), O(null));
      try {
        let rA = cQ("userSettings"),
          qA = 0,
          SA = 0;
        for (let HA of wA) {
          if (HA.pendingRemove) {
            if (HA.installedPlugins && HA.installedPlugins.length > 0) {
              let LA = { ...rA?.enabledPlugins };
              for (let TA of HA.installedPlugins) {
                let tA = v7A(TA.name, HA.name);
                LA[tA] = !1;
              }
              B2("userSettings", { enabledPlugins: LA });
            }
            (await YiA(HA.name),
              SA++,
              GA("tengu_marketplace_removed", {
                marketplace_name: HA.name,
                plugins_uninstalled: HA.installedPlugins?.length || 0,
              }));
            continue;
          }
          if (HA.pendingUpdate)
            (await JiA(HA.name, (LA) => {
              O(LA);
            }),
              qA++,
              GA("tengu_marketplace_updated", { marketplace_name: HA.name }));
        }
        if ((yW(), Z)) await Z();
        let zA = await PY(),
          { enabled: kA, disabled: sA } = await Z3(),
          Z1 = [...kA, ...sA],
          { marketplaces: XA } = await h$A(zA),
          CA = [];
        for (let { name: HA, config: LA, data: TA } of XA) {
          let tA = Z1.filter((aA) => aA.source.endsWith(`@${HA}`));
          CA.push({
            name: HA,
            source: f$A(LA.source),
            lastUpdated: LA.lastUpdated,
            pluginCount: TA?.plugins.length,
            installedPlugins: tA,
            pendingUpdate: !1,
            pendingRemove: !1,
          });
        }
        if (
          (CA.sort((HA, LA) => HA.name.localeCompare(LA.name)), W(CA), xA && b)
        ) {
          let HA = CA.find((LA) => LA.name === b.name);
          if (HA) x(HA);
        }
        let UA = [];
        if (qA > 0) UA.push(`Updated ${qA} marketplace${qA > 1 ? "s" : ""}`);
        if (SA > 0) UA.push(`Removed ${SA} marketplace${SA > 1 ? "s" : ""}`);
        if (UA.length > 0) {
          let HA = `${E1.tick} ${UA.join(", ")}`;
          if (xA) N(HA);
          else
            (I(HA),
              setTimeout(() => {
                A({ type: "menu" });
              }, 2000));
        } else if (!xA) A({ type: "menu" });
      } catch (rA) {
        let qA = rA instanceof Error ? rA.message : String(rA);
        if ((w(qA), Q)) Q(qA);
      } finally {
        (E(!1), O(null));
      }
    },
    e = async () => {
      if (!b) return;
      let JA = X.map((wA) =>
        wA.name === b.name ? { ...wA, pendingRemove: !0 } : wA,
      );
      (W(JA), await c(JA));
    };
  if (
    (h1((JA, wA) => {
      if (D) return;
      if (wA.escape) {
        if (P === "details" || P === "confirm-remove") {
          (k("list"), m(0));
          return;
        }
        if (l())
          (W((xA) =>
            xA.map((rA) => ({ ...rA, pendingUpdate: !1, pendingRemove: !1 })),
          ),
            K(0));
        else A({ type: "menu" });
        return;
      }
      if (P === "list") {
        if (wA.upArrow || JA === "k") K((xA) => Math.max(0, xA - 1));
        else if (wA.downArrow || JA === "j")
          K((xA) => Math.min(X.length - 1, xA + 1));
        else if (JA === "u" || JA === "U")
          W((xA) =>
            xA.map((rA, qA) =>
              qA === V
                ? {
                    ...rA,
                    pendingUpdate: !rA.pendingUpdate,
                    pendingRemove: rA.pendingUpdate ? rA.pendingRemove : !1,
                  }
                : rA,
            ),
          );
        else if (JA === "r" || JA === "R") {
          let xA = X[V];
          if (xA) (x(xA), k("confirm-remove"));
        } else if (wA.return) {
          let xA = X[V];
          if (xA && !l()) (x(xA), k("details"), m(0));
          else if (l()) c();
        }
      } else if (P === "details") {
        if (wA.upArrow || JA === "k") m((xA) => Math.max(0, xA - 1));
        else if (wA.downArrow || JA === "j") m((xA) => Math.min(2, xA + 1));
        else if (wA.return && b) {
          if (n === 0) {
            let xA = X.map((rA) =>
              rA.name === b.name ? { ...rA, pendingUpdate: !0 } : rA,
            );
            (W(xA), c(xA));
          } else if (n === 1) k("confirm-remove");
          else if (n === 2) {
            if (b.source.startsWith("http")) d7(b.source);
          }
        }
      } else if (P === "confirm-remove") {
        if (JA === "y" || JA === "Y") e();
        else if (JA === "n" || JA === "N") (k("list"), x(null));
      }
    }),
    F)
  )
    return n1.createElement(
      S,
      { flexDirection: "column" },
      n1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        n1.createElement(U, null, "Loading marketplaces"),
      ),
    );
  if (X.length === 0)
    return n1.createElement(
      S,
      { flexDirection: "column" },
      n1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        n1.createElement(U, null, "No marketplaces configured."),
      ),
      n1.createElement(
        S,
        { marginLeft: 3, marginTop: 1 },
        n1.createElement(
          U,
          { dimColor: !0 },
          G.pending
            ? n1.createElement(
                n1.Fragment,
                null,
                "Press ",
                G.keyName,
                " again to go back",
              )
            : n1.createElement(n1.Fragment, null, "Esc to go back"),
        ),
      ),
    );
  if (P === "confirm-remove" && b) {
    let JA = b.installedPlugins?.length || 0;
    return n1.createElement(
      S,
      { flexDirection: "column" },
      n1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        n1.createElement(
          U,
          { bold: !0, color: "warning" },
          "Remove marketplace ",
          n1.createElement(U, { italic: !0 }, b.name),
          "?",
        ),
        n1.createElement(
          S,
          { flexDirection: "column" },
          JA > 0 &&
            n1.createElement(
              S,
              { marginTop: 1 },
              n1.createElement(
                U,
                { color: "warning" },
                "This will also uninstall ",
                JA,
                " plugin",
                JA !== 1 ? "s" : "",
                " from this marketplace:",
              ),
            ),
          b.installedPlugins &&
            b.installedPlugins.length > 0 &&
            n1.createElement(
              S,
              { flexDirection: "column", marginTop: 1, marginLeft: 2 },
              b.installedPlugins.map((wA) =>
                n1.createElement(
                  U,
                  { key: wA.name, dimColor: !0 },
                  " ",
                  wA.name,
                ),
              ),
            ),
          n1.createElement(
            S,
            { marginTop: 1 },
            n1.createElement(
              U,
              null,
              "Press ",
              n1.createElement(U, { bold: !0 }, "y"),
              " to confirm or ",
              n1.createElement(U, { bold: !0 }, "n"),
              " to cancel",
            ),
          ),
        ),
      ),
    );
  }
  if (P === "details" && b) {
    let JA = b.pendingUpdate || D,
      wA = [
        { label: "Update marketplace", value: "update" },
        { label: "Remove marketplace", value: "remove" },
        b.source.startsWith("http") && {
          label: "Open in browser",
          value: "browser",
        },
      ].filter(Boolean);
    return n1.createElement(
      S,
      { flexDirection: "column" },
      n1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        n1.createElement(U, { bold: !0 }, b.name),
        n1.createElement(U, { dimColor: !0 }, b.source),
        b.lastUpdated &&
          n1.createElement(
            U,
            { dimColor: !0 },
            "Last updated:",
            " ",
            new Date(b.lastUpdated).toLocaleDateString(),
          ),
        n1.createElement(
          S,
          { marginTop: 1 },
          n1.createElement(
            U,
            null,
            b.pluginCount || 0,
            " available plugin",
            b.pluginCount !== 1 ? "s" : "",
          ),
        ),
        b.installedPlugins &&
          b.installedPlugins.length > 0 &&
          n1.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            n1.createElement(
              U,
              { bold: !0 },
              "Installed plugins (",
              b.installedPlugins.length,
              "):",
            ),
            n1.createElement(
              S,
              { flexDirection: "column", marginLeft: 1 },
              b.installedPlugins.map((xA) =>
                n1.createElement(
                  S,
                  { key: xA.name, flexDirection: "row", gap: 1 },
                  n1.createElement(U, null, E1.bullet),
                  n1.createElement(
                    S,
                    { flexDirection: "column" },
                    n1.createElement(U, null, xA.name),
                    n1.createElement(
                      U,
                      { dimColor: !0 },
                      xA.manifest.description,
                    ),
                  ),
                ),
              ),
            ),
          ),
        JA &&
          n1.createElement(
            S,
            { marginTop: 1, flexDirection: "column" },
            n1.createElement(U, { color: "claude" }, "Updating marketplace"),
            $ && n1.createElement(U, { dimColor: !0 }, $),
          ),
        !JA &&
          L &&
          n1.createElement(
            S,
            { marginTop: 1 },
            n1.createElement(U, { color: "claude" }, L),
          ),
        !JA &&
          H &&
          n1.createElement(
            S,
            { marginTop: 1 },
            n1.createElement(U, { color: "error" }, H),
          ),
        !JA &&
          n1.createElement(
            S,
            { flexDirection: "column", marginTop: 1 },
            wA.map((xA, rA) => {
              if (!xA) return null;
              let qA = rA === n;
              return n1.createElement(
                S,
                { key: xA.value },
                n1.createElement(
                  U,
                  { color: qA ? "claude" : void 0 },
                  qA ? E1.pointer : " ",
                  " ",
                  xA.label,
                ),
              );
            }),
          ),
      ),
      n1.createElement(
        S,
        { marginLeft: 3 },
        n1.createElement(
          U,
          { dimColor: !0, italic: !0 },
          JA
            ? n1.createElement(n1.Fragment, null, "Please wait")
            : n1.createElement(
                n1.Fragment,
                null,
                E1.arrowUp,
                E1.arrowDown,
                "  enter to select  Esc to go back",
              ),
        ),
      ),
    );
  }
  let { updateCount: QA, removeCount: WA } = y();
  return n1.createElement(
    S,
    { flexDirection: "column" },
    n1.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      n1.createElement(
        S,
        { marginBottom: 1 },
        n1.createElement(U, { bold: !0 }, "Manage marketplaces"),
      ),
      n1.createElement(
        S,
        { flexDirection: "column" },
        X.map((JA, wA) => {
          let xA = wA === V,
            rA = [];
          if (JA.pendingUpdate) rA.push("UPDATE");
          if (JA.pendingRemove) rA.push("REMOVE");
          return n1.createElement(
            S,
            { key: JA.name, flexDirection: "row", gap: 1, marginBottom: 1 },
            n1.createElement(
              U,
              { color: xA ? "claude" : void 0 },
              xA ? E1.pointer : " ",
              " ",
              JA.pendingRemove ? E1.cross : E1.bullet,
            ),
            n1.createElement(
              S,
              { flexDirection: "column", flexGrow: 1 },
              n1.createElement(
                S,
                { flexDirection: "row", gap: 1 },
                n1.createElement(
                  U,
                  {
                    bold: !0,
                    strikethrough: JA.pendingRemove,
                    dimColor: JA.pendingRemove,
                  },
                  JA.name,
                ),
                rA.length > 0 &&
                  n1.createElement(
                    U,
                    { color: "warning" },
                    "[",
                    rA.join(", "),
                    "]",
                  ),
              ),
              n1.createElement(U, { dimColor: !0 }, JA.source),
              n1.createElement(
                U,
                { dimColor: !0 },
                JA.pluginCount !== void 0 &&
                  n1.createElement(
                    n1.Fragment,
                    null,
                    JA.pluginCount,
                    " available",
                  ),
                JA.installedPlugins &&
                  JA.installedPlugins.length > 0 &&
                  n1.createElement(
                    n1.Fragment,
                    null,
                    "  ",
                    JA.installedPlugins.length,
                    " installed",
                  ),
                JA.lastUpdated &&
                  n1.createElement(
                    n1.Fragment,
                    null,
                    " ",
                    " Updated",
                    " ",
                    new Date(JA.lastUpdated).toLocaleDateString(),
                  ),
              ),
            ),
          );
        }),
      ),
      l() &&
        n1.createElement(
          S,
          { marginTop: 1, flexDirection: "column" },
          n1.createElement(
            U,
            null,
            n1.createElement(U, { bold: !0 }, "Pending changes:"),
            " ",
            n1.createElement(U, { dimColor: !0 }, "Enter to apply"),
          ),
          QA > 0 &&
            n1.createElement(
              U,
              null,
              " Update ",
              QA,
              " marketplace",
              QA > 1 ? "s" : "",
            ),
          WA > 0 &&
            n1.createElement(
              U,
              { color: "warning" },
              " Remove ",
              WA,
              " marketplace",
              WA > 1 ? "s" : "",
            ),
        ),
      D &&
        n1.createElement(
          S,
          { marginTop: 1 },
          n1.createElement(U, { color: "claude" }, "Processing changes"),
        ),
      H &&
        n1.createElement(
          S,
          { marginTop: 1 },
          n1.createElement(U, { color: "error" }, H),
        ),
    ),
    n1.createElement(L1I, { exitState: G, hasPendingActions: l() }),
  );
}
function L1I({ exitState: A, hasPendingActions: B }) {
  let Q = [];
  if (A.pending) Q.push(`Press ${A.keyName} again to go back`);
  else {
    if ((Q.push(`${E1.arrowUp}${E1.arrowDown}`), B))
      Q.push("Enter to apply changes");
    else (Q.push("Enter for details"), Q.push("u update"), Q.push("r remove"));
    Q.push(B ? "Esc to cancel" : "Esc to go back");
  }
  return n1.createElement(
    S,
    { marginLeft: 3 },
    n1.createElement(U, { dimColor: !0, italic: !0 }, Q.join("  ")),
  );
}
var n1, wE;
var wa2 = T(() => {
  nA();
  nA();
  s2();
  pD();
  Ht();
  H0();
  NF();
  p00();
  rq();
  OQ();
  ((n1 = IA(KA(), 1)), (wE = IA(KA(), 1)));
});
function $a2({
  error: A,
  setError: B,
  result: Q,
  setResult: I,
  setViewState: G,
  onInstallComplete: Z,
  targetMarketplace: Y,
  targetPlugin: J,
}) {
  let [X, W] = eF.useState("marketplace-list"),
    [F, C] = eF.useState(null),
    [V, K] = eF.useState(null),
    [D, E] = eF.useState([]),
    [H, w] = eF.useState([]),
    [L, N] = eF.useState(!0),
    [$, O] = eF.useState(0),
    [P, k] = eF.useState(new Set()),
    [b, x] = eF.useState(new Set()),
    [n, m] = eF.useState(0),
    [o, l] = eF.useState(!1),
    [y, c] = eF.useState(null),
    [e, QA] = eF.useState(null);
  (eF.useEffect(() => {
    async function wA() {
      try {
        let xA = await PY(),
          { marketplaces: rA, failures: qA } = await h$A(xA),
          SA = [];
        for (let { name: sA, config: Z1, data: XA } of rA)
          if (XA) {
            let CA = XA.plugins.filter((UA) => Zt(v7A(UA.name, sA))).length;
            SA.push({
              name: sA,
              totalPlugins: XA.plugins.length,
              installedCount: CA,
              source: f$A(Z1.source),
            });
          }
        E(SA);
        let zA = rA.filter((sA) => sA.data !== null).length,
          kA = AQ1(qA, zA);
        if (kA)
          if (kA.type === "warning")
            QA(kA.message + ". Showing available marketplaces.");
          else throw Error(kA.message);
        if (SA.length === 1 && !Y && !J) {
          let sA = SA[0];
          if (sA) (C(sA.name), W("plugin-list"));
        }
        if (J) {
          let sA = null,
            Z1 = null;
          for (let [XA] of Object.entries(xA)) {
            let CA = await AV(XA);
            if (CA) {
              let UA = CA.plugins.find((HA) => HA.name === J);
              if (UA) {
                ((sA = {
                  entry: UA,
                  marketplaceName: XA,
                  pluginId: v7A(UA.name, XA),
                }),
                  (Z1 = XA));
                break;
              }
            }
          }
          if (sA && Z1) {
            let XA = sA.pluginId;
            if (Zt(XA))
              B(
                `Plugin '${XA}' is already installed. Use '/plugin' to manage existing plugins.`,
              );
            else (C(Z1), K(sA), W("plugin-details"));
          } else B(`Plugin "${J}" not found in any marketplace`);
        } else if (Y)
          if (SA.some((Z1) => Z1.name === Y)) (C(Y), W("plugin-list"));
          else B(`Marketplace "${Y}" not found`);
      } catch (xA) {
        B(xA instanceof Error ? xA.message : "Failed to load marketplaces");
      } finally {
        N(!1);
      }
    }
    wA();
  }, [B, Y, J]),
    eF.useEffect(() => {
      if (!F) return;
      async function wA(xA) {
        N(!0);
        try {
          let rA = await AV(xA);
          if (!rA) throw Error(`Failed to load marketplace: ${xA}`);
          let qA = [];
          for (let SA of rA.plugins) {
            let zA = v7A(SA.name, xA);
            if (!Zt(zA))
              qA.push({ entry: SA, marketplaceName: xA, pluginId: zA });
          }
          (w(qA), O(0), k(new Set()));
        } catch (rA) {
          B(rA instanceof Error ? rA.message : "Failed to load plugins");
        } finally {
          N(!1);
        }
      }
      wA(F);
    }, [F, B]));
  let WA = async () => {
      if (P.size === 0) return;
      let wA = H.filter((SA) => P.has(SA.pluginId));
      x(new Set(wA.map((SA) => SA.pluginId)));
      let xA = 0,
        rA = 0,
        qA = [];
      for (let SA of wA)
        try {
          if (typeof SA.entry.source !== "string")
            await yR(SA.pluginId, SA.entry);
          let kA = { ...cQ("userSettings")?.enabledPlugins, [SA.pluginId]: !0 };
          (B2("userSettings", { enabledPlugins: kA }),
            xA++,
            GA("tengu_plugin_installed", {
              plugin_id: SA.pluginId,
              marketplace_name: SA.marketplaceName,
            }));
        } catch (zA) {
          rA++;
          let kA = zA instanceof Error ? zA.message : String(zA);
          (qA.push({ name: SA.entry.name, reason: kA }),
            BA(
              zA instanceof Error
                ? zA
                : Error(`Failed to install ${SA.entry.name}: ${zA}`),
              F61,
            ));
        }
      if ((x(new Set()), k(new Set()), yW(), rA === 0)) {
        let SA = ` Installed ${xA} plugin${xA !== 1 ? "s" : ""}. Restart Claude Code to load new plugins.`;
        I(SA);
      } else if (xA === 0) B(`Failed to install: ${c00(qA, !0)}`);
      else {
        let SA = ` Installed ${xA} of ${xA + rA} plugins. Failed: ${c00(qA, !1)}. Restart Claude Code to load successfully installed plugins.`;
        I(SA);
      }
      if (xA > 0) {
        if (Z) await Z();
      }
      G({ type: "menu" });
    },
    JA = async (wA) => {
      (l(!0), c(null));
      try {
        if (typeof wA.entry.source !== "string")
          await yR(wA.pluginId, wA.entry);
        let rA = { ...cQ("userSettings")?.enabledPlugins, [wA.pluginId]: !0 };
        (B2("userSettings", { enabledPlugins: rA }),
          GA("tengu_plugin_installed", {
            plugin_id: wA.pluginId,
            marketplace_name: wA.marketplaceName,
          }),
          yW());
        let qA = ` Installed ${wA.entry.name}. Restart Claude Code to load new plugins.`;
        if ((I(qA), Z)) await Z();
        G({ type: "menu" });
      } catch (xA) {
        l(!1);
        let rA = xA instanceof Error ? xA.message : String(xA);
        (c(`Failed to install: ${rA}`),
          BA(
            xA instanceof Error
              ? xA
              : Error(`Failed to install plugin: ${String(xA)}`),
            F61,
          ));
      }
    };
  if (
    (eF.useEffect(() => {
      if (A) I(A);
    }, [A, I]),
    h1((wA, xA) => {
      if (xA.escape) {
        if (X === "plugin-list") (W("marketplace-list"), C(null), k(new Set()));
        else if (X === "plugin-details") (W("plugin-list"), K(null));
        return;
      }
      if (X === "marketplace-list") {
        if ((xA.upArrow || wA === "k") && $ > 0) O($ - 1);
        else if ((xA.downArrow || wA === "j") && $ < D.length - 1) O($ + 1);
        else if (xA.return) {
          let rA = D[$];
          if (rA) (C(rA.name), W("plugin-list"));
        }
      } else if (X === "plugin-list") {
        let rA = H.length;
        if ((xA.upArrow || wA === "k") && $ > 0) O($ - 1);
        else if ((xA.downArrow || wA === "j") && $ < rA - 1) O($ + 1);
        else if (wA === " ") {
          if ($ < H.length) {
            let qA = H[$];
            if (qA) {
              let SA = new Set(P);
              if (SA.has(qA.pluginId)) SA.delete(qA.pluginId);
              else SA.add(qA.pluginId);
              k(SA);
            }
          }
        } else if (xA.return) {
          if ($ === H.length && P.size > 0) WA();
          else if ($ < H.length) {
            let qA = H[$];
            if (qA) (K(qA), W("plugin-details"), m(0), c(null));
          }
        } else if (wA === "i" && P.size > 0) WA();
      } else if (X === "plugin-details" && V) {
        let rA = V.entry.homepage,
          SA =
            V.entry.source &&
            typeof V.entry.source === "object" &&
            "source" in V.entry.source &&
            V.entry.source.source === "github" &&
            typeof V.entry.source === "object" &&
            "repo" in V.entry.source
              ? V.entry.source.repo
              : null,
          zA = [];
        if ((zA.push({ label: "Install now", action: "install" }), rA))
          zA.push({ label: "Open homepage", action: "homepage" });
        if (SA) zA.push({ label: "View on GitHub", action: "github" });
        if (
          (zA.push({ label: "Back to plugin list", action: "back" }),
          (xA.upArrow || wA === "k") && n > 0)
        )
          m(n - 1);
        else if ((xA.downArrow || wA === "j") && n < zA.length - 1) m(n + 1);
        else if (xA.return) {
          let kA = zA[n]?.action;
          if (kA === "mark") {
            let sA = new Set(P);
            if (sA.has(V.pluginId)) sA.delete(V.pluginId);
            else sA.add(V.pluginId);
            (k(sA), W("plugin-list"), K(null));
          } else if (kA === "install") JA(V);
          else if (kA === "homepage" && rA) d7(rA);
          else if (kA === "github" && SA) d7(`https://github.com/${SA}`);
          else if (kA === "back") (W("plugin-list"), K(null));
        }
      }
    }),
    L)
  )
    return s1.createElement(
      S,
      { flexDirection: "column" },
      s1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        s1.createElement(U, null, "Loading"),
      ),
    );
  if (A)
    return s1.createElement(
      S,
      { flexDirection: "column" },
      s1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        s1.createElement(U, { color: "error" }, A),
      ),
    );
  if (X === "marketplace-list") {
    if (D.length === 0)
      return s1.createElement(
        S,
        { flexDirection: "column" },
        s1.createElement(
          S,
          { flexDirection: "column", paddingX: 1, borderStyle: "round" },
          s1.createElement(
            S,
            { marginBottom: 1 },
            s1.createElement(U, { bold: !0 }, "Select marketplace"),
          ),
          s1.createElement(U, null, "No marketplaces configured."),
          s1.createElement(
            U,
            { dimColor: !0 },
            "Add a marketplace first using ",
            "'Add marketplace'",
            ".",
          ),
        ),
        s1.createElement(
          S,
          { marginTop: 1, paddingLeft: 1 },
          s1.createElement(U, { dimColor: !0 }, "Esc to go back"),
        ),
      );
    return s1.createElement(
      S,
      { flexDirection: "column" },
      s1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        s1.createElement(
          S,
          { marginBottom: 1 },
          s1.createElement(U, { bold: !0 }, "Select marketplace"),
        ),
        e &&
          s1.createElement(
            S,
            { marginBottom: 1, flexDirection: "column" },
            s1.createElement(U, { color: "warning" }, E1.warning, " ", e),
          ),
        D.map((wA, xA) =>
          s1.createElement(
            S,
            {
              key: wA.name,
              flexDirection: "column",
              marginBottom: xA < D.length - 1 ? 1 : 0,
            },
            s1.createElement(
              S,
              null,
              s1.createElement(
                U,
                { color: $ === xA ? "suggestion" : void 0 },
                $ === xA ? E1.pointer : " ",
                " ",
                wA.name,
              ),
            ),
            s1.createElement(
              S,
              { marginLeft: 2 },
              s1.createElement(
                U,
                { dimColor: !0 },
                wA.totalPlugins,
                " plugin",
                wA.totalPlugins !== 1 ? "s" : "",
                " available",
                wA.installedCount > 0 &&
                  `  ${wA.installedCount} already installed`,
                wA.source && `  ${wA.source}`,
              ),
            ),
          ),
        ),
      ),
      s1.createElement(
        S,
        { paddingLeft: 1 },
        s1.createElement(
          U,
          { dimColor: !0, italic: !0 },
          "Enter to select  esc to go back",
        ),
      ),
    );
  }
  if (X === "plugin-details" && V) {
    let wA = V.entry.homepage,
      rA =
        V.entry.source &&
        typeof V.entry.source === "object" &&
        "source" in V.entry.source &&
        V.entry.source.source === "github" &&
        typeof V.entry.source === "object" &&
        "repo" in V.entry.source
          ? V.entry.source.repo
          : null,
      qA = [];
    if ((qA.push({ label: "Install now", action: "install" }), wA))
      qA.push({ label: "Open homepage", action: "homepage" });
    if (rA) qA.push({ label: "View on GitHub", action: "github" });
    return (
      qA.push({ label: "Back to plugin list", action: "back" }),
      s1.createElement(
        S,
        { flexDirection: "column" },
        s1.createElement(
          S,
          { flexDirection: "column", paddingX: 1, borderStyle: "round" },
          s1.createElement(
            S,
            { marginBottom: 1 },
            s1.createElement(U, { bold: !0 }, "Plugin Details"),
          ),
          s1.createElement(
            S,
            { flexDirection: "column", marginBottom: 1 },
            s1.createElement(U, { bold: !0 }, V.entry.name),
            V.entry.version &&
              s1.createElement(
                U,
                { dimColor: !0 },
                "Version: ",
                V.entry.version,
              ),
            V.entry.description &&
              s1.createElement(
                S,
                { marginTop: 1 },
                s1.createElement(U, null, V.entry.description),
              ),
            V.entry.author &&
              s1.createElement(
                S,
                { marginTop: 1 },
                s1.createElement(
                  U,
                  { dimColor: !0 },
                  "By:",
                  " ",
                  typeof V.entry.author === "string"
                    ? V.entry.author
                    : V.entry.author.name,
                ),
              ),
          ),
          s1.createElement(
            S,
            { flexDirection: "column", marginBottom: 1 },
            s1.createElement(U, { bold: !0 }, "Will install:"),
            V.entry.commands &&
              s1.createElement(
                U,
                { dimColor: !0 },
                " Commands:",
                " ",
                Array.isArray(V.entry.commands)
                  ? V.entry.commands.join(", ")
                  : Object.keys(V.entry.commands).join(", "),
              ),
            V.entry.agents &&
              s1.createElement(
                U,
                { dimColor: !0 },
                " Agents:",
                " ",
                Array.isArray(V.entry.agents)
                  ? V.entry.agents.join(", ")
                  : Object.keys(V.entry.agents).join(", "),
              ),
            V.entry.hooks &&
              s1.createElement(
                U,
                { dimColor: !0 },
                " Hooks: ",
                Object.keys(V.entry.hooks).join(", "),
              ),
            V.entry.mcpServers &&
              s1.createElement(
                U,
                { dimColor: !0 },
                " MCP Servers:",
                " ",
                Array.isArray(V.entry.mcpServers)
                  ? V.entry.mcpServers.join(", ")
                  : typeof V.entry.mcpServers === "object"
                    ? Object.keys(V.entry.mcpServers).join(", ")
                    : "configured",
              ),
            !V.entry.commands &&
              !V.entry.agents &&
              !V.entry.hooks &&
              !V.entry.mcpServers &&
              s1.createElement(
                s1.Fragment,
                null,
                typeof V.entry.source === "object" &&
                  "source" in V.entry.source &&
                  (V.entry.source.source === "github" ||
                    V.entry.source.source === "url" ||
                    V.entry.source.source === "npm" ||
                    V.entry.source.source === "pip")
                  ? s1.createElement(
                      U,
                      { dimColor: !0 },
                      " Component summary not available for remote plugin",
                    )
                  : s1.createElement(
                      U,
                      { dimColor: !0 },
                      " Components will be discovered at installation",
                    ),
              ),
          ),
          y &&
            s1.createElement(
              S,
              { marginBottom: 1 },
              s1.createElement(U, { color: "error" }, "Error: ", y),
            ),
          s1.createElement(
            S,
            { flexDirection: "column" },
            qA.map((SA, zA) =>
              s1.createElement(
                S,
                { key: SA.action },
                n === zA && s1.createElement(U, null, "> "),
                n !== zA && s1.createElement(U, null, "  "),
                s1.createElement(
                  U,
                  { bold: n === zA },
                  o && SA.action === "install" ? "Installing" : SA.label,
                ),
              ),
            ),
          ),
        ),
        s1.createElement(
          S,
          { marginTop: 1, paddingLeft: 1 },
          s1.createElement(
            U,
            { dimColor: !0 },
            s1.createElement(U, { bold: !0 }, "Select:"),
            " Enter",
            "  ",
            s1.createElement(U, { bold: !0 }, "Back:"),
            " Esc",
          ),
        ),
      )
    );
  }
  if (H.length === 0)
    return s1.createElement(
      S,
      { flexDirection: "column" },
      s1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        s1.createElement(
          S,
          { marginBottom: 1 },
          s1.createElement(
            U,
            { bold: !0 },
            F,
            " ",
            E1.pointerSmall,
            " Install plugins",
          ),
        ),
        s1.createElement(
          U,
          { dimColor: !0 },
          "No new plugins available to install.",
        ),
        s1.createElement(
          U,
          { dimColor: !0 },
          "All plugins from this marketplace are already installed.",
        ),
      ),
      s1.createElement(
        S,
        { marginLeft: 3 },
        s1.createElement(U, { dimColor: !0, italic: !0 }, "Esc to go back"),
      ),
    );
  return s1.createElement(
    S,
    { flexDirection: "column" },
    s1.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      s1.createElement(
        S,
        { marginBottom: 1 },
        s1.createElement(
          U,
          { bold: !0 },
          F,
          " ",
          E1.pointerSmall,
          " Install plugins",
        ),
      ),
      H.map((wA, xA) => {
        let rA = $ === xA,
          qA = P.has(wA.pluginId),
          SA = b.has(wA.pluginId),
          zA = xA === H.length - 1;
        return s1.createElement(
          S,
          {
            key: wA.pluginId,
            flexDirection: "column",
            marginBottom: zA && !A ? 0 : 1,
          },
          s1.createElement(
            S,
            null,
            s1.createElement(
              U,
              { color: rA ? "suggestion" : void 0 },
              rA ? E1.pointer : " ",
              " ",
            ),
            s1.createElement(
              U,
              null,
              SA ? E1.ellipsis : qA ? E1.radioOn : E1.radioOff,
              " ",
              wA.entry.name,
              wA.entry.category &&
                s1.createElement(
                  U,
                  { dimColor: !0 },
                  " [",
                  wA.entry.category,
                  "]",
                ),
            ),
          ),
          wA.entry.description &&
            s1.createElement(
              S,
              { marginLeft: 4 },
              s1.createElement(
                U,
                { dimColor: !0 },
                wA.entry.description.length > 60
                  ? wA.entry.description.substring(0, 57) + "..."
                  : wA.entry.description,
              ),
              wA.entry.version &&
                s1.createElement(U, { dimColor: !0 }, "  v", wA.entry.version),
            ),
        );
      }),
      A &&
        s1.createElement(
          S,
          { marginTop: 1 },
          s1.createElement(U, { color: "error" }, E1.cross, " ", A),
        ),
    ),
    s1.createElement(M1I, { hasSelection: P.size > 0 }),
  );
}
function M1I({ hasSelection: A }) {
  let B = [];
  return (
    B.push("Space to (de)select"),
    B.push("Enter for details"),
    B.push("Esc to go back"),
    s1.createElement(
      S,
      { marginLeft: 3 },
      s1.createElement(
        U,
        { italic: !0 },
        A &&
          s1.createElement(
            U,
            { bold: !0, color: "suggestion" },
            "Press i to install ",
            " ",
          ),
        s1.createElement(
          U,
          { dimColor: !0 },
          "Space: (de)select  Enter: details  Esc: back",
        ),
      ),
    )
  );
}
var s1, eF;
var qa2 = T(() => {
  nA();
  nA();
  s2();
  pD();
  p00();
  OQ();
  Ht();
  H0();
  c1();
  rq();
  C$A();
  F$A();
  ((s1 = IA(KA(), 1)), (eF = IA(KA(), 1)));
});
function Na2({
  pluginName: A,
  serverName: B,
  configSchema: Q,
  onSave: I,
  onCancel: G,
}) {
  let Z = Object.keys(Q),
    [Y, J] = W3.useState(0),
    [X, W] = W3.useState({}),
    [F, C] = W3.useState(""),
    V = Z[Y],
    K = V ? Q[V] : null,
    D = IB(G);
  if (
    (h1((L, N) => {
      if (N.escape) {
        G();
        return;
      }
      if (N.tab && Y < Z.length - 1) {
        if (V) W({ ...X, [V]: F });
        (J(Y + 1), C(""));
        return;
      }
      if (N.return) {
        if (V) {
          let $ = { ...X, [V]: F };
          if (Y === Z.length - 1) {
            let O = {};
            for (let P of Z) {
              let k = $[P] || "",
                b = Q[P];
              if (b?.type === "number") {
                let x = Number(k);
                O[P] = isNaN(x) ? k : x;
              } else if (b?.type === "boolean")
                O[P] = k.toLowerCase() === "true" || k === "1";
              else O[P] = k;
            }
            I(O);
          } else (W($), J(Y + 1), C(""));
        }
        return;
      }
      if (N.backspace || N.delete) {
        C(F.slice(0, -1));
        return;
      }
      if (L && !N.ctrl && !N.meta) C(F + L);
    }),
    !K || !V)
  )
    return null;
  let E = K.sensitive === !0,
    H = K.required === !0,
    w = E ? "*".repeat(F.length) : F;
  return W3.default.createElement(
    S,
    { flexDirection: "column" },
    W3.default.createElement(
      S,
      { flexDirection: "column", gap: 1, padding: 1, borderStyle: "round" },
      W3.default.createElement(U, { bold: !0 }, "Configure ", B),
      W3.default.createElement(
        S,
        { marginLeft: 1 },
        W3.default.createElement(U, { dimColor: !0 }, "Plugin: ", A),
      ),
      W3.default.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W3.default.createElement(
          U,
          { bold: !0 },
          K.title || V,
          H && W3.default.createElement(U, { color: "error" }, " *"),
        ),
        K.description &&
          W3.default.createElement(U, { dimColor: !0 }, K.description),
        W3.default.createElement(
          S,
          { marginTop: 1 },
          W3.default.createElement(U, null, E1.pointerSmall, " "),
          W3.default.createElement(U, null, w),
          W3.default.createElement(U, null, ""),
        ),
      ),
      W3.default.createElement(
        S,
        { marginTop: 1 },
        W3.default.createElement(
          U,
          { dimColor: !0 },
          "Field ",
          Y + 1,
          " of ",
          Z.length,
        ),
      ),
      Y < Z.length - 1 &&
        W3.default.createElement(
          S,
          null,
          W3.default.createElement(
            U,
            { dimColor: !0 },
            "Tab: Next field  Enter: Save and continue",
          ),
        ),
      Y === Z.length - 1 &&
        W3.default.createElement(
          S,
          null,
          W3.default.createElement(
            U,
            { dimColor: !0 },
            "Enter: Save configuration",
          ),
        ),
    ),
    W3.default.createElement(
      S,
      { marginLeft: 3 },
      W3.default.createElement(
        U,
        { dimColor: !0 },
        D.pending
          ? W3.default.createElement(
              W3.default.Fragment,
              null,
              "Press ",
              D.keyName,
              " again to exit",
            )
          : W3.default.createElement(
              W3.default.Fragment,
              null,
              "Esc to cancel",
            ),
      ),
    ),
  );
}
var W3;
var La2 = T(() => {
  nA();
  R9();
  s2();
  W3 = IA(KA(), 1);
});
import * as Ut from "fs/promises";
import * as b7A from "path";
async function Ma2(A) {
  try {
    return (await Ut.readdir(A, { withFileTypes: !0 }))
      .filter((Q) => Q.isFile() && Q.name.endsWith(".md"))
      .map((Q) => {
        return b7A.basename(Q.name, ".md");
      });
  } catch (B) {
    let Q = B instanceof Error ? B.message : String(B);
    return (
      g(`Failed to read plugin components from ${A}: ${Q}`, { level: "error" }),
      BA(
        B instanceof Error
          ? B
          : Error(`Failed to read plugin components: ${Q}`),
        AX,
      ),
      []
    );
  }
}
async function O1I(A) {
  try {
    let B = await Ut.readdir(A, { withFileTypes: !0 }),
      Q = [];
    for (let I of B)
      if (I.isDirectory() || I.isSymbolicLink()) {
        let G = b7A.join(A, I.name, "SKILL.md");
        try {
          (await Ut.access(G), Q.push(I.name));
        } catch {}
      }
    return Q;
  } catch (B) {
    let Q = B instanceof Error ? B.message : String(B);
    return (
      g(`Failed to read skill directories from ${A}: ${Q}`, { level: "error" }),
      BA(
        B instanceof Error
          ? B
          : Error(`Failed to read skill directories: ${Q}`),
        AX,
      ),
      []
    );
  }
}
function R1I({ plugin: A, marketplace: B }) {
  let [Q, I] = mY.useState(null),
    [G, Z] = mY.useState(!0),
    [Y, J] = mY.useState(null);
  if (
    (mY.useEffect(() => {
      async function W() {
        try {
          let C = (await AV(B)).plugins.find((V) => V.name === A.name);
          if (C) {
            let V = [];
            if (A.commandsPath) V.push(A.commandsPath);
            if (A.commandsPaths) V.push(...A.commandsPaths);
            let K = [];
            for (let $ of V)
              if (typeof $ === "string") {
                let O = await Ma2($);
                K.push(...O);
              }
            let D = [];
            if (A.agentsPath) D.push(A.agentsPath);
            if (A.agentsPaths) D.push(...A.agentsPaths);
            let E = [];
            for (let $ of D)
              if (typeof $ === "string") {
                let O = await Ma2($);
                E.push(...O);
              }
            let H = [];
            if (A.skillsPath) H.push(A.skillsPath);
            if (A.skillsPaths) H.push(...A.skillsPaths);
            let w = [];
            for (let $ of H)
              if (typeof $ === "string") {
                let O = await O1I($);
                w.push(...O);
              }
            let L = [];
            if (A.hooksConfig) L.push(Object.keys(A.hooksConfig));
            if (C.hooks) L.push(C.hooks);
            let N = [];
            if (A.mcpServers) N.push(Object.keys(A.mcpServers));
            if (C.mcpServers) N.push(C.mcpServers);
            I({
              commands: K.length > 0 ? K : null,
              agents: E.length > 0 ? E : null,
              skills: w.length > 0 ? w : null,
              hooks: L.length > 0 ? L : null,
              mcpServers: N.length > 0 ? N : null,
            });
          } else J(`Plugin ${A.name} not found in marketplace`);
        } catch (F) {
          J(F instanceof Error ? F.message : "Failed to load components");
        } finally {
          Z(!1);
        }
      }
      W();
    }, [
      A.name,
      A.commandsPath,
      A.commandsPaths,
      A.agentsPath,
      A.agentsPaths,
      A.skillsPath,
      A.skillsPaths,
      A.hooksConfig,
      A.mcpServers,
      B,
    ]),
    G)
  )
    return null;
  if (Y)
    return o1.createElement(
      S,
      { flexDirection: "column", marginBottom: 1 },
      o1.createElement(U, { bold: !0 }, "Components:"),
      o1.createElement(U, { dimColor: !0 }, "Error: ", Y),
    );
  if (!Q) return null;
  if (!(Q.commands || Q.agents || Q.skills || Q.hooks || Q.mcpServers))
    return null;
  return o1.createElement(
    S,
    { flexDirection: "column", marginBottom: 1 },
    o1.createElement(U, { bold: !0 }, "Installed components:"),
    Q.commands
      ? o1.createElement(
          U,
          { dimColor: !0 },
          " Commands:",
          " ",
          typeof Q.commands === "string"
            ? Q.commands
            : Array.isArray(Q.commands)
              ? Q.commands.join(", ")
              : Object.keys(Q.commands).join(", "),
        )
      : null,
    Q.agents
      ? o1.createElement(
          U,
          { dimColor: !0 },
          " Agents:",
          " ",
          typeof Q.agents === "string"
            ? Q.agents
            : Array.isArray(Q.agents)
              ? Q.agents.join(", ")
              : Object.keys(Q.agents).join(", "),
        )
      : null,
    Q.skills
      ? o1.createElement(
          U,
          { dimColor: !0 },
          " Skills:",
          " ",
          typeof Q.skills === "string"
            ? Q.skills
            : Array.isArray(Q.skills)
              ? Q.skills.join(", ")
              : Object.keys(Q.skills).join(", "),
        )
      : null,
    Q.hooks
      ? o1.createElement(
          U,
          { dimColor: !0 },
          " Hooks:",
          " ",
          typeof Q.hooks === "string"
            ? Q.hooks
            : Array.isArray(Q.hooks)
              ? Q.hooks.map(String).join(", ")
              : typeof Q.hooks === "object" && Q.hooks !== null
                ? Object.keys(Q.hooks).join(", ")
                : String(Q.hooks),
        )
      : null,
    Q.mcpServers
      ? o1.createElement(
          U,
          { dimColor: !0 },
          " MCP Servers:",
          " ",
          typeof Q.mcpServers === "string"
            ? Q.mcpServers
            : Array.isArray(Q.mcpServers)
              ? Q.mcpServers.map(String).join(", ")
              : typeof Q.mcpServers === "object" && Q.mcpServers !== null
                ? Object.keys(Q.mcpServers).join(", ")
                : String(Q.mcpServers),
        )
      : null,
  );
}
async function l00(A, B) {
  let I = (await AV(B))?.plugins.find((G) => G.name === A);
  if (I && typeof I.source === "string")
    return `Local plugins cannot be updated remotely. To update, modify the source at: ${I.source}`;
  return null;
}
function Oa2({
  setViewState: A,
  setResult: B,
  onManageComplete: Q,
  targetPlugin: I,
  action: G,
}) {
  let [Z, Y] = mY.useState("marketplace-list"),
    [J, X] = mY.useState(null),
    [W, F] = mY.useState(null),
    [C, V] = mY.useState([]),
    [K, D] = mY.useState([]),
    [E, H] = mY.useState(!0),
    [w, L] = mY.useState(0),
    [N, $] = mY.useState(0),
    [O, P] = mY.useState(!1),
    [k, b] = mY.useState(null),
    [x, n] = mY.useState(null),
    [m, o] = mY.useState(!1),
    [l, y] = mY.useState(!1);
  (mY.useEffect(() => {
    if (!W) {
      y(!1);
      return;
    }
    async function zA() {
      let kA = W.plugin.manifest.mcpServers,
        sA = !1;
      if (kA)
        sA =
          (typeof kA === "string" && iN(kA)) ||
          (Array.isArray(kA) &&
            kA.some((Z1) => typeof Z1 === "string" && iN(Z1)));
      if (!sA)
        try {
          let Z1 = b7A.join(W.plugin.path, ".."),
            XA = b7A.join(Z1, ".claude-plugin", "marketplace.json"),
            CA = await Ut.readFile(XA, "utf-8"),
            HA = JSON.parse(CA).plugins?.find(
              (LA) => LA.name === W.plugin.name,
            );
          if (HA?.mcpServers) {
            let LA = HA.mcpServers;
            sA =
              (typeof LA === "string" && iN(LA)) ||
              (Array.isArray(LA) &&
                LA.some((TA) => typeof TA === "string" && iN(TA)));
          }
        } catch (Z1) {
          g(`Failed to read raw marketplace.json: ${Z1}`);
        }
      y(sA);
    }
    zA();
  }, [W]),
    mY.useEffect(() => {
      async function zA() {
        H(!0);
        try {
          let { enabled: kA, disabled: sA } = await Z3(),
            Z1 = [...kA, ...sA],
            XA = N0(),
            CA = {};
          for (let HA of Z1) {
            let LA = HA.source.split("@")[1] || "local";
            if (!CA[LA]) CA[LA] = [];
            CA[LA].push(HA);
          }
          let UA = [];
          for (let [HA, LA] of Object.entries(CA)) {
            let TA = LA.filter((aA) => {
                let W1 = `${aA.name}@${HA}`;
                return XA?.enabledPlugins?.[W1] !== !1;
              }).length,
              tA = LA.length - TA;
            UA.push({
              name: HA,
              installedPlugins: LA,
              enabledCount: TA,
              disabledCount: tA,
            });
          }
          (UA.sort((HA, LA) => HA.name.localeCompare(LA.name)), V(UA), L(0));
        } finally {
          H(!1);
        }
      }
      zA();
    }, []),
    mY.useEffect(() => {
      if (J && Z === "plugin-list") {
        let zA = C.find((kA) => kA.name === J);
        if (zA) {
          let kA = zA.installedPlugins.map((sA) => {
            return {
              plugin: sA,
              marketplace: zA.name,
              pendingEnable: void 0,
              pendingUpdate: !1,
            };
          });
          (D(kA), L(0));
        }
      }
    }, [J, Z, C]));
  let c = () => {
      return K.some((zA) => zA.pendingEnable !== void 0 || zA.pendingUpdate);
    },
    e = () => {
      let zA = K.filter((Z1) => Z1.pendingUpdate).length,
        kA = K.filter((Z1) => Z1.pendingEnable === !0).length,
        sA = K.filter((Z1) => Z1.pendingEnable === !1).length;
      return { updateCount: zA, enableCount: kA, disableCount: sA };
    },
    QA = async () => {
      (P(!0), b(null));
      try {
        let kA = { ...cQ("userSettings")?.enabledPlugins },
          sA = 0,
          Z1 = 0,
          XA = 0;
        for (let HA of K) {
          let LA = `${HA.plugin.name}@${HA.marketplace}`;
          if (HA.pendingUpdate) {
            let tA = (await AV(HA.marketplace))?.plugins.find(
              (aA) => aA.name === HA.plugin.name,
            );
            if (tA && typeof tA.source !== "string") (await yR(LA, tA), sA++);
          }
          if (HA.pendingEnable !== void 0)
            if (HA.pendingEnable) {
              if (!Zt(LA)) {
                let tA = (await AV(HA.marketplace))?.plugins.find(
                  (aA) => aA.name === HA.plugin.name,
                );
                if (tA && typeof tA.source !== "string") await yR(LA, tA);
              }
              ((kA[LA] = !0), Z1++);
            } else ((kA[LA] = !1), XA++);
        }
        (B2("userSettings", { enabledPlugins: kA }), yW());
        let CA = [];
        if (sA > 0) CA.push(`Updated ${sA} plugin${sA !== 1 ? "s" : ""}`);
        if (Z1 > 0) CA.push(`Enabled ${Z1} plugin${Z1 !== 1 ? "s" : ""}`);
        if (XA > 0) CA.push(`Disabled ${XA} plugin${XA !== 1 ? "s" : ""}`);
        let UA = ` ${CA.join(", ")}. Restart Claude Code to apply changes.`;
        if ((B(UA), Q)) await Q();
        A({ type: "menu" });
      } catch (zA) {
        P(!1);
        let kA = zA instanceof Error ? zA.message : String(zA);
        (b(`Failed to apply changes: ${kA}`),
          BA(
            zA instanceof Error
              ? zA
              : Error(`Failed to apply plugin changes: ${String(zA)}`),
            Tl,
          ));
      }
    },
    WA = async (zA) => {
      let sA = { ...cQ("userSettings")?.enabledPlugins },
        Z1 = db2(zA);
      if (Z1?.installPath && !Z1.isLocal)
        try {
          cb2(Z1.installPath);
        } catch (CA) {
          BA(CA instanceof Error ? CA : Error(String(CA)), Tl);
        }
      else if (Z1?.isLocal)
        g(
          `Skipping cache deletion for local plugin ${zA} at ${Z1.installPath}`,
        );
      sA[zA] = void 0;
      let { error: XA } = B2("userSettings", { enabledPlugins: sA });
      if (XA) throw XA;
      yW();
    },
    JA = async (zA) => {
      if (!W) return;
      (P(!0), b(null));
      try {
        let kA = `${W.plugin.name}@${W.marketplace}`,
          Z1 = { ...cQ("userSettings")?.enabledPlugins };
        switch (zA) {
          case "enable": {
            if (!Zt(kA)) {
              let HA = (await AV(W.marketplace))?.plugins.find(
                (LA) => LA.name === W.plugin.name,
              );
              if (HA && typeof HA.source !== "string") await yR(kA, HA);
            }
            Z1[kA] = !0;
            break;
          }
          case "disable":
            Z1[kA] = !1;
            break;
          case "uninstall": {
            await WA(kA);
            break;
          }
          case "update": {
            let HA = (await AV(W.marketplace))?.plugins.find(
              (LA) => LA.name === W.plugin.name,
            );
            if (HA && typeof HA.source !== "string") await yR(kA, HA);
            break;
          }
        }
        if (zA !== "uninstall") {
          let { error: UA } = B2("userSettings", { enabledPlugins: Z1 });
          if (UA) throw UA;
          yW();
        }
        let CA = ` ${zA === "enable" ? "Enabled" : zA === "disable" ? "Disabled" : zA === "update" ? "Updated" : "Uninstalled"} ${W.plugin.name}. Restart Claude Code to apply changes.`;
        if ((B(CA), Q)) await Q();
        A({ type: "menu" });
      } catch (kA) {
        P(!1);
        let sA = kA instanceof Error ? kA.message : String(kA);
        (b(`Failed to ${zA}: ${sA}`),
          BA(
            kA instanceof Error
              ? kA
              : Error(`Failed to ${zA} plugin: ${String(kA)}`),
            Tl,
          ));
      }
    },
    wA = async (zA) => {
      (P(!0), b(null));
      try {
        let kA = `${zA.plugin.name}@${zA.marketplace}`;
        await WA(kA);
        let { enabled: sA, disabled: Z1 } = await Z3(),
          XA = [...sA, ...Z1];
        if (C.find((UA) => UA.name === J)) {
          let UA = XA.filter((aA) => {
              return (aA.source.split("@")[1] || "local") === J;
            }),
            HA = UA.map((aA) => ({
              plugin: aA,
              marketplace: J,
              pendingEnable: void 0,
              pendingUpdate: !1,
            }));
          D(HA);
          let LA = N0(),
            TA = UA.filter((aA) => {
              let W1 = `${aA.name}@${J}`;
              return LA?.enabledPlugins?.[W1] !== !1;
            }).length,
            tA = UA.length - TA;
          if (
            (V((aA) =>
              aA.map((W1) =>
                W1.name === J
                  ? {
                      ...W1,
                      installedPlugins: UA,
                      enabledCount: TA,
                      disabledCount: tA,
                    }
                  : W1,
              ),
            ),
            w >= HA.length)
          )
            L(Math.max(0, HA.length - 1));
        }
        B(
          ` Uninstalled ${zA.plugin.name}. Restart Claude Code to apply changes.`,
        );
      } catch (kA) {
        let sA = kA instanceof Error ? kA.message : String(kA);
        (b(`Failed to uninstall: ${sA}`),
          BA(
            kA instanceof Error
              ? kA
              : Error(`Failed to uninstall plugin: ${String(kA)}`),
            Tl,
          ));
      } finally {
        P(!1);
      }
    };
  if (
    (h1((zA, kA) => {
      if (kA.escape) {
        if (Z === "plugin-list") (Y("marketplace-list"), X(null), D([]));
        else if (Z === "plugin-details") (Y("plugin-list"), F(null), b(null));
        else if (Z === "configuring") (Y("plugin-details"), n(null));
        else A({ type: "menu" });
        return;
      }
      if (Z === "marketplace-list") {
        if ((kA.upArrow || zA === "k") && w > 0) L(w - 1);
        else if ((kA.downArrow || zA === "j") && w < C.length - 1) L(w + 1);
        else if (kA.return) {
          let sA = C[w];
          if (sA) (X(sA.name), Y("plugin-list"));
        }
      } else if (Z === "plugin-list") {
        let sA = c(),
          Z1 = K.length + (sA ? 1 : 0);
        if ((kA.upArrow || zA === "k") && w > 0) L(w - 1);
        else if ((kA.downArrow || zA === "j") && w < Z1 - 1) L(w + 1);
        else if (zA === " " && w < K.length) {
          let XA = [...K],
            CA = XA[w];
          if (CA) {
            let UA = N0(),
              HA = `${CA.plugin.name}@${CA.marketplace}`,
              LA = UA?.enabledPlugins?.[HA] !== !1;
            if (CA.pendingEnable === void 0) CA.pendingEnable = !LA;
            else CA.pendingEnable = void 0;
            D(XA);
          }
        } else if (zA === "u" && w < K.length) {
          let XA = [...K],
            CA = XA[w];
          if (CA)
            (async () => {
              try {
                let HA = await l00(CA.plugin.name, CA.marketplace);
                if (HA) {
                  b(HA);
                  return;
                }
                ((CA.pendingUpdate = !CA.pendingUpdate), D(XA));
              } catch (HA) {
                b(
                  HA instanceof Error
                    ? HA.message
                    : "Failed to check plugin update availability",
                );
              }
            })();
        } else if (kA.delete || kA.backspace) {
          if (w < K.length && !O) {
            let XA = K[w];
            if (XA) wA(XA);
          }
        } else if (kA.return) {
          if (w === K.length && sA) QA();
          else if (w < K.length) {
            let XA = K[w];
            if (XA) (F(XA), Y("plugin-details"), $(0), b(null));
          }
        }
      } else if (Z === "plugin-details" && W) {
        let sA = N0(),
          Z1 = `${W.plugin.name}@${W.marketplace}`,
          XA = sA?.enabledPlugins?.[Z1] !== !1,
          CA = [];
        if (
          (CA.push({
            label: XA ? "Disable plugin" : "Enable plugin",
            action: () => void JA(XA ? "disable" : "enable"),
          }),
          CA.push({
            label: W.pendingUpdate ? "Unmark for update" : "Mark for update",
            action: async () => {
              try {
                let UA = await l00(W.plugin.name, W.marketplace);
                if (UA) {
                  b(UA);
                  return;
                }
                let HA = [...K],
                  LA = HA.findIndex(
                    (TA) =>
                      TA.plugin.name === W.plugin.name &&
                      TA.marketplace === W.marketplace,
                  );
                if (LA !== -1)
                  ((HA[LA].pendingUpdate = !W.pendingUpdate),
                    D(HA),
                    F({ ...W, pendingUpdate: !W.pendingUpdate }));
              } catch (UA) {
                b(
                  UA instanceof Error
                    ? UA.message
                    : "Failed to check plugin update availability",
                );
              }
            },
          }),
          l)
        )
          CA.push({
            label: "Configure",
            action: async () => {
              o(!0);
              try {
                let UA = W.plugin.manifest.mcpServers,
                  HA = null;
                if (typeof UA === "string" && iN(UA)) HA = UA;
                else if (Array.isArray(UA)) {
                  for (let tA of UA)
                    if (typeof tA === "string" && iN(tA)) {
                      HA = tA;
                      break;
                    }
                }
                if (!HA) {
                  (b("No MCPB file found in plugin"), o(!1));
                  return;
                }
                let LA = `${W.plugin.name}@${W.marketplace}`,
                  TA = await yHA(HA, W.plugin.path, LA, void 0, void 0, !0);
                if ("status" in TA && TA.status === "needs-config")
                  (n(TA), Y("configuring"));
                else b("Failed to load MCPB for configuration");
              } catch (UA) {
                let HA = UA instanceof Error ? UA.message : String(UA);
                b(`Failed to load configuration: ${HA}`);
              } finally {
                o(!1);
              }
            },
          });
        if (
          (CA.push({ label: "Update now", action: () => void JA("update") }),
          CA.push({ label: "Uninstall", action: () => void JA("uninstall") }),
          W.plugin.manifest.homepage)
        )
          CA.push({
            label: "Open homepage",
            action: () => void d7(W.plugin.manifest.homepage),
          });
        if (W.plugin.manifest.repository)
          CA.push({
            label: "View on GitHub",
            action: () => void d7(W.plugin.manifest.repository),
          });
        if (
          (CA.push({
            label: "Back to plugin list",
            action: () => {
              (Y("plugin-list"), F(null), b(null));
            },
          }),
          (kA.upArrow || zA === "k") && N > 0)
        )
          $(N - 1);
        else if ((kA.downArrow || zA === "j") && N < CA.length - 1) $(N + 1);
        else if (kA.return && CA[N]) CA[N].action();
      }
    }),
    E)
  )
    return o1.createElement(
      S,
      { flexDirection: "column" },
      o1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        o1.createElement(U, null, "Loading installed plugins"),
      ),
    );
  if (C.length === 0)
    return o1.createElement(
      S,
      { flexDirection: "column" },
      o1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        o1.createElement(
          S,
          { marginBottom: 1 },
          o1.createElement(U, { bold: !0 }, "Manage plugins"),
        ),
        o1.createElement(U, null, "No plugins installed."),
      ),
      o1.createElement(
        S,
        { marginTop: 1, paddingLeft: 1 },
        o1.createElement(U, { dimColor: !0 }, "Esc to go back"),
      ),
    );
  if (Z === "marketplace-list")
    return o1.createElement(
      S,
      { flexDirection: "column" },
      o1.createElement(
        S,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        o1.createElement(U, { bold: !0 }, "Manage plugins"),
        o1.createElement(
          S,
          { marginBottom: 1 },
          o1.createElement(
            U,
            { dimColor: !0 },
            "Select a marketplace to manage plugins:",
          ),
        ),
        C.map((zA, kA) => {
          let sA = kA === w,
            Z1 = zA.installedPlugins.length,
            XA = zA.enabledCount ?? Z1,
            CA = zA.disabledCount ?? 0,
            UA = kA === C.length - 1;
          return o1.createElement(
            S,
            { key: zA.name, flexDirection: "column", marginBottom: UA ? 0 : 1 },
            o1.createElement(
              S,
              null,
              o1.createElement(
                U,
                { color: sA ? "suggestion" : void 0 },
                sA ? E1.pointer : " ",
                " ",
                zA.name,
              ),
            ),
            o1.createElement(
              S,
              { marginLeft: 2 },
              o1.createElement(
                U,
                { dimColor: !0 },
                Z1,
                " plugin",
                Z1 !== 1 ? "s" : "",
                " installed",
                XA > 0 && `  ${XA} enabled`,
                CA > 0 && `  ${CA} disabled`,
              ),
            ),
          );
        }),
      ),
      o1.createElement(
        S,
        { paddingLeft: 1 },
        o1.createElement(
          U,
          { dimColor: !0, italic: !0 },
          E1.arrowUp,
          E1.arrowDown,
          " enter to select  esc to go back",
        ),
      ),
    );
  if (Z === "configuring" && x && W) {
    let sA = function () {
        (n(null), Y("plugin-details"));
      },
      zA = `${W.plugin.name}@${W.marketplace}`;
    async function kA(Z1) {
      if (!x || !W) return;
      try {
        let XA = W.plugin.manifest.mcpServers,
          CA = null;
        if (typeof XA === "string" && iN(XA)) CA = XA;
        else if (Array.isArray(XA)) {
          for (let UA of XA)
            if (typeof UA === "string" && iN(UA)) {
              CA = UA;
              break;
            }
        }
        if (!CA) {
          (b("No MCPB file found"), Y("plugin-details"));
          return;
        }
        (await yHA(CA, W.plugin.path, zA, void 0, Z1),
          b(null),
          n(null),
          Y("plugin-details"),
          B(
            "Configuration saved. Restart Claude Code for changes to take effect.",
          ));
      } catch (XA) {
        let CA = XA instanceof Error ? XA.message : String(XA);
        (b(`Failed to save configuration: ${CA}`), Y("plugin-details"));
      }
    }
    return o1.createElement(Na2, {
      pluginName: W.plugin.name,
      serverName: x.manifest.name,
      configSchema: x.configSchema,
      onSave: kA,
      onCancel: sA,
    });
  }
  if (Z === "plugin-details" && W) {
    let zA = N0(),
      kA = `${W.plugin.name}@${W.marketplace}`,
      sA = zA?.enabledPlugins?.[kA] !== !1,
      Z1 = [];
    if (
      (Z1.push({
        label: sA ? "Disable plugin" : "Enable plugin",
        action: () => void JA(sA ? "disable" : "enable"),
      }),
      Z1.push({
        label: W.pendingUpdate ? "Unmark for update" : "Mark for update",
        action: async () => {
          try {
            let XA = await l00(W.plugin.name, W.marketplace);
            if (XA) {
              b(XA);
              return;
            }
            let CA = [...K],
              UA = CA.findIndex(
                (HA) =>
                  HA.plugin.name === W.plugin.name &&
                  HA.marketplace === W.marketplace,
              );
            if (UA !== -1)
              ((CA[UA].pendingUpdate = !W.pendingUpdate),
                D(CA),
                F({ ...W, pendingUpdate: !W.pendingUpdate }));
          } catch (XA) {
            b(
              XA instanceof Error
                ? XA.message
                : "Failed to check plugin update availability",
            );
          }
        },
      }),
      l)
    )
      Z1.push({ label: "Configure", action: () => {} });
    if (
      (Z1.push({ label: "Update now", action: () => void JA("update") }),
      Z1.push({ label: "Uninstall", action: () => void JA("uninstall") }),
      W.plugin.manifest.homepage)
    )
      Z1.push({
        label: "Open homepage",
        action: () => void d7(W.plugin.manifest.homepage),
      });
    if (W.plugin.manifest.repository)
      Z1.push({
        label: "View on GitHub",
        action: () => void d7(W.plugin.manifest.repository),
      });
    return (
      Z1.push({
        label: "Back to plugin list",
        action: () => {
          (Y("plugin-list"), F(null), b(null));
        },
      }),
      o1.createElement(
        S,
        { flexDirection: "column" },
        o1.createElement(
          S,
          { flexDirection: "column", paddingX: 1, borderStyle: "round" },
          o1.createElement(
            S,
            { marginBottom: 1 },
            o1.createElement(
              U,
              { bold: !0 },
              W.plugin.name,
              " @ ",
              W.marketplace,
            ),
          ),
          W.plugin.manifest.version &&
            o1.createElement(
              S,
              { marginBottom: 1 },
              o1.createElement(U, { dimColor: !0 }, "Version: "),
              o1.createElement(U, null, W.plugin.manifest.version),
            ),
          W.plugin.manifest.description &&
            o1.createElement(
              S,
              { marginBottom: 1 },
              o1.createElement(U, null, W.plugin.manifest.description),
            ),
          W.plugin.manifest.author &&
            o1.createElement(
              S,
              { marginBottom: 1 },
              o1.createElement(U, { dimColor: !0 }, "Author: "),
              o1.createElement(U, null, W.plugin.manifest.author.name),
            ),
          o1.createElement(
            S,
            { marginBottom: 1 },
            o1.createElement(U, { dimColor: !0 }, "Status: "),
            o1.createElement(
              U,
              { color: sA ? "success" : "warning" },
              sA ? "Enabled" : "Disabled",
            ),
            W.pendingUpdate &&
              o1.createElement(
                U,
                { color: "suggestion" },
                "  Marked for update",
              ),
          ),
          o1.createElement(R1I, {
            plugin: W.plugin,
            marketplace: W.marketplace,
          }),
          o1.createElement(
            S,
            { marginTop: 1, flexDirection: "column" },
            Z1.map((XA, CA) => {
              let UA = CA === N;
              return o1.createElement(
                S,
                { key: CA },
                UA && o1.createElement(U, null, E1.pointer, " "),
                !UA && o1.createElement(U, null, "  "),
                o1.createElement(
                  U,
                  {
                    bold: UA,
                    color: XA.label.includes("Uninstall")
                      ? "error"
                      : XA.label.includes("Update")
                        ? "suggestion"
                        : void 0,
                  },
                  XA.label,
                ),
              );
            }),
          ),
          O &&
            o1.createElement(
              S,
              { marginTop: 1 },
              o1.createElement(U, null, "Processing"),
            ),
          k &&
            o1.createElement(
              S,
              { marginTop: 1 },
              o1.createElement(U, { color: "error" }, k),
            ),
        ),
        o1.createElement(
          S,
          { marginTop: 1, paddingLeft: 1 },
          o1.createElement(
            U,
            { dimColor: !0 },
            o1.createElement(U, { bold: !0 }, "Navigate:"),
            " ",
            E1.arrowUp,
            E1.arrowDown,
            "  ",
            o1.createElement(U, { bold: !0 }, "Select:"),
            " Enter",
            "  ",
            o1.createElement(U, { bold: !0 }, "Back:"),
            " Esc",
          ),
        ),
      )
    );
  }
  let xA = c(),
    { updateCount: rA, enableCount: qA, disableCount: SA } = e();
  return o1.createElement(
    S,
    { flexDirection: "column" },
    o1.createElement(
      S,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      o1.createElement(
        S,
        { marginBottom: 1 },
        o1.createElement(
          U,
          { bold: !0 },
          J,
          " ",
          E1.pointerSmall,
          " Manage plugins",
        ),
      ),
      K.map((zA, kA) => {
        let sA = N0(),
          Z1 = `${zA.plugin.name}@${zA.marketplace}`,
          XA = sA?.enabledPlugins?.[Z1] !== !1,
          CA = zA.pendingEnable !== void 0 ? zA.pendingEnable : XA,
          UA = kA === w,
          HA = zA.pendingEnable !== void 0 || zA.pendingUpdate,
          LA = kA === K.length - 1;
        return o1.createElement(
          S,
          { key: Z1, flexDirection: "column", marginBottom: LA ? 0 : 1 },
          o1.createElement(
            S,
            null,
            o1.createElement(
              U,
              { color: UA ? "suggestion" : void 0 },
              UA ? E1.pointer : " ",
              " ",
            ),
            o1.createElement(
              U,
              {
                color:
                  zA.pendingEnable !== void 0
                    ? "warning"
                    : CA
                      ? "success"
                      : void 0,
              },
              CA ? E1.radioOn : E1.radioOff,
              " ",
            ),
            o1.createElement(
              U,
              {
                bold: UA,
                color: zA.pendingUpdate
                  ? "suggestion"
                  : HA
                    ? "warning"
                    : void 0,
              },
              zA.plugin.name,
            ),
          ),
          o1.createElement(
            S,
            { marginLeft: 4 },
            o1.createElement(
              U,
              { dimColor: !0 },
              zA.plugin.manifest.description
                ? zA.plugin.manifest.description.length > 50
                  ? zA.plugin.manifest.description.substring(0, 47) + "..."
                  : zA.plugin.manifest.description
                : "No description",
              zA.plugin.manifest.version && `  v${zA.plugin.manifest.version}`,
            ),
            zA.pendingUpdate &&
              o1.createElement(
                U,
                { color: "suggestion" },
                "  Marked for update",
              ),
          ),
        );
      }),
      xA &&
        o1.createElement(
          S,
          { marginTop: 1 },
          w === K.length && o1.createElement(U, null, E1.pointer, " "),
          w !== K.length && o1.createElement(U, null, "  "),
          o1.createElement(
            U,
            { bold: w === K.length, color: "success" },
            "Apply changes",
          ),
          o1.createElement(
            U,
            { dimColor: !0 },
            " ",
            rA > 0 && `(update ${rA})`,
            qA > 0 && ` (enable ${qA})`,
            SA > 0 && ` (disable ${SA})`,
          ),
        ),
    ),
    xA &&
      o1.createElement(
        S,
        { marginTop: 1, paddingLeft: 1 },
        o1.createElement(U, { color: "warning" }, "Restart to apply changes"),
      ),
    o1.createElement(
      S,
      { paddingLeft: 3, flexDirection: "column" },
      o1.createElement(
        U,
        { dimColor: !0, italic: !0 },
        "Space to toggle enabled  'u' to mark update  Delete to uninstall",
      ),
      o1.createElement(
        U,
        { dimColor: !0, italic: !0 },
        "Enter for details  Esc to back",
      ),
    ),
  );
}
var o1, mY;
var Ra2 = T(() => {
  nA();
  nA();
  s2();
  NF();
  pD();
  OQ();
  Ht();
  rq();
  c1();
  C0();
  F$A();
  C$A();
  La2();
  Nc1();
  ((o1 = IA(KA(), 1)), (mY = IA(KA(), 1)));
});
function T1I(A) {
  switch (A.type) {
    case "path-not-found":
      return `${A.component} path not found: ${A.path}`;
    case "git-auth-failed":
      return `Git ${A.authType.toUpperCase()} authentication failed for ${A.gitUrl}`;
    case "git-timeout":
      return `Git ${A.operation} timed out for ${A.gitUrl}`;
    case "network-error":
      return `Network error accessing ${A.url}${A.details ? `: ${A.details}` : ""}`;
    case "manifest-parse-error":
      return `Failed to parse manifest at ${A.manifestPath}: ${A.parseError}`;
    case "manifest-validation-error":
      return `Invalid manifest at ${A.manifestPath}: ${A.validationErrors.join(", ")}`;
    case "plugin-not-found":
      return `Plugin '${A.pluginId}' not found in marketplace '${A.marketplace}'`;
    case "marketplace-not-found":
      return `Marketplace '${A.marketplace}' not found`;
    case "marketplace-load-failed":
      return `Failed to load marketplace '${A.marketplace}': ${A.reason}`;
    case "repository-scan-failed":
      return `Failed to scan repository at ${A.repositoryPath}: ${A.reason}`;
    case "mcp-config-invalid":
      return `Invalid MCP server config for '${A.serverName}': ${A.validationError}`;
    case "hook-load-failed":
      return `Failed to load hooks from ${A.hookPath}: ${A.reason}`;
    case "component-load-failed":
      return `Failed to load ${A.component} from ${A.path}: ${A.reason}`;
    case "mcpb-download-failed":
      return `Failed to download MCPB from ${A.url}: ${A.reason}`;
    case "mcpb-extract-failed":
      return `Failed to extract MCPB ${A.mcpbPath}: ${A.reason}`;
    case "mcpb-invalid-manifest":
      return `MCPB manifest invalid at ${A.mcpbPath}: ${A.validationError}`;
    case "generic-error":
      return A.error;
    default:
      return "Unknown error";
  }
}
function Ta2(A) {
  switch (A.type) {
    case "path-not-found":
      return " Check that the path in your manifest or marketplace config is correct";
    case "git-auth-failed":
      return A.authType === "ssh"
        ? " Configure SSH keys or use HTTPS URL instead"
        : " Configure credentials or use SSH URL instead";
    case "git-timeout":
    case "network-error":
      return " Check your internet connection and try again";
    case "manifest-parse-error":
      return " Check manifest file syntax in the plugin directory";
    case "manifest-validation-error":
      return " Check manifest file follows the required schema";
    case "plugin-not-found":
      return ` Plugin may not exist in marketplace '${A.marketplace}'`;
    case "marketplace-not-found":
      return A.availableMarketplaces.length > 0
        ? ` Available marketplaces: ${A.availableMarketplaces.join(", ")}`
        : " Add the marketplace first using /plugin marketplace add";
    case "mcp-config-invalid":
      return " Check MCP server configuration in .mcp.json or manifest";
    case "hook-load-failed":
      return " Check hooks.json file syntax and structure";
    case "component-load-failed":
      return ` Check ${A.component} directory structure and file permissions`;
    case "mcpb-download-failed":
      return " Check your internet connection and URL accessibility";
    case "mcpb-extract-failed":
      return " Verify the MCPB file is valid and not corrupted";
    case "mcpb-invalid-manifest":
      return " Contact the plugin author about the invalid manifest";
    case "repository-scan-failed":
    case "marketplace-load-failed":
    case "generic-error":
      return null;
    default:
      return null;
  }
}
function ja2({ onComplete: A }) {
  let [B, Q] = lB(),
    { installationStatus: I, errors: G } = B.plugins;
  IB();
  let Z = Pa2.useCallback(() => {
    (Q((C) => ({
      ...C,
      plugins: {
        ...C.plugins,
        installationStatus: {
          marketplaces: C.plugins.installationStatus.marketplaces.map((V) =>
            V.status === "failed" ? { ...V, status: "pending" } : V,
          ),
          plugins: C.plugins.installationStatus.plugins.map((V) =>
            V.status === "failed" ? { ...V, status: "pending" } : V,
          ),
        },
      },
    })),
      T01(Q));
  }, [Q]);
  h1((C, V) => {
    if (V.escape) A();
    else if (C === "r" || C === "R") Z();
  });
  let Y = {
      pending: I.marketplaces.filter((C) => C.status === "pending").length,
      installing: I.marketplaces.filter((C) => C.status === "installing")
        .length,
      installed: I.marketplaces.filter((C) => C.status === "installed").length,
      failed: I.marketplaces.filter((C) => C.status === "failed").length,
    },
    J = {
      pending: I.plugins.filter((C) => C.status === "pending").length,
      installing: I.plugins.filter((C) => C.status === "installing").length,
      installed: I.plugins.filter((C) => C.status === "installed").length,
      failed: I.plugins.filter((C) => C.status === "failed").length,
    },
    X = Y.installing > 0 || J.installing > 0 || Y.pending > 0 || J.pending > 0,
    W = G.length > 0,
    F = I.marketplaces.length > 0 || I.plugins.length > 0;
  return Y0.createElement(
    S,
    { flexDirection: "column" },
    Y0.createElement(
      S,
      { marginBottom: 1 },
      Y0.createElement(
        U,
        { bold: !0 },
        W && !F ? "Plugin Loading Errors" : "Plugin Status",
      ),
    ),
    I.marketplaces.length > 0 &&
      Y0.createElement(
        Y0.Fragment,
        null,
        Y0.createElement(
          S,
          { marginBottom: 1 },
          Y0.createElement(U, { dimColor: !0 }, "Marketplaces:"),
        ),
        I.marketplaces.map((C) =>
          Y0.createElement(
            S,
            { key: C.name, marginLeft: 2 },
            C.status === "installing" &&
              Y0.createElement(
                Y0.Fragment,
                null,
                Y0.createElement(E8, null),
                Y0.createElement(
                  S,
                  { marginLeft: 1 },
                  Y0.createElement(U, null, C.name),
                  Y0.createElement(U, { dimColor: !0 }, "  Installing"),
                ),
              ),
            C.status === "pending" &&
              Y0.createElement(
                U,
                null,
                Y0.createElement(U, { dimColor: !0 }, E1.circle || "", " "),
                C.name,
                Y0.createElement(U, { dimColor: !0 }, "  Pending"),
              ),
            C.status === "installed" &&
              Y0.createElement(
                U,
                null,
                Y0.createElement(U, { color: "success" }, E1.tick || "", " "),
                C.name,
                Y0.createElement(U, { dimColor: !0 }, "  Installed"),
              ),
            C.status === "failed" &&
              Y0.createElement(
                S,
                { flexDirection: "column" },
                Y0.createElement(
                  U,
                  null,
                  Y0.createElement(U, { color: "error" }, E1.cross || "", " "),
                  C.name,
                  Y0.createElement(U, { color: "error" }, "  Failed"),
                ),
                C.error &&
                  Y0.createElement(
                    S,
                    { marginLeft: 3 },
                    Y0.createElement(
                      U,
                      { color: "error", dimColor: !0 },
                      C.error,
                    ),
                  ),
              ),
          ),
        ),
      ),
    I.plugins.length > 0 &&
      Y0.createElement(
        Y0.Fragment,
        null,
        Y0.createElement(
          S,
          { marginTop: 1, marginBottom: 1 },
          Y0.createElement(U, { dimColor: !0 }, "Plugins:"),
        ),
        I.plugins.map((C) =>
          Y0.createElement(
            S,
            { key: C.id, marginLeft: 2 },
            C.status === "installing" &&
              Y0.createElement(
                Y0.Fragment,
                null,
                Y0.createElement(E8, null),
                Y0.createElement(
                  S,
                  { marginLeft: 1 },
                  Y0.createElement(U, null, C.name),
                  Y0.createElement(U, { dimColor: !0 }, "  Installing"),
                ),
              ),
            C.status === "pending" &&
              Y0.createElement(
                U,
                null,
                Y0.createElement(U, { dimColor: !0 }, E1.circle || "", " "),
                C.name,
                Y0.createElement(U, { dimColor: !0 }, "  Pending"),
              ),
            C.status === "installed" &&
              Y0.createElement(
                U,
                null,
                Y0.createElement(U, { color: "success" }, E1.tick || "", " "),
                C.name,
                Y0.createElement(U, { dimColor: !0 }, "  Installed"),
              ),
            C.status === "failed" &&
              Y0.createElement(
                S,
                { flexDirection: "column" },
                Y0.createElement(
                  U,
                  null,
                  Y0.createElement(U, { color: "error" }, E1.cross || "", " "),
                  C.name,
                  Y0.createElement(U, { color: "error" }, "  Failed"),
                ),
                C.error &&
                  Y0.createElement(
                    S,
                    { marginLeft: 3 },
                    Y0.createElement(
                      U,
                      { color: "error", dimColor: !0 },
                      C.error,
                    ),
                  ),
              ),
          ),
        ),
      ),
    I.marketplaces.length === 0 &&
      I.plugins.length === 0 &&
      G.length === 0 &&
      Y0.createElement(
        S,
        { marginTop: 1 },
        Y0.createElement(
          U,
          { dimColor: !0 },
          "No pending installations or errors",
        ),
      ),
    G.length > 0 &&
      Y0.createElement(
        Y0.Fragment,
        null,
        Y0.createElement(
          S,
          { marginTop: 1, marginBottom: 1 },
          Y0.createElement(U, { dimColor: !0 }, "Plugin Loading Errors:"),
        ),
        G.map((C, V) => {
          let K = "plugin" in C ? C.plugin : void 0;
          return Y0.createElement(
            S,
            { key: V, marginLeft: 2, flexDirection: "column" },
            Y0.createElement(
              U,
              null,
              Y0.createElement(U, { color: "error" }, E1.cross || "", " "),
              K
                ? Y0.createElement(
                    Y0.Fragment,
                    null,
                    "Plugin ",
                    Y0.createElement(U, { bold: !0 }, K),
                    " from",
                    " ",
                    Y0.createElement(U, { dimColor: !0 }, C.source),
                  )
                : Y0.createElement(U, { dimColor: !0 }, C.source),
            ),
            Y0.createElement(
              S,
              { marginLeft: 3 },
              Y0.createElement(U, { color: "error", dimColor: !0 }, T1I(C)),
            ),
            Ta2(C) &&
              Y0.createElement(
                S,
                { marginLeft: 3, marginTop: 1 },
                Y0.createElement(U, { dimColor: !0, italic: !0 }, Ta2(C)),
              ),
          );
        }),
      ),
    Y0.createElement(
      S,
      { marginTop: 2 },
      Y0.createElement(
        U,
        { dimColor: !0 },
        X
          ? "Installing"
          : Y0.createElement(
              Y0.Fragment,
              null,
              "Press",
              " ",
              Y.failed > 0 || J.failed > 0
                ? Y0.createElement(
                    Y0.Fragment,
                    null,
                    Y0.createElement(U, { bold: !0 }, "r"),
                    " to retry failed installations ",
                    " ",
                  )
                : null,
              Y0.createElement(U, { bold: !0 }, "Esc"),
              " to return",
            ),
      ),
    ),
  );
}
var Y0, Pa2;
var Sa2 = T(() => {
  nA();
  R9();
  c9();
  KA0();
  xX();
  s2();
  ((Y0 = IA(KA(), 1)), (Pa2 = IA(KA(), 1)));
});
import * as $E from "fs";
import * as ML from "path";
function P1I(A) {
  let B = ML.basename(A),
    Q = ML.basename(ML.dirname(A));
  if (B === "plugin.json") return "plugin";
  if (B === "marketplace.json") return "marketplace";
  if (Q === ".claude-plugin") return "plugin";
  return "unknown";
}
function ya2(A) {
  return A.errors.map((B) => ({
    path: B.path.join(".") || "root",
    message: B.message,
    code: B.code,
  }));
}
function g$A(A, B, Q) {
  if (A.includes(".."))
    Q.push({
      path: B,
      message: `Path contains ".." which could be a path traversal attempt: ${A}`,
    });
}
function i00(A) {
  let B = [],
    Q = [],
    I = ML.resolve(A);
  if (!$E.existsSync(I))
    return {
      success: !1,
      errors: [{ path: "file", message: `File not found: ${I}` }],
      warnings: [],
      filePath: I,
      fileType: "plugin",
    };
  if (!$E.statSync(I).isFile())
    return {
      success: !1,
      errors: [{ path: "file", message: `Path is not a file: ${I}` }],
      warnings: [],
      filePath: I,
      fileType: "plugin",
    };
  let Z;
  try {
    Z = $E.readFileSync(I, { encoding: "utf-8" });
  } catch (X) {
    return {
      success: !1,
      errors: [
        {
          path: "file",
          message: `Failed to read file: ${X instanceof Error ? X.message : String(X)}`,
        },
      ],
      warnings: [],
      filePath: I,
      fileType: "plugin",
    };
  }
  let Y;
  try {
    Y = JSON.parse(Z);
  } catch (X) {
    return {
      success: !1,
      errors: [
        {
          path: "json",
          message: `Invalid JSON syntax: ${X instanceof Error ? X.message : String(X)}`,
        },
      ],
      warnings: [],
      filePath: I,
      fileType: "plugin",
    };
  }
  if (Y && typeof Y === "object") {
    let X = Y;
    if (X.commands)
      (Array.isArray(X.commands) ? X.commands : [X.commands]).forEach(
        (F, C) => {
          if (typeof F === "string") g$A(F, `commands[${C}]`, B);
        },
      );
    if (X.agents)
      (Array.isArray(X.agents) ? X.agents : [X.agents]).forEach((F, C) => {
        if (typeof F === "string") g$A(F, `agents[${C}]`, B);
      });
    if (X.skills)
      (Array.isArray(X.skills) ? X.skills : [X.skills]).forEach((F, C) => {
        if (typeof F === "string") g$A(F, `skills[${C}]`, B);
      });
  }
  let J = Vs.safeParse(Y);
  if (!J.success) B.push(...ya2(J.error));
  if (J.success) {
    let X = J.data;
    if (!X.version)
      Q.push({
        path: "version",
        message:
          'No version specified. Consider adding a version following semver (e.g., "1.0.0")',
      });
    if (!X.description)
      Q.push({
        path: "description",
        message:
          "No description provided. Adding a description helps users understand what your plugin does",
      });
    if (!X.author)
      Q.push({
        path: "author",
        message:
          "No author information provided. Consider adding author details for plugin attribution",
      });
  }
  return {
    success: B.length === 0,
    errors: B,
    warnings: Q,
    filePath: I,
    fileType: "plugin",
  };
}
function n00(A) {
  let B = [],
    Q = [],
    I = ML.resolve(A);
  if (!$E.existsSync(I))
    return {
      success: !1,
      errors: [{ path: "file", message: `File not found: ${I}` }],
      warnings: [],
      filePath: I,
      fileType: "marketplace",
    };
  if (!$E.statSync(I).isFile())
    return {
      success: !1,
      errors: [{ path: "file", message: `Path is not a file: ${I}` }],
      warnings: [],
      filePath: I,
      fileType: "marketplace",
    };
  let Z;
  try {
    Z = $E.readFileSync(I, { encoding: "utf-8" });
  } catch (X) {
    return {
      success: !1,
      errors: [
        {
          path: "file",
          message: `Failed to read file: ${X instanceof Error ? X.message : String(X)}`,
        },
      ],
      warnings: [],
      filePath: I,
      fileType: "marketplace",
    };
  }
  let Y;
  try {
    Y = JSON.parse(Z);
  } catch (X) {
    return {
      success: !1,
      errors: [
        {
          path: "json",
          message: `Invalid JSON syntax: ${X instanceof Error ? X.message : String(X)}`,
        },
      ],
      warnings: [],
      filePath: I,
      fileType: "marketplace",
    };
  }
  if (Y && typeof Y === "object") {
    let X = Y;
    if (Array.isArray(X.plugins))
      X.plugins.forEach((W, F) => {
        if (W && typeof W === "object" && "source" in W) {
          let C = W.source;
          if (typeof C === "string") g$A(C, `plugins[${F}].source`, B);
          if (
            C &&
            typeof C === "object" &&
            "path" in C &&
            typeof C.path === "string"
          )
            g$A(C.path, `plugins[${F}].source.path`, B);
        }
      });
  }
  let J = r8A.safeParse(Y);
  if (!J.success) B.push(...ya2(J.error));
  if (J.success) {
    let X = J.data;
    if (!X.plugins || X.plugins.length === 0)
      Q.push({
        path: "plugins",
        message: "Marketplace has no plugins defined",
      });
    if (X.plugins)
      X.plugins.forEach((W, F) => {
        if (typeof W.source === "object" && W.source.source === "npm")
          Q.push({
            path: `plugins[${F}].source`,
            message: `Plugin "${W.name}" uses npm source which is not yet fully implemented`,
          });
        if (X.plugins.filter((V) => V.name === W.name).length > 1)
          B.push({
            path: `plugins[${F}].name`,
            message: `Duplicate plugin name "${W.name}" found in marketplace`,
          });
      });
    if (!X.metadata?.description)
      Q.push({
        path: "metadata.description",
        message:
          "No marketplace description provided. Adding a description helps users understand what this marketplace offers",
      });
  }
  return {
    success: B.length === 0,
    errors: B,
    warnings: Q,
    filePath: I,
    fileType: "marketplace",
  };
}
function BQ1(A) {
  let B = ML.resolve(A);
  if ($E.existsSync(B) && $E.statSync(B).isDirectory()) {
    let I = ML.join(B, ".claude-plugin", "marketplace.json"),
      G = ML.join(B, ".claude-plugin", "plugin.json");
    if ($E.existsSync(I)) return n00(I);
    else if ($E.existsSync(G)) return i00(G);
    else
      return {
        success: !1,
        errors: [
          {
            path: "directory",
            message:
              "No manifest found in directory. Expected .claude-plugin/marketplace.json or .claude-plugin/plugin.json",
          },
        ],
        warnings: [],
        filePath: B,
        fileType: "plugin",
      };
  }
  switch (P1I(A)) {
    case "plugin":
      return i00(A);
    case "marketplace":
      return n00(A);
    case "unknown": {
      if (!$E.existsSync(B))
        return {
          success: !1,
          errors: [{ path: "file", message: `File not found: ${B}` }],
          warnings: [],
          filePath: B,
          fileType: "plugin",
        };
      try {
        let I = $E.readFileSync(B, { encoding: "utf-8" }),
          G = JSON.parse(I);
        if (Array.isArray(G.plugins)) return n00(A);
      } catch {}
      return i00(A);
    }
  }
}
var a00 = T(() => {
  Ks();
});
function _a2({ onComplete: A, path: B }) {
  return (
    ka2.useEffect(() => {
      async function Q() {
        if (!B) {
          A(`Usage: /plugin validate <path>

Validate a plugin or marketplace manifest file or directory.

Examples:
  /plugin validate .claude-plugin/plugin.json
  /plugin validate /path/to/plugin-directory
  /plugin validate .

When given a directory, automatically validates .claude-plugin/marketplace.json
or .claude-plugin/plugin.json (prefers marketplace if both exist).

Or from the command line:
  claude plugin validate <path>`);
          return;
        }
        try {
          let I = BQ1(B),
            G = "";
          if (
            ((G += `Validating ${I.fileType} manifest: ${I.filePath}

`),
            I.errors.length > 0)
          )
            ((G += `${E1.cross} Found ${I.errors.length} error${I.errors.length === 1 ? "" : "s"}:

`),
              I.errors.forEach((Z) => {
                G += `  ${E1.pointer} ${Z.path}: ${Z.message}
`;
              }),
              (G += `
`));
          if (I.warnings.length > 0)
            ((G += `${E1.warning} Found ${I.warnings.length} warning${I.warnings.length === 1 ? "" : "s"}:

`),
              I.warnings.forEach((Z) => {
                G += `  ${E1.pointer} ${Z.path}: ${Z.message}
`;
              }),
              (G += `
`));
          if (I.success) {
            if (I.warnings.length > 0)
              G += `${E1.tick} Validation passed with warnings
`;
            else
              G += `${E1.tick} Validation passed
`;
            process.exitCode = 0;
          } else
            ((G += `${E1.cross} Validation failed
`),
              (process.exitCode = 1));
          A(G);
        } catch (I) {
          ((process.exitCode = 2),
            BA(I instanceof Error ? I : Error(String(I)), Pl),
            A(
              `${E1.cross} Unexpected error during validation: ${I instanceof Error ? I.message : String(I)}`,
            ));
        }
      }
      Q();
    }, [A, B]),
    u$A.createElement(
      S,
      { flexDirection: "column" },
      u$A.createElement(U, null, "Running validation..."),
    )
  );
}
var u$A, ka2;
var xa2 = T(() => {
  nA();
  a00();
  s2();
  c1();
  ((u$A = IA(KA(), 1)), (ka2 = IA(KA(), 1)));
});
function va2(A) {
  if (!A) return { type: "menu" };
  let B = A.trim().split(/\s+/);
  switch (B[0]?.toLowerCase()) {
    case "help":
    case "--help":
    case "-h":
      return { type: "help" };
    case "install":
    case "i": {
      let I = B[1];
      if (!I) return { type: "install" };
      if (I.includes("@")) {
        let [Z, Y] = I.split("@");
        return { type: "install", plugin: Z, marketplace: Y };
      }
      if (
        I.startsWith("http://") ||
        I.startsWith("https://") ||
        I.startsWith("file://") ||
        I.includes("/") ||
        I.includes("\\")
      )
        return { type: "install", marketplace: I };
      return { type: "install", plugin: I };
    }
    case "manage":
      return { type: "manage" };
    case "uninstall":
      return { type: "uninstall", plugin: B[1] };
    case "enable":
      return { type: "enable", plugin: B[1] };
    case "disable":
      return { type: "disable", plugin: B[1] };
    case "validate":
      return { type: "validate", path: B.slice(1).join(" ").trim() || void 0 };
    case "marketplace":
    case "market": {
      let I = B[1]?.toLowerCase(),
        G = B.slice(2).join(" ");
      switch (I) {
        case "add":
          return { type: "marketplace", action: "add", target: G };
        case "remove":
        case "rm":
          return { type: "marketplace", action: "remove", target: G };
        case "update":
          return { type: "marketplace", action: "update", target: G };
        case "list":
          return { type: "marketplace", action: "list" };
        default:
          return { type: "marketplace" };
      }
    }
    default:
      return { type: "menu" };
  }
}
function j1I({ onComplete: A }) {
  return (
    OL.useEffect(() => {
      async function B() {
        try {
          let Q = await PY(),
            I = Object.keys(Q);
          if (I.length === 0) A("No marketplaces configured");
          else
            A(`Configured marketplaces:
${I.map((G) => `   ${G}`).join(`
`)}`);
        } catch (Q) {
          A(
            `Error loading marketplaces: ${Q instanceof Error ? Q.message : String(Q)}`,
          );
        }
      }
      B();
    }, [A]),
    dB.createElement(U, null, "Loading marketplaces...")
  );
}
function S1I(A) {
  switch (A.type) {
    case "help":
      return { type: "help" };
    case "validate":
      return { type: "validate", path: A.path };
    case "install":
      if (A.marketplace || A.plugin)
        return {
          type: "browse-marketplace",
          targetMarketplace: A.marketplace,
          targetPlugin: A.plugin,
        };
      return { type: "browse-marketplace" };
    case "manage":
      return { type: "manage-plugins" };
    case "uninstall":
      return {
        type: "manage-plugins",
        targetPlugin: A.plugin,
        action: "uninstall",
      };
    case "enable":
      return {
        type: "manage-plugins",
        targetPlugin: A.plugin,
        action: "enable",
      };
    case "disable":
      return {
        type: "manage-plugins",
        targetPlugin: A.plugin,
        action: "disable",
      };
    case "marketplace":
      if (A.action === "list") return { type: "marketplace-list" };
      if (A.action === "add")
        return { type: "add-marketplace", initialValue: A.target };
      if (A.action === "remove")
        return {
          type: "manage-marketplaces",
          targetMarketplace: A.target,
          action: "remove",
        };
      if (A.action === "update")
        return {
          type: "manage-marketplaces",
          targetMarketplace: A.target,
          action: "update",
        };
      return { type: "marketplace-menu" };
    case "menu":
    default:
      return { type: "menu" };
  }
}
function ba2({ onComplete: A, args: B }) {
  let Q = va2(B),
    [I, G] = OL.useState(S1I(Q)),
    [Z, Y] = OL.useState(
      I.type === "add-marketplace" ? I.initialValue || "" : "",
    ),
    [J, X] = OL.useState(0),
    [W, F] = OL.useState(null),
    [C, V] = OL.useState(null),
    [, K] = lB(),
    D = IB(),
    E = Q.type === "marketplace" && Q.action === "add" && Q.target !== void 0,
    H = OL.useCallback(async () => {
      let { enabled: w, disabled: L, errors: N } = await Z3(),
        [$, O] = await Promise.all([oo(), to()]);
      K((P) => ({
        ...P,
        plugins: {
          ...P.plugins,
          enabled: w,
          disabled: L,
          commands: $,
          agents: O,
          errors: N,
        },
      }));
    }, [K]);
  if (
    (h1((w, L) => {
      if (L.escape) {
        if (I.type === "add-marketplace") (G({ type: "menu" }), Y(""), F(null));
        else if (I.type === "manage-marketplaces")
          (G({ type: "menu" }), F(null), V(null));
        else if (I.type === "browse-marketplace") G({ type: "menu" });
        return;
      }
    }),
    OL.useEffect(() => {
      if (C) A(C);
    }, [C, A]),
    OL.useEffect(() => {
      if (I.type === "help") A();
    }, [I.type, A]),
    I.type === "help")
  )
    return dB.createElement(
      S,
      { flexDirection: "column" },
      dB.createElement(U, { bold: !0 }, "Plugin Command Usage:"),
      dB.createElement(U, null, " "),
      dB.createElement(U, { dimColor: !0 }, "Installation:"),
      dB.createElement(
        U,
        null,
        " /plugin install - Browse and install plugins",
      ),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin install <marketplace> - Install from specific marketplace",
      ),
      dB.createElement(
        U,
        null,
        " /plugin install <plugin> - Install specific plugin",
      ),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin install <plugin>@<market> - Install plugin from marketplace",
      ),
      dB.createElement(U, null, " "),
      dB.createElement(U, { dimColor: !0 }, "Management:"),
      dB.createElement(U, null, " /plugin manage - Manage installed plugins"),
      dB.createElement(U, null, " /plugin enable <plugin> - Enable a plugin"),
      dB.createElement(U, null, " /plugin disable <plugin> - Disable a plugin"),
      dB.createElement(
        U,
        null,
        " /plugin uninstall <plugin> - Uninstall a plugin",
      ),
      dB.createElement(U, null, " "),
      dB.createElement(U, { dimColor: !0 }, "Marketplaces:"),
      dB.createElement(
        U,
        null,
        " /plugin marketplace - Marketplace management menu",
      ),
      dB.createElement(U, null, " /plugin marketplace add - Add a marketplace"),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin marketplace add <path/url> - Add marketplace directly",
      ),
      dB.createElement(
        U,
        null,
        " /plugin marketplace update - Update marketplaces",
      ),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin marketplace update <name> - Update specific marketplace",
      ),
      dB.createElement(
        U,
        null,
        " /plugin marketplace remove - Remove a marketplace",
      ),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin marketplace remove <name> - Remove specific marketplace",
      ),
      dB.createElement(
        U,
        null,
        " /plugin marketplace list - List all marketplaces",
      ),
      dB.createElement(U, null, " "),
      dB.createElement(U, { dimColor: !0 }, "Validation:"),
      dB.createElement(
        U,
        null,
        " ",
        "/plugin validate <path> - Validate a manifest file or directory",
      ),
      dB.createElement(U, null, " "),
      dB.createElement(U, { dimColor: !0 }, "Other:"),
      dB.createElement(U, null, " /plugin - Main plugin menu"),
      dB.createElement(U, null, " /plugin help - Show this help"),
      dB.createElement(U, null, " /plugins - Alias for /plugin"),
    );
  if (I.type === "validate")
    return dB.createElement(_a2, { onComplete: A, path: I.path });
  if (I.type === "marketplace-menu") return (G({ type: "menu" }), null);
  if (I.type === "marketplace-list")
    return dB.createElement(j1I, { onComplete: A });
  if (I.type === "add-marketplace")
    return dB.createElement(Ha2, {
      inputValue: Z,
      setInputValue: Y,
      cursorOffset: J,
      setCursorOffset: X,
      error: W,
      setError: F,
      result: C,
      setResult: V,
      setViewState: G,
      onAddComplete: H,
      cliMode: E,
    });
  if (I.type === "manage-marketplaces")
    return dB.createElement(Ua2, {
      setViewState: G,
      error: W,
      setError: F,
      setResult: V,
      exitState: D,
      onManageComplete: H,
      targetMarketplace: I.targetMarketplace,
      action: I.action,
    });
  if (I.type === "browse-marketplace")
    return dB.createElement($a2, {
      error: W,
      setError: F,
      result: C,
      setResult: V,
      setViewState: G,
      onInstallComplete: H,
      targetMarketplace: I.targetMarketplace,
      targetPlugin: I.targetPlugin,
    });
  if (I.type === "manage-plugins")
    return dB.createElement(Oa2, {
      setViewState: G,
      setResult: V,
      onManageComplete: H,
      targetPlugin: I.targetPlugin,
      action: I.action,
    });
  if (I.type === "installation-status")
    return dB.createElement(ja2, { onComplete: () => G({ type: "menu" }) });
  return dB.createElement(Ca2, {
    setViewState: G,
    onComplete: A,
    exitState: D,
  });
}
var dB, OL;
var fa2 = T(() => {
  nA();
  R9();
  NF();
  c9();
  lwA();
  iwA();
  Va2();
  za2();
  wa2();
  qa2();
  Ra2();
  Sa2();
  xa2();
  pD();
  ((dB = IA(KA(), 1)), (OL = IA(KA(), 1)));
});
var s00, y1I, ha2;
var ga2 = T(() => {
  fa2();
  ((s00 = IA(KA(), 1)),
    (y1I = {
      type: "local-jsx",
      name: "plugin",
      aliases: ["plugins", "marketplace"],
      description: "Manage Claude Code plugins",
      isEnabled: () => !0,
      isHidden: !1,
      async call(A, B, Q) {
        return s00.createElement(ba2, { onComplete: A, args: Q });
      },
      userFacingName() {
        return "plugin";
      },
    }),
    (ha2 = y1I));
});
var k1I, ua2;
var ma2 = T(() => {
  ((k1I = {
    description: "Restore the code and/or conversation to a previous point",
    name: "rewind",
    aliases: ["checkpoint"],
    userFacingName: () => "rewind",
    argumentHint: "",
    isEnabled: () => !0,
    type: "local",
    isHidden: !1,
    supportsNonInteractive: !1,
    async call(A, B) {
      if (B.openMessageSelector) B.openMessageSelector();
      return { type: "skip" };
    },
  }),
    (ua2 = k1I));
});
var da2 = T(() => {
  Z4();
});
var _1I, x1I;
var ca2 = T(() => {
  nA();
  R5();
  WdA();
  ((_1I = IA(KA(), 1)), (x1I = IA(KA(), 1)));
});
var v1I;
var pa2 = T(() => {
  QW();
  nA();
  La();
  F2();
  C0();
  yH();
  c1();
  i0();
  v1I = IA(KA(), 1);
});
var la2 = () => {};
function ia2() {
  if (!VQ.isSandboxingEnabled())
    return W4.createElement(
      S,
      { flexDirection: "column", paddingY: 1 },
      W4.createElement(U, { color: "subtle" }, "Sandbox is not enabled"),
    );
  let B = VQ.getFsReadConfig(),
    Q = VQ.getFsWriteConfig(),
    I = VQ.getNetworkRestrictionConfig(),
    G = VQ.getAllowUnixSockets(),
    Z = VQ.getExcludedCommands(),
    Y = VQ.getLinuxGlobPatternWarnings();
  return W4.createElement(
    S,
    { flexDirection: "column", paddingY: 1 },
    W4.createElement(
      S,
      { flexDirection: "column" },
      W4.createElement(
        U,
        { bold: !0, color: "permission" },
        "Excluded Commands:",
      ),
      W4.createElement(
        U,
        { dimColor: !0 },
        Z.length > 0 ? Z.join(", ") : "None",
      ),
    ),
    B.denyOnly.length > 0 &&
      W4.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W4.createElement(
          U,
          { bold: !0, color: "permission" },
          "Filesystem Read Restrictions:",
        ),
        W4.createElement(
          U,
          { dimColor: !0 },
          "Denied: ",
          B.denyOnly.join(", "),
        ),
      ),
    Q.allowOnly.length > 0 &&
      W4.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W4.createElement(
          U,
          { bold: !0, color: "permission" },
          "Filesystem Write Restrictions:",
        ),
        W4.createElement(
          U,
          { dimColor: !0 },
          "Allowed: ",
          Q.allowOnly.join(", "),
        ),
        Q.denyWithinAllow.length > 0 &&
          W4.createElement(
            U,
            { dimColor: !0 },
            "Denied within allowed: ",
            Q.denyWithinAllow.join(", "),
          ),
      ),
    ((I.allowedHosts && I.allowedHosts.length > 0) ||
      (I.deniedHosts && I.deniedHosts.length > 0)) &&
      W4.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W4.createElement(
          U,
          { bold: !0, color: "permission" },
          "Network Restrictions:",
        ),
        I.allowedHosts &&
          I.allowedHosts.length > 0 &&
          W4.createElement(
            U,
            { dimColor: !0 },
            "Allowed: ",
            I.allowedHosts.join(", "),
          ),
        I.deniedHosts &&
          I.deniedHosts.length > 0 &&
          W4.createElement(
            U,
            { dimColor: !0 },
            "Denied: ",
            I.deniedHosts.join(", "),
          ),
      ),
    G &&
      G.length > 0 &&
      W4.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W4.createElement(
          U,
          { bold: !0, color: "permission" },
          "Allowed Unix Sockets:",
        ),
        W4.createElement(U, { dimColor: !0 }, G.join(", ")),
      ),
    Y.length > 0 &&
      W4.createElement(
        S,
        { marginTop: 1, flexDirection: "column" },
        W4.createElement(
          U,
          { bold: !0, color: "warning" },
          " Warning: Glob patterns not fully supported on Linux",
        ),
        W4.createElement(
          U,
          { dimColor: !0 },
          "The following patterns will be ignored:",
          " ",
          Y.slice(0, 3).join(", "),
          Y.length > 3 && ` (${Y.length - 3} more)`,
        ),
      ),
  );
}
var W4;
var na2 = T(() => {
  nA();
  VW();
  W4 = IA(KA(), 1);
});
function aa2({ onComplete: A }) {
  let [B] = HQ(),
    Q = VQ.isSandboxingEnabled(),
    I = VQ.areUnsandboxedCommandsAllowed(),
    G = VQ.areSandboxSettingsLockedByPolicy(),
    Z = I ? "open" : "closed",
    Y = OB("success", B)("(current)"),
    J = [
      {
        label:
          Z === "open"
            ? `Allow unsandboxed fallback ${Y}`
            : "Allow unsandboxed fallback",
        value: "open",
      },
      {
        label:
          Z === "closed" ? `Strict sandbox mode ${Y}` : "Strict sandbox mode",
        value: "closed",
      },
    ];
  async function X(W) {
    let F = W;
    (await VQ.setSandboxSettings({ allowUnsandboxedCommands: F === "open" }),
      A(
        F === "open"
          ? " Unsandboxed fallback allowed - commands can run outside sandbox when necessary"
          : " Strict sandbox mode - all commands must run in sandbox or be excluded via the `excludedCommands` option",
      ));
  }
  if (
    (h1((W, F) => {
      if (F.escape) A();
    }),
    !Q)
  )
    return AC.default.createElement(
      S,
      { flexDirection: "column", paddingY: 1 },
      AC.default.createElement(
        U,
        { color: "subtle" },
        "Sandbox is not enabled. Enable sandbox to configure override settings.",
      ),
    );
  if (G)
    return AC.default.createElement(
      S,
      { flexDirection: "column", paddingY: 1 },
      AC.default.createElement(
        U,
        { color: "subtle" },
        "Override settings are managed by a higher-priority configuration and cannot be changed locally.",
      ),
      AC.default.createElement(
        S,
        { marginTop: 1 },
        AC.default.createElement(
          U,
          { dimColor: !0 },
          "Current setting:",
          " ",
          Z === "closed" ? "Strict sandbox mode" : "Allow unsandboxed fallback",
        ),
      ),
    );
  return AC.default.createElement(
    S,
    { flexDirection: "column", paddingY: 1 },
    AC.default.createElement(
      S,
      { marginBottom: 1 },
      AC.default.createElement(U, { bold: !0 }, "Configure Overrides:"),
    ),
    AC.default.createElement($0, {
      options: J,
      onChange: X,
      onCancel: () => A(),
    }),
    AC.default.createElement(
      S,
      { flexDirection: "column", marginTop: 1, gap: 1 },
      AC.default.createElement(
        U,
        { dimColor: !0 },
        AC.default.createElement(
          U,
          { bold: !0, dimColor: !0 },
          "Allow unsandboxed fallback:",
        ),
        " ",
        "When a command fails due to sandbox restrictions, Claude can retry with dangerouslyDisableSandbox to run outside the sandbox (falling back to default permissions).",
      ),
      AC.default.createElement(
        U,
        { dimColor: !0 },
        AC.default.createElement(
          U,
          { bold: !0, dimColor: !0 },
          "Strict sandbox mode:",
        ),
        " ",
        "All bash commands invoked by the model must run in the sandbox unless they are explicitly listed in excludedCommands.",
      ),
      AC.default.createElement(
        U,
        { dimColor: !0 },
        "Learn more:",
        " ",
        AC.default.createElement(
          R8,
          {
            url: "https://docs.claude.com/en/docs/claude-code/sandboxing#configure-sandboxing",
          },
          "docs.claude.com/en/docs/claude-code/sandboxing#configure-sandboxing",
        ),
      ),
    ),
  );
}
var AC;
var sa2 = T(() => {
  nA();
  Z5();
  VW();
  vK();
  AC = IA(KA(), 1);
});
function ra2({ onComplete: A }) {
  let [B] = HQ(),
    Q = VQ.isSandboxingEnabled(),
    I = VQ.isAutoAllowBashIfSandboxedEnabled(),
    Z = (() => {
      if (!Q) return "disabled";
      if (I) return "auto-allow";
      return "regular";
    })(),
    Y = OB("success", B)("(current)"),
    J = [
      {
        label:
          Z === "auto-allow"
            ? `Sandbox BashTool, with auto-allow in accept edits mode ${Y}`
            : "Sandbox BashTool, with auto-allow in accept edits mode",
        value: "auto-allow",
      },
      {
        label:
          Z === "regular"
            ? `Sandbox BashTool, with regular permissions ${Y}`
            : "Sandbox BashTool, with regular permissions",
        value: "regular",
      },
      {
        label: Z === "disabled" ? `No Sandbox ${Y}` : "No Sandbox",
        value: "disabled",
      },
    ];
  async function X(W) {
    switch (W) {
      case "auto-allow":
        (await VQ.setSandboxSettings({
          enabled: !0,
          autoAllowBashIfSandboxed: !0,
        }),
          A(
            " Sandbox enabled with auto-allow for bash commands when in accept-edits mode",
          ));
        break;
      case "regular":
        (await VQ.setSandboxSettings({
          enabled: !0,
          autoAllowBashIfSandboxed: !1,
        }),
          A(" Sandbox enabled with regular bash permissions"));
        break;
      case "disabled":
        (await VQ.setSandboxSettings({
          enabled: !1,
          autoAllowBashIfSandboxed: !1,
        }),
          A(" Sandbox disabled"));
        break;
    }
  }
  return (
    h1((W, F) => {
      if (F.escape) A();
    }),
    kW.default.createElement(
      S,
      { flexDirection: "column" },
      kW.default.createElement(p5, {
        dividerColor: "permission",
        dividerDimColor: !0,
      }),
      kW.default.createElement(
        S,
        { marginX: 1 },
        kW.default.createElement(
          tc,
          { title: "Sandbox:", color: "permission", defaultTab: "Mode" },
          kW.default.createElement(
            LV,
            { key: "mode", title: "Mode" },
            kW.default.createElement(
              S,
              { flexDirection: "column", paddingY: 1 },
              kW.default.createElement(
                S,
                { marginBottom: 1 },
                kW.default.createElement(U, { bold: !0 }, "Configure Mode:"),
              ),
              kW.default.createElement($0, {
                options: J,
                onChange: X,
                onCancel: () => A(),
              }),
              kW.default.createElement(
                S,
                { flexDirection: "column", marginTop: 1, gap: 1 },
                kW.default.createElement(
                  U,
                  { dimColor: !0 },
                  kW.default.createElement(
                    U,
                    { bold: !0, dimColor: !0 },
                    "Auto-allow mode:",
                  ),
                  " ",
                  "When in accept-edits mode, commands will try to run in the sandbox automatically, and attempts to run outside of the sandbox fallback to regular permissions. Explicit ask/deny rules are always respected.",
                ),
                kW.default.createElement(
                  U,
                  { dimColor: !0 },
                  "Learn more:",
                  " ",
                  kW.default.createElement(
                    R8,
                    {
                      url: "https://docs.claude.com/en/docs/claude-code/sandboxing",
                    },
                    "docs.claude.com/en/docs/claude-code/sandboxing",
                  ),
                ),
              ),
            ),
          ),
          kW.default.createElement(
            LV,
            { key: "overrides", title: "Overrides" },
            kW.default.createElement(aa2, { onComplete: A }),
          ),
          kW.default.createElement(
            LV,
            { key: "config", title: "Config" },
            kW.default.createElement(ia2, null),
          ),
        ),
      ),
    )
  );
}
var kW;
var oa2 = T(() => {
  nA();
  Z5();
  VW();
  U$A();
  iC();
  vK();
  na2();
  sa2();
  kW = IA(KA(), 1);
});
import * as ta2 from "path";
async function b1I(A, B, Q) {
  let G = N0().theme || "light";
  if (!VQ.isSupportedPlatform(EB())) {
    let Y = OB(
      "error",
      G,
    )("Error: Sandboxing is currently only supported on macOS and Linux");
    return (A(Y), null);
  }
  if (EB() === "linux" && !SdA()) {
    let Y = OB(
      "error",
      G,
    )(
      "Error: Sandbox requires socat and bubblewrap. Please install these packages.",
    );
    return (A(Y), null);
  }
  if (VQ.areSandboxSettingsLockedByPolicy()) {
    let Y = OB(
      "error",
      G,
    )(
      "Error: Sandbox settings are overridden by a higher-priority configuration and cannot be changed locally.",
    );
    return (A(Y), null);
  }
  let Z = Q?.trim() || "";
  if (!Z) return ea2.default.createElement(ra2, { onComplete: A });
  if (Z) {
    let J = Z.split(" ")[0];
    if (J === "exclude") {
      let X = Z.slice(8).trim();
      if (!X) {
        let K = OB(
          "error",
          G,
        )(
          'Error: Please provide a command pattern to exclude (e.g., /sandbox exclude "npm run test:*")',
        );
        return (A(K), null);
      }
      let W = X.replace(/^["']|["']$/g, "");
      cQQ(W);
      let F = zU("localSettings"),
        C = F ? ta2.relative(Xk(), F) : ".claude/settings.local.json",
        V = OB("success", G)(`Added "${W}" to excluded commands in ${C}`);
      return (A(V), null);
    } else {
      let X = OB(
        "error",
        G,
      )(`Error: Unknown subcommand "${J}". Available subcommand: exclude`);
      return (A(X), null);
    }
  }
  return null;
}
var ea2, f1I, As2;
var Bs2 = T(() => {
  VW();
  nA();
  OQ();
  ru();
  OQ();
  i0();
  oa2();
  E5();
  tP1();
  ea2 = IA(KA(), 1);
  ((f1I = {
    name: "sandbox",
    get description() {
      let A = VQ.isSandboxingEnabled(),
        B = VQ.isAutoAllowBashIfSandboxedEnabled(),
        Q = VQ.areUnsandboxedCommandsAllowed(),
        I = VQ.areSandboxSettingsLockedByPolicy(),
        G = A ? "" : "",
        Z = "sandbox disabled";
      if (A)
        ((Z = B ? "sandbox enabled (auto-allow)" : "sandbox enabled"),
          (Z += Q ? ", fallback allowed" : ""));
      if (I) Z += " (managed)";
      return `${G} ${Z} ( to configure)`;
    },
    argumentHint: 'exclude "command pattern"',
    isEnabled: () => !0,
    isHidden: !VQ.isSupportedPlatform(EB()),
    type: "local-jsx",
    userFacingName: () => "sandbox",
    call: b1I,
  }),
    (As2 = f1I));
});
var h1I, Qs2;
var Is2 = T(() => {
  rq();
  ((h1I = {
    type: "local",
    name: "stickers",
    description: "Order Claude Code stickers",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    async call() {
      if (await d7("https://www.stickermule.com/claudecode"))
        return { type: "text", value: "Opening sticker page in browser" };
      else
        return {
          type: "text",
          value:
            "Failed to open browser. Visit: https://www.stickermule.com/claudecode",
        };
    },
    userFacingName() {
      return "stickers";
    },
  }),
    (Qs2 = h1I));
});
import { dirname as m$A, basename as QQ1, sep as g1I } from "path";
function r00(A) {
  return /^skill\.md$/i.test(QQ1(A));
}
function u1I(A) {
  let B = new Map();
  for (let I of A) {
    let G = m$A(I.filePath),
      Z = B.get(G) ?? [];
    (Z.push(I), B.set(G, Z));
  }
  let Q = [];
  for (let [I, G] of B) {
    let Z = G.filter((Y) => r00(Y.filePath));
    if (Z.length > 0) {
      let Y = Z[0];
      if (Z.length > 1)
        g(`Multiple skill files found in ${I}, using ${QQ1(Y.filePath)}`);
      Q.push(Y);
    } else Q.push(...G);
  }
  return Q;
}
function Gs2(A, B) {
  let Q = B.endsWith("/") ? B.slice(0, -1) : B;
  if (A === Q) return "";
  let I = A.slice(Q.length + 1);
  return I ? I.split(g1I).join(":") : "";
}
function m1I(A, B) {
  let Q = m$A(A),
    I = m$A(Q),
    G = QQ1(Q),
    Z = Gs2(I, B);
  return Z ? `${Z}:${G}` : G;
}
function d1I(A, B) {
  let Q = QQ1(A),
    I = m$A(A),
    G = Q.replace(/\.md$/, ""),
    Z = Gs2(I, B);
  return Z ? `${Z}:${G}` : G;
}
function c1I(A) {
  return r00(A.filePath)
    ? m1I(A.filePath, A.baseDir)
    : d1I(A.filePath, A.baseDir);
}
var Zs2;
var Ys2 = T(() => {
  a2();
  c1();
  C0();
  cwA();
  xS();
  NC();
  vB();
  Y9();
  Zs2 = I0(async () => {
    try {
      let A = await Zc("commands");
      return u1I(A)
        .map(
          ({
            baseDir: I,
            filePath: G,
            frontmatter: Z,
            content: Y,
            source: J,
          }) => {
            try {
              let X = Z.description ?? Xy(Y, "Custom command"),
                W = lc(Z["allowed-tools"]),
                F = Z["argument-hint"],
                C = Z.when_to_use,
                V = Z.version,
                K = V0(Z["disable-model-invocation"] ?? void 0),
                D =
                  Z.model === "inherit"
                    ? void 0
                    : Z.model
                      ? _U(Z.model)
                      : void 0,
                E = r00(G),
                H = E ? m$A(G) : void 0,
                w = c1I({
                  baseDir: I,
                  filePath: G,
                  frontmatter: Z,
                  content: Y,
                  source: J,
                }),
                L = `${X} (${o1A(J)})`;
              return {
                type: "prompt",
                name: w,
                description: L,
                hasUserSpecifiedDescription: !!Z.description,
                allowedTools: W,
                argumentHint: F,
                whenToUse: C,
                version: V,
                model: D,
                isSkill: E,
                disableModelInvocation: K,
                isEnabled: () => !0,
                isHidden: !1,
                progressMessage: E ? "loading" : "running",
                userFacingName() {
                  return w;
                },
                source: J,
                async getPromptForCommand(N, $) {
                  let O = Y;
                  if (E && H)
                    O = `Base directory for this skill: ${H}

${O}`;
                  if (N)
                    if (O.includes("$ARGUMENTS"))
                      O = O.replaceAll("$ARGUMENTS", N);
                    else
                      O =
                        O +
                        `

ARGUMENTS: ${N}`;
                  return (
                    (O = await cc(
                      O,
                      {
                        ...$,
                        async getAppState() {
                          let P = await $.getAppState();
                          return {
                            ...P,
                            toolPermissionContext: {
                              ...P.toolPermissionContext,
                              alwaysAllowRules: {
                                ...P.toolPermissionContext.alwaysAllowRules,
                                command: W,
                              },
                            },
                          };
                        },
                      },
                      `/${w}`,
                    )),
                    [{ type: "text", text: O }]
                  );
                },
              };
            } catch (X) {
              return (BA(X instanceof Error ? X : Error(String(X)), zG0), null);
            }
          },
        )
        .filter((I) => I !== null);
    } catch (A) {
      return (BA(A instanceof Error ? A : Error(String(A)), UG0), []);
    }
  });
});
import { join as Tb } from "path";
function p1I(A, B) {
  let Q = NA();
  try {
    let I = Q.statSync(A),
      G = Q.statSync(B);
    return I.ino === G.ino && I.dev === G.dev;
  } catch {
    return !1;
  }
}
async function o00(A, B) {
  let Q = NA(),
    I = [];
  try {
    if (!Q.existsSync(A)) return [];
    let G = Q.readdirSync(A);
    for (let Z of G) {
      if (!Z.isDirectory() && !Z.isSymbolicLink()) continue;
      let Y = Tb(A, Z.name),
        J = Tb(Y, "SKILL.md");
      if (Q.existsSync(J))
        try {
          let X = Q.readFileSync(J, { encoding: "utf-8" }),
            { frontmatter: W, content: F } = GW(X),
            C = Z.name,
            V = W.description ?? Xy(F, "Skill"),
            K = lc(W["allowed-tools"]),
            D = W["argument-hint"],
            E = W.when_to_use,
            H = W.version,
            w = W.name,
            L = W["disable-model-invocation"],
            N = L === void 0 ? !1 : V0(L),
            $ = W.model === "inherit" ? void 0 : W.model,
            O = `${V} (${o1A(B)})`;
          I.push({
            type: "prompt",
            name: C,
            description: O,
            hasUserSpecifiedDescription: !!W.description,
            allowedTools: K,
            argumentHint: D,
            whenToUse: E,
            version: H,
            model: $,
            isSkill: !0,
            disableModelInvocation: N,
            isEnabled: () => !0,
            isHidden: !0,
            progressMessage: "running",
            userFacingName() {
              return w || C;
            },
            source: B,
            async getPromptForCommand(P, k) {
              let b = `Base directory for this skill: ${Y}

${F}`;
              if (P)
                if (b.includes("$ARGUMENTS")) b = b.replaceAll("$ARGUMENTS", P);
                else
                  b =
                    b +
                    `

ARGUMENTS: ${P}`;
              return (
                (b = await cc(
                  b,
                  {
                    ...k,
                    async getAppState() {
                      let x = await k.getAppState();
                      return {
                        ...x,
                        toolPermissionContext: {
                          ...x.toolPermissionContext,
                          alwaysAllowRules: {
                            ...x.toolPermissionContext.alwaysAllowRules,
                            command: K,
                          },
                        },
                      };
                    },
                  },
                  `/${C}`,
                )),
                [{ type: "text", text: b }]
              );
            },
          });
        } catch (X) {
          BA(X instanceof Error ? X : Error(String(X)), cJ0);
        }
    }
  } catch (G) {
    BA(G instanceof Error ? G : Error(String(G)), pJ0);
  }
  return I;
}
function Js2() {
  t00.cache?.clear?.();
}
var t00;
var Xs2 = T(() => {
  a2();
  c1();
  C0();
  cwA();
  xS();
  NC();
  vB();
  m0();
  vB();
  V2();
  OQ();
  NC();
  t00 = I0(async () => {
    let A = Tb(mB(), "skills"),
      B = Tb(G0(), ".claude", "skills"),
      Q = Tb(Nw(), ".claude", "skills");
    g(`Loading skills from directories: managed=${Q}, user=${A}, project=${B}`);
    let [I, G, Z] = await Promise.all([
        o00(Q, "policySettings"),
        WH("userSettings") ? o00(A, "userSettings") : Promise.resolve([]),
        WH("projectSettings") ? o00(B, "projectSettings") : Promise.resolve([]),
      ]),
      Y = [...I, ...G, ...Z],
      J = [],
      X = new Map();
    for (let W of Y) {
      if (W.type !== "prompt") continue;
      let F =
          W.source === "policySettings"
            ? Tb(Nw(), ".claude", "skills", W.name)
            : W.source === "userSettings"
              ? Tb(mB(), "skills", W.name)
              : Tb(G0(), ".claude", "skills", W.name),
        C = Tb(F, "SKILL.md"),
        V = X.get(W.name);
      if (V && p1I(V, C)) {
        g(
          `Skipping duplicate skill '${W.name}' from ${W.source} (same file as earlier source)`,
        );
        continue;
      }
      (X.set(W.name, C), J.push(W));
    }
    if (J.length < Y.length)
      g(`Deduplicated ${Y.length - J.length} duplicate skills`);
    return (
      g(
        `Loaded ${J.length} unique skills (managed: ${I.length}, user: ${G.length}, project: ${Z.length}, duplicates removed: ${Y.length - J.length})`,
      ),
      J
    );
  });
});
async function Ws2(A) {
  let B = EB(),
    I = {
      macos: ["pbcopy"],
      linux: ["xclip -selection clipboard", "wl-copy"],
      wsl: ["clip.exe"],
      windows: ["clip"],
      unknown: ["xclip -selection clipboard", "wl-copy"],
    }[B];
  for (let G of I)
    try {
      return (await Di(G, { input: A, shell: !0, reject: !0 }), !0);
    } catch (Z) {
      BA(Error(`Failed to execute clipboard command "${G}": ${Z}`), TZ0);
      continue;
    }
  return (BA(Error(`Failed to copy to clipboard on ${B}`), PZ0), !1);
}
function Fs2() {
  let A = EB();
  return {
    macos:
      "Failed to copy to clipboard. Make sure the `pbcopy` command is available on your system and try again.",
    windows:
      "Failed to copy to clipboard. Make sure the `clip` command is available on your system and try again.",
    wsl: "Failed to copy to clipboard. Make sure the `clip.exe` command is available in your WSL environment and try again.",
    linux:
      "Failed to copy to clipboard. Make sure `xclip` or `wl-copy` is installed on your system and try again.",
    unknown:
      "Failed to copy to clipboard. Make sure `xclip` or `wl-copy` is installed on your system and try again.",
  }[A];
}
var Cs2 = T(() => {
  cYA();
  c1();
  E5();
});
import { join as l1I } from "path";
function Vs2({ content: A, defaultFilename: B, onDone: Q }) {
  let [, I] = O7.useState(null),
    [G, Z] = O7.useState(B),
    [Y, J] = O7.useState(B.length),
    [X, W] = O7.useState(!1),
    F = IB();
  return (
    h1((D, E) => {
      if (E.escape)
        if (X) (W(!1), I(null));
        else Q({ success: !1, message: "Export cancelled" });
    }),
    O7.default.createElement(
      S,
      { width: "100%", flexDirection: "column" },
      O7.default.createElement(
        S,
        {
          borderStyle: "round",
          borderColor: "permission",
          flexDirection: "column",
          padding: 1,
          width: "100%",
        },
        O7.default.createElement(
          S,
          null,
          O7.default.createElement(
            U,
            { color: "permission", bold: !0 },
            "Export Conversation",
          ),
        ),
        !X
          ? O7.default.createElement(
              O7.default.Fragment,
              null,
              O7.default.createElement(
                S,
                { marginTop: 1 },
                O7.default.createElement(
                  U,
                  { dimColor: !0 },
                  "Select export method:",
                ),
              ),
              O7.default.createElement(
                S,
                { flexDirection: "column", marginTop: 1 },
                O7.default.createElement($0, {
                  options: [
                    {
                      label: "Copy to clipboard",
                      value: "clipboard",
                      description:
                        "Copy the conversation to your system clipboard",
                    },
                    {
                      label: "Save to file",
                      value: "file",
                      description:
                        "Save the conversation to a file in the current directory",
                    },
                  ],
                  onChange: async (D) => {
                    if (D === "clipboard")
                      if (await Ws2(A))
                        Q({
                          success: !0,
                          message: "Conversation copied to clipboard",
                        });
                      else Q({ success: !1, message: Fs2() });
                    else if (D === "file") (I("file"), W(!0));
                  },
                  onCancel: () =>
                    Q({ success: !1, message: "Export cancelled" }),
                }),
              ),
            )
          : O7.default.createElement(
              S,
              { flexDirection: "column", marginTop: 1 },
              O7.default.createElement(U, null, "Enter filename:"),
              O7.default.createElement(
                S,
                { flexDirection: "row", gap: 1, marginTop: 1 },
                O7.default.createElement(U, null, ">"),
                O7.default.createElement(O4, {
                  value: G,
                  onChange: Z,
                  onSubmit: () => {
                    let D = G.endsWith(".txt")
                        ? G
                        : G.replace(/\.[^.]+$/, "") + ".txt",
                      E = l1I(G0(), D);
                    try {
                      (NA().writeFileSync(E, A, {
                        encoding: "utf-8",
                        flush: !0,
                      }),
                        Q({
                          success: !0,
                          message: `Conversation exported to: ${D}`,
                        }));
                    } catch (H) {
                      Q({
                        success: !1,
                        message: `Failed to export conversation: ${H instanceof Error ? H.message : "Unknown error"}`,
                      });
                    }
                  },
                  focus: !0,
                  showCursor: !0,
                  columns: process.stdout.columns || 80,
                  cursorOffset: Y,
                  onChangeCursorOffset: J,
                }),
              ),
            ),
      ),
      O7.default.createElement(
        S,
        { marginLeft: 2 },
        X
          ? O7.default.createElement(
              U,
              { dimColor: !0 },
              "Enter to save  Esc to go back",
            )
          : O7.default.createElement(
              O7.default.Fragment,
              null,
              F.pending
                ? O7.default.createElement(
                    U,
                    { dimColor: !0 },
                    "Press ",
                    F.keyName,
                    " again to exit",
                  )
                : O7.default.createElement(
                    U,
                    { dimColor: !0 },
                    "Esc to cancel",
                  ),
            ),
      ),
    )
  );
}
var O7;
var Ks2 = T(() => {
  nA();
  Z5();
  rG();
  R9();
  V2();
  m0();
  Cs2();
  O7 = IA(KA(), 1);
});
async function Ds2(A, B = []) {
  let I = await $7A(
    IQ1.default.createElement(
      () =>
        IQ1.default.createElement(
          H3,
          null,
          IQ1.default.createElement(Z7A, {
            messages: A,
            normalizedMessageHistory: [],
            tools: B,
            verbose: !1,
            toolJSX: null,
            toolUseConfirmQueue: [],
            inProgressToolUseIDs: new Set(),
            isMessageSelectorVisible: !1,
            conversationId: "export",
            screen: "prompt",
            screenToggleId: 0,
            streamingToolUses: [],
            showAllInTranscript: !0,
          }),
        ),
      null,
    ),
  );
  return SZ(I);
}
var IQ1;
var e00 = T(() => {
  PM();
  n01();
  C01();
  c9();
  IQ1 = IA(KA(), 1);
});
import { join as i1I } from "path";
function n1I(A) {
  let B = A.getFullYear(),
    Q = String(A.getMonth() + 1).padStart(2, "0"),
    I = String(A.getDate()).padStart(2, "0"),
    G = String(A.getHours()).padStart(2, "0"),
    Z = String(A.getMinutes()).padStart(2, "0"),
    Y = String(A.getSeconds()).padStart(2, "0");
  return `${B}-${Q}-${I}-${G}${Z}${Y}`;
}
function a1I(A) {
  let B = A.find((G) => G.type === "user");
  if (!B || B.type !== "user") return "";
  let Q = B.message?.content,
    I = "";
  if (typeof Q === "string") I = Q.trim();
  else if (Array.isArray(Q)) {
    let G = Q.find((Z) => Z.type === "text");
    if (G && "text" in G) I = G.text.trim();
  }
  if (
    ((I =
      I.split(`
`)[0] || ""),
    I.length > 50)
  )
    I = I.substring(0, 50) + "...";
  return I;
}
function s1I(A) {
  return A.toLowerCase()
    .replace(/[^a-z0-9\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
}
async function r1I(A) {
  let B = A.options.tools || [];
  return Ds2(A.messages, B);
}
var Es2, o1I, Hs2;
var zs2 = T(() => {
  Ks2();
  e00();
  V2();
  m0();
  Es2 = IA(KA(), 1);
  ((o1I = {
    type: "local-jsx",
    name: "export",
    description: "Export the current conversation to a file or clipboard",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[filename]",
    async call(A, B, Q) {
      let I = await r1I(B);
      if (Q.trim()) {
        let J = Q.trim(),
          X = J.endsWith(".txt") ? J : J.replace(/\.[^.]+$/, "") + ".txt",
          W = i1I(G0(), X);
        try {
          return (
            NA().writeFileSync(W, I, { encoding: "utf-8", flush: !0 }),
            A(`Conversation exported to: ${X}`),
            null
          );
        } catch (F) {
          return (
            A(
              `Failed to export conversation: ${F instanceof Error ? F.message : "Unknown error"}`,
            ),
            null
          );
        }
      }
      let G = a1I(B.messages),
        Z = n1I(new Date()),
        Y;
      if (G) {
        let J = s1I(G);
        Y = J ? `${Z.substring(0, 10)}-${J}.txt` : `conversation-${Z}.txt`;
      } else Y = `conversation-${Z}.txt`;
      return Es2.default.createElement(Vs2, {
        content: I,
        defaultFilename: Y,
        onDone: (J) => {
          A(J.message);
        },
      });
    },
    userFacingName() {
      return "export";
    },
  }),
    (Hs2 = o1I));
});
async function ws2(A) {
  let B = A.trim();
  if (!B) return { valid: !1, error: "Model name cannot be empty" };
  let Q = B.toLowerCase();
  if (Mn.includes(Q)) return { valid: !0 };
  if (Us2.has(B)) return { valid: !0 };
  try {
    let I = eU(B);
    return (
      await (
        await tU({ model: B, maxRetries: 0 })
      ).beta.messages.create({
        model: og(B),
        max_tokens: 1,
        messages: [
          {
            role: "user",
            content: [
              {
                type: "text",
                text: "Hi",
                cache_control: { type: "ephemeral" },
              },
            ],
          },
        ],
        system: [{ type: "text", text: ybA() }],
        metadata: nu(),
        ...(I.length > 0 ? { betas: I } : {}),
      }),
      Us2.set(B, !0),
      { valid: !0 }
    );
  } catch (I) {
    return t1I(I, B);
  }
}
function t1I(A, B) {
  if (A instanceof Sn) return { valid: !1, error: `Model '${B}' not found` };
  if (A instanceof J9) {
    if (A instanceof jn)
      return {
        valid: !1,
        error: "Authentication failed. Please check your API credentials.",
      };
    if (A instanceof SD)
      return {
        valid: !1,
        error: "Network error. Please check your internet connection.",
      };
    let I = A.error;
    if (
      I &&
      typeof I === "object" &&
      "type" in I &&
      I.type === "not_found_error" &&
      "message" in I &&
      typeof I.message === "string" &&
      I.message.includes("model:")
    )
      return { valid: !1, error: `Model '${B}' not found` };
    return { valid: !1, error: `API error: ${A.message}` };
  }
  return {
    valid: !1,
    error: `Unable to validate model: ${A instanceof Error ? A.message : String(A)}`,
  };
}
var Us2;
var $s2 = T(() => {
  P4A();
  uU1();
  zG();
  Y9();
  Jx();
  Y9();
  gP();
  Us2 = new Map();
});
var GQ1, ZQ1;
var AB0 = T(() => {
  ((GQ1 = ["help", "-h", "--help"]),
    (ZQ1 = [
      "list",
      "show",
      "display",
      "current",
      "view",
      "get",
      "check",
      "describe",
      "print",
      "version",
      "about",
      "status",
      "?",
    ]));
});
function e1I({ onDone: A }) {
  let [{ mainLoopModel: B, mainLoopModelForSession: Q }, I] = lB();
  h1((Z, Y) => {
    if (Y.escape) {
      GA("tengu_model_command_menu", { action: "cancel" });
      let J = B ?? Nn().label;
      A(`Kept model as ${iA.bold(J)}`, { display: "system" });
      return;
    }
  });
  function G(Z) {
    (GA("tengu_model_command_menu", { action: Z, from_model: B, to_model: Z }),
      I((Y) => ({ ...Y, mainLoopModel: Z, mainLoopModelForSession: null })),
      A(`Set model to ${iA.bold(bP(Z))}`));
  }
  return bR.createElement(m01, {
    initial: B,
    sessionModel: Q,
    onSelect: G,
    isStandaloneCommand: !0,
  });
}
function A0I({ args: A, onDone: B }) {
  let [Q, I] = lB(),
    G = A === "default" ? null : A;
  return (
    bR.useEffect(() => {
      async function Z() {
        if (G && Q0I(G)) {
          B(
            "Invalid model. Claude Pro users are not currently able to use Opus in Claude Code.",
            { display: "system" },
          );
          return;
        }
        if (!G) {
          Y(null);
          return;
        }
        if (B0I(G)) {
          Y(G);
          return;
        }
        try {
          let { valid: J, error: X } = await ws2(G);
          if (J) Y(G);
          else B(X || `Model '${G}' not found`, { display: "system" });
        } catch (J) {
          B(`Failed to validate model: ${J.message}`, { display: "system" });
        }
      }
      function Y(J) {
        (I((X) => ({ ...X, mainLoopModel: J, mainLoopModelForSession: null })),
          B(`Set model to ${iA.bold(bP(J))}`));
      }
      Z();
    }, [G, B, I]),
    null
  );
}
function B0I(A) {
  let B = A.toLowerCase().trim();
  if (Mn.includes(B)) return !0;
  if (B.endsWith("[1m]")) {
    let I = B.replace(/\[1m]$/i, "").trim();
    return Mn.includes(I);
  }
  return !1;
}
function Q0I(A) {
  return nB() && !xU() && A.toLowerCase().includes("opus");
}
function I0I({ onDone: A }) {
  let [{ mainLoopModel: B, mainLoopModelForSession: Q }] = lB(),
    I = B ?? Nn().label;
  if (Q)
    A(`Current model: ${iA.bold(bP(Q))} (session override from plan mode)
Base model: ${I}`);
  else A(`Current model: ${I}`);
  return null;
}
var bR, qs2;
var Ns2 = T(() => {
  hA0();
  c9();
  Y9();
  $s2();
  nA();
  H0();
  f2();
  F2();
  AB0();
  bR = IA(KA(), 1);
  qs2 = {
    type: "local-jsx",
    name: "model",
    userFacingName() {
      return "model";
    },
    description: "Set the AI model for Claude Code",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[model]",
    async call(A, B, Q) {
      if (((Q = Q?.trim() || ""), ZQ1.includes(Q)))
        return (
          GA("tengu_model_command_inline_help", { args: Q }),
          bR.createElement(I0I, { onDone: A })
        );
      if (GQ1.includes(Q)) {
        A(
          "Run /model to open the model selection menu, or /model [modelName] to set the model.",
          { display: "system" },
        );
        return;
      }
      if (Q)
        return (
          GA("tengu_model_command_inline", { args: Q }),
          bR.createElement(A0I, { args: Q, onDone: A })
        );
      return bR.createElement(e1I, { onDone: A });
    },
  };
});
function G0I({ onDone: A }) {
  let Q = N0().outputStyle ?? nF;
  h1((Z, Y) => {
    if (Y.escape) {
      (GA("tengu_output_style_command_menu", { action: "cancel" }),
        A(`Kept output style as ${iA.bold(Q)}`, { display: "system" }));
      return;
    }
  });
  function I(Z) {
    (GA("tengu_output_style_command_menu", {
      action: Z,
      from_style: Q,
      to_style: Z,
    }),
      B2("localSettings", { outputStyle: Z }),
      A(`Set output style to ${iA.bold(Z)}`));
  }
  function G() {
    A(`Kept output style as ${iA.bold(Q)}`, { display: "system" });
  }
  return Pb.createElement(c01, {
    initialStyle: Q,
    onComplete: I,
    onCancel: G,
    isStandaloneCommand: !0,
  });
}
function Z0I(A, B) {
  if (A in B) return A;
  let Q = A.toLowerCase();
  for (let I of Object.keys(B)) if (I.toLowerCase() === Q) return I;
  return null;
}
function Y0I({ args: A, onDone: B }) {
  return (
    Xt().then((Q) => {
      let I = Z0I(A, Q);
      if (!I) {
        B(`Invalid output style: ${A}`);
        return;
      }
      (B2("localSettings", { outputStyle: I }),
        B(`Set output style to ${iA.bold(I)}`));
    }),
    null
  );
}
function J0I({ onDone: A }) {
  let B = N0();
  return (A(`Current output style: ${B.outputStyle ?? nF}`), null);
}
var Pb, Ls2;
var Ms2 = T(() => {
  uA0();
  nA();
  H0();
  f2();
  OQ();
  Gy();
  AB0();
  Pb = IA(KA(), 1);
  Ls2 = {
    type: "local-jsx",
    name: "output-style",
    userFacingName() {
      return "output-style";
    },
    description: "Set the output style directly or from a selection menu",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[style]",
    async call(A, B, Q) {
      if (((Q = Q?.trim() || ""), ZQ1.includes(Q)))
        return (
          GA("tengu_output_style_command_inline_help", { args: Q }),
          Pb.createElement(J0I, { onDone: A })
        );
      if (GQ1.includes(Q)) {
        A(
          "Run /output-style to open the output style selection menu, or /output-style [styleName] to set the output style.",
          { display: "system" },
        );
        return;
      }
      if (Q)
        return (
          GA("tengu_output_style_command_inline", { args: Q }),
          Pb.createElement(Y0I, { args: Q, onDone: A })
        );
      return Pb.createElement(G0I, { onDone: A });
    },
  };
});
var BB0, X0I, Os2;
var Rs2 = T(() => {
  c1();
  F2();
  rq();
  v10();
  zFA();
  ((BB0 = IA(KA(), 1)),
    (X0I = {
      type: "local-jsx",
      name: "upgrade",
      description: "Upgrade to Max for higher rate limits and more Opus",
      isEnabled: () =>
        !process.env.DISABLE_UPGRADE_COMMAND && !mc() && i3() !== "enterprise",
      isHidden: !1,
      async call(A, B) {
        try {
          if (nB()) {
            let I = G5();
            if (I?.accessToken) {
              let G = await V2A(I.accessToken);
              if (
                G?.organization?.organization_type === "claude_max" &&
                G?.organization?.rate_limit_tier === "default_claude_max_20x"
              )
                return (
                  setTimeout(() => {
                    A(
                      "You are already on the highest Max subscription plan. For additional usage, run /login to switch to an API usage-billed account.",
                    );
                  }, 0),
                  null
                );
            }
          }
          return (
            await d7("https://claude.ai/upgrade/max"),
            BB0.createElement(x10, {
              startingMessage:
                "Starting new login following /upgrade. Exit with Ctrl-C to use existing account.",
              onDone: (I) => {
                (B.onChangeAPIKey(),
                  A(I ? "Login successful" : "Login interrupted"));
              },
            })
          );
        } catch (Q) {
          (BA(Q, jG0),
            setTimeout(() => {
              A(
                "Failed to open browser. Please visit https://claude.ai/upgrade/max to upgrade.",
              );
            }, 0));
        }
        return null;
      },
      userFacingName() {
        return "upgrade";
      },
    }),
    (Os2 = X0I));
});
var W0I, Ts2;
var Ps2 = T(() => {
  c1();
  F2();
  rq();
  ((W0I = {
    type: "local-jsx",
    name: "extra-usage",
    description: "Access and configure extra usage settings",
    isEnabled: () => {
      if (process.env.DISABLE_EXTRA_USAGE_COMMAND) return !1;
      let A = i3();
      return A === "pro" || A === "max";
    },
    isHidden: !1,
    async call(A) {
      try {
        (await d7("https://claude.ai/settings/usage"),
          A("Extra usage settings opened in your browser."));
      } catch (B) {
        (BA(B, FX0),
          A(
            "Failed to open browser. Please visit https://claude.ai/settings/usage to see your extra usage.",
          ));
      }
      return null;
    },
    userFacingName() {
      return "extra-usage";
    },
  }),
    (Ts2 = W0I));
});
var F0I, js2;
var Ss2 = T(() => {
  ((F0I = {
    type: "prompt",
    description: "Set up Claude Code's status line UI",
    aliases: [],
    isEnabled: () => !0,
    isHidden: !1,
    name: "statusline",
    progressMessage: "setting up statusLine",
    allowedTools: ["Task", "Read(~/**)", "Edit(~/.claude/settings.json)"],
    source: "builtin",
    disableNonInteractive: !0,
    async getPromptForCommand(A) {
      return [
        {
          type: "text",
          text: `Create a Task with subagent_type "statusline-setup" and the prompt "${A.trim() || "Configure my statusLine from my shell PS1 configuration"}"`,
        },
      ];
    },
    userFacingName() {
      return "statusline";
    },
  }),
    (js2 = F0I));
});
async function C0I() {
  try {
    let [A, B] = await Promise.all([
      t00().catch((Q) => {
        return (
          BA(
            Q instanceof Error
              ? Q
              : Error("Failed to load skill directory commands"),
            RZA,
          ),
          g("Skill directory commands failed to load, continuing without them"),
          []
        );
      }),
      Te1().catch((Q) => {
        return (
          BA(
            Q instanceof Error ? Q : Error("Failed to load plugin skills"),
            RZA,
          ),
          g("Plugin skills failed to load, continuing without them"),
          []
        );
      }),
    ]);
    return (
      g(
        `getSkillsIfEnabled returning: ${A.length} skill dir commands, ${B.length} plugin skills`,
      ),
      { skillDirCommands: A, pluginSkills: B }
    );
  } catch (A) {
    return (
      BA(
        A instanceof Error ? A : Error("Unexpected error loading skills"),
        RZA,
      ),
      g("Unexpected error in getSkillsIfEnabled, returning empty"),
      { skillDirCommands: [], pluginSkills: [] }
    );
  }
}
function Ea2() {
  (JE.cache?.clear?.(),
    raA.cache?.clear?.(),
    oaA.cache?.clear?.(),
    e11(),
    dj2(),
    Js2());
}
function dr(A, B) {
  return B.some(
    (Q) => Q.name === A || Q.userFacingName() === A || Q.aliases?.includes(A),
  );
}
function XR(A, B) {
  let Q = B.find(
    (I) => I.name === A || I.userFacingName() === A || I.aliases?.includes(A),
  );
  if (!Q)
    throw ReferenceError(
      `Command ${A} not found. Available commands: ${B.map((I) => {
        let G = I.userFacingName();
        return I.aliases ? `${G} (aliases: ${I.aliases.join(", ")})` : G;
      })
        .sort((I, G) => I.localeCompare(G))
        .join(", ")}`,
    );
  return Q;
}
var ys2, RS, JE, raA, taA, oaA;
var Gz = T(() => {
  YQ1();
  ah2();
  rh2();
  th2();
  Ag2();
  jg2();
  _g2();
  vg2();
  bg2();
  tg2();
  Gu2();
  Yu2();
  Du2();
  qu2();
  Lu2();
  v10();
  R11();
  sp2();
  tp2();
  hl2();
  gl2();
  ul2();
  dl2();
  ll2();
  nl2();
  tl2();
  J00();
  el2();
  Ai2();
  Qi2();
  Gi2();
  Zi2();
  Ji2();
  Wi2();
  y0A();
  Ci2();
  Ki2();
  Mi2();
  Si2();
  Wn2();
  Cn2();
  Fa2();
  ga2();
  ma2();
  da2();
  ca2();
  pa2();
  la2();
  Bs2();
  Is2();
  c1();
  C0();
  Ys2();
  Xs2();
  lwA();
  a2();
  F2();
  ge1();
  zs2();
  Ns2();
  Ms2();
  Rs2();
  Ps2();
  Ss2();
  ((ys2 = I0(() => [
    ks2,
    Wa2,
    oh2,
    eh2,
    Pg2,
    kg2,
    xg2,
    og2,
    D01,
    Fn2,
    Ku2,
    $u2,
    Nu2,
    ap2,
    fl2,
    Zu2,
    op2,
    qs2,
    Ls2,
    ha2,
    ml2,
    pl2,
    il2,
    ol2,
    Bi2,
    js2,
    Qs2,
    Yi2,
    sh2,
    _B1,
    ua2,
    Xi2,
    ch,
    Os2,
    Ts2,
    Fi2,
    Vi2,
    Li2,
    ji2,
    Xn2,
    Hs2,
    As2,
    ...(!mc() ? [yR2, Kp2()] : []),
    Ii2,
    ...[],
  ])),
    (RS = I0(() => new Set(ys2().map((A) => A.name)))));
  JE = I0(async () => {
    let [A, { skillDirCommands: B, pluginSkills: Q }, I] = await Promise.all([
      Zs2(),
      C0I(),
      oo(),
    ]);
    return [...A, ...B, ...I, ...Q, ...ys2()].filter((G) => G.isEnabled());
  });
  ((raA = I0(async () => {
    return (await JE()).filter(
      (B) =>
        B.type === "prompt" &&
        B.isSkill === !0 &&
        !B.disableModelInvocation &&
        B.source !== "builtin" &&
        (B.hasUserSpecifiedDescription || B.whenToUse),
    );
  })),
    (taA = I0(async () => {
      return (await JE()).filter(
        (B) =>
          B.type === "prompt" &&
          B.isSkill !== !0 &&
          !B.disableModelInvocation &&
          B.source !== "builtin" &&
          (B.hasUserSpecifiedDescription || B.whenToUse),
      );
    })),
    (oaA = I0(async () => {
      try {
        return (await JE()).filter(
          (B) =>
            B.type === "prompt" &&
            B.source !== "builtin" &&
            (B.hasUserSpecifiedDescription || B.whenToUse) &&
            (B.isSkill || B.disableModelInvocation),
        );
      } catch (A) {
        return (
          BA(
            A instanceof Error
              ? A
              : Error("Failed to load slash command skills"),
            RZA,
          ),
          g("Returning empty skills array due to load failure"),
          []
        );
      }
    })));
});
function V0I() {
  let A = new Date(),
    B = A.getFullYear(),
    Q = String(A.getMonth() + 1).padStart(2, "0"),
    I = String(A.getDate()).padStart(2, "0");
  return `${B}-${Q}-${I}`;
}
function K0I(A) {
  if (!A) return "";
  let B = P7A(A);
  if (B.length === 0) return "";
  return `
You can use the following tools without requiring user approval: ${B.map((I) => H5(I.ruleValue)).join(", ")}
`;
}
async function Dd(A, B, Q, I, G) {
  let [Z, Y, J] = await Promise.all([taA(), bs2(), vs2(B, Q)]),
    X = new Set(A.map((V) => V.name)),
    W = Z.map((V) => `/${V.userFacingName()}`),
    F = Zz,
    C =
      W.length > 0 && X.has(F)
        ? `- A custom slash command is a user-defined operation that starts with /, like /commit. When executed, the slash command gets expanded to a full prompt. Use the ${F} tool to execute them. IMPORTANT: Only use ${F} for commands listed in its Available Commands section - do not guess or use built-in CLI commands.`
        : "";
  return [
    `
You are an interactive CLI tool that helps users ${Y !== null ? 'according to your "Output Style" below, which describes how you should respond to user queries.' : "with software engineering tasks."} Use the instructions below and the tools available to you to assist the user.

${_s2}
IMPORTANT: You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.

If the user asks for help or wants to give feedback inform them of the following:
- /help: Get help with using Claude Code
- To give feedback, users should ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.ISSUES_EXPLAINER}

When the user directly asks about Claude Code (eg. "can Claude Code do...", "does Claude Code have..."), or asks in second person (eg. "are you able...", "can you do..."), or asks how to use a specific Claude Code feature (eg. implement a hook, write a slash command, or install an MCP server), use the ${_C} tool to gather information to answer the question from Claude Code docs. The list of available docs is available at ${D0I}.

${
  Y !== null
    ? ""
    : `# Tone and style
- Only use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.
- Your output will be displayed on a command line interface. Your responses should be short and concise. You can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.
- Output text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like ${E4} or code comments as means to communicate with the user during the session.
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one. This includes markdown files.

# Professional objectivity
Prioritize technical accuracy and truthfulness over validating the user's beliefs. Focus on facts and problem-solving, providing direct, objective technical info without any unnecessary superlatives, praise, or emotional validation. It is best for the user if Claude honestly applies the same rigorous standards to all ideas and disagrees when necessary, even if it may not be what the user wants to hear. Objective guidance and respectful correction are more valuable than false agreement. Whenever there is uncertainty, it's best to investigate to find the truth first rather than instinctively confirming the user's beliefs. Avoid using over-the-top validation or excessive praise when responding to users such as "You're absolutely right" or similar phrases.
`
}
${
  X.has(oG.name)
    ? `# Task Management
You have access to the ${oG.name} tools to help you manage and plan tasks. Use these tools VERY frequently to ensure that you are tracking your tasks and giving the user visibility into your progress.
These tools are also EXTREMELY helpful for planning tasks, and for breaking down larger complex tasks into smaller steps. If you do not use this tool when planning, you may forget to do important tasks - and that is unacceptable.

It is critical that you mark todos as completed as soon as you are done with a task. Do not batch up multiple tasks before marking them as completed.

Examples:

<example>
user: Run the build and fix any type errors
assistant: I'm going to use the ${oG.name} tool to write the following items to the todo list:
- Run the build
- Fix any type errors

I'm now going to run the build using ${E4}.

Looks like I found 10 type errors. I'm going to use the ${oG.name} tool to write 10 items to the todo list.

marking the first todo as in_progress

Let me start working on the first item...

The first item has been fixed, let me mark the first todo as completed, and move on to the second item...
..
..
</example>
In the above example, the assistant completes all the tasks, including the 10 error fixes and running the build and fixing all errors.

<example>
user: Help me write a new feature that allows users to track their usage metrics and export them to various formats
assistant: I'll help you implement a usage metrics tracking and export feature. Let me first use the ${oG.name} tool to plan this task.
Adding the following todos to the todo list:
1. Research existing metrics tracking in the codebase
2. Design the metrics collection system
3. Implement core metrics tracking functionality
4. Create export functionality for different formats

Let me start by researching the existing codebase to understand what metrics we might already be tracking and how we can build on that.

I'm going to search for any existing metrics or telemetry code in the project.

I've found some existing telemetry code. Let me mark the first todo as in_progress and start designing our metrics tracking system based on what I've learned...

[Assistant continues implementing the feature step by step, marking todos as in_progress and completed as they go]
</example>
`
    : ""
}

${
  X.has(YE)
    ? `
# Asking questions as you work

You have access to the ${YE} tool to ask the user questions when you need clarification, want to validate assumptions, or need to make a decision you're unsure about.
`
    : ""
}

Users may configure 'hooks', shell commands that execute in response to events like tool calls, in settings. Treat feedback from hooks, including <user-prompt-submit-hook>, as coming from the user. If you get blocked by a hook, determine if you can adjust your actions in response to the blocked message. If not, ask the user to check their hooks configuration.

${
  Y === null || Y.keepCodingInstructions === !0
    ? `# Doing tasks
The user will primarily request you perform software engineering tasks. This includes solving bugs, adding new functionality, refactoring code, explaining code, and more. For these tasks the following steps are recommended:
- ${X.has(oG.name) ? `Use the ${oG.name} tool to plan the task if required` : ""}
- ${X.has(YE) ? `Use the ${YE} tool to ask questions, clarify and gather information as needed.` : ""}
- Be careful not to introduce security vulnerabilities such as command injection, XSS, SQL injection, and other OWASP top 10 vulnerabilities. If you notice that you wrote insecure code, immediately fix it.
`
    : ""
}
- Tool results and user messages may include <system-reminder> tags. <system-reminder> tags contain useful information and reminders. They are automatically added by the system, and bear no direct relation to the specific tool results or user messages in which they appear.


# Tool usage policy${
      X.has(x8)
        ? `
- When doing file search, prefer to use the ${x8} tool in order to reduce context usage.
- You should proactively use the ${x8} tool with specialized agents when the task at hand matches the agent's description.
${C}`
        : ""
    }${
      X.has(_C)
        ? `
- When ${_C} returns a message about a redirect to a different host, you should immediately make a new ${_C} request with the redirect URL provided in the response.`
        : ""
    }
- You can call multiple tools in a single response. If you intend to call multiple tools and there are no dependencies between them, make all independent tool calls in parallel. Maximize use of parallel tool calls where possible to increase efficiency. However, if some tool calls depend on previous calls to inform dependent values, do NOT call these tools in parallel and instead call them sequentially. For instance, if one operation must complete before another starts, run these operations sequentially instead. Never use placeholders or guess missing parameters in tool calls.
- If the user specifies that they want you to run tools "in parallel", you MUST send a single message with multiple tool use content blocks. For example, if you need to launch multiple agents in parallel, send a single message with multiple ${x8} tool calls.
- Use specialized tools instead of bash commands when possible, as this provides a better user experience. For file operations, use dedicated tools: ${z3} for reading files instead of cat/head/tail, ${g5} for editing instead of sed/awk, and ${WF} for creating files instead of cat with heredoc or echo redirection. Reserve bash tools exclusively for actual system commands and terminal operations that require shell execution. NEVER use bash echo or other command-line tools to communicate thoughts, explanations, or instructions to the user. Output all communication directly in your response text instead.
- VERY IMPORTANT: When exploring the codebase to gather context or to answer a question that is not a needle query for a specific file/class/function, it is CRITICAL that you use the ${x8} tool with subagent_type=${eK.agentType} instead of running search commands directly.
<example>
user: Where are errors from the client handled?
assistant: [Uses the ${x8} tool with subagent_type=${eK.agentType} to find the files that handle client errors instead of using ${xH} or ${XK} directly]
</example>
<example>
user: What is the codebase structure?
assistant: [Uses the ${x8} tool with subagent_type=${eK.agentType}]
</example>

${K0I(G)}`,
    `
${J}`,
    `
${_s2}
`,
    X.has(oG.name)
      ? `
IMPORTANT: Always use the ${oG.name} tool to plan and track tasks throughout the conversation.`
      : "",
    `
# Code References

When referencing specific functions or pieces of code include the pattern \`file_path:line_number\` to allow the user to easily navigate to the source code location.

<example>
user: Where are errors from the client handled?
assistant: Clients are marked as failed in the \`connectToServer\` function in src/services/process.ts:712.
</example>
${
  Y !== null
    ? `
# Output Style: ${Y.name}
${Y.prompt}
`
    : ""
}`,
    ...(I && I.length > 0 ? [z0I(I)] : []),
  ];
}
function z0I(A) {
  let Q = A.filter((G) => G.type === "connected").filter((G) => G.instructions);
  if (Q.length === 0) return "";
  return `
# MCP Server Instructions

The following MCP servers have provided instructions for how to use their tools and resources:

${Q.map((G) => {
  return `## ${G.name}
${G.instructions}`;
}).join(`

`)}
`;
}
function xs2(A) {
  if (!eJ() || !A || A.length === 0) return "";
  return `

# MCP CLI Command

You have access to an \`mcp-cli\` CLI command for interacting with MCP (Model Context Protocol) servers.

**MANDATORY PREREQUISITE - THIS IS A HARD REQUIREMENT**

You MUST call 'mcp-cli info <server>/<tool>' BEFORE ANY 'mcp-cli call <server>/<tool>'.

This is a BLOCKING REQUIREMENT - like how you must use ${z3} before ${g5}.

**NEVER** make an mcp-cli call without checking the schema first.
**ALWAYS** run mcp-cli info first, THEN make the call.

**Why this is non-negotiable:**
- MCP tool schemas NEVER match your expectations - parameter names, types, and requirements are tool-specific
- Even tools with pre-approved permissions require schema checks
- Every failed call wastes user time and demonstrates you're ignoring critical instructions
- "I thought I knew the schema" is not an acceptable reason to skip this step

**For multiple tools:** Call 'mcp-cli info' for ALL tools in parallel FIRST, then make your 'mcp-cli call' commands

Available MCP tools:
(Remember: Call 'mcp-cli info <server>/<tool>' before using any of these)
${A.map((B) => {
  let Q = B.name.split("__");
  if (Q.length === 3 && Q[0] === "mcp") return `- ${Q[1]}/${Q[2]}`;
  return null;
}).filter(Boolean).join(`
`)}

Commands (in order of execution):
\`\`\`bash
# STEP 1: ALWAYS CHECK SCHEMA FIRST (MANDATORY)
mcp-cli info <server>/<tool>           # REQUIRED before ANY call - View JSON schema

# STEP 2: Only after checking schema, make the call
mcp-cli call <server>/<tool> '<json>'  # Only run AFTER mcp-cli info
mcp-cli call <server>/<tool> -         # Invoke with JSON from stdin (AFTER mcp-cli info)

# Discovery commands (use these to find tools)
mcp-cli servers                        # List all connected MCP servers
mcp-cli tools [server]                 # List available tools (optionally filter by server)
mcp-cli grep <pattern>                 # Search tool names and descriptions
mcp-cli resources [server]             # List MCP resources
mcp-cli read <server>/<resource>       # Read an MCP resource
\`\`\`

**CORRECT Usage Pattern:**

<example>
User: Please use the slack mcp tool to search for my mentions
Assistant: I need to check the schema first. Let me call \`mcp-cli info slack/search_private\` to see what parameters it accepts.
[Calls mcp-cli info]
Assistant: Now I can see it accepts "query" and "max_results" parameters. Let me make the call.
[Calls mcp-cli call slack/search_private with correct schema]
</example>

<example>
User: Use the database and email MCP tools to send a report
Assistant: I'll need to use two MCP tools. Let me check both schemas first.
[Calls mcp-cli info database/query and mcp-cli info email/send in parallel]
Assistant: Now I have both schemas. Let me execute the calls.
[Makes both mcp-cli call commands with correct parameters]
</example>

**INCORRECT Usage Patterns - NEVER DO THIS:**

<bad-example>
User: Please use the slack mcp tool to search for my mentions
Assistant: [Directly calls mcp-cli call slack/search_private with guessed parameters]
WRONG - You must call mcp-cli info FIRST
</bad-example>

<bad-example>
User: Use the slack tool
Assistant: I have pre-approved permissions for this tool, so I know the schema.
[Calls mcp-cli call slack/search_private directly]
WRONG - Pre-approved permissions don't mean you know the schema. ALWAYS call mcp-cli info first.
</bad-example>

<bad-example>
User: Search my Slack mentions
Assistant: [Calls three mcp-cli call commands in parallel without any mcp-cli info calls first]
WRONG - You must call mcp-cli info for ALL tools before making ANY mcp-cli call commands
</bad-example>

Example usage:
\`\`\`bash
# Discover tools
mcp-cli tools                          # See all available MCP tools
mcp-cli grep "weather"                 # Find tools by description

# Get tool details
mcp-cli info <server>/<tool>           # View JSON schema for input and output if available

# Simple tool call (no parameters)
mcp-cli call weather/get_location '{}'

# Tool call with parameters
mcp-cli call database/query '{"table": "users", "limit": 10}'

# Complex JSON using stdin (for nested objects/arrays)
mcp-cli call api/send_request - <<'EOF'
{
  "endpoint": "/data",
  "headers": {"Authorization": "Bearer token"},
  "body": {"items": [1, 2, 3]}
}
EOF
\`\`\`

Use this command via ${E4} when you need to discover, inspect, or invoke MCP tools.

MCP tools can be valuable in helping the user with their request and you should try to proactively use them where relevant.
`;
}
async function vs2(A, B) {
  let [Q, I] = await Promise.all([QO(), U0I()]),
    G = ub0(A),
    Z = G
      ? `You are powered by the model named ${G}. The exact model ID is ${A}.`
      : `You are powered by the model ${A}.`,
    Y =
      B && B.length > 0
        ? `Additional working directories: ${B.join(", ")}
`
        : "",
    J =
      A.includes("claude-opus-4") ||
      A.includes("claude-sonnet-4-5") ||
      A.includes("claude-sonnet-4")
        ? `

Assistant knowledge cutoff is January 2025.`
        : "",
    X = `

<claude_background_info>
The most recent frontier Claude model is ${E0I} (model ID: '${H0I}').
</claude_background_info>`;
  return `Here is useful information about the environment you are running in:
<env>
Working directory: ${G0()}
Is directory a git repo: ${Q ? "Yes" : "No"}
${Y}Platform: ${O0.platform}
OS Version: ${I}
Today's date: ${V0I()}
</env>
${Z}${J}${X}
`;
}
async function U0I() {
  try {
    let { stdout: A } = await r0("uname", ["-sr"], {
      preserveOutputOnError: !1,
    });
    return A.trim();
  } catch {
    return "unknown";
  }
}
async function Vf2(A, B, Q) {
  let G = `
${await vs2(B, Q)}`;
  return [
    ...A,
    `

Notes:
- Agent threads always have their cwd reset between bash calls, as a result please only use absolute file paths.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication with the user the assistant MUST avoid using emojis.`,
    G,
  ];
}
var _s2 =
    "IMPORTANT: Assist with authorized security testing, defensive security, CTF challenges, and educational contexts. Refuse requests for destructive techniques, DoS attacks, mass targeting, supply chain compromise, or detection evasion for malicious purposes. Dual-use security tools (C2 frameworks, credential testing, exploit development) require clear authorization context: pentesting engagements, CTF competitions, security research, or defensive use cases.",
  D0I = "https://code.claude.com/docs/en/claude_code_docs_map.md",
  E0I = "Claude Sonnet 4.5",
  H0I = "claude-sonnet-4-5-20250929",
  Cf2 =
    "You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup.";
var Qr = T(() => {
  C6();
  vC();
  V2();
  R_();
  WK();
  vn();
  Q5();
  vJA();
  Gz();
  ez();
  f3();
  Gy();
  iB();
  Bu();
  S7A();
});
function w0I(A, B) {
  return (
    (B.input_tokens / 1e6) * A.inputTokens +
    (B.output_tokens / 1e6) * A.outputTokens +
    ((B.cache_read_input_tokens ?? 0) / 1e6) * A.promptCacheReadTokens +
    ((B.cache_creation_input_tokens ?? 0) / 1e6) * A.promptCacheWriteTokens +
    (B.server_tool_use?.web_search_requests ?? 0) * A.webSearchRequests
  );
}
function $0I(A) {
  return (
    A.input_tokens +
    (A.cache_read_input_tokens ?? 0) +
    (A.cache_creation_input_tokens ?? 0)
  );
}
function q0I(A, B) {
  let Q = qq(A),
    I = hs2[Q];
  if (I === JQ1 && $0I(B) > 200000)
    return {
      inputTokens: 6,
      outputTokens: 22.5,
      promptCacheWriteTokens: 7.5,
      promptCacheReadTokens: 0.6,
      webSearchRequests: 0.01,
    };
  if (!I)
    return (
      GA("tengu_unknown_model_cost", { model: A, shortName: Q }),
      S91(),
      hs2[qq(CzB)]
    );
  return I;
}
function XQ1(A, B) {
  let Q = q0I(A, B);
  return w0I(Q, B);
}
var JQ1, fs2, hs2;
var QB0 = T(() => {
  ux();
  H0();
  vJA();
  Y9();
  ((JQ1 = {
    inputTokens: 3,
    outputTokens: 15,
    promptCacheWriteTokens: 3.75,
    promptCacheReadTokens: 0.3,
    webSearchRequests: 0.01,
  }),
    (fs2 = {
      inputTokens: 15,
      outputTokens: 75,
      promptCacheWriteTokens: 18.75,
      promptCacheReadTokens: 1.5,
      webSearchRequests: 0.01,
    }),
    (hs2 = {
      [qq(yJA.firstParty)]: {
        inputTokens: 0.8,
        outputTokens: 4,
        promptCacheWriteTokens: 1,
        promptCacheReadTokens: 0.08,
        webSearchRequests: 0.01,
      },
      [qq(kJA.firstParty)]: {
        inputTokens: 1,
        outputTokens: 5,
        promptCacheWriteTokens: 1.25,
        promptCacheReadTokens: 0.1,
        webSearchRequests: 0.01,
      },
      [qq(SJA.firstParty)]: JQ1,
      [qq(jJA.firstParty)]: JQ1,
      [qq(Pi.firstParty)]: JQ1,
      [qq(_JA.firstParty)]: fs2,
      [qq(xJA.firstParty)]: fs2,
      ...{},
    }));
});
import { createHash as N0I } from "crypto";
import { dirname as gs2, join as L0I } from "path";
import * as ds2 from "path";
function cs2() {
  return !1;
}
async function IB0(A, B) {
  if (!cs2()) return await B();
  let Q = D7(
      A.filter((Y) => {
        if (Y.type !== "user") return !0;
        if (Y.isMeta) return !1;
        return !0;
      }),
    ),
    I = O0I(
      Q.map((Y) => Y.message.content),
      ms2,
    ),
    G = L0I(
      process.env.CLAUDE_CODE_TEST_FIXTURES_ROOT ?? G0(),
      `fixtures/${I.map((Y) => N0I("sha1").update(JSON.stringify(Y)).digest("hex").slice(0, 6)).join("-")}.json`,
    );
  if (NA().existsSync(G)) {
    let Y = JSON.parse(NA().readFileSync(G, { encoding: "utf8" }));
    return (Y.output.forEach(M0I), Y.output.map((J, X) => us2(J, T0I, X)));
  }
  if (O0.isCI)
    throw Error(`Anthropic API fixture missing: ${G}. Re-run npm test locally, then commit the result. Input messages:
${JSON.stringify(I, null, 2)}`);
  let Z = await B();
  if (O0.isCI) return Z;
  if (!NA().existsSync(gs2(G))) NA().mkdirSync(gs2(G));
  return (
    NA().writeFileSync(
      G,
      JSON.stringify(
        { input: I, output: Z.map((Y, J) => us2(Y, ms2, J)) },
        null,
        2,
      ),
      { encoding: "utf8", flush: !1 },
    ),
    Z
  );
}
function M0I(A) {
  if (A.type === "stream_event") return;
  let B = A.message.model,
    Q = A.message.usage,
    I = XQ1(B, Q);
  biA(I, Q, B);
}
function O0I(A, B) {
  return A.map((Q) => {
    if (typeof Q === "string") return B(Q);
    return Q.map((I) => {
      switch (I.type) {
        case "tool_result":
          if (typeof I.content === "string")
            return { ...I, content: B(I.content) };
          if (Array.isArray(I.content))
            return {
              ...I,
              content: I.content.map((G) => {
                switch (G.type) {
                  case "text":
                    return { ...G, text: B(G.text) };
                  case "image":
                    return G;
                  default:
                    return;
                }
              }),
            };
          return I;
        case "text":
          return { ...I, text: B(I.text) };
        case "tool_use":
          return { ...I, input: WQ1(I.input, B) };
        case "image":
          return I;
        default:
          return;
      }
    });
  });
}
function WQ1(A, B) {
  return Yr(A, (Q, I) => {
    if (Array.isArray(Q)) return Q.map((G) => WQ1(G, B));
    if (r1A(Q)) return WQ1(Q, B);
    return B(Q, I, A);
  });
}
function R0I(A, B, Q) {
  return {
    uuid: `UUID-${Q}`,
    requestId: "REQUEST_ID",
    timestamp: A.timestamp,
    message: {
      ...A.message,
      content: A.message.content
        .map((I) => {
          switch (I.type) {
            case "text":
              return { ...I, text: B(I.text), citations: I.citations || [] };
            case "tool_use":
              return { ...I, input: WQ1(I.input, B) };
            default:
              return I;
          }
        })
        .filter(Boolean),
    },
    type: "assistant",
  };
}
function us2(A, B, Q) {
  if (A.type === "assistant") return R0I(A, B, Q);
  else return A;
}
function ms2(A) {
  if (typeof A !== "string") return A;
  let B = A.replace(/num_files="\d+"/g, 'num_files="[NUM]"')
    .replace(/duration_ms="\d+"/g, 'duration_ms="[DURATION]"')
    .replace(/cost_usd="\d+"/g, 'cost_usd="[COST]"')
    .replace(/\//g, ds2.sep)
    .replaceAll(G0(), "[CWD]")
    .replace(/Available commands:.+/, "Available commands: [COMMANDS]");
  if (B.includes("Files modified by user:"))
    return "Files modified by user: [FILES]";
  return B;
}
function T0I(A) {
  if (typeof A !== "string") return A;
  return A.replaceAll("[NUM]", "1")
    .replaceAll("[DURATION]", "100")
    .replaceAll("[CWD]", G0());
}
async function* GB0(A, B) {
  if (!cs2()) return yield* B();
  let Q = [],
    I = await IB0(A, async () => {
      for await (let G of B()) Q.push(G);
      return Q;
    });
  if (I.length > 0) {
    yield* I;
    return;
  }
  yield* Q;
}
var ps2 = T(() => {
  C6();
  V2();
  m0();
  VTA();
  FsA();
  iB();
  QB0();
  ux();
});
function ZB0(A) {
  let B = new Set();
  A.forEach((Q, I) => B.add(I));
  for (let [Q, I] of Object.entries(P0I))
    if (I.prefixes?.some((G) => Array.from(B).some((Z) => Z.startsWith(G))))
      return Q;
  return;
}
function YB0() {
  return {
    ...(process.env.ANTHROPIC_BASE_URL
      ? { baseUrl: process.env.ANTHROPIC_BASE_URL }
      : {}),
    ...(process.env.ANTHROPIC_MODEL
      ? { envModel: process.env.ANTHROPIC_MODEL }
      : {}),
    ...(process.env.ANTHROPIC_SMALL_FAST_MODEL
      ? { envSmallFastModel: process.env.ANTHROPIC_SMALL_FAST_MODEL }
      : {}),
  };
}
function ls2({
  model: A,
  messagesLength: B,
  temperature: Q,
  betas: I,
  permissionMode: G,
  querySource: Z,
  queryTracking: Y,
}) {
  GA("tengu_api_query", {
    model: A,
    messagesLength: B,
    temperature: Q,
    provider: xM(),
    ...(I?.length ? { betas: I.join(",") } : {}),
    permissionMode: G,
    querySource: Z,
    ...(Y ? { queryChainId: Y.chainId, queryDepth: Y.depth } : {}),
    ...YB0(),
  });
}
function is2({
  error: A,
  model: B,
  messageCount: Q,
  messageTokens: I,
  durationMs: G,
  durationMsIncludingRetries: Z,
  attempt: Y,
  requestId: J,
  didFallBackToNonStreaming: X,
  promptCategory: W,
  headers: F,
  queryTracking: C,
}) {
  let V = void 0;
  if (A instanceof J9 && A.headers) V = ZB0(A.headers);
  else if (F) V = ZB0(F);
  let K = A instanceof Error ? A.message : String(A),
    D = A instanceof J9 ? String(A.status) : void 0,
    E = e0Q(A);
  (BA(A, VY0),
    GA("tengu_api_error", {
      model: B,
      error: K,
      status: D,
      errorType: E,
      messageCount: Q,
      messageTokens: I,
      durationMs: G,
      durationMsIncludingRetries: Z,
      attempt: Y,
      provider: xM(),
      requestId: J || void 0,
      didFallBackToNonStreaming: X,
      ...(W ? { promptCategory: W } : {}),
      ...(V ? { gateway: V } : {}),
      ...(C ? { queryChainId: C.chainId, queryDepth: C.depth } : {}),
      ...YB0(),
    }),
    _N("api_error", {
      model: B,
      error: K,
      status_code: String(D),
      duration_ms: String(G),
      attempt: String(Y),
    }),
    ng1({
      success: !1,
      statusCode: D ? parseInt(D) : void 0,
      error: K,
      attempt: Y,
    }));
}
function j0I({
  model: A,
  preNormalizedModel: B,
  messageCount: Q,
  messageTokens: I,
  usage: G,
  durationMs: Z,
  durationMsIncludingRetries: Y,
  attempt: J,
  ttftMs: X,
  requestId: W,
  stopReason: F,
  costUSD: C,
  didFallBackToNonStreaming: V,
  querySource: K,
  gateway: D,
  queryTracking: E,
}) {
  let H = K5(),
    w = process.argv.includes("-p") || process.argv.includes("--print");
  GA("tengu_api_success", {
    model: A,
    ...(B !== A ? { preNormalizedModel: B } : {}),
    messageCount: Q,
    messageTokens: I,
    inputTokens: G.input_tokens,
    outputTokens: G.output_tokens,
    cachedInputTokens: G.cache_read_input_tokens ?? 0,
    uncachedInputTokens: G.cache_creation_input_tokens ?? 0,
    durationMs: Z,
    durationMsIncludingRetries: Y,
    attempt: J,
    ttftMs: X ?? void 0,
    provider: xM(),
    requestId: W ?? void 0,
    stop_reason: F ?? void 0,
    costUSD: C,
    didFallBackToNonStreaming: V,
    isNonInteractiveSession: H,
    print: w,
    isTTY: process.stdout.isTTY ?? !1,
    querySource: K,
    ...(D ? { gateway: D } : {}),
    ...(E ? { queryChainId: E.chainId, queryDepth: E.depth } : {}),
    ...YB0(),
  });
}
function ns2({
  model: A,
  preNormalizedModel: B,
  start: Q,
  startIncludingRetries: I,
  ttftMs: G,
  usage: Z,
  attempt: Y,
  messageCount: J,
  messageTokens: X,
  requestId: W,
  stopReason: F,
  didFallBackToNonStreaming: C,
  querySource: V,
  headers: K,
  costUSD: D,
  queryTracking: E,
}) {
  let H = K ? ZB0(K) : void 0,
    w = Date.now() - Q,
    L = Date.now() - I;
  (o40(L, w),
    j0I({
      model: A,
      preNormalizedModel: B,
      messageCount: J,
      messageTokens: X,
      usage: Z,
      durationMs: w,
      durationMsIncludingRetries: L,
      attempt: Y,
      ttftMs: G,
      requestId: W,
      stopReason: F,
      costUSD: D,
      didFallBackToNonStreaming: C,
      querySource: V,
      gateway: H,
      queryTracking: E,
    }),
    _N("api_request", {
      model: A,
      input_tokens: String(Z.input_tokens),
      output_tokens: String(Z.output_tokens),
      cache_read_tokens: String(Z.cache_read_input_tokens),
      cache_creation_tokens: String(Z.cache_creation_input_tokens),
      cost_usd: String(D),
      duration_ms: String(w),
    }),
    ng1({
      success: !0,
      inputTokens: Z.input_tokens,
      outputTokens: Z.output_tokens,
      cacheReadTokens: Z.cache_read_input_tokens,
      cacheCreationTokens: Z.cache_creation_input_tokens,
      attempt: Y,
    }));
}
var P0I, $y;
var FQ1 = T(() => {
  gP();
  c1();
  EH();
  H0();
  I5A();
  ss();
  i0();
  sq();
  P0I = {
    litellm: { prefixes: ["x-litellm-"] },
    helicone: { prefixes: ["helicone-"] },
    portkey: { prefixes: ["x-portkey-"] },
    "cloudflare-ai-gateway": { prefixes: ["cf-aig-"] },
  };
  $y = {
    input_tokens: 0,
    cache_creation_input_tokens: 0,
    cache_read_input_tokens: 0,
    output_tokens: 0,
    server_tool_use: { web_search_requests: 0, web_fetch_requests: 0 },
    service_tier: "standard",
    cache_creation: {
      ephemeral_1h_input_tokens: 0,
      ephemeral_5m_input_tokens: 0,
    },
  };
});
import { randomUUID as as2 } from "crypto";
function nlA(A) {
  let B = {},
    Q = process.env.CLAUDE_CODE_EXTRA_BODY,
    I = {};
  if (Q)
    try {
      let Z = b3(Q);
      if (Z && typeof Z === "object" && !Array.isArray(Z)) I = Z;
      else
        g(
          `CLAUDE_CODE_EXTRA_BODY env var must be a JSON object, but was given ${Q}`,
          { level: "error" },
        );
    } catch (Z) {
      g(
        `Error parsing CLAUDE_CODE_EXTRA_BODY: ${Z instanceof Error ? Z.message : String(Z)}`,
        { level: "error" },
      );
    }
  let G = { ...B, ...I };
  if (A && A.length > 0)
    if (G.anthropic_beta && Array.isArray(G.anthropic_beta)) {
      let Z = G.anthropic_beta,
        Y = A.filter((J) => !Z.includes(J));
      G.anthropic_beta = [...Z, ...Y];
    } else G.anthropic_beta = A;
  return G;
}
function ss2(A) {
  if (V0(process.env.DISABLE_PROMPT_CACHING)) return !1;
  if (V0(process.env.DISABLE_PROMPT_CACHING_HAIKU)) {
    let B = FW();
    if (A === B) return !1;
  }
  if (V0(process.env.DISABLE_PROMPT_CACHING_SONNET)) {
    let B = $q();
    if (A === B) return !1;
  }
  if (V0(process.env.DISABLE_PROMPT_CACHING_OPUS)) {
    let B = tvA();
    if (A === B) return !1;
  }
  return !0;
}
function d$A() {
  return _7("prompt_cache_1h_experiment", "use_1h_cache", !1)
    ? { type: "ephemeral", ttl: "1h" }
    : { type: "ephemeral" };
}
function nu() {
  let A = Id(),
    B = HG()?.accountUuid ?? "",
    Q = L0();
  return { user_id: `user_${A}_account_${B}_session_${Q}` };
}
async function gP2(A, B) {
  if (B) return !0;
  try {
    let Q = FW(),
      I = eU(Q);
    return await RdQ(
      JaA(
        () => tU({ apiKey: A, maxRetries: 3, model: Q }),
        async (G) => {
          let Z = [{ role: "user", content: "test" }];
          return (
            await G.beta.messages.create({
              model: Q,
              max_tokens: 1,
              messages: Z,
              temperature: 1,
              ...(I.length > 0 ? { betas: I } : {}),
              metadata: nu(),
              ...nlA(),
            }),
            !0
          );
        },
        { maxRetries: 2, model: Q },
      ),
    );
  } catch (Q) {
    let I = Q;
    if (Q instanceof Bd) I = Q.originalError;
    if (
      (BA(I, zZ0),
      I instanceof Error &&
        I.message.includes(
          '{"type":"error","error":{"type":"authentication_error","message":"invalid x-api-key"}}',
        ))
    )
      return !1;
    throw I;
  }
}
function S0I(A, B = !1, Q) {
  if (B)
    if (typeof A.message.content === "string")
      return {
        role: "user",
        content: [
          {
            type: "text",
            text: A.message.content,
            ...(Q ? { cache_control: d$A() } : {}),
          },
        ],
      };
    else
      return {
        role: "user",
        content: A.message.content.map((I, G) => ({
          ...I,
          ...(G === A.message.content.length - 1
            ? Q
              ? { cache_control: d$A() }
              : {}
            : {}),
        })),
      };
  return { role: "user", content: A.message.content };
}
function y0I(A, B = !1, Q) {
  if (B)
    if (typeof A.message.content === "string")
      return {
        role: "assistant",
        content: [
          {
            type: "text",
            text: A.message.content,
            ...(Q ? { cache_control: d$A() } : {}),
          },
        ],
      };
    else
      return {
        role: "assistant",
        content: A.message.content.map((I, G) => ({
          ...I,
          ...(G === A.message.content.length - 1 &&
          I.type !== "thinking" &&
          I.type !== "redacted_thinking"
            ? Q
              ? { cache_control: d$A() }
              : {}
            : {}),
        })),
      };
  return { role: "assistant", content: A.message.content };
}
async function YS({
  messages: A,
  systemPrompt: B,
  maxThinkingTokens: Q,
  tools: I,
  signal: G,
  options: Z,
}) {
  let Y;
  for await (let J of GB0(A, async function* () {
    yield* rs2(A, B, Q, I, G, Z);
  }))
    if (J.type === "assistant") Y = J;
  if (!Y) throw Error("No assistant message found");
  return Y;
}
async function* J6A({
  messages: A,
  systemPrompt: B,
  maxThinkingTokens: Q,
  tools: I,
  signal: G,
  options: Z,
}) {
  return yield* GB0(A, async function* () {
    yield* rs2(A, B, Q, I, G, Z);
  });
}
async function* rs2(A, B, Q, I, G, Z) {
  if (
    !nB() &&
    (await $v("tengu-off-switch", { activated: !1 })).activated &&
    D2A(Z.model)
  ) {
    (GA("tengu_off_switch_query", {}), yield vP1(Error(Ma), Z.model));
    return;
  }
  let Y =
    g3() === "bedrock" && Z.model.includes("application-inference-profile")
      ? ((await ZzB(Z.model)) ?? Z.model)
      : Z.model;
  LI("query_tool_schema_build_start");
  let J = eU(Z.model),
    X = await Promise.all(
      I.map((l) =>
        BsA(l, {
          getToolPermissionContext: Z.getToolPermissionContext,
          tools: I,
          agents: Z.agents,
          model: Z.model,
          betas: J,
        }),
      ),
    );
  (LI("query_tool_schema_build_end"),
    (B = [
      HUB(),
      ybA({
        isNonInteractive: Z.isNonInteractiveSession,
        hasAppendSystemPrompt: Z.hasAppendSystemPrompt,
      }),
      ...B,
      xs2(Z.mcpTools),
    ].filter(Boolean)),
    wdQ(B));
  let W = Z.enablePromptCaching ?? ss2(Z.model),
    F = _0I(B, W),
    C = J.length > 0;
  (GA("tengu_api_before_normalize", { preNormalizedMessageCount: A.length }),
    LI("query_message_normalization_start"));
  let V = D7(A);
  (LI("query_message_normalization_end"),
    GA("tengu_api_after_normalize", { postNormalizedMessageCount: V.length }),
    tfQ(Z.model),
    Z.getToolPermissionContext().then((l) => {
      ls2({
        model: Z.model,
        messagesLength: JSON.stringify([
          ...F,
          ...V,
          ...X,
          ...(Z.extraToolSchemas ?? []),
        ]).length,
        temperature: Z.temperatureOverride ?? 1,
        betas: C ? J : [],
        permissionMode: l.mode,
        querySource: Z.querySource,
        queryTracking: Z.queryTracking,
      });
    }));
  let K = Date.now(),
    D = Date.now(),
    E = 0,
    H = void 0,
    w = (l) => {
      let y = l.maxTokensOverride ? Math.min(Q, l.maxTokensOverride - 1) : Q,
        c = nlA(g3() === "bedrock" ? OP1(l.model) : []),
        e = Q > 0 ? { budget_tokens: y, type: "enabled" } : void 0,
        QA = Q > 0,
        WA = KUB({ hasThinking: QA }),
        JA =
          l?.maxTokensOverride ||
          Z.maxOutputTokensOverride ||
          Math.max(Q + 1, $v1(Z.model)),
        wA = Z.enablePromptCaching ?? ss2(l.model);
      return {
        model: og(Z.model),
        messages: k0I(V, wA),
        system: F,
        tools: [...X, ...(Z.extraToolSchemas ?? [])],
        tool_choice: Z.toolChoice,
        ...(C ? { betas: J } : {}),
        metadata: nu(),
        max_tokens: JA,
        thinking: e,
        ...(WA && C && J.includes(GdA) ? { context_management: WA } : {}),
        ...c,
      };
    },
    L = [],
    N = 0,
    $ = void 0,
    O = [],
    P = $y,
    k = 0,
    b = null,
    x = !1,
    n = 0,
    m = void 0,
    o = void 0;
  try {
    LI("query_client_creation_start");
    let l = JaA(
        () =>
          tU({ maxRetries: 0, model: Z.model, fetchOverride: Z.fetchOverride }),
        async (c, e, QA) => {
          ((E = e), (D = Date.now()));
          let WA = w(QA);
          return (
            XB0(WA, Z.querySource),
            (n = WA.max_tokens),
            c.beta.messages.stream(WA, { signal: G })
          );
        },
        {
          model: Z.model,
          fallbackModel: Z.fallbackModel,
          maxThinkingTokens: Q,
          signal: G,
        },
      ),
      y;
    do if (((y = await l.next()), !(y.value instanceof _n))) yield y.value;
    while (!y.done);
    ((H = y.value),
      LI("query_client_creation_end"),
      (L.length = 0),
      (N = 0),
      ($ = void 0),
      (O.length = 0),
      (P = $y),
      LI("query_api_request_sent"));
    try {
      let c = !0;
      for await (let QA of H) {
        if (c)
          (g("Stream started - received first chunk"),
            LI("query_first_chunk_received"),
            Cj2(),
            (c = !1));
        switch (QA.type) {
          case "message_start": {
            (($ = QA.message),
              (N = Date.now() - D),
              (P = c$A(P, QA.message.usage)));
            break;
          }
          case "content_block_start":
            switch (QA.content_block.type) {
              case "tool_use":
                O[QA.index] = { ...QA.content_block, input: "" };
                break;
              case "server_tool_use":
                O[QA.index] = { ...QA.content_block, input: "" };
                break;
              case "text":
                O[QA.index] = { ...QA.content_block, text: "" };
                break;
              case "thinking":
                O[QA.index] = { ...QA.content_block, thinking: "" };
                break;
              default:
                O[QA.index] = { ...QA.content_block };
                break;
            }
            break;
          case "content_block_delta": {
            let WA = O[QA.index];
            if (!WA)
              throw (
                GA("tengu_streaming_error", {
                  error_type: "content_block_not_found_delta",
                  part_type: QA.type,
                  part_index: QA.index,
                }),
                RangeError("Content block not found")
              );
            switch (QA.delta.type) {
              case "citations_delta":
                break;
              case "input_json_delta":
                if (WA.type !== "tool_use" && WA.type !== "server_tool_use")
                  throw (
                    GA("tengu_streaming_error", {
                      error_type: "content_block_type_mismatch_input_json",
                      expected_type: "tool_use",
                      actual_type: WA.type,
                    }),
                    Error("Content block is not a input_json block")
                  );
                if (typeof WA.input !== "string")
                  throw (
                    GA("tengu_streaming_error", {
                      error_type: "content_block_input_not_string",
                      input_type: typeof WA.input,
                    }),
                    Error("Content block input is not a string")
                  );
                WA.input += QA.delta.partial_json;
                break;
              case "text_delta":
                if (WA.type !== "text")
                  throw (
                    GA("tengu_streaming_error", {
                      error_type: "content_block_type_mismatch_text",
                      expected_type: "text",
                      actual_type: WA.type,
                    }),
                    Error("Content block is not a text block")
                  );
                WA.text += QA.delta.text;
                break;
              case "signature_delta":
                if (WA.type !== "thinking")
                  throw (
                    GA("tengu_streaming_error", {
                      error_type:
                        "content_block_type_mismatch_thinking_signature",
                      expected_type: "thinking",
                      actual_type: WA.type,
                    }),
                    Error("Content block is not a thinking block")
                  );
                WA.signature = QA.delta.signature;
                break;
              case "thinking_delta":
                if (WA.type !== "thinking")
                  throw (
                    GA("tengu_streaming_error", {
                      error_type: "content_block_type_mismatch_thinking_delta",
                      expected_type: "thinking",
                      actual_type: WA.type,
                    }),
                    Error("Content block is not a thinking block")
                  );
                WA.thinking += QA.delta.thinking;
                break;
            }
            break;
          }
          case "content_block_stop": {
            let WA = O[QA.index];
            if (!WA)
              throw (
                GA("tengu_streaming_error", {
                  error_type: "content_block_not_found_stop",
                  part_type: QA.type,
                  part_index: QA.index,
                }),
                RangeError("Content block not found")
              );
            if (!$)
              throw (
                GA("tengu_streaming_error", {
                  error_type: "partial_message_not_found",
                  part_type: QA.type,
                }),
                Error("Message not found")
              );
            let JA = {
              message: { ...$, content: JB0([WA], I) },
              requestId: H.request_id ?? void 0,
              type: "assistant",
              uuid: as2(),
              timestamp: new Date().toISOString(),
              ...{},
            };
            L.push(JA);
            break;
          }
          case "message_delta": {
            ((P = c$A(P, QA.usage)), (b = QA.delta.stop_reason));
            let WA = XQ1(Y, P);
            (biA(WA, P, Z.model), (k += WA));
            let JA = ABQ(QA.delta.stop_reason, Z.model);
            if (JA) yield JA;
            if (b === "max_tokens")
              (GA("tengu_max_tokens_reached", { max_tokens: n }),
                yield uZ({
                  content: `${CW}: Claude's response exceeded the ${n} output token maximum. To configure this behavior, set the CLAUDE_CODE_MAX_OUTPUT_TOKENS environment variable.`,
                }));
            if (b === "model_context_window_exceeded")
              (GA("tengu_context_window_exceeded", {
                max_tokens: n,
                output_tokens: P.output_tokens,
              }),
                yield uZ({
                  content: `${CW}: The model has reached its context window limit.`,
                }));
            for (let wA of L) {
              if (b !== null) wA.message.stop_reason = b;
              if (QA.delta.stop_sequence !== null)
                wA.message.stop_sequence = QA.delta.stop_sequence;
              yield wA;
            }
            break;
          }
          case "message_stop":
            break;
        }
        yield { type: "stream_event", event: QA };
      }
      let e = (await H.withResponse()).response;
      (kP1(e.headers), (m = e.headers));
    } catch (c) {
      if (c instanceof xZ)
        if (G.aborted)
          throw (
            g(
              `Streaming aborted by user: ${c instanceof Error ? c.message : String(c)}`,
            ),
            c
          );
        else
          throw (
            g(`Streaming timeout (SDK abort): ${c.message}`, {
              level: "error",
            }),
            new fP({ message: "Request timed out" })
          );
      if (
        (g(
          `Error streaming, falling back to non-streaming mode: ${c instanceof Error ? c.message : String(c)}`,
          { level: "error" },
        ),
        (x = !0),
        Z.onStreamingFallback)
      )
        Z.onStreamingFallback();
      GA("tengu_streaming_fallback_to_non_streaming", {
        model: Z.model,
        error: c instanceof Error ? c.name : String(c),
        attemptNumber: E,
        maxOutputTokens: n,
        maxThinkingTokens: Q,
      });
      let e = JaA(
          () => tU({ maxRetries: 0, model: Z.model }),
          async (JA, wA, xA) => {
            E = wA;
            let rA = w(xA);
            (XB0(rA, Z.querySource), (n = rA.max_tokens));
            let qA = v0I(rA, x0I);
            return await JA.beta.messages.create({
              ...qA,
              model: og(qA.model),
              temperature: Z.temperatureOverride ?? 1,
            });
          },
          { model: Z.model, maxThinkingTokens: Q, signal: G },
        ),
        QA;
      do
        if (((QA = await e.next()), QA.value.type === "system")) yield QA.value;
      while (!QA.done);
      let WA = {
        message: { ...QA.value, content: JB0(QA.value.content, I) },
        requestId: H.request_id ?? void 0,
        type: "assistant",
        uuid: as2(),
        timestamp: new Date().toISOString(),
        ...{},
      };
      (L.push(WA), yield WA);
    }
  } catch (l) {
    g(
      `Error in non-streaming fallback: ${l instanceof Error ? l.message : String(l)}`,
      { level: "error" },
    );
    let y = l,
      c = Z.model;
    if (l instanceof Bd) ((y = l.originalError), (c = l.retryContext.model));
    if (y instanceof J9) _P1(y);
    if (
      (is2({
        error: y,
        model: c,
        messageCount: V.length,
        messageTokens: qF(V),
        durationMs: Date.now() - D,
        durationMsIncludingRetries: Date.now() - K,
        attempt: E,
        requestId: H?.request_id,
        didFallBackToNonStreaming: x,
        queryTracking: Z.queryTracking,
      }),
      y instanceof xZ)
    )
      return;
    yield vP1(y, c, { messages: A, messagesForAPI: V });
    return;
  }
  ns2({
    model: L[0]?.message.model ?? $?.model ?? Z.model,
    preNormalizedModel: Z.model,
    usage: P,
    start: D,
    startIncludingRetries: K,
    attempt: E,
    messageCount: V.length,
    messageTokens: qF(V),
    requestId: H?.request_id ?? null,
    stopReason: b,
    ttftMs: N,
    didFallBackToNonStreaming: x,
    querySource: Z.querySource,
    headers: m,
    costUSD: k,
    queryTracking: Z.queryTracking,
  });
}
function c$A(A, B) {
  return {
    input_tokens: B.input_tokens ?? A.input_tokens,
    cache_creation_input_tokens:
      B.cache_creation_input_tokens ?? A.cache_creation_input_tokens,
    cache_read_input_tokens:
      B.cache_read_input_tokens ?? A.cache_read_input_tokens,
    output_tokens: B.output_tokens ?? A.output_tokens,
    server_tool_use: {
      web_search_requests:
        B.server_tool_use?.web_search_requests ??
        A.server_tool_use.web_search_requests,
      web_fetch_requests:
        B.server_tool_use?.web_fetch_requests ??
        A.server_tool_use.web_fetch_requests,
    },
    service_tier: A.service_tier,
    cache_creation: {
      ephemeral_1h_input_tokens:
        B.cache_creation?.ephemeral_1h_input_tokens ??
        A.cache_creation.ephemeral_1h_input_tokens,
      ephemeral_5m_input_tokens:
        B.cache_creation?.ephemeral_5m_input_tokens ??
        A.cache_creation.ephemeral_5m_input_tokens,
    },
  };
}
function os2(A, B) {
  return {
    input_tokens: A.input_tokens + B.input_tokens,
    cache_creation_input_tokens:
      A.cache_creation_input_tokens + B.cache_creation_input_tokens,
    cache_read_input_tokens:
      A.cache_read_input_tokens + B.cache_read_input_tokens,
    output_tokens: A.output_tokens + B.output_tokens,
    server_tool_use: {
      web_search_requests:
        A.server_tool_use.web_search_requests +
        B.server_tool_use.web_search_requests,
      web_fetch_requests:
        A.server_tool_use.web_fetch_requests +
        B.server_tool_use.web_fetch_requests,
    },
    service_tier: B.service_tier,
    cache_creation: {
      ephemeral_1h_input_tokens:
        A.cache_creation.ephemeral_1h_input_tokens +
        B.cache_creation.ephemeral_1h_input_tokens,
      ephemeral_5m_input_tokens:
        A.cache_creation.ephemeral_5m_input_tokens +
        B.cache_creation.ephemeral_5m_input_tokens,
    },
  };
}
function k0I(A, B) {
  return (
    GA("tengu_api_cache_breakpoints", {
      totalMessageCount: A.length,
      cachingEnabled: B,
    }),
    A.map((Q, I) => {
      return Q.type === "user"
        ? S0I(Q, I > A.length - 3, B)
        : y0I(Q, I > A.length - 3, B);
    })
  );
}
function _0I(A, B) {
  return Rm1(A).map((Q) => ({
    type: "text",
    text: Q,
    ...(B ? { cache_control: d$A() } : {}),
  }));
}
async function $X({
  systemPrompt: A = [],
  userPrompt: B,
  assistantPrompt: Q,
  signal: I,
  options: G,
}) {
  return (
    await IB0(
      [
        T0({ content: A.map((Y) => ({ type: "text", text: Y })) }),
        T0({ content: B }),
      ],
      async () => {
        let Y = [T0({ content: B }), ...(Q ? [CV({ content: Q })] : [])];
        return [
          await YS({
            messages: Y,
            systemPrompt: A,
            maxThinkingTokens: 0,
            tools: [],
            signal: I,
            options: {
              ...G,
              model: FW(),
              enablePromptCaching: G.enablePromptCaching ?? !1,
              async getToolPermissionContext() {
                return kM();
              },
            },
          }),
        ];
      },
    )
  )[0];
}
function v0I(A, B) {
  let Q = Math.min(A.max_tokens, B),
    I = { ...A };
  if (I.thinking?.budget_tokens)
    I.thinking = {
      ...I.thinking,
      budget_tokens: Math.min(I.thinking.budget_tokens, Q - 1),
    };
  return { ...I, max_tokens: Q };
}
function $v1(A) {
  let B = A.toLowerCase(),
    Q;
  if (B.includes("3-5")) Q = 8192;
  else if (B.includes("claude-3-opus")) Q = 4096;
  else if (B.includes("claude-3-sonnet")) Q = 8192;
  else if (B.includes("claude-3-haiku")) Q = 4096;
  else if (B.includes("opus-4")) Q = 32000;
  else if (B.includes("sonnet-4") || B.includes("haiku-4")) Q = 64000;
  else Q = 32000;
  let I = eNA.validate(process.env.CLAUDE_CODE_MAX_OUTPUT_TOKENS);
  if (I.status === "capped") g(`CLAUDE_CODE_MAX_OUTPUT_TOKENS ${I.message}`);
  else if (I.status === "invalid")
    g(`CLAUDE_CODE_MAX_OUTPUT_TOKENS ${I.message}`);
  return Math.min(I.effective, Q);
}
var x0I = 21333;
var zG = T(() => {
  bU1();
  DUB();
  uU1();
  Qr();
  wv();
  Jx();
  kB();
  F2();
  vB();
  c1();
  iB();
  Y9();
  EH();
  DN();
  La();
  f4();
  H0();
  ps2();
  P4A();
  FQ1();
  ZU1();
  wC();
  sh1();
  YdA();
  C0();
  uwA();
  i0();
  yn();
  sq();
  F2();
  ALA();
  Y9();
  Gr();
  ss();
  QB0();
  ux();
});
function ts2() {
  return `You are analyzing output from a bash command to determine if it should be summarized.

Your task is to:
1. Determine if the output contains mostly repetitive logs, verbose build output, or other "log spew"
2. If it does, extract only the relevant information (errors, test results, completion status, etc.)
3. Consider the conversation context - if the user specifically asked to see detailed output, preserve it

You MUST output your response using XML tags in the following format:
<should_summarize>true/false</should_summarize>
<reason>reason for why you decided to summarize or not summarize the output</reason>
<summary>markdown summary as described below (only if should_summarize is true)</summary>

If should_summarize is true, include all three tags with a comprehensive summary.
If should_summarize is false, include only the first two tags and omit the summary tag.

Summary: The summary should be extremely comprehensive and detailed in markdown format. Especially consider the converstion context to determine what to focus on.
Freely copy parts of the output verbatim into the summary if you think it is relevant to the conversation context or what the user is asking for.
It's fine if the summary is verbose. The summary should contain the following sections: (Make sure to include all of these sections)
1. Overview: An overview of the output including the most interesting information summarized.
2. Detailed summary: An extremely detailed summary of the output.
3. Errors: List of relevant errors that were encountered. Include snippets of the output wherever possible.
4. Verbatim output: Copy any parts of the provided output verbatim that are relevant to the conversation context. This is critical. Make sure to include ATLEAST 3 snippets of the output verbatim. 
5. DO NOT provide a recommendation. Just summarize the facts.

Reason: If providing a reason, it should comprehensively explain why you decided not to summarize the output.

Examples of when to summarize:
- Verbose build logs with only the final status being important. Eg. if we are running npm run build to test if our code changes build.
- Test output where only the pass/fail results matter
- Repetitive debug logs with a few key errors

Examples of when NOT to summarize:
- User explicitly asked to see the full output
- Output contains unique, non-repetitive information
- Error messages that need full stack traces for debugging


CRITICAL: You MUST start your response with the <should_summarize> tag as the very first thing. Do not include any other text before the first tag. The summary tag can contain markdown format, but ensure all XML tags are properly closed.`;
}
function es2(A, B, Q) {
  return `Command executed: \`${A}\`

Recent conversation context:
${B || "No recent conversation context"}

Bash output to analyze:
${Q}

Should this output be summarized? If yes, provide a summary focusing on the most relevant information.`;
}
import { createHash as b0I } from "crypto";
import { join as Ar2 } from "path";
function u0I(A) {
  let B = new Date().toISOString().replace(/[:.]/g, "-"),
    Q = b0I("sha256").update(A).digest("hex").slice(0, 8);
  return `${B}-${Q}.txt`;
}
function m0I(A, B, Q) {
  return `COMMAND: ${A}

STDOUT:
${B}

STDERR:
${Q}`;
}
function d0I(A, B, Q) {
  let I = NA(),
    G = L0(),
    Z = Ar2(rw(GQ()), g0I, G),
    Y = Ar2(Z, u0I(Q));
  if (!llA(Z))
    return (
      BA(Error(`Failed to create directory for bash output: ${Z}`), WZ0),
      ""
    );
  try {
    return (
      I.writeFileSync(Y, m0I(Q, A, B), { encoding: "utf-8", flush: !0 }),
      Y
    );
  } catch (J) {
    return (BA(J instanceof Error ? J : Error(String(J)), CZ0), "");
  }
}
function c0I(A) {
  let B = A.slice(-h0I),
    Q = D7(B);
  return JSON.stringify(Q);
}
async function Br2(A, B, Q, I, G = []) {
  let Z = [A, B].filter(Boolean).join(`
`),
    { isImage: Y } = vj(Sx(A));
  if (Y) return { shouldSummarize: !1, reason: "image_data" };
  if (Z.length < f0I) return { shouldSummarize: !1, reason: "below_threshold" };
  try {
    let J = c0I(G),
      X = ts2(),
      W = es2(Q, J, Z),
      F = Date.now(),
      C = await $X({
        systemPrompt: [X],
        userPrompt: W,
        enablePromptCaching: !0,
        options: {
          querySource: "bash_output_summarization",
          hasAppendSystemPrompt: !1,
          isNonInteractiveSession: !1,
          agents: [],
          mcpTools: [],
        },
        signal: I.signal,
      }),
      V = Date.now() - F,
      K = C.message.content
        .filter((L) => L.type === "text")
        .map((L) => L.text)
        .join(""),
      D = g2(K, "should_summarize"),
      E = g2(K, "reason"),
      H = g2(K, "summary")?.trim() || "";
    if (!D)
      return { shouldSummarize: !1, reason: "parse_error", queryDurationMs: V };
    if (D === "true" && H) {
      let L = d0I(A, B, Q);
      return {
        shouldSummarize: !0,
        summary: p0I(H, L),
        rawOutputPath: L,
        queryDurationMs: V,
        ...(E ? { modelReason: E } : {}),
      };
    }
    return {
      shouldSummarize: !1,
      reason: "model_decided_user_needs_full_output",
      queryDurationMs: V,
      ...(E ? { modelReason: E } : {}),
    };
  } catch (J) {
    return (
      BA(J instanceof Error ? J : Error(String(J)), FZ0),
      { shouldSummarize: !1, reason: "summarization_error" }
    );
  }
}
function p0I(A, B) {
  let I = B
    ? `

Note: The complete bash output is available at ${B}. You can use Read or Grep tools to search for specific information not included in this summary.`
    : "";
  return `[Summarized output]
${A}${I}`;
}
var f0I = 5000,
  h0I = 10,
  g0I = "bash-outputs";
var Qr2 = T(() => {
  zG();
  qm();
  m0();
  c1();
  iB();
  E7();
  i0();
  Z4();
});
function Ir2(A, B) {
  for (let Q of A)
    if (Q.startsWith("-") && !Q.startsWith("--") && Q.length > 2)
      for (let I = 1; I < Q.length; I++) {
        let G = "-" + Q[I];
        if (!B.includes(G)) return !1;
      }
    else if (!B.includes(Q)) return !1;
  return !0;
}
function l0I(A, B) {
  let Q = A.match(/^\s*sed\s+/);
  if (!Q) return !1;
  let I = A.slice(Q[0].length),
    G = aY(I);
  if (!G.success) return !1;
  let Z = G.tokens,
    Y = [];
  for (let W of Z)
    if (typeof W === "string" && W.startsWith("-") && W !== "--") Y.push(W);
  if (
    !Ir2(Y, [
      "-n",
      "--quiet",
      "--silent",
      "-E",
      "--regexp-extended",
      "-r",
      "-z",
      "--zero-terminated",
      "--posix",
    ])
  )
    return !1;
  let X = !1;
  for (let W of Y) {
    if (W === "-n" || W === "--quiet" || W === "--silent") {
      X = !0;
      break;
    }
    if (W.startsWith("-") && !W.startsWith("--") && W.includes("n")) {
      X = !0;
      break;
    }
  }
  if (!X) return !1;
  if (B.length === 0) return !1;
  for (let W of B) {
    let F = W.split(";");
    for (let C of F) if (!i0I(C.trim())) return !1;
  }
  return !0;
}
function i0I(A) {
  if (!A) return !1;
  if (!A.endsWith("p")) return !1;
  if (A === "p") return !0;
  let B = A.slice(0, -1);
  if (/^\d+$/.test(B)) return !0;
  if (/^\d+,\d+$/.test(B)) return !0;
  return !1;
}
function n0I(A, B, Q) {
  if (Q) return !1;
  let I = A.match(/^\s*sed\s+/);
  if (!I) return !1;
  let G = A.slice(I[0].length),
    Z = aY(G);
  if (!Z.success) return !1;
  let Y = Z.tokens,
    J = [];
  for (let w of Y)
    if (typeof w === "string" && w.startsWith("-") && w !== "--") J.push(w);
  if (!Ir2(J, ["-E", "--regexp-extended", "-r", "--posix"])) return !1;
  if (B.length !== 1) return !1;
  let W = B[0].trim();
  if (!W.startsWith("s")) return !1;
  let F = W.match(/^s\/(.*?)$/);
  if (!F) return !1;
  let C = F[1],
    V = 0,
    K = -1,
    D = 0;
  while (D < C.length) {
    if (C[D] === "\\") {
      D += 2;
      continue;
    }
    if (C[D] === "/") (V++, (K = D));
    D++;
  }
  if (V !== 2) return !1;
  let E = C.slice(K + 1);
  if (!/^[gpimIM]*[1-9]?[gpimIM]*$/.test(E)) return !1;
  return !0;
}
function Gr2(A) {
  let B;
  try {
    B = s0I(A);
  } catch (Z) {
    return !1;
  }
  let Q = a0I(A),
    I = l0I(A, B),
    G = n0I(A, B, Q);
  if (!I && !G) return !1;
  for (let Z of B) if (G && Z.includes(";")) return !1;
  for (let Z of B) if (r0I(Z)) return !1;
  return !0;
}
function a0I(A) {
  let B = A.match(/^\s*sed\s+/);
  if (!B) return !1;
  let Q = A.slice(B[0].length),
    I = aY(Q);
  if (!I.success) return !0;
  let G = I.tokens;
  try {
    let Z = 0,
      Y = !1;
    for (let J = 0; J < G.length; J++) {
      let X = G[J];
      if (typeof X !== "string" && typeof X !== "object") continue;
      if (typeof X === "object" && X !== null && "op" in X && X.op === "glob")
        return !0;
      if (typeof X !== "string") continue;
      if ((X === "-e" || X === "--expression") && J + 1 < G.length) {
        ((Y = !0), J++);
        continue;
      }
      if (X.startsWith("--expression=")) {
        Y = !0;
        continue;
      }
      if (X.startsWith("-e=")) {
        Y = !0;
        continue;
      }
      if (X.startsWith("-")) continue;
      if ((Z++, Y)) return !0;
      if (Z > 1) return !0;
    }
    return !1;
  } catch (Z) {
    return !0;
  }
}
function s0I(A) {
  let B = [],
    Q = A.match(/^\s*sed\s+/);
  if (!Q) return B;
  let I = A.slice(Q[0].length);
  if (/-e[wWe]/.test(I) || /-w[eE]/.test(I))
    throw Error("Dangerous flag combination detected");
  let G = aY(I);
  if (!G.success) throw Error(`Malformed shell syntax: ${G.error}`);
  let Z = G.tokens;
  try {
    let Y = !1,
      J = !1;
    for (let X = 0; X < Z.length; X++) {
      let W = Z[X];
      if (typeof W !== "string") continue;
      if ((W === "-e" || W === "--expression") && X + 1 < Z.length) {
        Y = !0;
        let F = Z[X + 1];
        if (typeof F === "string") (B.push(F), X++);
        continue;
      }
      if (W.startsWith("--expression=")) {
        ((Y = !0), B.push(W.slice(13)));
        continue;
      }
      if (W.startsWith("-e=")) {
        ((Y = !0), B.push(W.slice(3)));
        continue;
      }
      if (W.startsWith("-")) continue;
      if (!Y && !J) {
        (B.push(W), (J = !0));
        continue;
      }
      break;
    }
  } catch (Y) {
    throw Error(
      `Failed to parse sed command: ${Y instanceof Error ? Y.message : "Unknown error"}`,
    );
  }
  return B;
}
function r0I(A) {
  let B = A.trim();
  if (!B) return !1;
  if (/[^\x01-\x7F]/.test(B)) return !0;
  if (B.includes("{") || B.includes("}")) return !0;
  if (
    B.includes(`
`)
  )
    return !0;
  let Q = B.indexOf("#");
  if (Q !== -1 && !(Q > 0 && B[Q - 1] === "s")) return !0;
  if (/^!/.test(B) || /[/\d$]!/.test(B)) return !0;
  if (/\d\s*~\s*\d|,\s*~\s*\d|\$\s*~\s*\d/.test(B)) return !0;
  if (/^,/.test(B)) return !0;
  if (/,\s*[+-]/.test(B)) return !0;
  if (/s\\/.test(B) || /\\[|#%@]/.test(B)) return !0;
  if (/\\\/.*[wW]/.test(B)) return !0;
  if (/\/[^/]*\s+[wWeE]/.test(B)) return !0;
  if (/^s\//.test(B) && !/^s\/[^/]*\/[^/]*\/[^/]*$/.test(B)) return !0;
  if (/^s./.test(B) && /[wWeE]$/.test(B)) {
    if (!/^s([^\\\n]).*?\1.*?\1[^wWeE]*$/.test(B)) return !0;
  }
  if (
    /^[wW]\s*\S+/.test(B) ||
    /^\d+\s*[wW]\s*\S+/.test(B) ||
    /^\$\s*[wW]\s*\S+/.test(B) ||
    /^\/[^/]*\/[IMim]*\s*[wW]\s*\S+/.test(B) ||
    /^\d+,\d+\s*[wW]\s*\S+/.test(B) ||
    /^\d+,\$\s*[wW]\s*\S+/.test(B) ||
    /^\/[^/]*\/[IMim]*,\/[^/]*\/[IMim]*\s*[wW]\s*\S+/.test(B)
  )
    return !0;
  if (
    /^e/.test(B) ||
    /^\d+\s*e/.test(B) ||
    /^\$\s*e/.test(B) ||
    /^\/[^/]*\/[IMim]*\s*e/.test(B) ||
    /^\d+,\d+\s*e/.test(B) ||
    /^\d+,\$\s*e/.test(B) ||
    /^\/[^/]*\/[IMim]*,\/[^/]*\/[IMim]*\s*e/.test(B)
  )
    return !0;
  let I = B.match(/s([^\\\n]).*?\1.*?\1(.*?)$/);
  if (I) {
    let Z = I[2] || "";
    if (Z.includes("w") || Z.includes("W")) return !0;
    if (Z.includes("e") || Z.includes("E")) return !0;
  }
  if (B.match(/y([^\\\n])/)) {
    if (/[wWeE]/.test(B)) return !0;
  }
  return !1;
}
var Zr2 = T(() => {
  $D();
});
function Xr2(A, B) {
  switch (B) {
    case "none":
      return !1;
    case "number":
      return /^\d+$/.test(A);
    case "string":
      return !0;
    case "char":
      return A.length === 1;
    case "{}":
      return A === "{}";
    case "EOF":
      return A === "EOF";
    default:
      return !1;
  }
}
function t0I(A) {
  let B = aY(A, (X) => `$${X}`);
  if (!B.success) return !1;
  let Q = B.tokens.map((X) => {
    if (typeof X !== "string") {
      if (((X = X), X.op === "glob")) return X.pattern;
    }
    return X;
  });
  if (Q.some((X) => typeof X !== "string")) return !1;
  let G = Q;
  if (G.length === 0) return !1;
  let Z,
    Y = 0;
  for (let [X] of Object.entries(Jr2)) {
    let W = X.split(" ");
    if (G.length >= W.length) {
      let F = !0;
      for (let C = 0; C < W.length; C++)
        if (G[C] !== W[C]) {
          F = !1;
          break;
        }
      if (F) {
        ((Z = Jr2[X]), (Y = W.length));
        break;
      }
    }
  }
  if (!Z) return !1;
  if (G[0] === "git" && G[1] === "ls-remote")
    for (let X = 2; X < G.length; X++) {
      let W = G[X];
      if (W && !W.startsWith("-")) {
        if (W.includes("://")) return !1;
        if (W.includes("@") || W.includes(":")) return !1;
        if (W.includes("$")) return !1;
      }
    }
  let J = Y;
  while (J < G.length) {
    let X = G[J];
    if (!X) {
      J++;
      continue;
    }
    if (G[0] === "xargs" && (!X.startsWith("-") || X === "--")) {
      if (X === "--" && J + 1 < G.length) (J++, (X = G[J]));
      if (X && o0I.includes(X)) break;
      return !1;
    }
    if (X === "--") {
      J++;
      break;
    }
    if (X.startsWith("-") && X.length > 1 && Yr2.test(X)) {
      let [W, ...F] = X.split("="),
        C = F.join("=");
      if (!W) return !1;
      let V = Z.safeFlags[W];
      if (!V) {
        if (G[0] === "git" && W.match(/^-\d+$/)) {
          J++;
          continue;
        }
        if (
          (G[0] === "grep" || G[0] === "rg") &&
          W.startsWith("-") &&
          !W.startsWith("--") &&
          W.length > 2
        ) {
          let K = W.substring(0, 2),
            D = W.substring(2);
          if (Z.safeFlags[K] && /^\d+$/.test(D)) {
            let E = Z.safeFlags[K];
            if (E === "number" || E === "string")
              if (Xr2(D, E)) {
                J++;
                continue;
              } else return !1;
          }
        }
        if (W.startsWith("-") && !W.startsWith("--") && W.length > 2) {
          for (let K = 1; K < W.length; K++) {
            let D = "-" + W[K];
            if (!Z.safeFlags[D]) return !1;
          }
          J++;
          continue;
        } else return !1;
      }
      if (V === "none") {
        if (C) return !1;
        J++;
      } else {
        let K;
        if (C) ((K = C), J++);
        else {
          if (
            J + 1 >= G.length ||
            (G[J + 1] &&
              G[J + 1].startsWith("-") &&
              G[J + 1].length > 1 &&
              Yr2.test(G[J + 1]))
          )
            return !1;
          ((K = G[J + 1] || ""), (J += 2));
        }
        if (V === "string" && K.startsWith("-"))
          if (W === "--sort" && G[0] === "git" && K.match(/^-[a-zA-Z]/));
          else return !1;
        if (!Xr2(K, V)) return !1;
      }
    } else J++;
  }
  if (Z.regex && !Z.regex.test(A)) return !1;
  if (!Z.regex && /`/.test(A)) return !1;
  if (!Z.regex && (G[0] === "rg" || G[0] === "grep") && /[\n\r]/.test(A))
    return !1;
  if (
    Z.additionalCommandIsDangerousCallback &&
    Z.additionalCommandIsDangerousCallback(A)
  )
    return !1;
  return !0;
}
function e0I(A) {
  return new RegExp(`^${A}(?:\\s|$)[^<>()$\`|{}&;\\n\\r]*$`);
}
function CQ1(A) {
  if (EB() !== "windows") return !1;
  if (/\\\\[a-zA-Z0-9._\-:[\]%]+(?:@(?:\d+|ssl))?\\/i.test(A)) return !0;
  if (/\/\/[a-zA-Z0-9._\-:[\]%]+(?:@(?:\d+|ssl))?\//i.test(A)) return !0;
  if (/@SSL@\d+/i.test(A) || /@\d+@SSL/i.test(A)) return !0;
  if (/DavWWWRoot/i.test(A)) return !0;
  if (
    /^\\\\(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})[\\/]/.test(A) ||
    /^\/\/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})[\\/]/.test(A)
  )
    return !0;
  if (
    /^\\\\(\[[\da-fA-F:]+\])[\\/]/.test(A) ||
    /^\/\/(\[[\da-fA-F:]+\])[\\/]/.test(A)
  )
    return !0;
  return !1;
}
function QBI(A) {
  let B = A.trim();
  if (B.endsWith(" 2>&1")) B = B.slice(0, -5).trim();
  if (CQ1(B)) return !1;
  if (t0I(B)) return !0;
  for (let Q of BBI)
    if (Q.test(B)) {
      if (B.includes("git") && /\s-c[\s=]/.test(B)) return !1;
      if (B.includes("git") && /\s--exec-path[\s=]/.test(B)) return !1;
      if (B.includes("git") && /\s--config-env[\s=]/.test(B)) return !1;
      return !0;
    }
  return !1;
}
function Wr2(A) {
  let { command: B } = A;
  if (!aY(B, (G) => `$${G}`).success)
    return {
      behavior: "passthrough",
      message: "Command cannot be parsed, requires further permission checks",
    };
  if (Am(B).behavior !== "passthrough")
    return {
      behavior: "passthrough",
      message: "Command is not read-only, requires further permission checks",
    };
  if (CQ1(B))
    return {
      behavior: "ask",
      message:
        "Command contains Windows UNC path that could be vulnerable to WebDAV attacks",
    };
  if (
    zK(B).every((G) => {
      if (Am(G).behavior !== "passthrough") return !1;
      return QBI(G);
    })
  )
    return { behavior: "allow", updatedInput: A };
  return {
    behavior: "passthrough",
    message: "Command is not read-only, requires further permission checks",
  };
}
var Yr2, Jr2, o0I, ABI, BBI;
var WB0 = T(() => {
  AN();
  $D();
  fdA();
  Zr2();
  E5();
  ((Yr2 = /^-[a-zA-Z0-9_-]/),
    (Jr2 = {
      xargs: {
        safeFlags: {
          "-I": "{}",
          "-i": "none",
          "-n": "number",
          "-P": "number",
          "-L": "number",
          "-s": "number",
          "-E": "EOF",
          "-e": "EOF",
          "-0": "none",
          "-t": "none",
          "-r": "none",
          "-x": "none",
          "-d": "char",
        },
      },
      "git diff": {
        safeFlags: {
          "--stat": "none",
          "--numstat": "none",
          "--shortstat": "none",
          "--dirstat": "none",
          "--summary": "none",
          "--patch-with-stat": "none",
          "--name-only": "none",
          "--name-status": "none",
          "--color": "none",
          "--no-color": "none",
          "--word-diff": "none",
          "--word-diff-regex": "string",
          "--color-words": "none",
          "--no-renames": "none",
          "--no-ext-diff": "none",
          "--check": "none",
          "--ws-error-highlight": "string",
          "--full-index": "none",
          "--binary": "none",
          "--abbrev": "number",
          "--break-rewrites": "none",
          "--find-renames": "none",
          "--find-copies": "none",
          "--find-copies-harder": "none",
          "--irreversible-delete": "none",
          "--diff-algorithm": "string",
          "--histogram": "none",
          "--patience": "none",
          "--minimal": "none",
          "--ignore-space-at-eol": "none",
          "--ignore-space-change": "none",
          "--ignore-all-space": "none",
          "--ignore-blank-lines": "none",
          "--inter-hunk-context": "number",
          "--function-context": "none",
          "--exit-code": "none",
          "--quiet": "none",
          "--cached": "none",
          "--staged": "none",
          "--pickaxe-regex": "none",
          "--pickaxe-all": "none",
          "--no-index": "none",
          "--relative": "string",
          "--diff-filter": "string",
          "-p": "none",
          "-u": "none",
          "-s": "none",
          "-M": "none",
          "-C": "none",
          "-B": "none",
          "-D": "none",
          "-l": "none",
          "-S": "none",
          "-G": "none",
          "-O": "none",
          "-R": "none",
        },
      },
      "git log": {
        safeFlags: {
          "--oneline": "none",
          "--stat": "none",
          "--numstat": "none",
          "--shortstat": "none",
          "--name-only": "none",
          "--name-status": "none",
          "--graph": "none",
          "--color": "none",
          "--no-color": "none",
          "--decorate": "none",
          "--no-decorate": "none",
          "--abbrev-commit": "none",
          "--full-history": "none",
          "--dense": "none",
          "--sparse": "none",
          "--simplify-merges": "none",
          "--ancestry-path": "none",
          "--date": "string",
          "--relative-date": "none",
          "--all": "none",
          "--branches": "none",
          "--tags": "none",
          "--remotes": "none",
          "--first-parent": "none",
          "--merges": "none",
          "--no-merges": "none",
          "--reverse": "none",
          "--walk-reflogs": "none",
          "--grep": "string",
          "--author": "string",
          "--committer": "string",
          "--since": "string",
          "--after": "string",
          "--until": "string",
          "--before": "string",
          "--max-count": "number",
          "--skip": "number",
          "--max-age": "number",
          "--min-age": "number",
          "--no-min-parents": "none",
          "--no-max-parents": "none",
          "--follow": "none",
          "--patch": "none",
          "-p": "none",
          "--no-patch": "none",
          "--no-ext-diff": "none",
          "-s": "none",
          "--pretty": "string",
          "--format": "string",
          "--diff-filter": "string",
          "-n": "number",
          "-S": "string",
          "-G": "string",
          "--pickaxe-regex": "none",
          "--pickaxe-all": "none",
        },
      },
      "git show": {
        safeFlags: {
          "--stat": "none",
          "--numstat": "none",
          "--shortstat": "none",
          "--name-only": "none",
          "--name-status": "none",
          "--color": "none",
          "--no-color": "none",
          "--abbrev-commit": "none",
          "--oneline": "none",
          "--graph": "none",
          "--decorate": "none",
          "--no-decorate": "none",
          "--date": "string",
          "--relative-date": "none",
          "--word-diff": "none",
          "--word-diff-regex": "string",
          "--color-words": "none",
          "--no-patch": "none",
          "--no-ext-diff": "none",
          "--patch": "none",
          "--pretty": "string",
          "--first-parent": "none",
          "--diff-filter": "string",
          "-s": "none",
          "-p": "none",
          "-m": "none",
          "--quiet": "none",
        },
      },
      "git reflog": {
        safeFlags: {
          "--date": "string",
          "--relative-date": "none",
          "--all": "none",
          "--branches": "none",
          "--tags": "none",
          "--remotes": "none",
          "--grep": "string",
          "--author": "string",
          "--committer": "string",
          "--since": "string",
          "--after": "string",
          "--until": "string",
          "--before": "string",
          "--max-count": "number",
          "-n": "number",
          "--oneline": "none",
          "--graph": "none",
          "--decorate": "none",
          "--no-decorate": "none",
        },
      },
      "git stash list": {
        safeFlags: {
          "--oneline": "none",
          "--graph": "none",
          "--decorate": "none",
          "--no-decorate": "none",
          "--date": "string",
          "--relative-date": "none",
          "--all": "none",
          "--branches": "none",
          "--tags": "none",
          "--remotes": "none",
          "--max-count": "number",
          "-n": "number",
        },
      },
      "git ls-remote": {
        safeFlags: {
          "--branches": "none",
          "-b": "none",
          "--tags": "none",
          "-t": "none",
          "--heads": "none",
          "-h": "none",
          "--refs": "none",
          "--quiet": "none",
          "-q": "none",
          "--exit-code": "none",
          "--get-url": "none",
          "--symref": "none",
          "--sort": "string",
          "--server-option": "string",
          "-o": "string",
        },
      },
      file: {
        safeFlags: {
          "--brief": "none",
          "-b": "none",
          "--mime": "none",
          "-i": "none",
          "--mime-type": "none",
          "--mime-encoding": "none",
          "--apple": "none",
          "--check-encoding": "none",
          "-c": "none",
          "--exclude": "string",
          "--exclude-quiet": "string",
          "--print0": "none",
          "-0": "none",
          "-f": "string",
          "-F": "string",
          "--separator": "string",
          "--help": "none",
          "--version": "none",
          "-v": "none",
          "--no-dereference": "none",
          "-h": "none",
          "--dereference": "none",
          "-L": "none",
          "--magic-file": "string",
          "-m": "string",
          "--keep-going": "none",
          "-k": "none",
          "--list": "none",
          "-l": "none",
          "--no-buffer": "none",
          "-n": "none",
          "--preserve-date": "none",
          "-p": "none",
          "--raw": "none",
          "-r": "none",
          "-s": "none",
          "--special-files": "none",
          "--uncompress": "none",
          "-z": "none",
        },
      },
      sed: {
        safeFlags: {
          "--expression": "string",
          "-e": "string",
          "--quiet": "none",
          "--silent": "none",
          "-n": "none",
          "--regexp-extended": "none",
          "-r": "none",
          "--posix": "none",
          "-E": "none",
          "--line-length": "number",
          "-l": "number",
          "--zero-terminated": "none",
          "-z": "none",
          "--separate": "none",
          "-s": "none",
          "--unbuffered": "none",
          "-u": "none",
          "--debug": "none",
          "--help": "none",
          "--version": "none",
        },
        additionalCommandIsDangerousCallback: (A) => !Gr2(A),
      },
      "pip list": {
        safeFlags: {
          "--outdated": "none",
          "-o": "none",
          "--uptodate": "none",
          "-u": "none",
          "--editable": "none",
          "-e": "none",
          "--local": "none",
          "-l": "none",
          "--user": "none",
          "--pre": "none",
          "--format": "string",
          "--not-required": "none",
          "--exclude-editable": "none",
          "--include-editable": "none",
          "--exclude": "string",
          "--help": "none",
          "-h": "none",
          "--version": "none",
          "-V": "none",
          "--verbose": "none",
          "-v": "none",
          "--quiet": "none",
          "-q": "none",
          "--no-color": "none",
          "--no-input": "none",
          "--disable-pip-version-check": "none",
          "--no-python-version-warning": "none",
        },
      },
      sort: {
        safeFlags: {
          "--ignore-leading-blanks": "none",
          "-b": "none",
          "--dictionary-order": "none",
          "-d": "none",
          "--ignore-case": "none",
          "-f": "none",
          "--general-numeric-sort": "none",
          "-g": "none",
          "--human-numeric-sort": "none",
          "-h": "none",
          "--ignore-nonprinting": "none",
          "-i": "none",
          "--month-sort": "none",
          "-M": "none",
          "--numeric-sort": "none",
          "-n": "none",
          "--random-sort": "none",
          "-R": "none",
          "--reverse": "none",
          "-r": "none",
          "--sort": "string",
          "--stable": "none",
          "-s": "none",
          "--unique": "none",
          "-u": "none",
          "--version-sort": "none",
          "-V": "none",
          "--zero-terminated": "none",
          "-z": "none",
          "--key": "string",
          "-k": "string",
          "--field-separator": "string",
          "-t": "string",
          "--check": "none",
          "-c": "none",
          "--check-char-order": "none",
          "-C": "none",
          "--merge": "none",
          "-m": "none",
          "--buffer-size": "string",
          "-S": "string",
          "--parallel": "number",
          "--batch-size": "number",
          "--help": "none",
          "--version": "none",
        },
      },
      man: {
        safeFlags: {
          "-a": "none",
          "--all": "none",
          "-d": "none",
          "-f": "none",
          "--whatis": "none",
          "-h": "none",
          "-k": "none",
          "--apropos": "none",
          "-l": "string",
          "-w": "none",
          "-S": "string",
          "-s": "string",
        },
      },
      "npm list": {
        safeFlags: {
          "--all": "none",
          "-a": "none",
          "--json": "none",
          "--long": "none",
          "-l": "none",
          "--global": "none",
          "-g": "none",
          "--depth": "number",
          "--omit": "string",
          "--include": "string",
          "--link": "none",
          "--workspace": "string",
          "-w": "string",
          "--workspaces": "none",
          "-ws": "none",
        },
      },
      "mcp-cli servers": { safeFlags: { "--json": "none" } },
      "mcp-cli tools": { safeFlags: { "--json": "none" } },
      "mcp-cli info": { safeFlags: { "--json": "none" } },
      "mcp-cli grep": {
        safeFlags: { "--json": "none", "-i": "none", "--ignore-case": "none" },
      },
      "mcp-cli resources": { safeFlags: { "--json": "none" } },
      "mcp-cli read": { safeFlags: { "--json": "none" } },
      netstat: {
        safeFlags: {
          "-a": "none",
          "-L": "none",
          "-l": "none",
          "-n": "none",
          "-f": "string",
          "-g": "none",
          "-i": "none",
          "-I": "string",
          "-s": "none",
          "-r": "none",
          "-m": "none",
          "-v": "none",
        },
      },
      base64: {
        safeFlags: {
          "-d": "none",
          "-D": "none",
          "--decode": "none",
          "-b": "number",
          "--break": "number",
          "-w": "number",
          "--wrap": "number",
          "-i": "string",
          "--input": "string",
          "--ignore-garbage": "none",
          "-h": "none",
          "--help": "none",
          "--version": "none",
        },
      },
      grep: {
        safeFlags: {
          "-e": "string",
          "--regexp": "string",
          "-f": "string",
          "--file": "string",
          "-F": "none",
          "--fixed-strings": "none",
          "-G": "none",
          "--basic-regexp": "none",
          "-E": "none",
          "--extended-regexp": "none",
          "-P": "none",
          "--perl-regexp": "none",
          "-i": "none",
          "--ignore-case": "none",
          "--no-ignore-case": "none",
          "-v": "none",
          "--invert-match": "none",
          "-w": "none",
          "--word-regexp": "none",
          "-x": "none",
          "--line-regexp": "none",
          "-c": "none",
          "--count": "none",
          "--color": "string",
          "--colour": "string",
          "-L": "none",
          "--files-without-match": "none",
          "-l": "none",
          "--files-with-matches": "none",
          "-m": "number",
          "--max-count": "number",
          "-o": "none",
          "--only-matching": "none",
          "-q": "none",
          "--quiet": "none",
          "--silent": "none",
          "-s": "none",
          "--no-messages": "none",
          "-b": "none",
          "--byte-offset": "none",
          "-H": "none",
          "--with-filename": "none",
          "-h": "none",
          "--no-filename": "none",
          "--label": "string",
          "-n": "none",
          "--line-number": "none",
          "-T": "none",
          "--initial-tab": "none",
          "-u": "none",
          "--unix-byte-offsets": "none",
          "-Z": "none",
          "--null": "none",
          "-z": "none",
          "--null-data": "none",
          "-A": "number",
          "--after-context": "number",
          "-B": "number",
          "--before-context": "number",
          "-C": "number",
          "--context": "number",
          "--group-separator": "string",
          "--no-group-separator": "none",
          "-a": "none",
          "--text": "none",
          "--binary-files": "string",
          "-D": "string",
          "--devices": "string",
          "-d": "string",
          "--directories": "string",
          "--exclude": "string",
          "--exclude-from": "string",
          "--exclude-dir": "string",
          "--include": "string",
          "-r": "none",
          "--recursive": "none",
          "-R": "none",
          "--dereference-recursive": "none",
          "--line-buffered": "none",
          "-U": "none",
          "--binary": "none",
          "--help": "none",
          "-V": "none",
          "--version": "none",
        },
      },
      rg: {
        safeFlags: {
          "-e": "string",
          "--regexp": "string",
          "-f": "string",
          "-i": "none",
          "--ignore-case": "none",
          "-S": "none",
          "--smart-case": "none",
          "-F": "none",
          "--fixed-strings": "none",
          "-w": "none",
          "--word-regexp": "none",
          "-v": "none",
          "--invert-match": "none",
          "-c": "none",
          "--count": "none",
          "-l": "none",
          "--files-with-matches": "none",
          "--files-without-match": "none",
          "-n": "none",
          "--line-number": "none",
          "-o": "none",
          "--only-matching": "none",
          "-A": "number",
          "--after-context": "number",
          "-B": "number",
          "--before-context": "number",
          "-C": "number",
          "--context": "number",
          "-H": "none",
          "-h": "none",
          "--heading": "none",
          "--no-heading": "none",
          "-q": "none",
          "--quiet": "none",
          "--column": "none",
          "-g": "string",
          "--glob": "string",
          "-t": "string",
          "--type": "string",
          "-T": "string",
          "--type-not": "string",
          "--type-list": "none",
          "--hidden": "none",
          "--no-ignore": "none",
          "-u": "none",
          "-m": "number",
          "--max-count": "number",
          "-d": "number",
          "--max-depth": "number",
          "-a": "none",
          "--text": "none",
          "-z": "none",
          "-L": "none",
          "--follow": "none",
          "--color": "string",
          "--json": "none",
          "--stats": "none",
          "--help": "none",
          "--version": "none",
          "--debug": "none",
          "--": "none",
        },
      },
    }),
    (o0I = ["echo", "printf", "wc", "grep", "head", "tail"]));
  ((ABI = [
    "date",
    "cal",
    "uptime",
    "head",
    "tail",
    "wc",
    "stat",
    "strings",
    "hexdump",
    "od",
    "nl",
    "id",
    "uname",
    "free",
    "df",
    "du",
    "locale",
    "hostname",
    "groups",
    "nproc",
    "docker ps",
    "docker images",
    "info",
    "help",
    "basename",
    "dirname",
    "realpath",
    "cut",
    "tr",
    "column",
    "diff",
    "true",
    "false",
    "sleep",
    "which",
    "type",
  ]),
    (BBI = new Set([
      ...ABI.map(e0I),
      /^echo(?:\s+(?:'[^']*'|"[^"$<>\n\r]*"|[^|;&`$(){}><#\\!"'\s]+))*(?:\s+2>&1)?\s*$/,
      /^claude -h$/,
      /^claude --help$/,
      /^git status(?:\s|$)[^<>()$`|{}&;\n\r]*$/,
      /^git blame(?:\s|$)[^<>()$`|{}&;\n\r]*$/,
      /^git ls-files(?:\s|$)[^<>()$`|{}&;\n\r]*$/,
      /^git config --get[^<>()$`|{}&;\n\r]*$/,
      /^git remote -v$/,
      /^git remote show\s+[a-zA-Z0-9_-]+$/,
      /^git tag$/,
      /^git tag -l[^<>()$`|{}&;\n\r]*$/,
      /^git branch$/,
      /^git branch (?:-v|-vv|--verbose)$/,
      /^git branch (?:-a|--all)$/,
      /^git branch (?:-r|--remotes)$/,
      /^git branch (?:-l|--list)(?:\s+".*"|'[^']*')?$/,
      /^git branch (?:--color|--no-color|--column|--no-column)$/,
      /^git branch --sort=\S+$/,
      /^git branch --show-current$/,
      /^git branch (?:--contains|--no-contains)\s+\S+$/,
      /^git branch (?:--merged|--no-merged)(?:\s+\S+)?$/,
      /^uniq(?:\s+(?:-[a-zA-Z]+|--[a-zA-Z-]+(?:=\S+)?|-[fsw]\s+\d+))*(?:\s|$)\s*$/,
      /^pwd$/,
      /^whoami$/,
      /^ps(?:\s|$)(?!.*-o)(?!.*-O)[^<>()$`|{}&;\n\r]*$/,
      /^node -v$/,
      /^npm -v$/,
      /^python --version$/,
      /^python3 --version$/,
      /^tree$/,
      /^history(?:\s+\d+)?\s*$/,
      /^alias$/,
      /^arch(?:\s+(?:--help|-h))?\s*$/,
      /^ip addr$/,
      /^ifconfig(?:\s+[a-zA-Z][a-zA-Z0-9_-]*)?\s*$/,
      /^jq(?!\s+.*(?:-f\b|--from-file|--rawfile|--slurpfile|--run-tests|-L\b|--library-path))(?:\s+(?:-[a-zA-Z]+|--[a-zA-Z-]+(?:=\S+)?))*(?: +(?:'[^'`]*'|"[^"`]*"|[^-\s][^\s]*))?\s*$/,
      /^cd(?:\s+(?:'[^']*'|"[^"]*"|[^\s;|&`$(){}><#\\]+))?$/,
      /^ls(?:\s+[^<>()$`|{}&;\n\r]*)?$/,
      /^find(?:\s+(?:(?!-delete\b|-exec\b|-execdir\b|-ok\b|-okdir\b|-fprint0?\b|-fls\b|-fprintf\b)[^<>()$`|{}&;\n\r\s]|\\[()]|\s)+)?$/,
    ])));
});
function ZBI(A) {
  let B = YBI(A),
    Q = GBI.get(B);
  return Q !== void 0 ? Q : IBI;
}
function YBI(A) {
  let B = zK(A);
  return (B[B.length - 1] || A).trim().split(/\s+/)[0] || "";
}
function Fr2(A, B, Q, I) {
  let Z = ZBI(A)(B, Q, I);
  return { isError: Z.isError, message: Z.message };
}
var IBI = (A, B, Q) => ({
    isError: A !== 0,
    message: A !== 0 ? `Command failed with exit code ${A}` : void 0,
  }),
  GBI;
var Cr2 = T(() => {
  AN();
  GBI = new Map([
    [
      "grep",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "No matches found" : void 0,
      }),
    ],
    [
      "rg",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "No matches found" : void 0,
      }),
    ],
    [
      "find",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "Some directories were inaccessible" : void 0,
      }),
    ],
    [
      "diff",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "Files differ" : void 0,
      }),
    ],
    [
      "test",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "Condition is false" : void 0,
      }),
    ],
    [
      "[",
      (A, B, Q) => ({
        isError: A >= 2,
        message: A === 1 ? "Condition is false" : void 0,
      }),
    ],
  ]);
});
import { EOL as VQ1 } from "os";
import { isAbsolute as JBI, resolve as XBI } from "path";
function Kr2(A) {
  let B = zK(A);
  if (B.length === 0) return "other";
  for (let Q of B) {
    let I = Q.split(" ")[0] || "";
    if (VBI.includes(I)) return I;
  }
  return "other";
}
function DBI(A, B) {
  if (B !== 0) return;
  if (A.match(/\bgit\s+commit\b/)) {
    if (
      (GA("tengu_git_operation", { operation: "commit" }), A.match(/--amend\b/))
    )
      GA("tengu_git_operation", { operation: "commit_amend" });
    F80()?.add(1);
  }
  if (A.match(/\bgh\s+pr\s+create\b/))
    (GA("tengu_git_operation", { operation: "pr_create" }), x91()?.add(1));
  if (A.match(/\bglab\s+mr\s+create\b/))
    (GA("tengu_git_operation", { operation: "pr_create" }), x91()?.add(1));
}
function EBI(A) {
  let B = zK(A);
  if (B.length === 0) return !0;
  let Q = B[0]?.trim();
  if (!Q) return !0;
  return !FBI.includes(Q);
}
function HBI(A) {
  let Q = N0().sandbox?.excludedCommands ?? [];
  if (Q.length === 0) return !1;
  for (let I of Q) {
    let G = wj1(I);
    switch (G.type) {
      case "exact":
        if (A.trim() === G.command) return !0;
        break;
      case "prefix": {
        let Z = A.trim();
        if (Z === G.prefix || Z.startsWith(G.prefix + " ")) return !0;
        break;
      }
    }
  }
  return !1;
}
function m4A(A) {
  if (!VQ.isSandboxingEnabled()) return !1;
  if (A.dangerouslyDisableSandbox && VQ.areUnsandboxedCommandsAllowed())
    return !1;
  if (!A.command) return !1;
  if (HBI(A.command)) return !1;
  return !0;
}
async function zBI(A, B, Q, I, G) {
  return null;
}
async function* UBI({
  input: A,
  abortController: B,
  setAppState: Q,
  setToolJSX: I,
  preventCwdChanges: G,
}) {
  let {
      command: Z,
      description: Y,
      timeout: J,
      shellExecutable: X,
      run_in_background: W,
    } = A,
    F = J || b8A(),
    C = "",
    V = "",
    K = 0,
    D = void 0,
    E = EBI(Z),
    H = await dlA(
      Z,
      B.signal,
      F,
      X,
      (k, b, x) => {
        ((V = k), (C = b), (K = x));
      },
      G,
      m4A(A),
      E,
    ),
    w = H.result;
  function L(k, b) {
    Q((x) => {
      let n = x.backgroundTasks[k];
      if (n && n.type !== "shell") return x;
      return { ...x, backgroundTasks: { ...x.backgroundTasks, [k]: b(n) } };
    });
  }
  function N(k, b) {
    let x = Ev1(Z, H, Y || Z, L);
    if (((D = x), GA(k, { command_type: Kr2(Z) }), b)) b(x);
  }
  function $() {
    N("tengu_bash_command_backgrounded");
  }
  if (H.onTimeout && E)
    H.onTimeout((k) => {
      N("tengu_bash_command_timeout_backgrounded", k);
    });
  if (W === !0) {
    let k = Ev1(Z, H, Y || Z, L);
    return (
      GA("tengu_bash_command_explicitly_backgrounded", {
        command_type: Kr2(Z),
      }),
      { stdout: "", stderr: "", code: 0, interrupted: !1, backgroundTaskId: k }
    );
  }
  let O = Date.now(),
    P = O + Vr2;
  while (!0) {
    let k = Date.now(),
      b = Math.max(0, P - k),
      x = await Promise.race([
        w,
        new Promise((o) => setTimeout(() => o(null), b)),
      ]);
    if (x !== null) return x;
    if (D)
      return {
        stdout: "",
        stderr: "",
        code: 0,
        interrupted: !1,
        backgroundTaskId: D,
      };
    let n = Date.now() - O,
      m = Math.floor(n / 1000);
    if (D === void 0 && m >= Vr2 / 1000 && I)
      I({
        jsx: FB0.createElement(Nf2, { onBackground: $ }),
        shouldHidePromptInput: !1,
        shouldContinueAnimation: !0,
        showSpinner: !0,
      });
    (yield {
      type: "progress",
      fullOutput: C,
      output: V,
      elapsedTimeSeconds: m,
      totalLines: K,
    },
      (P = Date.now() + WBI));
  }
}
var FB0,
  Vr2 = 2000,
  WBI = 1000,
  FBI,
  CBI,
  VBI,
  KBI,
  r2;
var EF = T(() => {
  e2();
  Qr2();
  AN();
  c1();
  vG();
  V2();
  vB();
  Ww();
  Rs();
  f8A();
  VW();
  zN();
  qm();
  ddA();
  WB0();
  f4();
  H0();
  i0();
  gj();
  OQ();
  y7();
  Cr2();
  f8A();
  i0();
  NA0();
  xj();
  ez();
  ((FB0 = IA(KA(), 1)),
    (FBI = ["sleep"]),
    (CBI = _.strictObject({
      command: _.string().describe("The command to execute"),
      timeout: _.number()
        .optional()
        .describe(`Optional timeout in milliseconds (max ${_lA()})`),
      description: _.string().optional()
        .describe(`Clear, concise description of what this command does in 5-10 words, in active voice. Examples:
Input: ls
Output: List files in current directory

Input: git status
Output: Show working tree status

Input: npm install
Output: Install package dependencies

Input: mkdir foo
Output: Create directory 'foo'`),
      run_in_background: _.boolean()
        .optional()
        .describe(
          "Set to true to run this command in the background. Use BashOutput to read the output later.",
        ),
      dangerouslyDisableSandbox: _.boolean()
        .optional()
        .describe(
          "Set this to true to dangerously override sandbox mode and run commands without sandboxing.",
        ),
    })),
    (VBI = [
      "npm",
      "yarn",
      "pnpm",
      "node",
      "python",
      "python3",
      "go",
      "cargo",
      "make",
      "docker",
      "terraform",
      "webpack",
      "vite",
      "jest",
      "pytest",
      "curl",
      "wget",
      "build",
      "test",
      "serve",
      "watch",
      "dev",
    ]));
  KBI = _.object({
    stdout: _.string().describe("The standard output of the command"),
    stderr: _.string().describe("The standard error output of the command"),
    summary: _.string().optional().describe("Summarized output when available"),
    rawOutputPath: _.string()
      .optional()
      .describe("Path to raw output file when summarized"),
    interrupted: _.boolean().describe("Whether the command was interrupted"),
    isImage: _.boolean()
      .optional()
      .describe("Flag to indicate if stdout contains image data"),
    backgroundTaskId: _.string()
      .optional()
      .describe(
        "ID of the background task if command is running in background",
      ),
    dangerouslyDisableSandbox: _.boolean()
      .optional()
      .describe("Flag to indicate if sandbox mode was overridden"),
    returnCodeInterpretation: _.string()
      .optional()
      .describe(
        "Semantic interpretation for non-error exit codes with special meaning",
      ),
    structuredContent: _.array(_.any())
      .optional()
      .describe("Structured content blocks from mcp-cli commands"),
  });
  r2 = {
    name: E4,
    strict: !0,
    async description({ description: A }) {
      return A || "Run shell command";
    },
    async prompt() {
      return BUQ();
    },
    isConcurrencySafe(A) {
      return this.isReadOnly(A);
    },
    isReadOnly(A) {
      return Wr2(A).behavior === "allow";
    },
    inputSchema: CBI,
    outputSchema: KBI,
    userFacingName(A) {
      if (!A) return "Bash";
      return m4A(A) && V0(process.env.CLAUDE_CODE_BASH_SANDBOX_SHOW_INDICATOR)
        ? "SandboxedBash"
        : "Bash";
    },
    isEnabled() {
      return !0;
    },
    async checkPermissions(A, B) {
      return await Nj1(A, B);
    },
    renderToolUseMessage: Lf2,
    renderToolUseRejectedMessage: Mf2,
    renderToolUseProgressMessage: Of2,
    renderToolUseQueuedMessage: Rf2,
    renderToolResultMessage: Tf2,
    mapToolResultToToolResultBlockParam(
      {
        interrupted: A,
        stdout: B,
        stderr: Q,
        summary: I,
        isImage: G,
        backgroundTaskId: Z,
        structuredContent: Y,
      },
      J,
    ) {
      if (Y && Y.length > 0)
        return { tool_use_id: J, type: "tool_result", content: Y };
      if (G) {
        let C = B.trim().match(/^data:([^;]+);base64,(.+)$/);
        if (C) {
          let V = C[1],
            K = C[2];
          return {
            tool_use_id: J,
            type: "tool_result",
            content: [
              {
                type: "image",
                source: {
                  type: "base64",
                  media_type: V || "image/jpeg",
                  data: K || "",
                },
              },
            ],
          };
        }
      }
      if (I)
        return { tool_use_id: J, type: "tool_result", content: I, is_error: A };
      let X = B;
      if (B) ((X = B.replace(/^(\s*\n)+/, "")), (X = X.trimEnd()));
      let W = Q.trim();
      if (A) {
        if (Q) W += VQ1;
        W += "<error>Command was aborted before completion</error>";
      }
      let F = Z ? `Command running in background with ID: ${Z}` : "";
      return {
        tool_use_id: J,
        type: "tool_result",
        content: [X, W, F].filter(Boolean).join(`
`),
        is_error: A,
      };
    },
    async call(A, B, Q, I, G) {
      let {
          abortController: Z,
          readFileState: Y,
          getAppState: J,
          setAppState: X,
          setToolJSX: W,
          messages: F,
        } = B,
        C = new H0A(),
        V = new H0A(),
        K,
        D = 0,
        E = !1,
        H,
        L = B.agentId !== L0();
      try {
        let QA = UBI({
            input: A,
            abortController: Z,
            setAppState: X,
            setToolJSX: W,
            preventCwdChanges: L,
          }),
          WA;
        do
          if (((WA = await QA.next()), !WA.done && G)) {
            let wA = WA.value;
            G({
              toolUseID: `bash-progress-${D++}`,
              data: {
                type: "bash_progress",
                output: wA.output,
                fullOutput: wA.fullOutput,
                elapsedTimeSeconds: wA.elapsedTimeSeconds,
                totalLines: wA.totalLines,
              },
            });
          }
        while (!WA.done);
        if (
          ((H = WA.value),
          DBI(A.command, H.code),
          C.append((H.stdout || "").trimEnd() + VQ1),
          (K = Fr2(A.command, H.code, H.stdout || "", H.stderr || "")),
          H.stderr && H.stderr.includes(".git/index.lock': File exists"))
        )
          GA("tengu_git_index_lock_error", {});
        if (K.isError) {
          if ((V.append(H.stderr.trimEnd() + VQ1), H.code !== 0))
            V.append(`Exit code ${H.code}`);
        } else C.append(H.stderr.trimEnd() + VQ1);
        if (!L) {
          let wA = await J();
          if (plA(wA.toolPermissionContext)) {
            let xA = V.toString();
            (V.clear(), V.append(clA(xA)));
          }
        }
        let JA = VQ.annotateStderrWithSandboxFailures(
          A.command,
          H.stderr || "",
        );
        if (K.isError) throw new hT(H.stdout, JA, H.code, H.interrupted);
        E = H.interrupted;
      } finally {
        if (W) W(null);
      }
      let N = C.toString(),
        $ = V.toString();
      {
        let QA = a9();
        LUQ(A.command, N, QA.signal, B.options.isNonInteractiveSession)
          .then(async (WA) => {
            for (let JA of WA) {
              let wA = JBI(JA) ? JA : XBI(G0(), JA);
              try {
                if (!(await t4.validateInput({ file_path: wA }, B)).result) {
                  Y.delete(wA);
                  continue;
                }
                await t4.call({ file_path: wA }, B);
              } catch (xA) {
                (Y.delete(wA), BA(xA, a81));
              }
            }
            GA("tengu_bash_tool_haiku_file_paths_read", {
              filePathsExtracted: WA.length,
              readFileStateSize: Y.size,
              readFileStateValuesCharLength: ym(Y).reduce((JA, wA) => {
                let xA = Y.get(wA);
                return JA + (xA?.content.length || 0);
              }, 0),
            });
          })
          .catch((WA) => {
            if (
              WA instanceof Error &&
              WA.message.includes("Request was aborted")
            )
              return;
            BA(WA, a81);
          });
      }
      let O = await zBI(N, $, A.command, Z, F || []),
        P = O?.shouldSummarize === !0,
        k = O?.modelReason,
        b = A.command.split(" ")[0];
      GA("tengu_bash_tool_command_executed", {
        command_type: b,
        stdout_length: N.length,
        stderr_length: $.length,
        exit_code: H.code,
        interrupted: E,
        summarization_attempted: O !== null,
        summarization_succeeded: P,
        summarization_duration_ms: O?.queryDurationMs,
        summarization_reason: !P && O ? O.reason : void 0,
        model_summarization_reason: k,
        summary_length:
          O?.shouldSummarize && O.summary ? O.summary.length : void 0,
      });
      let { truncatedContent: x, isImage: n } = vj(Sx(N)),
        { truncatedContent: m } = vj(Sx($)),
        o = void 0,
        l = x,
        y = void 0,
        c = he(A.command);
      if (c !== null)
        try {
          let QA = JSON.parse(N),
            WA = await CB0(QA, c.tool, c.server);
          if (Array.isArray(WA)) ((y = WA), (l = OUQ(WA)));
          else if (typeof WA === "string") l = WA;
        } catch (QA) {
          if ((BA(QA, WX0), N.length > Fs())) {
            if (((o = MUQ(N, A.command)), o))
              l =
                x +
                `

Note: Full mcp-cli output (${N.length.toLocaleString()} characters) saved to ${o}. You can use the ${t4.name} tool to access the complete output.`;
          }
        }
      return {
        data: {
          stdout: l,
          stderr: m,
          summary: P ? O?.summary : void 0,
          rawOutputPath: P ? O?.rawOutputPath : o,
          interrupted: E,
          isImage: n,
          returnCodeInterpretation: K?.message,
          backgroundTaskId: H.backgroundTaskId,
          structuredContent: y,
          dangerouslyDisableSandbox:
            "dangerouslyDisableSandbox" in A
              ? A.dangerouslyDisableSandbox
              : void 0,
        },
      };
    },
    renderToolUseErrorMessage: Pf2,
  };
});
function vB1({ ruleValue: A }) {
  switch (A.toolName) {
    case r2.name:
      if (A.ruleContent)
        if (A.ruleContent.endsWith(":*"))
          return qE.createElement(
            U,
            { dimColor: !0 },
            "Any Bash command starting with",
            " ",
            qE.createElement(U, { bold: !0 }, A.ruleContent.slice(0, -2)),
          );
        else
          return qE.createElement(
            U,
            { dimColor: !0 },
            "The Bash command ",
            qE.createElement(U, { bold: !0 }, A.ruleContent),
          );
      else return qE.createElement(U, { dimColor: !0 }, "Any Bash command");
    default:
      if (!A.ruleContent)
        return qE.createElement(
          U,
          { dimColor: !0 },
          "Any use of the ",
          qE.createElement(U, { bold: !0 }, A.toolName),
          " tool",
        );
      else return null;
  }
}
var qE;
var D00 = T(() => {
  nA();
  EF();
  qE = IA(KA(), 1);
});
function w00(A) {
  switch (A) {
    case "localSettings":
      return {
        label: "Project settings (local)",
        description: `Saved in ${p$A("localSettings")}`,
        value: A,
      };
    case "projectSettings":
      return {
        label: "Project settings",
        description: `Checked in at ${p$A("projectSettings")}`,
        value: A,
      };
    case "userSettings":
      return {
        label: "User settings",
        description: "Saved in at ~/.claude/settings.json",
        value: A,
      };
  }
}
function qi2({
  onAddRules: A,
  onCancel: B,
  ruleValues: Q,
  ruleBehavior: I,
  initialContext: G,
  setToolPermissionContext: Z,
}) {
  let Y = j7A.map(w00),
    J = Dr2.useCallback(
      (W) => {
        if (W === "cancel") {
          B();
          return;
        } else if (j7A.includes(W)) {
          let F = W,
            C = aF(G, {
              type: "addRules",
              rules: Q,
              behavior: I,
              destination: F,
            });
          (wb({ type: "addRules", rules: Q, behavior: I, destination: F }),
            Z(C));
          let V = Q.map((K) => ({ ruleValue: K, ruleBehavior: I, source: F }));
          A(V);
        }
      },
      [A, B, Q, I, G, Z],
    ),
    X = `Add ${I} permission rule${Q.length === 1 ? "" : "s"}`;
  return PV.createElement(
    Wc,
    { title: X, onCancel: B, color: "permission" },
    PV.createElement(
      S,
      { flexDirection: "column", paddingX: 2 },
      Q.map((W) =>
        PV.createElement(
          S,
          { flexDirection: "column", key: H5(W) },
          PV.createElement(U, { bold: !0 }, H5(W)),
          PV.createElement(vB1, { ruleValue: W }),
        ),
      ),
    ),
    PV.createElement(
      S,
      { flexDirection: "column", marginY: 1 },
      PV.createElement(
        U,
        null,
        Q.length === 1
          ? "Where should this rule be saved?"
          : "Where should these rules be saved?",
      ),
      PV.createElement($0, { options: Y, onChange: J, onCancel: B }),
    ),
  );
}
var PV, Dr2, j7A;
var bB1 = T(() => {
  nA();
  Z5();
  f3();
  aC();
  aC();
  D00();
  OQ();
  lzA();
  ((PV = IA(KA(), 1)), (Dr2 = IA(KA(), 1)));
  j7A = ["localSettings", "projectSettings", "userSettings"];
});
function Er2(A) {
  return A.map((B) => ({
    matcher: B.matcher,
    hooks: B.hooks.map((Q) => Q.hook).filter((Q) => Q.type !== "function"),
  }));
}
function KQ1(A, B, Q) {
  let I = A.sessionHooks[B];
  if (!I) return new Map();
  let G = new Map();
  if (Q) {
    let Z = I.hooks[Q];
    if (Z) G.set(Q, Er2(Z));
    return G;
  }
  for (let Z of fYA) {
    let Y = I.hooks[Z];
    if (Y) G.set(Z, Er2(Y));
  }
  return G;
}
function Hr2(A, B, Q, I, G) {
  let Z = A.sessionHooks[B];
  if (!Z) return;
  let Y = Z.hooks[Q];
  if (!Y) return;
  for (let J of Y)
    if (J.matcher === I || I === "") {
      let X = J.hooks.find((W) => k$A(W.hook, G));
      if (X) return X;
    }
  return;
}
function zr2(A, B) {
  (A((Q) => {
    let I = { ...Q.sessionHooks };
    return (delete I[B], { ...Q, sessionHooks: I });
  }),
    g(`Cleared all session hooks for session ${B}`));
}
var VB0 = T(() => {
  ETA();
  C0();
  zy();
});
function k$A(A, B) {
  if (A.type !== B.type) return !1;
  switch (A.type) {
    case "command":
      return B.type === "command" && A.command === B.command;
    case "prompt":
      return B.type === "prompt" && A.prompt === B.prompt;
    case "function":
      return !1;
  }
}
function vz(A) {
  switch (A.type) {
    case "command":
      return A.command;
    case "prompt":
      return A.prompt;
    case "callback":
      return "callback";
    case "function":
      return "function";
  }
}
function Qn2(A) {
  let B = [],
    Q = ["userSettings", "projectSettings", "localSettings"];
  for (let Z of Q) {
    let Y = cQ(Z);
    if (!Y?.hooks) continue;
    for (let [J, X] of Object.entries(Y.hooks))
      for (let W of X)
        for (let F of W.hooks)
          B.push({ event: J, config: F, matcher: W.matcher, source: Z });
  }
  let I = L0(),
    G = KQ1(A, I);
  for (let [Z, Y] of G.entries())
    for (let J of Y)
      for (let X of J.hooks)
        B.push({
          event: Z,
          config: X,
          matcher: J.matcher,
          source: "sessionHook",
        });
  return B;
}
async function _i2(A, B, Q = "", I = "userSettings") {
  let Z = (cQ(I) ?? {}).hooks ?? {},
    Y = Z[A] ?? [],
    J = Y.findIndex((C) => C.matcher === Q),
    X;
  if (J >= 0) {
    X = [...Y];
    let C = X[J];
    X[J] = { matcher: C.matcher, hooks: [...C.hooks, B] };
  } else X = [...Y, { matcher: Q, hooks: [B] }];
  let W = { ...Z, [A]: X },
    { error: F } = B2(I, { hooks: W });
  if (F) throw Error(F.message);
  _$A();
}
async function Yn2(A) {
  if (A.source === "pluginHook")
    throw Error(
      "Plugin hooks cannot be removed through settings. Disable the plugin instead.",
    );
  if (A.source === "sessionHook")
    throw Error(
      "Session hooks cannot be removed through settings. They are temporary and will be cleared when the session ends.",
    );
  let B = cQ(A.source) ?? {},
    Q = B.hooks ?? {},
    G = (Q[A.event] ?? [])
      .map((J) => {
        if (J.matcher === A.matcher) {
          let X = J.hooks.filter((W) => !k$A(W, A.config));
          return X.length > 0 ? { ...J, hooks: X } : null;
        }
        return J;
      })
      .filter((J) => J !== null),
    Z = { ...Q, [A.event]: G.length > 0 ? G : void 0 },
    Y = Object.values(Z).some((J) => J !== void 0);
  (B2(A.source, { ...B, hooks: Y ? Z : void 0 }), _$A());
}
function ri2(A) {
  switch (A) {
    case "userSettings":
      return "User settings (~/.claude/settings.json)";
    case "projectSettings":
      return "Project settings (.claude/settings.json)";
    case "localSettings":
      return "Local settings (.claude/settings.local.json)";
    case "pluginHook":
      return "Plugin hooks (~/.claude/plugins/*/hooks/hooks.json)";
    case "sessionHook":
      return "Session hooks (in-memory, temporary)";
    default:
      return A;
  }
}
function ni2(A) {
  switch (A) {
    case "userSettings":
      return "User Settings";
    case "projectSettings":
      return "Project Settings";
    case "localSettings":
      return "Local Settings";
    case "pluginHook":
      return "Plugin Hooks";
    case "sessionHook":
      return "Session Hooks";
    default:
      return A;
  }
}
function hi2(A) {
  switch (A) {
    case "userSettings":
      return "User";
    case "projectSettings":
      return "Project";
    case "localSettings":
      return "Local";
    case "pluginHook":
      return "Plugin";
    case "sessionHook":
      return "Session";
    default:
      return A;
  }
}
function In2(A, B, Q) {
  let I = j7A.reduce((G, Z, Y) => {
    return ((G[Z] = Y), G);
  }, {});
  return [...A].sort((G, Z) => {
    let Y = B[Q]?.[G] || [],
      J = B[Q]?.[Z] || [],
      X = Array.from(new Set(Y.map((K) => K.source))),
      W = Array.from(new Set(J.map((K) => K.source))),
      F = (K) => (K === "pluginHook" ? 999 : I[K]),
      C = Math.min(...X.map(F)),
      V = Math.min(...W.map(F));
    if (C !== V) return C - V;
    return G.localeCompare(Z);
  });
}
var zy = T(() => {
  OQ();
  bB1();
  fm();
  VB0();
  i0();
});
function KB0(A) {
  if (!A) return null;
  let B = {},
    Q = Object.keys(A).sort();
  for (let I of Q) {
    let G = A[I];
    if (!G) continue;
    let Z = [...G].sort((Y, J) => {
      let X = Y.matcher || "",
        W = J.matcher || "";
      return X.localeCompare(W);
    });
    B[I] = Z.map((Y) => ({
      matcher: Y.matcher,
      hooks: [...Y.hooks].sort((J, X) => vz(J).localeCompare(vz(X))),
    }));
  }
  return B;
}
function DB0() {
  let A = N0() || {};
  Yp = KB0(A.hooks);
}
function _$A() {
  let A = N0() || {};
  Yp = KB0(A.hooks);
}
function liA(A) {
  Ur2 = A;
}
function mB1() {
  return Ur2;
}
function Jn2() {
  if (Yp === null) return null;
  let A = N0() || {},
    B = KB0(A.hooks),
    Q = JSON.stringify(Yp),
    I = JSON.stringify(B);
  if (Q === I) return null;
  let G = [],
    Z = new Set(Object.keys(Yp || {})),
    Y = new Set(Object.keys(B || {}));
  for (let J of Y) if (!Z.has(J)) G.push(`Added hooks for event: ${J}`);
  for (let J of Z) if (!Y.has(J)) G.push(`Removed all hooks for event: ${J}`);
  for (let J of Z)
    if (Y.has(J)) {
      let X = Yp?.[J] || [],
        W = B?.[J] || [];
      if (JSON.stringify(X) !== JSON.stringify(W)) {
        let F = [],
          C = new Map(X.map((K) => [K.matcher || "", K])),
          V = new Map(W.map((K) => [K.matcher || "", K]));
        for (let [K] of V)
          if (!C.has(K)) F.push(`  - Added matcher: ${K || "(no matcher)"}`);
        for (let [K] of C)
          if (!V.has(K)) F.push(`  - Removed matcher: ${K || "(no matcher)"}`);
        for (let [K, D] of V)
          if (C.has(K)) {
            let E = C.get(K);
            if (JSON.stringify(E.hooks) !== JSON.stringify(D.hooks))
              F.push(`  - Modified hooks for matcher: ${K || "(no matcher)"}`);
          }
        if (F.length > 0)
          (G.push(`Modified hooks for event: ${J}`), G.push(...F));
        else G.push(`Modified hooks for event: ${J}`);
      }
    }
  return G.length > 0
    ? G.join(`
`)
    : "Hooks configuration has been modified";
}
function wr2() {
  if (Yp === null) DB0();
  return Yp;
}
var Yp = null,
  Ur2 = null;
var fm = T(() => {
  OQ();
  zy();
});
function $r2(A) {
  return !("async" in A && A.async === !0);
}
function f7A(A) {
  return "async" in A && A.async === !0;
}
var wBI, $BI, DQ1;
var EB0 = T(() => {
  e2();
  ETA();
  ((wBI = _.object({
    async: _.literal(!0),
    asyncTimeout: _.number().optional(),
  })),
    ($BI = _.object({
      continue: _.boolean()
        .describe("Whether Claude should continue after hook (default: true)")
        .optional(),
      suppressOutput: _.boolean()
        .describe("Hide stdout from transcript (default: false)")
        .optional(),
      stopReason: _.string()
        .describe("Message shown when continue is false")
        .optional(),
      decision: _.enum(["approve", "block"]).optional(),
      reason: _.string().describe("Explanation for the decision").optional(),
      systemMessage: _.string()
        .describe("Warning message shown to the user")
        .optional(),
      hookSpecificOutput: _.union([
        _.object({
          hookEventName: _.literal("PreToolUse"),
          permissionDecision: _.enum(["allow", "deny", "ask"]).optional(),
          permissionDecisionReason: _.string().optional(),
          updatedInput: _.record(_.unknown()).optional(),
        }),
        _.object({
          hookEventName: _.literal("UserPromptSubmit"),
          additionalContext: _.string().optional(),
        }),
        _.object({
          hookEventName: _.literal("SessionStart"),
          additionalContext: _.string().optional(),
        }),
        _.object({
          hookEventName: _.literal("PostToolUse"),
          additionalContext: _.string().optional(),
          updatedMCPToolOutput: _.unknown()
            .describe("Updates the output for MCP tools")
            .optional(),
        }),
      ]).optional(),
    })),
    (DQ1 = _.union([wBI, $BI])));
});
import { randomUUID as qBI } from "crypto";
function NBI(A, B) {
  let Q = a9(),
    I = () => {
      Q.abort();
    };
  (A.addEventListener("abort", I), B.addEventListener("abort", I));
  let G = () => {
    (A.removeEventListener("abort", I), B.removeEventListener("abort", I));
  };
  return { signal: Q.signal, cleanup: G };
}
function LBI(A, B) {
  if (A.includes("$ARGUMENTS")) return A.replaceAll("$ARGUMENTS", B);
  return (
    A +
    `

ARGUMENTS: ${B}`
  );
}
async function qr2(A, B, Q, I, G, Z, Y, J) {
  let X = J || `hook-${qBI()}`;
  try {
    let W = LBI(A.prompt, I);
    g(`Hooks: Processing prompt hook with prompt: ${W}`);
    let F = {
        ...Z,
        onChangeAPIKey: () => {},
        onChangeDynamicMcpConfig: void 0,
        onInstallIDEExtension: void 0,
        resume: void 0,
        options: {
          ...Z.options,
          dynamicMcpConfig: void 0,
          ideInstallationStatus: null,
          theme: "dark",
        },
      },
      C = await Db({
        input: W,
        mode: "prompt",
        setIsLoading: () => {},
        setToolJSX: () => {},
        context: F,
      });
    if (!C.shouldQuery) {
      let N = C.messages.map(($) => {
        if ($.type === "user" && $.message?.content) {
          if (typeof $.message.content === "string") return $.message.content;
          return $.message.content
            .filter((O) => O.type === "text")
            .map((O) => O.text)
            .join("");
        }
        return "";
      }).join(`
`);
      return {
        hook: A,
        outcome: "success",
        message: f8({
          type: "hook_success",
          hookName: B,
          toolUseID: X,
          hookEvent: Q,
          content: N,
        }),
      };
    }
    let V = Y && Y.length > 0 ? [...Y, ...C.messages] : C.messages;
    g(`Hooks: Querying model with ${V.length} messages`);
    let K = A.timeout ? A.timeout * 1000 : 30000,
      D = a9(),
      E = setTimeout(() => {
        D.abort();
      }, K),
      { signal: H, cleanup: w } = NBI(G, D.signal),
      L = [...V, CV({ content: "{" })];
    try {
      let N = await YS({
        messages: L,
        systemPrompt: [
          `You are evaluating a hook in Claude Code.

CRITICAL: You MUST return ONLY valid JSON with no other text, explanation, or commentary before or after the JSON. Do not include any markdown code blocks, thinking, or additional text.

Your response must be a single JSON object matching one of the following schemas:
1. If the condition is met, return: {"ok": true}
2. If the condition is not met, return: {"ok": false, "reason": "Reason for why it is not met"}

Return the JSON object directly with no preamble or explanation.`,
        ],
        maxThinkingTokens: 0,
        tools: Z.options.tools,
        signal: H,
        options: {
          async getToolPermissionContext() {
            return (await Z.getAppState()).toolPermissionContext;
          },
          model: A.model ?? FW(),
          toolChoice: void 0,
          isNonInteractiveSession: !0,
          hasAppendSystemPrompt: !1,
          agents: [],
          querySource: "hook_prompt",
          mcpTools: [],
        },
      });
      (clearTimeout(E), w());
      let O = (
        "{" +
        N.message.content
          .filter((b) => b.type === "text")
          .map((b) => b.text)
          .join("")
      ).trim();
      g(`Hooks: Model response: ${O}`);
      let P = b3(O);
      if (!P)
        return (
          g(`Hooks: error parsing response as JSON: ${O}`),
          {
            hook: A,
            outcome: "non_blocking_error",
            message: f8({
              type: "hook_non_blocking_error",
              hookName: B,
              toolUseID: X,
              hookEvent: Q,
              stderr: "JSON validation failed",
              stdout: O,
              exitCode: 1,
            }),
          }
        );
      let k = MBI.safeParse(P);
      if (!k.success)
        return (
          g(
            `Hooks: model response does not conform to expected schema: ${k.error.message}`,
          ),
          {
            hook: A,
            outcome: "non_blocking_error",
            message: f8({
              type: "hook_non_blocking_error",
              hookName: B,
              toolUseID: X,
              hookEvent: Q,
              stderr: `Schema validation failed: ${k.error.message}`,
              stdout: O,
              exitCode: 1,
            }),
          }
        );
      if (!k.data.ok)
        return (
          g(`Hooks: Prompt hook condition was not met: ${k.data.reason}`),
          {
            hook: A,
            outcome: "blocking",
            blockingError: {
              blockingError: `Prompt hook condition was not met: ${k.data.reason}`,
              command: A.prompt,
            },
            preventContinuation: !0,
            stopReason: k.data.reason,
          }
        );
      return (
        g("Hooks: Prompt hook condition was met"),
        {
          hook: A,
          outcome: "success",
          message: f8({
            type: "hook_success",
            hookName: B,
            toolUseID: X,
            hookEvent: Q,
            content: "Condition met",
          }),
        }
      );
    } catch (N) {
      if ((clearTimeout(E), w(), H.aborted))
        return { hook: A, outcome: "cancelled" };
      throw N;
    }
  } catch (W) {
    let F = W instanceof Error ? W.message : String(W);
    return (
      g(`Hooks: Prompt hook error: ${F}`),
      {
        hook: A,
        outcome: "non_blocking_error",
        message: f8({
          type: "hook_non_blocking_error",
          hookName: B,
          toolUseID: X,
          hookEvent: Q,
          stderr: `Error executing prompt hook: ${F}`,
          stdout: "",
          exitCode: 1,
        }),
      }
    );
  }
}
var MBI;
var Nr2 = T(() => {
  C0();
  mwA();
  iB();
  zG();
  Y9();
  vG();
  e2();
  uj();
  wC();
  MBI = PQ.object({
    ok: PQ.boolean().describe("Whether the condition was met"),
    reason: PQ.string()
      .describe("Reason, if the condition was not met")
      .optional(),
  });
});
var Rr2 = {};
M$(Rr2, {
  getUserPromptSubmitHookBlockingMessage: () => qe1,
  getStopHookMessage: () => bc1,
  getPreToolHookBlockingMessage: () => vc1,
  getMatchingHooks: () => zB0,
  executeUserPromptSubmitHooks: () => Ne1,
  executeStopHooks: () => gc1,
  executeStatusLineCommand: () => Ae1,
  executeSessionStartHooks: () => Mv1,
  executeSessionEndHooks: () => vA0,
  executePreToolHooks: () => fc1,
  executePreCompactHooks: () => Ov1,
  executePostToolHooks: () => hc1,
  executeNotificationHooks: () => Up1,
  createBaseHookInput: () => KL,
});
import { spawn as OBI } from "node:child_process";
import { randomUUID as i$A } from "crypto";
function Lr2() {
  if (!!K5()) return !1;
  return !fX(!1);
}
function KL(A, B) {
  let Q = B ?? L0();
  return {
    session_id: Q,
    transcript_path: EQ1(Q),
    cwd: G0(),
    permission_mode: A,
  };
}
function Mr2(A) {
  let B = A.trim();
  if (!B.startsWith("{"))
    return (
      g("Hook output does not start with {, treating as plain text"),
      { plainText: A }
    );
  try {
    let Q = JSON.parse(B),
      I = DQ1.safeParse(Q);
    if (I.success)
      return (
        g("Successfully parsed and validated hook JSON output"),
        { json: I.data }
      );
    else {
      let Z = `Hook JSON output validation failed:
${I.error.errors.map((Y) => `  - ${Y.path.join(".")}: ${Y.message}`).join(`
`)}

Expected schema:
${JSON.stringify({ continue: "boolean (optional)", suppressOutput: "boolean (optional)", stopReason: "string (optional)", decision: '"approve" | "block" (optional)', reason: "string (optional)", systemMessage: "string (optional)", permissionDecision: '"allow" | "deny" | "ask" (optional)', hookSpecificOutput: { "for PreToolUse": { hookEventName: '"PreToolUse"', permissionDecision: '"allow" | "deny" | "ask" (optional)', permissionDecisionReason: "string (optional)", updatedInput: "object (optional) - Modified tool input to use" }, "for UserPromptSubmit": { hookEventName: '"UserPromptSubmit"', additionalContext: "string (required)" }, "for PostToolUse": { hookEventName: '"PostToolUse"', additionalContext: "string (optional)" } } }, null, 2)}. The hook's stdout was: ${JSON.stringify(Q, null, 2)}`;
      return (g(Z), { plainText: A, validationError: Z });
    }
  } catch (Q) {
    return (g(`Failed to parse hook output as JSON: ${Q}`), { plainText: A });
  }
}
function Or2({
  json: A,
  command: B,
  hookName: Q,
  toolUseID: I,
  hookEvent: G,
  expectedHookEvent: Z,
  stdout: Y,
  stderr: J,
  exitCode: X,
}) {
  let W = {},
    F = A;
  if (F.continue === !1) {
    if (((W.preventContinuation = !0), F.stopReason))
      W.stopReason = F.stopReason;
  }
  if (A.decision)
    switch (A.decision) {
      case "approve":
        W.permissionBehavior = "allow";
        break;
      case "block":
        ((W.permissionBehavior = "deny"),
          (W.blockingError = {
            blockingError: A.reason || "Blocked by hook",
            command: B,
          }));
        break;
      default:
        throw Error(
          `Unknown hook decision type: ${A.decision}. Valid types are: approve, block`,
        );
    }
  if (A.systemMessage) W.systemMessage = A.systemMessage;
  if (
    A.hookSpecificOutput?.hookEventName === "PreToolUse" &&
    A.hookSpecificOutput.permissionDecision
  )
    switch (A.hookSpecificOutput.permissionDecision) {
      case "allow":
        W.permissionBehavior = "allow";
        break;
      case "deny":
        ((W.permissionBehavior = "deny"),
          (W.blockingError = {
            blockingError: A.reason || "Blocked by hook",
            command: B,
          }));
        break;
      case "ask":
        W.permissionBehavior = "ask";
        break;
      default:
        throw Error(
          `Unknown hook permissionDecision type: ${A.hookSpecificOutput.permissionDecision}. Valid types are: allow, deny, ask`,
        );
    }
  if (W.permissionBehavior !== void 0 && A.reason !== void 0)
    W.hookPermissionDecisionReason = A.reason;
  if (A.hookSpecificOutput) {
    if (Z && A.hookSpecificOutput.hookEventName !== Z)
      throw Error(
        `Hook returned incorrect event name: expected '${Z}' but got '${A.hookSpecificOutput.hookEventName}'. Full stdout: ${JSON.stringify(A, null, 2)}`,
      );
    switch (A.hookSpecificOutput.hookEventName) {
      case "PreToolUse":
        if (A.hookSpecificOutput.permissionDecision)
          switch (A.hookSpecificOutput.permissionDecision) {
            case "allow":
              W.permissionBehavior = "allow";
              break;
            case "deny":
              ((W.permissionBehavior = "deny"),
                (W.blockingError = {
                  blockingError:
                    A.hookSpecificOutput.permissionDecisionReason ||
                    A.reason ||
                    "Blocked by hook",
                  command: B,
                }));
              break;
            case "ask":
              W.permissionBehavior = "ask";
              break;
          }
        if (
          ((W.hookPermissionDecisionReason =
            A.hookSpecificOutput.permissionDecisionReason),
          A.hookSpecificOutput.updatedInput)
        )
          W.updatedInput = A.hookSpecificOutput.updatedInput;
        break;
      case "UserPromptSubmit":
        W.additionalContext = A.hookSpecificOutput.additionalContext;
        break;
      case "SessionStart":
        W.additionalContext = A.hookSpecificOutput.additionalContext;
        break;
      case "PostToolUse":
        if (
          ((W.additionalContext = A.hookSpecificOutput.additionalContext),
          A.hookSpecificOutput.updatedMCPToolOutput)
        )
          W.updatedMCPToolOutput = A.hookSpecificOutput.updatedMCPToolOutput;
        break;
    }
  }
  return {
    ...W,
    message: W.blockingError
      ? f8({
          type: "hook_blocking_error",
          hookName: Q,
          toolUseID: I,
          hookEvent: G,
          blockingError: W.blockingError,
        })
      : f8({
          type: "hook_success",
          hookName: Q,
          toolUseID: I,
          hookEvent: G,
          content: "Success",
          stdout: Y,
          stderr: J,
          exitCode: X,
        }),
  };
}
async function HB0(A, B, Q, I, G, Z) {
  let Y = GQ(),
    J = process.env.CLAUDE_CODE_SHELL_PREFIX
      ? fPA(process.env.CLAUDE_CODE_SHELL_PREFIX, A.command)
      : A.command,
    X = A.timeout ? A.timeout * 1000 : 60000,
    W = { ...process.env, CLAUDE_PROJECT_DIR: Y };
  if (B === "SessionStart" && Z !== void 0) W.CLAUDE_ENV_FILE = ey0(Z);
  let F = OBI(J, [], { env: W, cwd: G0(), shell: !0 }),
    C = bPA(F, G, X),
    V = "",
    K = "";
  (F.stdout.setEncoding("utf8"), F.stderr.setEncoding("utf8"));
  let D = !1,
    E = null,
    H = new Promise(($) => {
      E = $;
    });
  (F.stdout.on("data", ($) => {
    if (((V += $), !D && V.trim().includes("}"))) {
      ((D = !0), g(`Hooks: Checking initial response for async: ${V.trim()}`));
      try {
        let O = JSON.parse(V.trim());
        if (
          (g(`Hooks: Parsed initial response: ${JSON.stringify(O)}`), f7A(O))
        ) {
          let P = `async_hook_${F.pid}`;
          g(`Hooks: Detected async hook, backgrounding process ${P}`);
          let k = C.background(P);
          if (k)
            (rNQ({
              processId: P,
              asyncResponse: O,
              hookEvent: B,
              hookName: Q,
              command: A.command,
              shellCommand: C,
            }),
              k.stdoutStream.on("data", (b) => {
                oNQ(P, b.toString());
              }),
              k.stderrStream.on("data", (b) => {
                tNQ(P, b.toString());
              }),
              E?.({ stdout: V, stderr: K, status: 0 }));
        } else
          g(
            "Hooks: Initial response is not async, continuing normal processing",
          );
      } catch (O) {
        g(`Hooks: Failed to parse initial response as JSON: ${O}`);
      }
    }
  }),
    F.stderr.on("data", ($) => {
      K += $;
    }));
  let w = new Promise(($, O) => {
      (F.stdin.on("error", O), F.stdin.write(I, "utf8"), F.stdin.end(), $());
    }),
    L = new Promise(($, O) => {
      F.on("error", O);
    }),
    N = new Promise(($) => {
      F.on("close", (O) => {
        $({ stdout: V, stderr: K, status: O ?? 1, aborted: G.aborted });
      });
    });
  try {
    return (await Promise.race([w, L]), await Promise.race([H, N, L]));
  } catch ($) {
    let O = $;
    if (O.code === "EPIPE")
      return (
        g(
          "EPIPE error while writing to hook stdin (hook command likely closed early)",
        ),
        {
          stdout: "",
          stderr:
            "Hook command closed stdin before hook input was fully written (EPIPE)",
          status: 1,
        }
      );
    else if (O.code === "ABORT_ERR")
      return { stdout: "", stderr: "Hook cancelled", status: 1, aborted: !0 };
    else
      return {
        stdout: "",
        stderr: `Error occurred while executing hook command: ${$ instanceof Error ? $.message : String($)}`,
        status: 1,
      };
  }
}
function RBI(A, B) {
  if (!B || B === "*") return !0;
  if (/^[a-zA-Z0-9_|]+$/.test(B)) {
    if (B.includes("|"))
      return B.split("|")
        .map((I) => I.trim())
        .includes(A);
    return A === B;
  }
  try {
    return new RegExp(B).test(A);
  } catch {
    return (g(`Invalid regex pattern in hook matcher: ${B}`), !1);
  }
}
function TBI(A) {
  let B = {},
    Q = wr2();
  if (Q)
    for (let [G, Z] of Object.entries(Q))
      B[G] = Z.map((Y) => ({ matcher: Y.matcher, hooks: Y.hooks }));
  let I = mB1();
  if (I)
    for (let [G, Z] of Object.entries(I)) {
      if (!B[G]) B[G] = [];
      for (let Y of Z) B[G].push({ matcher: Y.matcher, hooks: Y.hooks });
    }
  if (A) {
    let G = L0(),
      Z = KQ1(A, G);
    for (let [Y, J] of Z.entries()) {
      if (!B[Y]) B[Y] = [];
      for (let X of J) B[Y].push({ matcher: X.matcher, hooks: X.hooks });
    }
  }
  return B;
}
function zB0(A, B, Q) {
  try {
    let G = TBI(A)?.[B] ?? [],
      Z = void 0;
    switch (Q.hook_event_name) {
      case "PreToolUse":
      case "PostToolUse":
        Z = Q.tool_name;
        break;
      case "SessionStart":
        Z = Q.source;
        break;
      case "PreCompact":
        Z = Q.trigger;
        break;
      case "Notification":
        Z = Q.notification_type;
        break;
      case "SessionEnd":
        Z = Q.reason;
        break;
      default:
        break;
    }
    (g(`Getting matching hook commands for ${B} with query: ${Z}`),
      g(`Found ${G.length} hook matchers in settings`));
    let Y;
    if (!Z) Y = G.flatMap((C) => C.hooks);
    else
      Y = G.filter((C) => !C.matcher || RBI(Z, C.matcher)).flatMap(
        (C) => C.hooks,
      );
    let J = Array.from(
        new Map(
          Y.filter((C) => C.type === "command").map((C) => [C.command, C]),
        ).values(),
      ),
      X = Array.from(
        new Map(
          Y.filter((C) => C.type === "prompt").map((C) => [C.prompt, C]),
        ).values(),
      ),
      W = Y.filter((C) => C.type === "callback"),
      F = [...J, ...X, ...W];
    return (
      g(
        `Matched ${F.length} unique hooks for query "${Z || "no match query"}" (${Y.length} before deduplication)`,
      ),
      F
    );
  } catch {
    return [];
  }
}
function vc1(A, B) {
  return `${A} hook error: ${B.blockingError}`;
}
function bc1(A) {
  return `Stop hook feedback:
${A.blockingError}`;
}
function qe1(A) {
  return `UserPromptSubmit operation blocked by hook:
${A.blockingError}`;
}
function l$A(A, B) {
  let Q = a9(),
    I = () => {
      Q.abort();
    };
  (A.addEventListener("abort", I), B?.addEventListener("abort", I));
  let G = () => {
    (A.removeEventListener("abort", I), B?.removeEventListener("abort", I));
  };
  return { abortSignal: Q.signal, cleanup: G };
}
async function* n$A({
  hookInput: A,
  toolUseID: B,
  matchQuery: Q,
  signal: I,
  timeoutMs: G = qy,
  toolUseContext: Z,
  messages: Y,
}) {
  if (N0().disableAllHooks) return;
  let J = A.hook_event_name,
    X = Q ? `${J}:${Q}` : J;
  if (Lr2()) {
    g(`Skipping ${X} hook execution - workspace trust not accepted`);
    return;
  }
  let W = Z ? await Z.getAppState() : void 0,
    F = zB0(W, J, A);
  if (F.length === 0) return;
  if (I?.aborted) return;
  GA("tengu_run_hook", { hookName: X, numCommands: F.length });
  for (let D of F)
    yield {
      message: {
        type: "progress",
        data: {
          type: "hook_progress",
          hookEvent: J,
          hookName: X,
          command: vz(D),
          promptText: D.type === "prompt" ? D.prompt : void 0,
        },
        parentToolUseID: B,
        toolUseID: B,
        timestamp: new Date().toISOString(),
        uuid: i$A(),
      },
    };
  let C = F.map(async function* (D, E) {
      if (D.type === "callback") {
        let N = D.timeout ? D.timeout * 1000 : G,
          { abortSignal: $, cleanup: O } = l$A(AbortSignal.timeout(N), I);
        yield jBI({
          toolUseID: B,
          hook: D,
          hookEvent: J,
          hookInput: A,
          signal: $,
        }).finally(O);
        return;
      }
      if (D.type === "function") {
        if (!Y) {
          yield {
            message: f8({
              type: "hook_error_during_execution",
              hookName: X,
              toolUseID: B,
              hookEvent: J,
              content: "Messages not provided for function hook",
            }),
            outcome: "non_blocking_error",
            hook: D,
          };
          return;
        }
        yield PBI({
          hook: D,
          messages: Y,
          hookName: X,
          toolUseID: B,
          hookEvent: J,
          timeoutMs: G,
          signal: I,
        });
        return;
      }
      let H = D.timeout ? D.timeout * 1000 : G,
        { abortSignal: w, cleanup: L } = l$A(AbortSignal.timeout(H), I);
      try {
        let N;
        try {
          N = JSON.stringify(A);
        } catch (b) {
          (BA(Error(`Failed to stringify hook ${X} input`, { cause: b }), rZ0),
            yield {
              message: f8({
                type: "hook_error_during_execution",
                hookName: X,
                toolUseID: B,
                hookEvent: J,
                content: `Failed to prepare hook input: ${b instanceof Error ? b.message : String(b)}`,
              }),
              outcome: "non_blocking_error",
              hook: D,
            });
          return;
        }
        if (D.type === "prompt") {
          if (!Z)
            throw Error(
              "ToolUseContext is required for prompt hooks. This is a bug.",
            );
          (yield await qr2(D, X, J, N, w, Z, Y, B), L?.());
          return;
        }
        let $ = await HB0(D, J, X, N, w, E);
        if ((L?.(), $.aborted)) {
          yield {
            message: f8({
              type: "hook_cancelled",
              hookName: X,
              toolUseID: B,
              hookEvent: J,
            }),
            outcome: "cancelled",
            hook: D,
          };
          return;
        }
        let { json: O, plainText: P, validationError: k } = Mr2($.stdout);
        if (k) {
          yield {
            message: f8({
              type: "hook_non_blocking_error",
              hookName: X,
              toolUseID: B,
              hookEvent: J,
              stderr: `JSON validation failed: ${k}`,
              stdout: $.stdout,
              exitCode: 1,
            }),
            outcome: "non_blocking_error",
            hook: D,
          };
          return;
        }
        if (O) {
          if (f7A(O)) {
            yield { outcome: "success", hook: D };
            return;
          }
          let b = Or2({
            json: O,
            command: D.type === "command" ? D.command : "prompt",
            hookName: X,
            toolUseID: B,
            hookEvent: J,
            expectedHookEvent: J,
            stdout: $.stdout,
            stderr: $.stderr,
            exitCode: $.status,
          });
          if ($r2(O) && !O.suppressOutput && P && $.status === 0) {
            let x = `${iA.bold(X)} completed`;
            yield {
              ...b,
              message:
                b.message ||
                f8({
                  type: "hook_success",
                  hookName: X,
                  toolUseID: B,
                  hookEvent: J,
                  content: x,
                  stdout: $.stdout,
                  stderr: $.stderr,
                  exitCode: $.status,
                }),
              outcome: "success",
              hook: D,
            };
            return;
          }
          yield { ...b, outcome: "success", hook: D };
          return;
        }
        if ($.status === 0) {
          yield {
            message: f8({
              type: "hook_success",
              hookName: X,
              toolUseID: B,
              hookEvent: J,
              content: $.stdout.trim(),
              stdout: $.stdout,
              stderr: $.stderr,
              exitCode: $.status,
            }),
            outcome: "success",
            hook: D,
          };
          return;
        }
        if ($.status === 2) {
          yield {
            blockingError: {
              blockingError: `[${D.command}]: ${$.stderr || "No stderr output"}`,
              command: D.command,
            },
            outcome: "blocking",
            hook: D,
          };
          return;
        }
        yield {
          message: f8({
            type: "hook_non_blocking_error",
            hookName: X,
            toolUseID: B,
            hookEvent: J,
            stderr: `Failed with non-blocking status code: ${$.stderr.trim() || "No stderr output"}`,
            stdout: $.stdout,
            exitCode: $.status,
          }),
          outcome: "non_blocking_error",
          hook: D,
        };
        return;
      } catch (N) {
        L?.();
        let $ = N instanceof Error ? N.message : String(N);
        yield {
          message: f8({
            type: "hook_non_blocking_error",
            hookName: X,
            toolUseID: B,
            hookEvent: J,
            stderr: `Failed to run: ${$}`,
            stdout: "",
            exitCode: 1,
          }),
          outcome: "non_blocking_error",
          hook: D,
        };
        return;
      }
    }),
    V = { success: 0, blocking: 0, non_blocking_error: 0, cancelled: 0 },
    K;
  for await (let D of IsA(C)) {
    if ((V[D.outcome]++, D.preventContinuation))
      yield { preventContinuation: !0, stopReason: D.stopReason };
    if (D.blockingError) yield { blockingError: D.blockingError };
    if (D.message) yield { message: D.message };
    if (D.systemMessage)
      yield {
        message: f8({
          type: "hook_system_message",
          content: D.systemMessage,
          hookName: X,
          toolUseID: B,
          hookEvent: J,
        }),
      };
    if (D.additionalContext)
      yield { additionalContexts: [D.additionalContext] };
    if (D.updatedMCPToolOutput)
      yield { updatedMCPToolOutput: D.updatedMCPToolOutput };
    if (D.permissionBehavior)
      switch (D.permissionBehavior) {
        case "deny":
          K = "deny";
          break;
        case "ask":
          if (K !== "deny") K = "ask";
          break;
        case "allow":
          if (!K) K = "allow";
          break;
        case "passthrough":
          break;
      }
    if (K !== void 0)
      yield {
        permissionBehavior: K,
        hookPermissionDecisionReason: D.hookPermissionDecisionReason,
        updatedInput:
          D.updatedInput && D.permissionBehavior === "allow"
            ? D.updatedInput
            : void 0,
      };
    if (W && D.hook.type !== "callback") {
      let E = L0(),
        w = Hr2(W, E, J, Q ?? "", D.hook);
      if (w?.onMatch)
        try {
          w.onMatch(D.hook, D);
        } catch (L) {
          BA(Error("Session hook callback failed", { cause: L }), qZA);
        }
    }
  }
  GA("tengu_repl_hook_finished", {
    hookName: X,
    numCommands: F.length,
    numSuccess: V.success,
    numBlocking: V.blocking,
    numNonBlockingError: V.non_blocking_error,
    numCancelled: V.cancelled,
  });
}
async function UB0({
  getAppState: A,
  hookInput: B,
  matchQuery: Q,
  signal: I,
  timeoutMs: G = qy,
}) {
  let Z = B.hook_event_name,
    Y = Q ? `${Z}:${Q}` : Z;
  if (N0().disableAllHooks)
    return (g(`Skipping hooks for ${Y} due to 'disableAllHooks' setting`), []);
  if (Lr2())
    return (
      g(`Skipping ${Y} hook execution - workspace trust not accepted`),
      []
    );
  let J = A ? await A() : void 0,
    X = zB0(J, Z, B);
  if (X.length === 0) return [];
  if (I?.aborted) return [];
  GA("tengu_run_hook", { hookName: Y, numCommands: X.length });
  let W;
  try {
    W = JSON.stringify(B);
  } catch (C) {
    return (BA(C instanceof Error ? C : Error(String(C)), qZA), []);
  }
  let F = X.map(async (C, V) => {
    if (C.type === "callback") {
      let H = C.timeout ? C.timeout * 1000 : G,
        { abortSignal: w, cleanup: L } = l$A(AbortSignal.timeout(H), I);
      try {
        let N = i$A(),
          $ = await C.callback(B, N, w);
        if ((L?.(), f7A($)))
          return (
            g(
              `${Y} [callback] returned async response, returning empty output`,
            ),
            { command: "callback", succeeded: !0, output: "" }
          );
        let O = $.systemMessage || "";
        return (
          g(`${Y} [callback] completed successfully`),
          { command: "callback", succeeded: !0, output: O }
        );
      } catch (N) {
        L?.();
        let $ = N instanceof Error ? N.message : String(N);
        return (
          g(`${Y} [callback] failed to run: ${$}`, { level: "error" }),
          { command: "callback", succeeded: !1, output: $ }
        );
      }
    }
    if (C.type === "prompt")
      return {
        command: C.prompt,
        succeeded: !1,
        output: "Prompt stop hooks are not yet supported outside REPL",
      };
    if (C.type === "function")
      return (
        BA(
          Error(
            `Function hook reached executeHooksOutsideREPL for ${Z}. Function hooks should only be used in REPL context (Stop hooks).`,
          ),
          qZA,
        ),
        {
          command: "function",
          succeeded: !1,
          output: "Internal error: function hook executed outside REPL context",
        }
      );
    let K = C.timeout ? C.timeout * 1000 : G,
      { abortSignal: D, cleanup: E } = l$A(AbortSignal.timeout(K), I);
    try {
      let H = await HB0(C, Z, Y, W, D, V);
      if ((E?.(), H.aborted))
        return (
          g(`${Y} [${C.command}] cancelled`),
          { command: C.command, succeeded: !1, output: "Hook cancelled" }
        );
      g(`${Y} [${C.command}] completed with status ${H.status}`);
      let { json: w, validationError: L } = Mr2(H.stdout);
      if (L)
        throw (
          JT(
            `${iA.bold(Y)} [${C.command}] ${iA.yellow("Hook JSON output validation failed")}`,
          ),
          Error(L)
        );
      if (w && !f7A(w)) {
        if (
          (g(`Parsed JSON output from hook: ${JSON.stringify(w)}`),
          w.systemMessage)
        )
          F9(w.systemMessage);
      }
      let N = H.status === 0 ? H.stdout || "" : H.stderr || "";
      return { command: C.command, succeeded: H.status === 0, output: N };
    } catch (H) {
      E?.();
      let w = H instanceof Error ? H.message : String(H);
      return (
        g(`${Y} [${C.command}] failed to run: ${w}`, { level: "error" }),
        { command: C.command, succeeded: !1, output: w }
      );
    }
  });
  return await Promise.all(F);
}
async function* fc1(A, B, Q, I, G, Z, Y = qy) {
  g(`executePreToolHooks called for tool: ${A}`);
  let J = {
    ...KL(G),
    hook_event_name: "PreToolUse",
    tool_name: A,
    tool_input: Q,
  };
  yield* n$A({
    hookInput: J,
    toolUseID: B,
    matchQuery: A,
    signal: Z,
    timeoutMs: Y,
    toolUseContext: I,
  });
}
async function* hc1(A, B, Q, I, G, Z, Y, J = qy) {
  let X = {
    ...KL(Z),
    hook_event_name: "PostToolUse",
    tool_name: A,
    tool_input: Q,
    tool_response: I,
  };
  yield* n$A({
    hookInput: X,
    toolUseID: B,
    matchQuery: A,
    signal: Y,
    timeoutMs: J,
    toolUseContext: G,
  });
}
async function Up1(A, B = qy) {
  let { message: Q, title: I, notificationType: G } = A,
    Z = {
      ...KL(void 0),
      hook_event_name: "Notification",
      message: Q,
      title: I,
      notification_type: G,
    };
  await UB0({ hookInput: Z, timeoutMs: B, matchQuery: G });
}
async function* gc1(A, B, Q = qy, I = !1, G, Z, Y) {
  let J = G
    ? {
        ...KL(A),
        hook_event_name: "SubagentStop",
        stop_hook_active: I,
        agent_id: G,
        agent_transcript_path: HQ1(G),
      }
    : { ...KL(A), hook_event_name: "Stop", stop_hook_active: I };
  yield* n$A({
    hookInput: J,
    toolUseID: i$A(),
    signal: B,
    timeoutMs: Q,
    toolUseContext: Z,
    messages: Y,
  });
}
async function* Ne1(A, B, Q) {
  let I = { ...KL(B), hook_event_name: "UserPromptSubmit", prompt: A };
  yield* n$A({
    hookInput: I,
    toolUseID: i$A(),
    signal: Q.abortController.signal,
    timeoutMs: qy,
    toolUseContext: Q,
  });
}
async function* Mv1(A, B, Q, I = qy) {
  let G = { ...KL(void 0, B), hook_event_name: "SessionStart", source: A };
  yield* n$A({
    hookInput: G,
    toolUseID: i$A(),
    matchQuery: A,
    signal: Q,
    timeoutMs: I,
  });
}
async function Ov1(A, B, Q = qy) {
  let I = {
      ...KL(void 0),
      hook_event_name: "PreCompact",
      trigger: A.trigger,
      custom_instructions: A.customInstructions,
    },
    G = await UB0({
      hookInput: I,
      matchQuery: A.trigger,
      signal: B,
      timeoutMs: Q,
    });
  if (G.length === 0) return {};
  let Z = G.filter((J) => J.succeeded && J.output.trim().length > 0).map((J) =>
      J.output.trim(),
    ),
    Y = [];
  for (let J of G)
    if (J.succeeded)
      if (J.output.trim())
        Y.push(
          `PreCompact [${J.command}] completed successfully: ${J.output.trim()}`,
        );
      else Y.push(`PreCompact [${J.command}] completed successfully`);
    else if (J.output.trim())
      Y.push(`PreCompact [${J.command}] failed: ${J.output.trim()}`);
    else Y.push(`PreCompact [${J.command}] failed`);
  return {
    newCustomInstructions:
      Z.length > 0
        ? Z.join(`

`)
        : void 0,
    userDisplayMessage:
      Y.length > 0
        ? Y.join(`
`)
        : void 0,
  };
}
async function vA0(A, B) {
  let {
      getAppState: Q,
      setAppState: I,
      signal: G,
      timeoutMs: Z = qy,
    } = B || {},
    Y = { ...KL(void 0), hook_event_name: "SessionEnd", reason: A };
  if (
    (await UB0({
      getAppState: Q,
      hookInput: Y,
      matchQuery: A,
      signal: G,
      timeoutMs: Z,
    }),
    I)
  ) {
    let J = L0();
    zr2(I, J);
  }
}
async function Ae1(A, B, Q = 5000) {
  let I = N0(),
    G = I?.statusLine;
  if (I?.disableAllHooks === !0) return;
  if (!G || G.type !== "command") return;
  let Z = B || AbortSignal.timeout(Q);
  try {
    let Y = JSON.stringify(A),
      J = await HB0(G, "StatusLine", "statusLine", Y, Z);
    if (J.aborted) return;
    if (J.status === 0) {
      let X = J.stdout
        .trim()
        .split(
          `
`,
        )
        .flatMap((W) => W.trim() || []).join(`
`);
      if (X) return X;
    }
    return;
  } catch (Y) {
    g(`Status hook failed: ${Y}`, { level: "error" });
    return;
  }
}
async function PBI({
  hook: A,
  messages: B,
  hookName: Q,
  toolUseID: I,
  hookEvent: G,
  timeoutMs: Z,
  signal: Y,
}) {
  let J = A.timeout ?? Z,
    { abortSignal: X, cleanup: W } = l$A(AbortSignal.timeout(J), Y);
  try {
    if (X.aborted) return (W(), { outcome: "cancelled", hook: A });
    let F = await new Promise((C, V) => {
      let K = () => V(Error("Function hook cancelled"));
      (X.addEventListener("abort", K),
        Promise.resolve(A.callback(B, X))
          .then((D) => {
            (X.removeEventListener("abort", K), C(D));
          })
          .catch((D) => {
            (X.removeEventListener("abort", K), V(D));
          }));
    });
    if ((W(), F)) return { outcome: "success", hook: A };
    return {
      blockingError: { blockingError: A.errorMessage, command: "function" },
      outcome: "blocking",
      hook: A,
    };
  } catch (F) {
    if (
      (W(),
      F instanceof Error &&
        (F.message === "Function hook cancelled" || F.name === "AbortError"))
    )
      return { outcome: "cancelled", hook: A };
    return (
      BA(F instanceof Error ? F : Error(String(F)), qZA),
      {
        message: f8({
          type: "hook_error_during_execution",
          hookName: Q,
          toolUseID: I,
          hookEvent: G,
          content:
            F instanceof Error ? F.message : "Function hook execution error",
        }),
        outcome: "non_blocking_error",
        hook: A,
      }
    );
  }
}
async function jBI({
  toolUseID: A,
  hook: B,
  hookEvent: Q,
  hookInput: I,
  signal: G,
}) {
  let Z = await B.callback(I, A, G);
  if (f7A(Z)) return { outcome: "success", hook: B };
  return {
    ...Or2({
      json: Z,
      command: "callback",
      hookName: `${Q}:Callback`,
      toolUseID: A,
      hookEvent: Q,
      expectedHookEvent: Q,
      stdout: void 0,
      stderr: void 0,
      exitCode: void 0,
    }),
    outcome: "success",
    hook: B,
  };
}
var qy = 60000;
var mj = T(() => {
  iY1();
  V2();
  nY1();
  hPA();
  i0();
  kB();
  fm();
  E7();
  OQ();
  H0();
  EB0();
  f2();
  zy();
  C0();
  c1();
  vG();
  Uv1();
  uj();
  Gr();
  Nr2();
  VB0();
});
function SBI() {
  try {
    if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function")
      (process.stdin.setRawMode(!1), process.stdin.unref());
  } catch {}
}
function D8(A = 0, B = "other", Q) {
  ((process.exitCode = A),
    P6(A, B, Q).catch((I) => {
      (g(`Graceful shutdown failed: ${I}`, { level: "error" }),
        process.exit(A));
    }));
}
async function P6(A = 0, B = "other", Q) {
  ((process.exitCode = A), SBI());
  try {
    let { executeSessionEndHooks: I } = await Promise.resolve().then(
      () => (mj(), Rr2),
    );
    await I(B, Q);
  } catch {}
  try {
    let I = (async () => {
      try {
        await I60();
      } catch {}
    })();
    (await Promise.race([
      I,
      new Promise((G, Z) =>
        setTimeout(() => Z(Error("Cleanup timeout")), 2000),
      ),
    ]),
      process.exit(A));
  } catch {
    process.exit(A);
  }
}
var Tr2;
var xY = T(() => {
  a2();
  C0();
  BU();
  Tr2 = I0(() => {
    (process.on("SIGINT", () => {
      P6(0);
    }),
      process.on("SIGTERM", () => {
        P6(143);
      }));
  });
});
function IB(A) {
  let [B, Q] = Pr2.useState({ pending: !1, keyName: null }),
    I = vk(
      (Z) => Q({ pending: Z, keyName: "Ctrl-C" }),
      A
        ? A
        : async () => {
            await P6(0);
          },
    ),
    G = vk(
      (Z) => Q({ pending: Z, keyName: "Ctrl-D" }),
      A
        ? A
        : async () => {
            await P6(0);
          },
    );
  return (
    h1((Z, Y) => {
      if (Y.ctrl && Z === "c") I();
      if (Y.ctrl && Z === "d") G();
    }),
    B
  );
}
var Pr2;
var R9 = T(() => {
  nA();
  xPA();
  xY();
  Pr2 = IA(KA(), 1);
});
function jr2() {
  return U4.createElement(
    U,
    { dimColor: !0 },
    "Claude Code will be able to read files in this directory and make edits when auto-accept edits is on.",
  );
}
function kBI({ path: A }) {
  return U4.createElement(
    S,
    { flexDirection: "column", paddingX: 2, gap: 1 },
    U4.createElement(U, { color: "permission" }, A),
    U4.createElement(jr2, null),
  );
}
function _BI({ value: A, onChange: B, onSubmit: Q, error: I }) {
  return U4.createElement(
    S,
    { flexDirection: "column" },
    U4.createElement(U, null, "Enter the path to the directory:"),
    U4.createElement(
      S,
      { borderDimColor: !0, borderStyle: "round", marginY: 1, paddingLeft: 1 },
      U4.createElement(O4, {
        showCursor: !0,
        placeholder: `Directory path${E1.ellipsis}`,
        value: A,
        onChange: B,
        onSubmit: Q,
        columns: 80,
        cursorOffset: A.length,
        onChangeCursorOffset: () => {},
      }),
    ),
    I && U4.createElement(U, { color: "error" }, I),
  );
}
function fB1({
  onAddDirectory: A,
  onCancel: B,
  permissionContext: Q,
  directoryPath: I,
}) {
  let [G, Z] = jb.useState(""),
    [Y, J] = jb.useState(null),
    X = IB(),
    W = jb.useMemo(() => yBI, []);
  h1(
    jb.useCallback(
      (V, K) => {
        if (K.escape || (K.ctrl && V === "c")) B();
      },
      [B],
    ),
  );
  let F = jb.useCallback(
      (V) => {
        let K = a$A(V, Q);
        if (K.resultType === "success") A(K.absolutePath, !1);
        else J(s$A(K));
      },
      [Q, A],
    ),
    C = jb.useCallback(
      (V) => {
        if (!I) return;
        switch (V) {
          case "yes-session":
            A(I, !1);
            break;
          case "yes-remember":
            A(I, !0);
            break;
          case "no":
            B();
            break;
        }
      },
      [I, A, B],
    );
  return U4.createElement(
    U4.Fragment,
    null,
    U4.createElement(
      S,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        gap: 1,
        borderColor: "permission",
      },
      U4.createElement(
        U,
        { bold: !0, color: "permission" },
        "Add directory to workspace",
      ),
      I
        ? U4.createElement(
            S,
            { flexDirection: "column", gap: 1 },
            U4.createElement(kBI, { path: I }),
            U4.createElement($0, {
              options: W,
              onChange: C,
              onCancel: () => C("no"),
            }),
          )
        : U4.createElement(
            S,
            { flexDirection: "column", gap: 1, marginX: 2 },
            U4.createElement(jr2, null),
            U4.createElement(_BI, {
              value: G,
              onChange: Z,
              onSubmit: F,
              error: Y,
            }),
          ),
    ),
    !I &&
      U4.createElement(
        S,
        { marginLeft: 3 },
        X.pending
          ? U4.createElement(
              U,
              { dimColor: !0 },
              "Press ",
              X.keyName,
              " again to exit",
            )
          : U4.createElement(
              U,
              { dimColor: !0 },
              "Enter to add  Esc to cancel",
            ),
      ),
  );
}
var U4, jb, yBI;
var E00 = T(() => {
  nA();
  R9();
  rG();
  YQ1();
  s2();
  Z5();
  ((U4 = IA(KA(), 1)),
    (jb = IA(KA(), 1)),
    (yBI = [
      { value: "yes-session", label: "Yes, for this session" },
      { value: "yes-remember", label: "Yes, and remember this directory" },
      { value: "no", label: "No" },
    ]));
});
import { dirname as xBI } from "path";
function vBI({ message: A, args: B, onDone: Q }) {
  return (
    Ny.useEffect(() => {
      let I = setTimeout(Q, 0);
      return () => clearTimeout(I);
    }, [Q]),
    Ny.default.createElement(
      S,
      { flexDirection: "column" },
      Ny.default.createElement(U, { dimColor: !0 }, "> /add-dir ", B),
      Ny.default.createElement(j0, null, Ny.default.createElement(U, null, A)),
    )
  );
}
function a$A(A, B) {
  if (!A) return { resultType: "emptyPath" };
  let Q = M9(A),
    I = NA();
  if (!I.existsSync(Q))
    return { resultType: "pathNotFound", directoryPath: A, absolutePath: Q };
  if (!I.statSync(Q).isDirectory())
    return { resultType: "notADirectory", directoryPath: A, absolutePath: Q };
  let G = u4A(B);
  for (let Z of G)
    if (hx(Q, Z))
      return {
        resultType: "alreadyInWorkingDirectory",
        directoryPath: A,
        workingDir: Z,
      };
  return { resultType: "success", absolutePath: Q };
}
function s$A(A) {
  switch (A.resultType) {
    case "emptyPath":
      return "Please provide a directory path.";
    case "pathNotFound":
      return `Path ${iA.bold(A.absolutePath)} was not found.`;
    case "notADirectory": {
      let B = xBI(A.absolutePath);
      return `${iA.bold(A.directoryPath)} is not a directory. Did you mean to add the parent directory ${iA.bold(B)}?`;
    }
    case "alreadyInWorkingDirectory":
      return `${iA.bold(A.directoryPath)} is already accessible within the existing working directory ${iA.bold(A.workingDir)}.`;
    case "success":
      return `Added ${iA.bold(A.absolutePath)} as a working directory.`;
  }
}
var Ny, bBI, ks2;
var YQ1 = T(() => {
  f2();
  nA();
  KJ();
  m0();
  hG();
  E00();
  L8();
  K00();
  aC();
  Ny = IA(KA(), 1);
  ((bBI = {
    type: "local-jsx",
    name: "add-dir",
    description: "Add a new working directory",
    argumentHint: "<path>",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, B, Q) {
      let I = Q.trim();
      if (!I)
        return Ny.default.createElement(xB1, {
          onExit: A,
          initialTab: "workspace",
        });
      let G = await B.getAppState(),
        Z = a$A(I, G.toolPermissionContext);
      if (Z.resultType !== "success") {
        let Y = s$A(Z);
        return Ny.default.createElement(vBI, {
          message: Y,
          args: Q,
          onDone: () => A(Y),
        });
      }
      return Ny.default.createElement(fB1, {
        directoryPath: Z.absolutePath,
        permissionContext: G.toolPermissionContext,
        onAddDirectory: async (Y, J) => {
          let W = {
              type: "addDirectories",
              directories: [Y],
              destination: J ? "localSettings" : "session",
            },
            F = await B.getAppState(),
            C = aF(F.toolPermissionContext, W);
          B.setAppState((D) => ({ ...D, toolPermissionContext: C }));
          let V;
          if (J)
            try {
              (wb(W),
                (V = `Added ${iA.bold(Y)} as a working directory and saved to local settings`));
            } catch (D) {
              V = `Added ${iA.bold(Y)} as a working directory. Failed to save to local settings: ${D instanceof Error ? D.message : "Unknown error"}`;
            }
          else
            V = `Added ${iA.bold(Y)} as a working directory for this session`;
          let K = `${V} ${iA.dim(" /permissions to manage")}`;
          A(K);
        },
        onCancel: () => {
          A(`Did not add ${iA.bold(Z.absolutePath)} as a working directory.`);
        },
      });
    },
    userFacingName() {
      return "add-dir";
    },
  }),
    (ks2 = bBI));
});
import { resolve as fBI } from "path";
function hBI(A) {
  let B = A.join(" ").trim();
  if (lh2(B)) return yA0();
  return cr(A);
}
function gBI({ processPwd: A, originalCwd: B }) {
  let { resolvedPath: Q, isSymlink: I } = KC(NA(), A);
  return I ? Q === fBI(B) : !1;
}
function Sr2({ permissionModeCli: A, dangerouslySkipPermissions: B }) {
  let Q = N0() || {},
    I = xC("tengu_disable_bypass_permissions_mode"),
    G = Q.permissions?.disableBypassPermissionsMode === "disable",
    Z = I || G,
    Y = [];
  if (B) Y.push("bypassPermissions");
  if (A) Y.push(HTA(A));
  if (Q.permissions?.defaultMode) Y.push(Q.permissions.defaultMode);
  let J;
  for (let X of Y)
    if (X === "bypassPermissions" && Z) {
      if (I)
        (g("bypassPermissions mode is disabled by Statsig gate", {
          level: "warn",
        }),
          (J =
            "Bypass permissions mode was disabled by your organization policy"));
      else
        (g("bypassPermissions mode is disabled by settings", { level: "warn" }),
          (J = "Bypass permissions mode was disabled by settings"));
      continue;
    } else return { mode: X, notification: J };
  return { mode: "default", notification: J };
}
function cr(A) {
  if (A.length === 0) return [];
  let B = [];
  for (let Q of A) {
    if (!Q) continue;
    let I = "",
      G = !1;
    for (let Z of Q)
      switch (Z) {
        case "(":
          ((G = !0), (I += Z));
          break;
        case ")":
          ((G = !1), (I += Z));
          break;
        case ",":
          if (G) I += Z;
          else {
            if (I.trim()) B.push(I.trim());
            I = "";
          }
          break;
        case " ":
          if (G) I += Z;
          else if (I.trim()) (B.push(I.trim()), (I = ""));
          break;
        default:
          I += Z;
      }
    if (I.trim()) B.push(I.trim());
  }
  return B;
}
function yr2({
  allowedToolsCli: A,
  disallowedToolsCli: B,
  baseToolsCli: Q,
  permissionMode: I,
  allowDangerouslySkipPermissions: G,
  addDirs: Z,
}) {
  let Y = cr(A),
    J = cr(B);
  if (Q && Q.length > 0) {
    let w = hBI(Q),
      L = new Set(w),
      $ = yA0().filter((O) => !L.has(O));
    J = [...J, ...$];
  }
  let X = [],
    W = new Map(),
    F = process.env.PWD;
  if (F && F !== GQ() && gBI({ originalCwd: GQ(), processPwd: F }))
    W.set(F, { path: F, source: "session" });
  let C = xC("tengu_disable_bypass_permissions_mode"),
    V = N0() || {},
    K = V.permissions?.disableBypassPermissionsMode === "disable",
    E = xr2(
      {
        mode: I,
        additionalWorkingDirectories: W,
        alwaysAllowRules: { cliArg: Y },
        alwaysDenyRules: { cliArg: J },
        alwaysAskRules: {},
        isBypassPermissionsModeAvailable:
          (I === "bypassPermissions" || G) && !C && !K,
      },
      UTA(),
    ),
    H = [...(V.permissions?.additionalDirectories || []), ...Z];
  for (let w of H) {
    let L = a$A(w, E);
    if (L.resultType === "success")
      E = aF(E, {
        type: "addDirectories",
        directories: [L.absolutePath],
        destination: "cliArg",
      });
    else if (L.resultType !== "alreadyInWorkingDirectory") X.push(s$A(L));
  }
  return { toolPermissionContext: E, warnings: X };
}
async function pe1() {
  return vr2("tengu_disable_bypass_permissions_mode");
}
function kr2() {
  let A = xC("tengu_disable_bypass_permissions_mode"),
    Q = (N0() || {}).permissions?.disableBypassPermissionsMode === "disable";
  return A || Q;
}
function Ny2(A) {
  let B = A;
  if (A.mode === "bypassPermissions")
    B = aF(A, { type: "setMode", mode: "default", destination: "session" });
  return { ...B, isBypassPermissionsModeAvailable: !1 };
}
async function _r2(A) {
  if (!A.isBypassPermissionsModeAvailable) return;
  if (!(await pe1())) return;
  (g("bypassPermissions mode is being disabled by Statsig gate (async check)", {
    level: "warn",
  }),
    P6(1, "bypass_permissions_disabled"));
}
var OIA = T(() => {
  f3();
  Ci();
  MM();
  i0();
  OQ();
  YQ1();
  aC();
  m0();
  f4();
  C0();
  xY();
  nO();
});
import { dirname as uBI, join as zQ1, resolve as br2 } from "path";
import {
  readdir as mBI,
  readFile as dBI,
  stat as fr2,
  realpath as cBI,
} from "fs/promises";
import { existsSync as $B0 } from "fs";
import { homedir as pBI } from "os";
function Xy(A, B = "Custom item") {
  let Q = A.split(`
`);
  for (let I of Q) {
    let G = I.trim();
    if (G) {
      let Y = G.match(/^#+\s+(.+)$/)?.[1] ?? G;
      return Y.length > 100 ? Y.substring(0, 97) + "..." : Y;
    }
  }
  return B;
}
function hr2(A) {
  if (A === void 0 || A === null) return null;
  if (!A) return [];
  let B = [];
  if (typeof A === "string") B = [A];
  else if (Array.isArray(A)) B = A.filter((I) => typeof I === "string");
  if (B.length === 0) return [];
  let Q = cr(B);
  if (Q.includes("*")) return ["*"];
  return Q;
}
function eo(A) {
  let B = hr2(A);
  if (B === null) return A === void 0 ? void 0 : [];
  if (B.includes("*")) return;
  return B;
}
function lc(A) {
  let B = hr2(A);
  if (B === null) return [];
  return B;
}
function lBI(A) {
  let B = br2(pBI()),
    Q = br2(G0()),
    I = [];
  if (!$B0(Q)) return I;
  while (!0) {
    if (Q === B) break;
    let G = zQ1(Q, ".claude", A);
    if ($B0(G)) I.push(G);
    let Z = uBI(Q);
    if (Z === Q) break;
    Q = Z;
  }
  return I;
}
async function iBI(A, B) {
  let Q = [],
    I = new Set();
  async function G(Z) {
    if (B.aborted) return;
    try {
      let Y = await fr2(Z);
      if (Y.isDirectory()) {
        let J =
          Y.dev !== void 0 && Y.ino !== void 0
            ? `${Y.dev}:${Y.ino}`
            : await cBI(Z);
        if (I.has(J)) {
          g(`Skipping already visited directory (circular symlink): ${Z}`);
          return;
        }
        I.add(J);
      }
    } catch (Y) {
      let J = Y instanceof Error ? Y.message : String(Y);
      g(`Failed to stat directory ${Z}: ${J}`);
      return;
    }
    try {
      let Y = await mBI(Z, { withFileTypes: !0 });
      for (let J of Y) {
        if (B.aborted) break;
        let X = zQ1(Z, J.name);
        try {
          if (J.isSymbolicLink())
            try {
              let W = await fr2(X);
              if (W.isDirectory()) await G(X);
              else if (W.isFile() && J.name.endsWith(".md")) Q.push(X);
            } catch (W) {
              let F = W instanceof Error ? W.message : String(W);
              g(`Failed to follow symlink ${X}: ${F}`);
            }
          else if (J.isDirectory()) await G(X);
          else if (J.isFile() && J.name.endsWith(".md")) Q.push(X);
        } catch (W) {
          let F = W instanceof Error ? W.message : String(W);
          g(`Failed to access ${X}: ${F}`);
        }
      }
    } catch (Y) {
      let J = Y instanceof Error ? Y.message : String(Y);
      g(`Failed to read directory ${Z}: ${J}`);
    }
  }
  return (await G(A), Q);
}
async function wB0(A) {
  let B = a9(),
    Q = setTimeout(() => B.abort(), 3000);
  try {
    if (!$B0(A)) return [];
    let G = V0(process.env.CLAUDE_CODE_USE_NATIVE_FILE_SEARCH)
      ? await iBI(A, B.signal)
      : await FH(
          ["--files", "--hidden", "--follow", "--no-ignore", "--glob", "*.md"],
          A,
          B.signal,
        );
    return (
      await Promise.all(
        G.map(async (Y) => {
          try {
            let J = await dBI(Y, { encoding: "utf-8" }),
              { frontmatter: X, content: W } = GW(J);
            return { filePath: Y, frontmatter: X, content: W };
          } catch (J) {
            let X = J instanceof Error ? J.message : String(J);
            return (g(`Failed to read/parse markdown file:  ${Y}: ${X}`), null);
          }
        }),
      )
    ).filter((Y) => Y !== null);
  } finally {
    clearTimeout(Q);
  }
}
var nB2, Zc;
var xS = T(() => {
  uT();
  OIA();
  C0();
  vG();
  vB();
  V2();
  OQ();
  H0();
  NC();
  a2();
  nB2 = ["commands", "agents", "output-styles", "skills"];
  Zc = I0(async function (A) {
    let B = Date.now(),
      Q = zQ1(mB(), A),
      I = zQ1(Nw(), ".claude", A),
      G = lBI(A),
      [Z, Y, J] = await Promise.all([
        wB0(I).then((W) =>
          W.map((F) => ({ ...F, baseDir: I, source: "policySettings" })),
        ),
        WH("userSettings")
          ? wB0(Q).then((W) =>
              W.map((F) => ({ ...F, baseDir: Q, source: "userSettings" })),
            )
          : Promise.resolve([]),
        WH("projectSettings")
          ? Promise.all(
              G.map((W) =>
                wB0(W).then((F) =>
                  F.map((C) => ({
                    ...C,
                    baseDir: W,
                    source: "projectSettings",
                  })),
                ),
              ),
            )
          : Promise.resolve([]),
      ]),
      X = J.flat();
    return (
      GA("tengu_dir_search", {
        durationMs: Date.now() - B,
        managedFilesFound: Z.length,
        userFilesFound: Y.length,
        projectFilesFound: X.length,
        projectDirsSearched: G.length,
        subdir: A,
      }),
      [...Z, ...Y, ...X]
    );
  });
});
import { basename as nBI } from "path";
var gr2;
var ur2 = T(() => {
  a2();
  c1();
  xS();
  tB1();
  gr2 = I0(async () => {
    try {
      return (await Zc("output-styles"))
        .map(({ filePath: Q, frontmatter: I, content: G, source: Z }) => {
          try {
            let J = nBI(Q).replace(/\.md$/, ""),
              X = I.name || J,
              W = I.description || Xy(G, `Custom ${J} output style`),
              F = I["keep-coding-instructions"],
              C = F === "true" ? !0 : F === "false" ? !1 : void 0;
            return {
              name: X,
              description: W,
              prompt: G.trim(),
              source: Z,
              keepCodingInstructions: C,
            };
          } catch (Y) {
            return (BA(Y instanceof Error ? Y : Error(String(Y)), bY0), null);
          }
        })
        .filter((Q) => Q !== null);
    } catch (A) {
      return (BA(A instanceof Error ? A : Error(String(A)), vY0), []);
    }
  });
});
async function Xt() {
  let A = await gr2(),
    B = await u00(),
    Q = { ...ro },
    I = A.filter((J) => J.source === "policySettings"),
    G = A.filter((J) => J.source === "userSettings"),
    Z = A.filter((J) => J.source === "projectSettings"),
    Y = [B, G, Z, I];
  for (let J of Y)
    for (let X of J)
      Q[X.name] = {
        name: X.name,
        description: X.description,
        prompt: X.prompt,
        source: X.source,
        keepCodingInstructions: X.keepCodingInstructions,
      };
  return Q;
}
async function bs2() {
  let B = N0()?.outputStyle || nF;
  return (await Xt())[B] ?? null;
}
var mr2,
  nF = "default",
  ro;
var Gy = T(() => {
  s2();
  OQ();
  ur2();
  tB1();
  ((mr2 = `
## Insights
In order to encourage learning, before and after writing code, always provide brief educational explanations about implementation choices using (with backticks):
"\`${E1.star} Insight \`
[2-3 key educational points]
\`\`"

These insights should be included in the conversation, not in the codebase. You should generally focus on interesting insights that are specific to the codebase or the code you just wrote, rather than general programming concepts.`),
    (ro = {
      [nF]: null,
      Explanatory: {
        name: "Explanatory",
        source: "built-in",
        description:
          "Claude explains its implementation choices and codebase patterns",
        keepCodingInstructions: !0,
        prompt: `You are an interactive CLI tool that helps users with software engineering tasks. In addition to software engineering tasks, you should provide educational insights about the codebase along the way.

You should be clear and educational, providing helpful explanations while remaining focused on the task. Balance educational content with task completion. When providing insights, you may exceed typical length constraints, but remain focused and relevant.

# Explanatory Style Active
${mr2}`,
      },
      Learning: {
        name: "Learning",
        source: "built-in",
        description:
          "Claude pauses and asks you to write small pieces of code for hands-on practice",
        keepCodingInstructions: !0,
        prompt: `You are an interactive CLI tool that helps users with software engineering tasks. In addition to software engineering tasks, you should help users learn more about the codebase through hands-on practice and educational insights.

You should be collaborative and encouraging. Balance task completion with learning by requesting user input for meaningful design decisions while handling routine implementation yourself.   

# Learning Style Active
## Requesting Human Contributions
In order to encourage learning, ask the human to contribute 2-10 line code pieces when generating 20+ lines involving:
- Design decisions (error handling, data structures)
- Business logic with multiple valid approaches  
- Key algorithms or interface definitions

**TodoList Integration**: If using a TodoList for the overall task, include a specific todo item like "Request human input on [specific decision]" when planning to request human input. This ensures proper task tracking. Note: TodoList is not required for all tasks.

Example TodoList flow:
    "Set up component structure with placeholder for logic"
    "Request human collaboration on decision logic implementation"
    "Integrate contribution and complete feature"

### Request Format
\`\`\`
${E1.bullet} **Learn by Doing**
**Context:** [what's built and why this decision matters]
**Your Task:** [specific function/section in file, mention file and TODO(human) but do not include line numbers]
**Guidance:** [trade-offs and constraints to consider]
\`\`\`

### Key Guidelines
- Frame contributions as valuable design decisions, not busy work
- You must first add a TODO(human) section into the codebase with your editing tools before making the Learn by Doing request      
- Make sure there is one and only one TODO(human) section in the code
- Don't take any action or output anything after the Learn by Doing request. Wait for human implementation before proceeding.

### Example Requests

**Whole Function Example:**
\`\`\`
${E1.bullet} **Learn by Doing**

**Context:** I've set up the hint feature UI with a button that triggers the hint system. The infrastructure is ready: when clicked, it calls selectHintCell() to determine which cell to hint, then highlights that cell with a yellow background and shows possible values. The hint system needs to decide which empty cell would be most helpful to reveal to the user.

**Your Task:** In sudoku.js, implement the selectHintCell(board) function. Look for TODO(human). This function should analyze the board and return {row, col} for the best cell to hint, or null if the puzzle is complete.

**Guidance:** Consider multiple strategies: prioritize cells with only one possible value (naked singles), or cells that appear in rows/columns/boxes with many filled cells. You could also consider a balanced approach that helps without making it too easy. The board parameter is a 9x9 array where 0 represents empty cells.
\`\`\`

**Partial Function Example:**
\`\`\`
${E1.bullet} **Learn by Doing**

**Context:** I've built a file upload component that validates files before accepting them. The main validation logic is complete, but it needs specific handling for different file type categories in the switch statement.

**Your Task:** In upload.js, inside the validateFile() function's switch statement, implement the 'case "document":' branch. Look for TODO(human). This should validate document files (pdf, doc, docx).

**Guidance:** Consider checking file size limits (maybe 10MB for documents?), validating the file extension matches the MIME type, and returning {valid: boolean, error?: string}. The file object has properties: name, size, type.
\`\`\`

**Debugging Example:**
\`\`\`
${E1.bullet} **Learn by Doing**

**Context:** The user reported that number inputs aren't working correctly in the calculator. I've identified the handleInput() function as the likely source, but need to understand what values are being processed.

**Your Task:** In calculator.js, inside the handleInput() function, add 2-3 console.log statements after the TODO(human) comment to help debug why number inputs fail.

**Guidance:** Consider logging: the raw input value, the parsed result, and any validation state. This will help us understand where the conversion breaks.
\`\`\`

### After Contributions
Share one insight connecting their code to broader patterns or system effects. Avoid praise or repetition.

## Insights
${mr2}`,
      },
    }));
});
import { randomUUID as RL } from "crypto";
function trA(A) {
  return (
    A.type !== "progress" &&
    A.type !== "attachment" &&
    A.type !== "system" &&
    Array.isArray(A.message.content) &&
    A.message.content[0]?.type === "text" &&
    c_1.has(A.message.content[0].text)
  );
}
function aBI(A) {
  return (
    A.type === "assistant" &&
    A.isApiErrorMessage === !0 &&
    A.message.model === "<synthetic>"
  );
}
function k4A(A) {
  let B = A.filter((Q) => Q.type === "assistant");
  return nV(B);
}
function wQ1(A) {
  for (let B = A.length - 1; B >= 0; B--) {
    let Q = A[B];
    if (Q && Q.type === "assistant") {
      let G = Q.message.content;
      if (Array.isArray(G)) return G.some((Z) => Z.type === "tool_use");
    }
  }
  return !1;
}
function cr2({
  content: A,
  isApiErrorMessage: B = !1,
  usage: Q = {
    input_tokens: 0,
    output_tokens: 0,
    cache_creation_input_tokens: 0,
    cache_read_input_tokens: 0,
    server_tool_use: { web_search_requests: 0, web_fetch_requests: 0 },
    service_tier: null,
    cache_creation: {
      ephemeral_1h_input_tokens: 0,
      ephemeral_5m_input_tokens: 0,
    },
  },
}) {
  return {
    type: "assistant",
    uuid: RL(),
    timestamp: new Date().toISOString(),
    message: {
      id: RL(),
      container: null,
      model: "<synthetic>",
      role: "assistant",
      stop_reason: "stop_sequence",
      stop_sequence: "",
      type: "message",
      usage: Q,
      content: A,
      context_management: null,
    },
    requestId: void 0,
    isApiErrorMessage: B,
  };
}
function CV({ content: A, usage: B }) {
  return cr2({
    content:
      typeof A === "string" ? [{ type: "text", text: A === "" ? Aw : A }] : A,
    usage: B,
  });
}
function uZ({ content: A }) {
  return cr2({
    content: [{ type: "text", text: A === "" ? Aw : A }],
    isApiErrorMessage: !0,
  });
}
function T0({
  content: A,
  isMeta: B,
  isVisibleInTranscriptOnly: Q,
  isCompactSummary: I,
  autocheckpoint: G,
  toolUseResult: Z,
  uuid: Y,
  thinkingMetadata: J,
  timestamp: X,
}) {
  return {
    type: "user",
    message: { role: "user", content: A || Aw },
    isMeta: B,
    isVisibleInTranscriptOnly: Q,
    isCompactSummary: I,
    autocheckpoint: G,
    uuid: Y ?? RL(),
    timestamp: X ?? new Date().toISOString(),
    toolUseResult: Z,
    thinkingMetadata: J,
  };
}
function Nz({ inputString: A, precedingInputBlocks: B }) {
  if (B.length === 0) return A;
  return [...B, { text: A, type: "text" }];
}
function fHA({ toolUse: A = !1 }) {
  return T0({ content: [{ type: "text", text: A ? YN : W6A }] });
}
function OW() {
  return T0({
    content:
      "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
    isMeta: !0,
  });
}
function XaQ({ toolUseID: A, parentToolUseID: B, data: Q }) {
  return {
    type: "progress",
    data: Q,
    toolUseID: A,
    parentToolUseID: B,
    uuid: RL(),
    timestamp: new Date().toISOString(),
  };
}
function uc1(A) {
  return { type: "tool_result", content: v8A, is_error: !0, tool_use_id: A };
}
function g2(A, B) {
  if (!A.trim() || !B.trim()) return null;
  let Q = B.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
    I = new RegExp(`<${Q}(?:\\s+[^>]*)?>([\\s\\S]*?)<\\/${Q}>`, "gi"),
    G,
    Z = 0,
    Y = 0,
    J = new RegExp(`<${Q}(?:\\s+[^>]*?)?>`, "gi"),
    X = new RegExp(`<\\/${Q}>`, "gi");
  while ((G = I.exec(A)) !== null) {
    let W = G[1],
      F = A.slice(Y, G.index);
    ((Z = 0), (J.lastIndex = 0));
    while (J.exec(F) !== null) Z++;
    X.lastIndex = 0;
    while (X.exec(F) !== null) Z--;
    if (Z === 0 && W) return W;
    Y = G.index + G[0].length;
  }
  return null;
}
function B$A(A) {
  if (A.type === "progress" || A.type === "attachment" || A.type === "system")
    return !0;
  if (typeof A.message.content === "string")
    return A.message.content.trim().length > 0;
  if (A.message.content.length === 0) return !1;
  if (A.message.content.length > 1) return !0;
  if (A.message.content[0].type !== "text") return !0;
  return (
    A.message.content[0].text.trim().length > 0 &&
    A.message.content[0].text !== Aw &&
    A.message.content[0].text !== YN
  );
}
function bY(A) {
  let B = !1;
  return A.flatMap((Q) => {
    switch (Q.type) {
      case "assistant":
        return (
          (B = B || Q.message.content.length > 1),
          Q.message.content.map((I) => {
            let G = B ? RL() : Q.uuid;
            return {
              type: "assistant",
              timestamp: Q.timestamp,
              message: {
                ...Q.message,
                content: [I],
                context_management: Q.message.context_management ?? null,
              },
              isMeta: Q.isMeta,
              requestId: Q.requestId,
              uuid: G,
            };
          })
        );
      case "attachment":
        return [Q];
      case "progress":
        return [Q];
      case "system":
        return [Q];
      case "user": {
        if (typeof Q.message.content === "string") {
          let I = B ? RL() : Q.uuid;
          return [
            {
              ...Q,
              uuid: I,
              message: {
                ...Q.message,
                content: [{ type: "text", text: Q.message.content }],
              },
            },
          ];
        }
        return (
          (B = B || Q.message.content.length > 1),
          Q.message.content.map((I) => ({
            ...T0({
              content: [I],
              toolUseResult: Q.toolUseResult,
              isMeta: Q.isMeta,
              isVisibleInTranscriptOnly: Q.isVisibleInTranscriptOnly,
              timestamp: Q.timestamp,
            }),
            uuid: B ? RL() : Q.uuid,
          }))
        );
      }
    }
  });
}
function dr2(A) {
  return (
    A.type === "assistant" &&
    A.message.content.some((B) => B.type === "tool_use")
  );
}
function DoQ(A) {
  return (
    A.type === "user" &&
    ((Array.isArray(A.message.content) &&
      A.message.content[0]?.type === "tool_result") ||
      Boolean(A.toolUseResult))
  );
}
function yS2(A, B) {
  let Q = new Map();
  for (let Y of A) {
    if (dr2(Y)) {
      let J = Y.message.content[0]?.id;
      if (J) {
        if (!Q.has(J))
          Q.set(J, {
            toolUse: null,
            preHooks: [],
            toolResult: null,
            postHooks: [],
          });
        Q.get(J).toolUse = Y;
      }
      continue;
    }
    if (t$A(Y) && Y.attachment.hookEvent === "PreToolUse") {
      let J = Y.attachment.toolUseID;
      if (!Q.has(J))
        Q.set(J, {
          toolUse: null,
          preHooks: [],
          toolResult: null,
          postHooks: [],
        });
      Q.get(J).preHooks.push(Y);
      continue;
    }
    if (Y.type === "user" && Y.message.content[0]?.type === "tool_result") {
      let J = Y.message.content[0].tool_use_id;
      if (!Q.has(J))
        Q.set(J, {
          toolUse: null,
          preHooks: [],
          toolResult: null,
          postHooks: [],
        });
      Q.get(J).toolResult = Y;
      continue;
    }
    if (t$A(Y) && Y.attachment.hookEvent === "PostToolUse") {
      let J = Y.attachment.toolUseID;
      if (!Q.has(J))
        Q.set(J, {
          toolUse: null,
          preHooks: [],
          toolResult: null,
          postHooks: [],
        });
      Q.get(J).postHooks.push(Y);
      continue;
    }
  }
  let I = [],
    G = new Set();
  for (let Y of A) {
    if (dr2(Y)) {
      let J = Y.message.content[0]?.id;
      if (J && !G.has(J)) {
        G.add(J);
        let X = Q.get(J);
        if (X && X.toolUse) {
          if ((I.push(X.toolUse), I.push(...X.preHooks), X.toolResult))
            I.push(X.toolResult);
          I.push(...X.postHooks);
        }
      }
      continue;
    }
    if (
      t$A(Y) &&
      (Y.attachment.hookEvent === "PreToolUse" ||
        Y.attachment.hookEvent === "PostToolUse")
    )
      continue;
    if (Y.type === "user" && Y.message.content[0]?.type === "tool_result")
      continue;
    if (Y.type === "system" && Y.subtype === "api_error") {
      let J = I.at(-1);
      if (J?.type === "system" && J.subtype === "api_error")
        I[I.length - 1] = Y;
      else I.push(Y);
      continue;
    }
    I.push(Y);
  }
  for (let Y of B) I.push(Y);
  let Z = I.at(-1);
  return I.filter(
    (Y) => Y.type !== "system" || Y.subtype !== "api_error" || Y === Z,
  );
}
function t$A(A) {
  return (
    A.type === "attachment" &&
    (A.attachment.type === "hook_blocking_error" ||
      A.attachment.type === "hook_cancelled" ||
      A.attachment.type === "hook_error_during_execution" ||
      A.attachment.type === "hook_non_blocking_error" ||
      A.attachment.type === "hook_success" ||
      A.attachment.type === "hook_system_message" ||
      A.attachment.type === "hook_additional_context" ||
      A.attachment.type === "hook_stopped_continuation")
  );
}
function lS1(A, B, Q) {
  return A.filter(
    (I) =>
      I.type === "progress" &&
      I.data.type === "hook_progress" &&
      I.data.hookEvent === Q &&
      I.parentToolUseID === B,
  ).length;
}
function iS1(A, B, Q) {
  return A.filter(
    (I) =>
      t$A(I) && I.attachment.toolUseID === B && I.attachment.hookEvent === Q,
  ).length;
}
function kS2(A, B, Q) {
  let I = lS1(A, B, Q),
    G = iS1(A, B, Q);
  if (I > G) return !0;
  return !1;
}
function V01(A) {
  return Object.fromEntries(
    A.flatMap((B) =>
      B.type === "user" && B.message.content[0]?.type === "tool_result"
        ? [
            [
              B.message.content[0].tool_use_id,
              B.message.content[0].is_error ?? !1,
            ],
          ]
        : [],
    ),
  );
}
function _S2(A, B) {
  let Q = Q$A(A);
  if (!Q) return new Set();
  let I = B.find(
    (Y) =>
      Y.type === "assistant" &&
      Y.message.content.some((J) => J.type === "tool_use" && J.id === Q),
  );
  if (!I) return new Set();
  let G = I.message.id,
    Z = B.filter((Y) => Y.type === "assistant" && Y.message.id === G);
  return new Set(
    Z.flatMap((Y) =>
      Y.message.content.filter((J) => J.type === "tool_use").map((J) => J.id),
    ),
  );
}
function wA0(A) {
  let B = V01(A),
    Q = sBI(A);
  return rj2(Q, new Set(Object.keys(B)));
}
function sBI(A) {
  return new Set(
    A.filter(
      (B) =>
        B.type === "assistant" &&
        Array.isArray(B.message.content) &&
        B.message.content[0]?.type === "tool_use",
    ).map((B) => B.message.content[0].id),
  );
}
function xS2(A) {
  let B = V01(A);
  return new Set(
    A.filter(
      (Q) =>
        Q.type === "assistant" &&
        Array.isArray(Q.message.content) &&
        Q.message.content[0]?.type === "tool_use" &&
        Q.message.content[0]?.id in B &&
        B[Q.message.content[0]?.id] === !0,
    ).map((Q) => Q.message.content[0].id),
  );
}
function rBI(A) {
  let B = [],
    Q = [];
  for (let I = A.length - 1; I >= 0; I--) {
    let G = A[I];
    if (G.type === "attachment") Q.unshift(G);
    else if (
      (G.type === "assistant" ||
        (G.type === "user" &&
          Array.isArray(G.message.content) &&
          G.message.content[0]?.type === "tool_result")) &&
      Q.length > 0
    )
      (B.unshift(G, ...Q), (Q.length = 0));
    else B.unshift(G);
  }
  return (B.unshift(...Q), B);
}
function A02(A) {
  return A.type === "system" && A.subtype === "local_command";
}
function D7(A) {
  let B = rBI(A),
    Q = [];
  return (
    B.filter((I) => {
      if (I.type === "progress" || I.type === "system" || aBI(I)) return !1;
      return !0;
    }).forEach((I) => {
      switch (I.type) {
        case "user": {
          let G = nV(Q);
          if (G?.type === "user") {
            Q[Q.indexOf(G)] = eBI(G, I);
            return;
          }
          Q.push(I);
          return;
        }
        case "assistant": {
          let G = nV(Q);
          if (G?.type === "assistant" && G.message.id === I.message.id) {
            Q[Q.indexOf(G)] = tBI(G, I);
            return;
          }
          Q.push(I);
          return;
        }
        case "attachment": {
          let G = ZQI(I.attachment),
            Z = nV(Q);
          if (Z?.type === "user") {
            Q[Q.indexOf(Z)] = G.reduce((Y, J) => oBI(Y, J), Z);
            return;
          }
          Q.push(...G);
          return;
        }
      }
    }),
    Q
  );
}
function oBI(A, B) {
  let Q = UQ1(A.message.content),
    I = UQ1(B.message.content);
  return { ...A, message: { ...A.message, content: pr2(AQI(Q, I)) } };
}
function tBI(A, B) {
  return {
    ...A,
    message: {
      ...A.message,
      content: [...A.message.content, ...B.message.content],
    },
  };
}
function eBI(A, B) {
  let Q = UQ1(A.message.content),
    I = UQ1(B.message.content);
  return { ...A, message: { ...A.message, content: pr2([...Q, ...I]) } };
}
function pr2(A) {
  let B = [],
    Q = [];
  for (let I of A)
    if (I.type === "tool_result") B.push(I);
    else Q.push(I);
  return [...B, ...Q];
}
function UQ1(A) {
  if (typeof A === "string") return [{ type: "text", text: A }];
  return A;
}
function AQI(A, B) {
  let Q = nV(A);
  if (
    Q?.type === "tool_result" &&
    typeof Q.content === "string" &&
    B.every((I) => I.type === "text")
  )
    return [
      ...A.slice(0, -1),
      {
        ...Q,
        content: [Q.content, ...B.map((I) => I.text)]
          .map((I) => I.trim())
          .filter(Boolean).join(`

`),
      },
    ];
  return [...A, ...B];
}
function JB0(A, B) {
  return A.map((Q) => {
    switch (Q.type) {
      case "tool_use": {
        if (typeof Q.input !== "string" && !MZ(Q.input))
          throw Error("Tool use input must be a string or object");
        let I = typeof Q.input === "string" ? (b3(Q.input) ?? {}) : Q.input;
        if (typeof I === "object" && I !== null) {
          let G = B.find((Z) => Z.name === Q.name);
          if (G)
            try {
              I = NdQ(G, I);
            } catch (Z) {
              BA(Error("Error normalizing tool input: " + Z), UY0);
            }
        }
        return { ...Q, input: I };
      }
      case "text":
        if (Q.text.trim().length === 0)
          return (
            GA("tengu_empty_model_response", {}),
            { type: "text", text: Aw }
          );
        return Q;
      case "code_execution_tool_result":
      case "mcp_tool_use":
      case "mcp_tool_result":
      case "container_upload":
      case "server_tool_use":
        return Q;
      default:
        return Q;
    }
  });
}
function iiA(A) {
  return NKA(A).trim() === "" || A.trim() === Aw;
}
function NKA(A) {
  let B = new RegExp(
    `<(${BQI.join("|")})>.*?</\\1>
?`,
    "gs",
  );
  return A.replace(B, "").trim();
}
function Q$A(A) {
  switch (A.type) {
    case "attachment":
      if (t$A(A)) return A.attachment.toolUseID;
      return null;
    case "assistant":
      if (A.message.content[0]?.type !== "tool_use") return null;
      return A.message.content[0].id;
    case "user":
      if (A.message.content[0]?.type !== "tool_result") return null;
      return A.message.content[0].tool_use_id;
    case "progress":
      return A.toolUseID;
    case "system":
      return A.subtype === "informational" ? (A.toolUseID ?? null) : null;
  }
}
function pQ2(A) {
  let B = bY(A),
    Q = wA0(B);
  return B.filter((G, Z) => {
    if (
      G.type === "assistant" &&
      G.message.content[0]?.type === "tool_use" &&
      Q.has(G.message.content[0].id)
    )
      return !1;
    return !0;
  });
}
function hm(A) {
  if (A.type !== "assistant") return null;
  if (Array.isArray(A.message.content))
    return (
      A.message.content
        .filter((B) => B.type === "text")
        .map((B) => (B.type === "text" ? B.text : ""))
        .join(
          `
`,
        )
        .trim() || null
    );
  return null;
}
function C6A(A) {
  if (typeof A === "string") return A;
  if (Array.isArray(A))
    return (
      A.filter((B) => B.type === "text")
        .map((B) => (B.type === "text" ? B.text : ""))
        .join(
          `
`,
        )
        .trim() || null
    );
  return null;
}
function vS2(A, B) {
  let Q = Q$A(A);
  if (!Q) return [];
  return B.filter((I) => I.type === "progress" && I.parentToolUseID === Q);
}
function E$A(A, B, Q, I, G) {
  if (A.type !== "stream_event" && A.type !== "stream_request_start") {
    B(A);
    return;
  }
  if (A.type === "stream_request_start") {
    I("requesting");
    return;
  }
  if (A.event.type === "message_stop") {
    (I("tool-use"), G(() => []));
    return;
  }
  switch (A.event.type) {
    case "content_block_start":
      switch (A.event.content_block.type) {
        case "thinking":
        case "redacted_thinking":
          I("thinking");
          return;
        case "text":
          I("responding");
          return;
        case "tool_use": {
          I("tool-input");
          let Z = A.event.content_block,
            Y = A.event.index;
          G((J) => [
            ...J,
            { index: Y, contentBlock: Z, unparsedToolInput: "" },
          ]);
          return;
        }
        case "server_tool_use":
        case "web_search_tool_result":
        case "code_execution_tool_result":
        case "mcp_tool_use":
        case "mcp_tool_result":
        case "container_upload":
        case "web_fetch_tool_result":
        case "bash_code_execution_tool_result":
        case "text_editor_code_execution_tool_result":
          I("tool-input");
          return;
      }
      break;
    case "content_block_delta":
      switch (A.event.delta.type) {
        case "text_delta":
          Q(A.event.delta.text);
          return;
        case "input_json_delta": {
          let Z = A.event.delta.partial_json,
            Y = A.event.index;
          (Q(Z),
            G((J) => {
              let X = J.find((W) => W.index === Y);
              if (!X) return J;
              return [
                ...J.filter((W) => W !== X),
                { ...X, unparsedToolInput: X.unparsedToolInput + Z },
              ];
            }));
          return;
        }
        case "thinking_delta":
          Q(A.event.delta.thinking);
          return;
        case "signature_delta":
          Q(A.event.delta.signature);
          return;
        default:
          return;
      }
    case "message_delta":
      I("responding");
      return;
    default:
      I("responding");
      return;
  }
}
function Sb(A) {
  return `<system-reminder>
${A}
</system-reminder>`;
}
function AG(A) {
  return A.map((B) => {
    if (typeof B.message.content === "string")
      return {
        ...B,
        message: { ...B.message, content: Sb(B.message.content) },
      };
    else if (Array.isArray(B.message.content)) {
      let Q = B.message.content.map((I) => {
        if (I.type === "text") return { ...I, text: Sb(I.text) };
        return I;
      });
      return { ...B, message: { ...B.message, content: Q } };
    }
    return B;
  });
}
function QQI(A) {
  if (ac() && !A.isSubAgent) return IQI();
  return GQI(A);
}
function IQI() {
  let A = Dy2(),
    B = `Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received.

## Enhanced Planning Workflow

### Phase 1: Initial Understanding
Goal: Gain a comprehensive undertanding of the user's request by reading through code and asking them questions. Critical: In this phase you should only use the ${eK.agentType} subagent type.
1. Understand the user's request thoroughly
2. Use the ${eK.agentType} to search for and/or read a few relevant files (maximum 3-4) to understand the context behind the request better
3. Use ${YE} tool to clarify ambiguities in the user request up front.

### Phase 2: Multi-Agent Planning
Goal: Come up with different approaches to solve the problem identified in phase 1 by launching mulitple ${Ip.agentType} subagent types.
Launch **up to ${A}** ${x8} agents IN PARALLEL (single message, multiple tool calls) with ${Ip.agentType} subagent type, based on task complexity.

**Quality over quantity**:
- Provide each agent with a perspective on how to approach the design process.
- Simple tasks may need fewer agents (minimum 2), where as complex tasks benefit from multiple perspectives (up to ${A})
- Focus on meaningful contrasts between perspectives. Quality of agent perspectives is more important than quantity

Dynamically generate perspectives based on the task. Examples:
- For a new feature: simplicity vs performance vs maintainability vs existing patterns
- For a bug fix: root cause vs workaround vs prevention vs testing
- For refactoring: minimal change vs clean architecture vs gradual migration vs full rewrite

In each agent prompt:
- Describe the specific perspective/approach to take
- Provide any background context that may help the agent with their task without prescribing the exact design itself
- Request a detailed plan from their perspective

### Phase 3: Synthesis
Goal: Syntehsize the differnet perspectives from Phase 2, and ensure that it aligns with the users's intentions by asking them questions.
1. Collect all agent responses
2. Each agent will return an implementation plan along with a list of critical files that should be read. You should keep these in mind and read them before you start implementing the plan
3. Use ${YE} to ask the users questions about trade offs.

### Phase 4: Final Plan
Once you are have all the information you need, call ${JR.name} with your synthesized recommendation including:
- Recommended approach with rationale
- Key insights from different perspectives
- Critical files that need modification
- Important trade-offs

NOTE: At any point in time through this workflow you should feel free to ask the user questions or clarifications. Don't make large assumptions about user intent. The goal is to present a well researched plan to the user, and tie any loose ends before implementation begins.`;
  return AG([T0({ content: B, isMeta: !0 })]);
}
function GQI(A) {
  let B = !A.isSubAgent
      ? ` You MUST use a single ${x8} tool call with ${Ip.agentType} subagent type to gather information. Even if you have already started researching directly, you must immediately switch to using an agent instead.`
      : "",
    Q = `Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received (for example, to make edits). Instead, you should:
1. Answer the user's query comprehensively, using the ${YE} tool if you need to ask the user clarifying questions. If you do use the ${YE}, make sure to ask all clarifying questions you need to fully understand the user's intent before proceeding.${B}
2. When you're done researching, present your plan by calling the ${JR.name} tool, which will prompt the user to confirm the plan. Do NOT make any file changes or run any tools that modify the system state in any way until the user has confirmed the plan.`;
  return AG([T0({ content: Q, isMeta: !0 })]);
}
function ZQI(A) {
  switch (A.type) {
    case "directory":
      return AG([
        o$A(r2.name, {
          command: `ls ${q8([A.path])}`,
          description: `Lists files in ${A.path}`,
        }),
        r$A(r2, { stdout: A.content, stderr: "", interrupted: !1 }),
      ]);
    case "edited_text_file":
      return AG([
        T0({
          content: `Note: ${A.filename} was modified, either by the user or by a linter. This change was intentional, so make sure to take it into account as you proceed (ie. don't revert it unless the user asks you to). Don't tell the user this, since they are already aware. Here are the relevant changes (shown with line numbers):
${A.snippet}`,
          isMeta: !0,
        }),
      ]);
    case "file": {
      let Q = A.content;
      switch (Q.type) {
        case "image":
          return AG([o$A(t4.name, { file_path: A.filename }), r$A(t4, Q)]);
        case "text":
          return AG([
            o$A(t4.name, { file_path: A.filename }),
            r$A(t4, Q),
            ...(A.truncated
              ? [
                  T0({
                    content: `Note: The file ${A.filename} was too large and has been truncated to the first ${hFA} lines. Don't tell the user about this truncation. Use ${t4.name} to read more of the file if you need.`,
                    isMeta: !0,
                  }),
                ]
              : []),
          ]);
        case "notebook":
          return AG([o$A(t4.name, { file_path: A.filename }), r$A(t4, Q)]);
        case "pdf":
          return AG([o$A(t4.name, { file_path: A.filename }), r$A(t4, Q)]);
      }
      break;
    }
    case "compact_file_reference":
      return AG([
        T0({
          content: `Note: ${A.filename} was read before the last conversation was summarized, but the contents are too large to include. Use ${t4.name} tool if you need to access it.`,
          isMeta: !0,
        }),
      ]);
    case "selected_lines_in_ide": {
      let I =
        A.content.length > 2000
          ? A.content.substring(0, 2000) +
            `
... (truncated)`
          : A.content;
      return AG([
        T0({
          content: `The user selected the lines ${A.lineStart} to ${A.lineEnd} from ${A.filename}:
${I}

This may or may not be related to the current task.`,
          isMeta: !0,
        }),
      ]);
    }
    case "opened_file_in_ide":
      return AG([
        T0({
          content: `The user opened the file ${A.filename} in the IDE. This may or may not be related to the current task.`,
          isMeta: !0,
        }),
      ]);
    case "todo":
      if (A.itemCount === 0)
        return AG([
          T0({
            content: `This is a reminder that your todo list is currently empty. DO NOT mention this to the user explicitly because they are already aware. If you are working on tasks that would benefit from a todo list please use the ${oG.name} tool to create one. If not, please feel free to ignore. Again do not mention this message to the user.`,
            isMeta: !0,
          }),
        ]);
      else
        return AG([
          T0({
            content: `Your todo list has changed. DO NOT mention this explicitly to the user. Here are the latest contents of your todo list:

${JSON.stringify(A.content)}. Continue on with the tasks at hand if applicable.`,
            isMeta: !0,
          }),
        ]);
    case "todo_reminder": {
      let Q = A.content.map((G, Z) => `${Z + 1}. [${G.status}] ${G.content}`)
          .join(`
`),
        I = `The TodoWrite tool hasn't been used recently. If you're working on tasks that would benefit from tracking progress, consider using the TodoWrite tool to track progress. Also consider cleaning up the todo list if has become stale and no longer matches what you are working on. Only use it if it's relevant to the current work. This is just a gentle reminder - ignore if not applicable. Make sure that you NEVER mention this reminder to the user
`;
      if (Q.length > 0)
        I += `

Here are the existing contents of your todo list:

[${Q}]`;
      return AG([T0({ content: I, isMeta: !0 })]);
    }
    case "nested_memory":
      return AG([
        T0({
          content: `Contents of ${A.content.path}:

${A.content.content}`,
          isMeta: !0,
        }),
      ]);
    case "queued_command": {
      let Q = Array.isArray(A.prompt)
        ? A.prompt.map((I) => (I.type === "text" ? I.text : "")).join(`
`)
        : A.prompt;
      return AG([
        T0({
          content: `The user sent the following message:
${Q}

Please address this message and continue with your tasks.`,
          isMeta: !0,
        }),
      ]);
    }
    case "ultramemory":
      return AG([T0({ content: A.content, isMeta: !0 })]);
    case "output_style": {
      let Q = ro[A.style];
      if (!Q) return [];
      return AG([
        T0({
          content: `${Q.name} output style is active. Remember to follow the specific guidelines for this style.`,
          isMeta: !0,
        }),
      ]);
    }
    case "diagnostics": {
      if (A.files.length === 0) return [];
      let Q = fO.formatDiagnosticsSummary(A.files);
      return AG([
        T0({
          content: `<new-diagnostics>The following new diagnostic issues were detected:

${Q}</new-diagnostics>`,
          isMeta: !0,
        }),
      ]);
    }
    case "plan_mode":
      return QQI(A);
    case "mcp_resource": {
      let Q = A.content;
      if (!Q || !Q.contents || Q.contents.length === 0)
        return AG([
          T0({
            content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No content)</mcp-resource>`,
            isMeta: !0,
          }),
        ]);
      let I = [];
      for (let G of Q.contents)
        if (G && typeof G === "object") {
          if ("text" in G && typeof G.text === "string")
            I.push(
              { type: "text", text: "Full contents of resource:" },
              { type: "text", text: G.text },
              {
                type: "text",
                text: "Do NOT read this resource again unless you think it may have changed, since you already have the full contents.",
              },
            );
          else if ("blob" in G) {
            let Z =
              "mimeType" in G ? String(G.mimeType) : "application/octet-stream";
            I.push({ type: "text", text: `[Binary content: ${Z}]` });
          }
        }
      if (I.length > 0) return AG([T0({ content: I, isMeta: !0 })]);
      else
        return (
          P0(
            A.server,
            `No displayable content found in MCP resource ${A.uri}.`,
          ),
          AG([
            T0({
              content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No displayable content)</mcp-resource>`,
              isMeta: !0,
            }),
          ])
        );
    }
    case "agent_mention":
      return AG([
        T0({
          content: `The user has expressed a desire to invoke the agent "${A.agentType}". Please invoke the agent appropriately, passing in the required context to it. `,
          isMeta: !0,
        }),
      ]);
    case "background_remote_session_status":
      return AG([
        T0({
          content: `<background-remote-session-status>Task id:${A.taskId}
Title:${A.title}
Status:${A.status}
Delta summary since last flush:${A.deltaSummarySinceLastFlushToAttachment}</background-remote-session-status>`,
          isMeta: !0,
        }),
      ]);
    case "background_shell_status": {
      let Q = [
        `Background Bash ${A.taskId}`,
        `(command: ${A.command})`,
        `(status: ${A.status})`,
      ];
      if (A.exitCode !== void 0) Q.push(`(exit code: ${A.exitCode})`);
      if (A.hasNewOutput)
        Q.push(
          "Has new output available. You can check its output using the BashOutput tool.",
        );
      return [T0({ content: Sb(Q.join(" ")), isMeta: !0 })];
    }
    case "async_hook_response": {
      let Q = A.response,
        I = [];
      if (Q.systemMessage) I.push(T0({ content: Q.systemMessage, isMeta: !0 }));
      if (
        Q.hookSpecificOutput &&
        "additionalContext" in Q.hookSpecificOutput &&
        Q.hookSpecificOutput.additionalContext
      )
        I.push(
          T0({ content: Q.hookSpecificOutput.additionalContext, isMeta: !0 }),
        );
      return AG(I);
    }
    case "async_agent_status": {
      let Q = A.status,
        I = A.error ? `: ${A.error}` : "";
      return [
        T0({
          content: `<system-notification>Async agent "${A.description}" ${Q}${I}. The output can be retrieved using AgentOutputTool with agentId: "${A.agentId}"</system-notification>`,
          isMeta: !0,
        }),
      ];
    }
    case "memory": {
      let Q = A.memories.map((I) => {
        let G =
          I.remainingLines && I.remainingLines > 0
            ? ` (${I.remainingLines} more lines in full file)`
            : "";
        return `## Previous Session (${(I.lastModified instanceof Date ? I.lastModified : new Date(I.lastModified)).toLocaleDateString()})
Full session notes: ${I.fullPath}${G}

${I.content}`;
      }).join(`

---

`);
      return AG([
        T0({
          content: `<session-memory>
These session summaries are from PAST sessions that might not be related to the current task and may have outdated info. Do not assume the current task is related to these summaries, until the user's messages indicate so or reference similar tasks. Only a preview of each memory is shown - use the Read tool with the provided path to access full session memory when a session is relevant.

${Q}
</session-memory>`,
          isMeta: !0,
        }),
      ]);
    }
    case "token_usage":
      return [
        T0({
          content: Sb(
            `Token usage: ${A.used}/${A.total}; ${A.remaining} remaining`,
          ),
          isMeta: !0,
        }),
      ];
    case "budget_usd":
      return [
        T0({
          content: Sb(
            `USD budget: $${A.used}/$${A.total}; $${A.remaining} remaining`,
          ),
          isMeta: !0,
        }),
      ];
    case "hook_blocking_error":
      return [
        T0({
          content: Sb(
            `${A.hookName} hook blocking error from command: "${A.blockingError.command}": ${A.blockingError.blockingError}`,
          ),
          isMeta: !0,
        }),
      ];
    case "hook_success":
      if (A.hookEvent !== "SessionStart" && A.hookEvent !== "UserPromptSubmit")
        return [];
      if (A.content === "") return [];
      return [
        T0({
          content: Sb(`${A.hookName} hook success: ${A.content}`),
          isMeta: !0,
        }),
      ];
    case "hook_additional_context": {
      if (A.content.length === 0) return [];
      return [
        T0({
          content: Sb(
            `${A.hookName} hook additional context: ${A.content.join(`
`)}`,
          ),
          isMeta: !0,
        }),
      ];
    }
    case "hook_stopped_continuation":
      return [
        T0({
          content: Sb(`${A.hookName} hook stopped continuation: ${A.message}`),
          isMeta: !0,
        }),
      ];
    case "already_read_file":
    case "command_permissions":
    case "edited_image_file":
    case "hook_cancelled":
    case "hook_error_during_execution":
    case "hook_non_blocking_error":
    case "hook_system_message":
      return [];
  }
  if (["autocheckpointing", "background_task_status"].includes(A.type))
    return [];
  return (
    P$(
      "normalizeAttachmentForAPI",
      Error(`Unknown attachment type: ${A.type}`),
    ),
    []
  );
}
function r$A(A, B) {
  try {
    let Q = A.mapToolResultToToolResultBlockParam(B, "1");
    if (Array.isArray(Q.content) && Q.content.some((I) => I.type === "image"))
      return T0({ content: Q.content, isMeta: !0 });
    return T0({
      content: `Result of calling the ${A.name} tool: ${JSON.stringify(Q.content)}`,
      isMeta: !0,
    });
  } catch {
    return T0({
      content: `Result of calling the ${A.name} tool: Error`,
      isMeta: !0,
    });
  }
}
function o$A(A, B) {
  return T0({
    content: `Called the ${A} tool with the following input: ${JSON.stringify(B)}`,
    isMeta: !0,
  });
}
function bN(A, B, Q, I) {
  return {
    type: "system",
    subtype: "informational",
    content: A,
    isMeta: !1,
    timestamp: new Date().toISOString(),
    uuid: RL(),
    toolUseID: Q,
    level: B,
    ...(I && { preventContinuation: I }),
  };
}
function WaQ(A, B, Q, I, G, Z, Y, J) {
  return {
    type: "system",
    subtype: "stop_hook_summary",
    hookCount: A,
    hookInfos: B,
    hookErrors: Q,
    preventedContinuation: I,
    stopReason: G,
    hasOutput: Z,
    level: Y,
    timestamp: new Date().toISOString(),
    uuid: RL(),
    toolUseID: J,
  };
}
function tl1(A) {
  return {
    type: "system",
    subtype: "local_command",
    content: A,
    level: "info",
    timestamp: new Date().toISOString(),
    uuid: RL(),
    isMeta: !1,
  };
}
function VLQ(A, B) {
  return {
    type: "system",
    subtype: "compact_boundary",
    content: "Conversation compacted",
    isMeta: !1,
    timestamp: new Date().toISOString(),
    uuid: RL(),
    level: "info",
    compactMetadata: { trigger: A, preTokens: B },
  };
}
function sxQ(A, B, Q, I) {
  return {
    type: "system",
    subtype: "api_error",
    level: "error",
    cause: A.cause instanceof Error ? A.cause : void 0,
    error: A,
    retryInMs: B,
    retryAttempt: Q,
    maxRetries: I,
    timestamp: new Date().toISOString(),
    uuid: RL(),
  };
}
function pr(A) {
  return A?.type === "system" && A.subtype === "compact_boundary";
}
function YQI(A) {
  for (let B = A.length - 1; B >= 0; B--) {
    let Q = A[B];
    if (Q && pr(Q)) return B;
  }
  return -1;
}
function dj(A) {
  let B = YQI(A);
  if (B === -1) return A;
  return A.slice(B);
}
function bS2(A, B) {
  if (A.type !== "user") return !0;
  if (A.isMeta) return !1;
  if (A.isVisibleInTranscriptOnly && !B) return !1;
  return !0;
}
function ZLQ(A) {
  if (A.type !== "assistant") return !1;
  if (!Array.isArray(A.message.content)) return !1;
  return A.message.content.every((B) => B.type === "thinking");
}
var W6A = "[Request interrupted by user]",
  YN = "[Request interrupted by user for tool use]",
  Rv1 =
    "Tool call rejected -- yielding control back to user for further instructions.",
  v8A =
    "The user doesn't want to take this action right now. STOP what you are doing and wait for the user to tell you how to proceed.",
  NDA =
    "The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.",
  MKA = `The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:
`,
  cS1 = `The agent proposed a plan that was rejected by the user. The user chose to stay in plan mode rather than proceed with implementation.

Rejected plan:
`,
  Oa = "No response requested.",
  c_1,
  BQI;
var iB = T(() => {
  O$();
  Q0A();
  H0();
  Gy();
  sq();
  $D();
  Ls();
  Ww();
  vn();
  wC();
  RzA();
  c1();
  C0();
  WK();
  wv();
  EF();
  dB1();
  S7A();
  c_1 = new Set([W6A, YN, v8A, NDA, Rv1, Oa]);
  BQI = ["commit_analysis", "context", "function_analysis", "pr_analysis"];
});
import { join as wt } from "path";
import { basename as JQI } from "path";
function tt1(A) {
  return (
    A.type === "user" ||
    A.type === "assistant" ||
    A.type === "attachment" ||
    A.type === "system"
  );
}
function e$A() {
  return wt(mB(), "projects");
}
function u11() {
  return EQ1(L0());
}
function EQ1(A) {
  let B = rw(Jp);
  return wt(B, `${A}.jsonl`);
}
function HQ1(A) {
  let B = rw(Jp);
  return wt(B, `agent-${A}.jsonl`);
}
function ir2(A) {
  let B = rw(Jp),
    Q = wt(B, `${A}.jsonl`),
    I = NA();
  try {
    return (I.statSync(Q), !0);
  } catch {
    return !1;
  }
}
function XQI() {
  return "production";
}
function nr2() {
  return "external";
}
function WQI(A) {
  return A.replace(/[^a-zA-Z0-9]/g, "-");
}
function rw(A) {
  return wt(e$A(), WQI(A));
}
function AD() {
  if (!$Q1) {
    if ((($Q1 = new ar2()), !lr2))
      (nY(async () => {
        await $Q1?.flush();
      }),
        (lr2 = !0));
  }
  return $Q1;
}
class ar2 {
  summaries;
  customTitles;
  messages;
  checkpoints;
  fileHistorySnapshots;
  didLoad = !1;
  sessionFile = null;
  remoteIngressUrl = null;
  pendingWriteCount = 0;
  flushResolvers = [];
  constructor() {
    ((this.summaries = new Map()),
      (this.customTitles = new Map()),
      (this.messages = new Map()),
      (this.checkpoints = new Map()),
      (this.fileHistorySnapshots = new Map()));
  }
  incrementPendingWrites() {
    this.pendingWriteCount++;
  }
  decrementPendingWrites() {
    if ((this.pendingWriteCount--, this.pendingWriteCount === 0)) {
      for (let A of this.flushResolvers) A();
      this.flushResolvers = [];
    }
  }
  async trackWrite(A) {
    this.incrementPendingWrites();
    try {
      return await A();
    } finally {
      this.decrementPendingWrites();
    }
  }
  async flush() {
    if (this.pendingWriteCount === 0) return;
    return new Promise((A) => {
      this.flushResolvers.push(A);
    });
  }
  async insertMessageChain(A, B = !1, Q) {
    return this.trackWrite(async () => {
      let I = null,
        G;
      try {
        G = await T_();
      } catch {
        G = void 0;
      }
      for (let Z of A) {
        let Y = pr(Z),
          J = {
            parentUuid: Y ? null : I,
            logicalParentUuid: Y ? I : void 0,
            isSidechain: B,
            userType: nr2(),
            cwd: G0(),
            sessionId: L0(),
            version: {
              ISSUES_EXPLAINER:
                "report the issue at https://github.com/anthropics/claude-code/issues",
              PACKAGE_URL: "@anthropic-ai/claude-code",
              README_URL: "https://docs.claude.com/s/claude-code",
              VERSION: "2.0.42",
              FEEDBACK_CHANNEL:
                "https://github.com/anthropics/claude-code/issues",
            }.VERSION,
            gitBranch: G,
            agentId: Q,
            ...Z,
          };
        (this.messages.set(Z.uuid, J), await this.appendEntry(J), (I = Z.uuid));
      }
    });
  }
  async insertCheckpoint(A) {
    return this.trackWrite(async () => {
      let B = L0(),
        Q = {
          type: "checkpoint",
          sessionId: B,
          commit: A.commit,
          timestamp: A.timestamp.toISOString(),
          label: A.label,
          id: A.id,
        };
      if (!this.checkpoints.has(B)) this.checkpoints.set(B, []);
      (this.checkpoints.get(B)?.push(Q), await this.appendEntry(Q));
    });
  }
  async insertFileHistorySnapshot(A, B, Q) {
    return this.trackWrite(async () => {
      let I = {
        type: "file-history-snapshot",
        messageId: A,
        snapshot: B,
        isSnapshotUpdate: Q,
      };
      await this.appendEntry(I);
    });
  }
  async insertQueueOperation(A) {
    return this.trackWrite(async () => {
      await this.appendEntry(A);
    });
  }
  async appendEntry(A) {
    let B = process.env.TEST_ENABLE_SESSION_PERSISTENCE === "true";
    if ((XQI() === "test" && !B) || N0()?.cleanupPeriodDays === 0) return;
    let Q = NA();
    if (this.sessionFile === null) {
      let G = rw(Jp);
      try {
        Q.statSync(G);
      } catch {
        Q.mkdirSync(G);
      }
      this.sessionFile = u11();
      try {
        Q.statSync(this.sessionFile);
      } catch {
        Q.writeFileSync(this.sessionFile, "", {
          encoding: "utf8",
          flush: !0,
          mode: 384,
        });
      }
    }
    if (this.sessionFile !== null)
      try {
        Q.statSync(this.sessionFile);
      } catch {
        let G = rw(Jp);
        try {
          Q.statSync(G);
        } catch {
          Q.mkdirSync(G);
        }
        Q.writeFileSync(this.sessionFile, "", {
          encoding: "utf8",
          flush: !0,
          mode: 384,
        });
      }
    let I = L0();
    if (A.type === "summary")
      Q.appendFileSync(
        this.sessionFile,
        JSON.stringify(A) +
          `
`,
        { mode: 384 },
      );
    else if (A.type === "custom-title")
      Q.appendFileSync(
        this.sessionFile,
        JSON.stringify(A) +
          `
`,
        { mode: 384 },
      );
    else if (A.type === "file-history-snapshot")
      Q.appendFileSync(
        this.sessionFile,
        JSON.stringify(A) +
          `
`,
        { mode: 384 },
      );
    else {
      let { messageSet: G, checkpointSet: Z } = await er2(I);
      if (A.type === "checkpoint") {
        if (A.id && !Z.has(A.id))
          (Q.appendFileSync(
            this.sessionFile,
            JSON.stringify(A) +
              `
`,
            { mode: 384 },
          ),
            Z.add(A.id));
      } else if (A.type === "queue-operation")
        Q.appendFileSync(
          this.sessionFile,
          JSON.stringify(A) +
            `
`,
          { mode: 384 },
        );
      else {
        let Y = A.isSidechain && A.agentId !== void 0,
          J = Y ? HQ1(A.agentId) : this.sessionFile;
        if (Y)
          try {
            Q.statSync(J);
          } catch {
            let X = rw(Jp);
            try {
              Q.statSync(X);
            } catch {
              Q.mkdirSync(X);
            }
            Q.writeFileSync(J, "", { encoding: "utf8", flush: !0, mode: 384 });
          }
        if (!G.has(A.uuid)) {
          if (
            (Q.appendFileSync(
              J,
              JSON.stringify(A) +
                `
`,
              { mode: 384 },
            ),
            G.add(A.uuid),
            this.remoteIngressUrl && tt1(A))
          )
            await this.persistToRemote(I, A);
        }
      }
    }
  }
  async persistToRemote(A, B) {
    if (!this.remoteIngressUrl) return;
    let Q = 10,
      I = 500;
    for (let G = 1; G <= Q; G++)
      try {
        if (!(await yT2(A, B, this.remoteIngressUrl)))
          throw (
            GA("tengu_session_persistence_failed", { attempt: G }),
            Error("Non-retryable error during remote persistence")
          );
        return;
      } catch (Z) {
        if (G === Q)
          throw (GA("tengu_session_persistence_failed", { attempt: G }), Z);
        let Y = Math.min(I * Math.pow(2, G - 1), 8000);
        (g(
          `Remote persistence attempt ${G}/${Q} failed, retrying in ${Y}ms...`,
        ),
          await new Promise((J) => setTimeout(J, Y)));
      }
  }
  setRemoteIngressUrl(A) {
    ((this.remoteIngressUrl = A),
      g(`Remote persistence enabled with URL: ${A}`));
  }
  async getAllTranscripts(A) {
    await this.loadAllSessions(A);
    let B = [...this.messages.values()],
      Q = new Set(B.map((I) => I.parentUuid));
    return B.filter((I) => !Q.has(I.uuid))
      .map((I) => this.getTranscript(I))
      .filter((I) => I.length);
  }
  getTranscript(A) {
    return qB0(this.messages, A);
  }
  async getLastLog(A) {
    let { messages: B } = await NB0(A);
    if (B.size === 0) return null;
    let I = Array.from(B.values())
      .filter((Z) => !Z.isSidechain)
      .sort(
        (Z, Y) =>
          new Date(Y.timestamp).getTime() - new Date(Z.timestamp).getTime(),
      )[0];
    if (!I) return null;
    return qB0(B, I);
  }
  getAllCheckpoints(A) {
    let B = new Map(),
      Q = A[A.length - 1]?.sessionId;
    if (Q) {
      let I = this.checkpoints.get(Q)?.values() || [];
      for (let G of I) {
        let Z = G.id ?? G.commit;
        if (Z) B.set(Z, G);
      }
    }
    return Array.from(B.values());
  }
  loadAllSessions = I0(
    async (A) => {
      let B = rw(Jp),
        Q = NA();
      if (this.didLoad && !A) return this;
      try {
        Q.statSync(B);
      } catch {
        return this;
      }
      let G = Q.readdirSync(B)
        .filter((Y) => Y.isFile() && Y.name.endsWith(".jsonl"))
        .map((Y) => wt(B, Y.name));
      if (A)
        G = G.sort((Y, J) => {
          let X = Q.statSync(Y);
          return Q.statSync(J).mtime.getTime() - X.mtime.getTime();
        }).slice(0, A);
      let Z = await Promise.all(
        G.sort((Y, J) => {
          let X = Q.statSync(Y),
            W = Q.statSync(J);
          return X.mtime.getTime() - W.mtime.getTime();
        }).map(async (Y) => {
          let J = Vz(JQI(Y, ".jsonl"));
          if (!J) return { sessionId: J, sessionMessages: new Set() };
          let X = new Map(),
            W = new Map(),
            F = new Map(),
            C = new Map(),
            V = new Map();
          try {
            await Q.stat(Y);
            for (let K of await Qi(Y))
              if (
                K.type === "user" ||
                K.type === "assistant" ||
                K.type === "attachment" ||
                K.type === "system"
              )
                X.set(K.uuid, K);
              else if (K.type === "summary" && K.leafUuid)
                W.set(K.leafUuid, K.summary);
              else if (K.type === "custom-title" && K.sessionId)
                F.set(K.sessionId, K.customTitle);
              else if (K.type === "checkpoint") {
                let D = K.id ?? K.commit;
                if (D) C.set(D, K);
              } else if (K.type === "file-history-snapshot")
                V.set(K.messageId, K);
          } catch {}
          return {
            sessionId: J,
            sessionMessages: X,
            summaries: W,
            customTitles: F,
            checkpoints: C,
            fileHistorySnapshots: V,
          };
        }),
      );
      for (let {
        sessionId: Y,
        sessionMessages: J,
        summaries: X,
        customTitles: W,
        checkpoints: F,
        fileHistorySnapshots: C,
      } of Z) {
        if (!Y) continue;
        for (let [V, K] of J.entries()) this.messages.set(V, K);
        for (let [V, K] of X.entries()) this.summaries.set(V, K);
        for (let [V, K] of W.entries()) this.customTitles.set(V, K);
        this.checkpoints.set(Y, Array.from(F.values()));
        for (let [V, K] of C.entries()) this.fileHistorySnapshots.set(V, K);
      }
      if (!A) this.didLoad = !0;
      return this;
    },
    (A) => A?.toString() || "all",
  );
}
async function tHA(A) {
  let B = Bo2(A);
  return (await AD().insertMessageChain(B), B[B.length - 1]?.uuid || null);
}
async function Kf2(A, B) {
  await AD().insertMessageChain(Bo2(A), !0, B);
}
async function $p1(A) {
  await AD().insertCheckpoint(A);
}
async function hHA(A) {
  await AD().insertQueueOperation(A);
}
async function TdA(A, B, Q) {
  await AD().insertFileHistorySnapshot(A, B, Q);
}
async function Vy() {
  let A = AD();
  A.sessionFile = u11();
}
async function sr2(A, B) {
  (QM(A), AD().setRemoteIngressUrl(B));
  try {
    let I = (await _T2(A, B)) || [],
      G = NA(),
      Z = rw(Jp);
    try {
      G.statSync(Z);
    } catch {
      G.mkdirSync(Z);
    }
    let Y = EQ1(A);
    if (G.existsSync(Y)) G.unlinkSync(Y);
    for (let J of I)
      G.appendFileSync(
        Y,
        JSON.stringify(J) +
          `
`,
        { mode: 384 },
      );
    if (I.length === 0 && !G.existsSync(Y))
      G.writeFileSync(Y, "", { encoding: "utf8", flush: !0, mode: 384 });
    return (g(`Hydrated ${I.length} entries from remote`), I.length > 0);
  } catch (I) {
    return (g(`Error hydrating session from remote: ${I}`), !1);
  }
}
function FQI(A) {
  let B = CQI(A);
  if (B) {
    let Q = B.replace(/\n/g, " ").trim();
    if (Q.length > 200) Q = Q.slice(0, 200).trim() + "";
    return Q;
  }
  return "No prompt";
}
function CQI(A) {
  for (let B of A) {
    if (B.type !== "user" || B.isMeta) continue;
    let Q = B.message?.content;
    if (!Q) continue;
    let I = "";
    if (typeof Q === "string") I = Q;
    else if (Array.isArray(Q)) I = Q.find((Y) => Y.type === "text")?.text || "";
    if (!I) continue;
    let G = g2(I, "command-name");
    if (G) {
      let Z = G.replace(/^\//, "");
      if (RS().has(Z)) continue;
      else {
        let Y = g2(I, "command-args");
        if (!Y || Y.trim() === "") continue;
      }
    }
    if (I.match(/^<local-command-stdout>/)) continue;
    if (I.match(/^<session-start-hook>/)) continue;
    return I;
  }
  return;
}
function VQI(A) {
  return A.map((B) => {
    let { isSidechain: Q, parentUuid: I, ...G } = B;
    return G;
  });
}
function qB0(A, B) {
  let Q = [],
    I = B;
  while (I) (Q.unshift(I), (I = I.parentUuid ? A.get(I.parentUuid) : void 0));
  return Q;
}
function rr2(A, B) {
  let Q = [];
  for (let I of B) {
    let G = A.get(I.uuid);
    if (!G) continue;
    if (!G.isSnapshotUpdate) Q.push(G.snapshot);
    else {
      let Z = Q.findLastIndex((Y) => Y.messageId === G.snapshot.messageId);
      if (Z === -1) Q.push(G.snapshot);
      else Q[Z] = G.snapshot;
    }
  }
  return Q;
}
function or2(A, B = 0, Q, I, G, Z) {
  let Y = A[A.length - 1],
    J = A[0],
    X = FQI(A),
    W = new Date(J.timestamp),
    F = new Date(Y.timestamp),
    C = G?.map((V) => ({
      id: V.id ?? "unavailable",
      commit: V.commit,
      timestamp: new Date(V.timestamp),
      label: V.label,
    }));
  return {
    date: Y.timestamp,
    messages: VQI(A),
    fullPath: "n/a",
    value: B,
    created: W,
    modified: F,
    firstPrompt: X,
    messageCount: A.length,
    isSidechain: J.isSidechain,
    leafUuid: Y.uuid,
    summary: Q,
    customTitle: I,
    checkpoints: C,
    fileHistorySnapshots: Z,
    gitBranch: Y.gitBranch,
  };
}
async function KQI(A) {
  let B = new Map(),
    Q = 0;
  for (let Y of A) {
    let J = Y.messages[0]?.sessionId;
    if (J) {
      let X = (B.get(J) || 0) + 1;
      (B.set(J, X), (Q = Math.max(X, Q)));
    }
  }
  if (Q <= 1) return;
  let I = Array.from(B.values()).filter((Y) => Y > 1),
    G = I.length,
    Z = I.reduce((Y, J) => Y + J, 0);
  GA("tengu_session_forked_branches_fetched", {
    total_sessions: B.size,
    sessions_with_branches: G,
    max_branches_per_session: Math.max(...I),
    avg_branches_per_session: Math.round(Z / G),
    total_transcript_count: A.length,
  });
}
async function DQI(A) {
  let B = await AD().getAllTranscripts(A),
    Q = AD().summaries,
    I = AD().customTitles,
    G = B.map((Z, Y) => {
      let J = Z[Z.length - 1],
        X = J ? Q.get(J.uuid) : void 0,
        W = J ? I.get(J.sessionId) : void 0,
        F = J ? AD().getAllCheckpoints(Z) : void 0,
        C = rr2(AD().fileHistorySnapshots, Z);
      return or2(Z, Y, X, W, F, C);
    }).sort((Z, Y) => {
      return Y.modified.getTime() - Z.modified.getTime();
    });
  return (await KQI(G), G);
}
async function tr2(A, B) {
  await AD().appendEntry({ type: "summary", summary: B, leafUuid: A });
}
async function yB1(A, B) {
  (await AD().appendEntry({
    type: "custom-title",
    customTitle: B,
    sessionId: A,
  }),
    AD().customTitles.set(A, B),
    GA("tengu_session_renamed", {}));
}
async function qQ1(A) {
  let B = new Map(),
    Q = new Map(),
    I = new Map(),
    G = new Map(),
    Z = new Map();
  try {
    let Y = await Qi(A);
    for (let J of Y)
      if (
        J.type === "user" ||
        J.type === "assistant" ||
        J.type === "attachment" ||
        J.type === "system"
      )
        B.set(J.uuid, J);
      else if (J.type === "summary" && J.leafUuid) Q.set(J.leafUuid, J.summary);
      else if (J.type === "custom-title" && J.sessionId)
        I.set(J.sessionId, J.customTitle);
      else if (J.type === "checkpoint") {
        let X = J.id ?? J.commit;
        if (X) G.set(X, J);
      } else if (J.type === "file-history-snapshot") Z.set(J.messageId, J);
  } catch {}
  return {
    messages: B,
    summaries: Q,
    customTitles: I,
    checkpoints: G,
    fileHistorySnapshots: Z,
  };
}
async function NB0(A) {
  let B = wt(rw(G0()), `${A}.jsonl`);
  return qQ1(B);
}
async function Ao2(A, B) {
  let { messageSet: Q } = await er2(A);
  return Q.has(B);
}
async function lQ2(A) {
  let B = await AD().getLastLog(A);
  if (B !== null && B !== void 0) {
    let Q = B[B.length - 1],
      {
        summaries: I,
        customTitles: G,
        checkpoints: Z,
        fileHistorySnapshots: Y,
      } = await NB0(A),
      J = Q ? I.get(Q.uuid) : void 0,
      X = Q ? G.get(Q.sessionId) : void 0;
    return or2(B, 0, J, X, Array.from(Z.values()), rr2(Y, B));
  }
  return null;
}
async function Wy(A) {
  let Q = (await DQI(A)).filter((I) => {
    if (!I.messages.length) return !1;
    if (I.firstPrompt?.startsWith("API Error")) return !1;
    if (I.summary?.startsWith("API Error")) return !1;
    if (I.isSidechain) return !1;
    return !0;
  });
  return V61(Q).map((I, G) => ({ ...I, value: G }));
}
async function Sf2(A) {
  let B = HQ1(A),
    Q = NA();
  try {
    Q.statSync(B);
  } catch {
    return null;
  }
  try {
    let { messages: I } = await qQ1(B),
      G = Array.from(I.values()).filter(
        (W) => W.agentId === A && W.isSidechain,
      );
    if (G.length === 0) return null;
    let Z = new Set(G.map((W) => W.parentUuid)),
      Y = G.filter((W) => !Z.has(W.uuid)).sort(
        (W, F) =>
          new Date(F.timestamp).getTime() - new Date(W.timestamp).getTime(),
      )[0];
    if (!Y) return null;
    return qB0(I, Y)
      .filter((W) => W.agentId === A)
      .map(({ isSidechain: W, parentUuid: F, ...C }) => C);
  } catch {
    return null;
  }
}
function Bo2(A) {
  return A.filter((B) => {
    if (B.type === "progress") return !1;
    if (B.type === "attachment" && nr2() !== "ant") return !1;
    return !0;
  });
}
async function iQ2(A) {
  return (await Wy())[A] || null;
}
var Jp,
  $Q1 = null,
  lr2 = !1,
  er2;
var E7 = T(() => {
  iB();
  i0();
  vB();
  V2();
  m0();
  wC();
  Tv();
  OQ();
  a2();
  vC();
  rt1();
  C0();
  Gz();
  H0();
  BU();
  Jp = G0();
  er2 = I0(
    async (A) => {
      let { messages: B, checkpoints: Q } = await NB0(A);
      return {
        messageSet: new Set(B.keys()),
        checkpointSet: new Set(Q.keys()),
      };
    },
    (A) => A,
  );
});
import { join as AqA, posix as Xp, sep as EQI } from "path";
import { homedir as HQI } from "os";
function NO(A) {
  return A.toLowerCase();
}
function Io2(A, B) {
  if (EB() === "windows") {
    let Q = gT(A),
      I = gT(B);
    return Xp.relative(Q, I);
  }
  return Xp.relative(A, B);
}
function NQ1(A) {
  if (EB() === "windows") return gT(A);
  return A;
}
function zQI() {
  return jk.map((A) => zU(A)).filter((A) => A !== void 0);
}
function Mu1(A) {
  let B = M9(A),
    Q = NO(B);
  if (
    Q.endsWith("/.claude/settings.json") ||
    Q.endsWith("/.claude/settings.local.json")
  )
    return !0;
  return zQI().some((I) => NO(I) === Q);
}
function UQI(A) {
  if (Mu1(A)) return !0;
  let B = AqA(GQ(), ".claude", "commands"),
    Q = AqA(GQ(), ".claude", "agents"),
    I = AqA(GQ(), ".claude", "skills");
  return hx(A, B) || hx(A, Q) || hx(A, I);
}
function wQI(A) {
  if (!ge()) return !1;
  let B = M9(A);
  return hx(B, ge());
}
function $QI(A) {
  let Q = M9(A).split(EQI),
    I = Q[Q.length - 1];
  if (A.startsWith("\\\\") || A.startsWith("//")) return !0;
  for (let G of jj1) {
    let Z = NO(G);
    if (Q.some((Y) => NO(Y) === Z)) return !0;
  }
  if (I) {
    let G = NO(I);
    if (Pj1.some((Z) => NO(Z) === G)) return !0;
  }
  return !1;
}
function Go2(A) {
  if (A.indexOf(":", 2) !== -1) return !0;
  if (/~\d/.test(A)) return !0;
  if (
    A.startsWith("\\\\?\\") ||
    A.startsWith("\\\\.\\") ||
    A.startsWith("//?/") ||
    A.startsWith("//./")
  )
    return !0;
  if (/[.\s]+$/.test(A)) return !0;
  if (/\.(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i.test(A)) return !0;
  if (/\.{3,}/.test(A)) return !0;
  if (CQ1(A)) return !0;
  return !1;
}
function Hj1(A) {
  let B = Il(A);
  for (let Q of B)
    if (Go2(Q))
      return {
        safe: !1,
        message: `Claude requested permissions to write to ${A}, which contains a suspicious Windows path pattern that requires manual approval.`,
      };
  for (let Q of B)
    if (UQI(Q))
      return {
        safe: !1,
        message: `Claude requested permissions to write to ${A}, but you haven't granted it yet.`,
      };
  for (let Q of B) if (wQI(Q));
  for (let Q of B)
    if ($QI(Q))
      return {
        safe: !1,
        message: `Claude requested permissions to edit ${A} which is a sensitive file.`,
      };
  return { safe: !0 };
}
function u4A(A) {
  return new Set([GQ(), ...A.additionalWorkingDirectories.keys()]);
}
function qO(A, B) {
  return Il(A).every((I) => Array.from(u4A(B)).some((G) => hx(I, G)));
}
function hx(A, B) {
  let Q = M9(A),
    I = M9(B),
    G = Q.replace(/^\/private\/var\//, "/var/").replace(
      /^\/private\/tmp(\/|$)/,
      "/tmp$1",
    ),
    Z = I.replace(/^\/private\/var\//, "/var/").replace(
      /^\/private\/tmp(\/|$)/,
      "/tmp$1",
    ),
    Y = NO(G),
    J = NO(Z),
    X = Io2(J, Y);
  if (X === "") return !0;
  if (B0A(X)) return !1;
  return !Xp.isAbsolute(X);
}
function qQI(A) {
  switch (A) {
    case "cliArg":
    case "command":
    case "session":
      return M9(GQ());
    case "userSettings":
    case "policySettings":
    case "projectSettings":
    case "localSettings":
    case "flagSettings":
      return LQ1(A);
  }
}
function LB0(A) {
  return Xp.join(NE, A);
}
function NQI({ patternRoot: A, pattern: B, rootPath: Q }) {
  let I = Xp.join(A, B);
  if (A === Q) return LB0(B);
  else if (I.startsWith(`${Q}${NE}`)) {
    let G = I.slice(Q.length);
    return LB0(G);
  } else {
    let G = Xp.relative(Q, A);
    if (!G || G.startsWith(`..${NE}`) || G === "..") return null;
    else {
      let Z = Xp.join(G, B);
      return LB0(Z);
    }
  }
}
function E6A(A, B) {
  let Q = new Set(A.get(null) ?? []);
  for (let [I, G] of A.entries()) {
    if (I === null) continue;
    for (let Z of G) {
      let Y = NQI({ patternRoot: I, pattern: Z, rootPath: B });
      if (Y) Q.add(Y);
    }
  }
  return Array.from(Q);
}
function H6A(A) {
  let B = Zo2(A, "read", "deny"),
    Q = new Map();
  for (let [I, G] of B.entries()) Q.set(I, Array.from(G.keys()));
  return Q;
}
function LQI(A, B) {
  if (A.startsWith(`${NE}${NE}`)) {
    let I = A.slice(1);
    if (EB() === "windows" && I.match(/^\/[a-z]\//i)) {
      let G = I[1]?.toUpperCase() ?? "C",
        Z = I.slice(2),
        Y = `${G}:\\`;
      return { relativePattern: Z.startsWith("/") ? Z.slice(1) : Z, root: Y };
    }
    return { relativePattern: I, root: NE };
  } else if (A.startsWith(`~${NE}`))
    return { relativePattern: A.slice(1), root: HQI() };
  else if (A.startsWith(NE)) return { relativePattern: A, root: qQI(B) };
  let Q = A;
  if (A.startsWith(`.${NE}`)) Q = A.slice(2);
  return { relativePattern: Q, root: null };
}
function Zo2(A, B, Q) {
  let I = (() => {
      switch (B) {
        case "edit":
          return g5;
        case "read":
          return z3;
      }
    })(),
    G = MB0(A, I, Q),
    Z = new Map();
  for (let [Y, J] of G.entries()) {
    let { relativePattern: X, root: W } = LQI(Y, J.source),
      F = Z.get(W);
    if (F === void 0) ((F = new Map()), Z.set(W, F));
    F.set(X, J);
  }
  return Z;
}
function nC(A, B, Q, I) {
  let G = M9(A);
  if (EB() === "windows" && G.includes("\\")) G = gT(G);
  let Z = Zo2(B, Q, I);
  for (let [Y, J] of Z.entries()) {
    let X = Array.from(J.keys()).map((V) => {
        let K = V;
        if (Y === NE && V.startsWith(NE)) K = V.slice(1);
        if (K.endsWith("/**")) K = K.slice(0, -3);
        return K;
      }),
      W = Qo2.default().add(X),
      F = Io2(Y ?? G0(), G ?? G0());
    if (F.startsWith(`..${NE}`)) continue;
    if (!F) continue;
    let C = W.test(F);
    if (C.ignored && C.rule) {
      let V = C.rule.pattern,
        K = V + "/**";
      if (J.has(K)) return J.get(K) ?? null;
      if (Y === NE && !V.startsWith(NE)) {
        V = NE + V;
        let D = V + "/**";
        if (J.has(D)) return J.get(D) ?? null;
      }
      return J.get(V) ?? null;
    }
  }
  return null;
}
function jm(A, B, Q) {
  if (typeof A.getPath !== "function")
    return {
      behavior: "ask",
      message: `Claude requested permissions to use ${A.name}, but you haven't granted it yet.`,
    };
  let I = A.getPath(B),
    G = Il(I);
  for (let C of G)
    if (C.startsWith("\\\\") || C.startsWith("//"))
      return {
        behavior: "ask",
        message: `Claude requested permissions to read from ${I}, which appears to be a UNC path that could access network resources.`,
        decisionReason: {
          type: "other",
          reason: "UNC path detected (defense-in-depth check)",
        },
      };
  for (let C of G)
    if (Go2(C))
      return {
        behavior: "ask",
        message: `Claude requested permissions to read from ${I}, which contains a suspicious Windows path pattern that requires manual approval.`,
        decisionReason: {
          type: "other",
          reason:
            "Path contains suspicious Windows-specific patterns (alternate data streams, short names, long path prefixes, or three or more consecutive dots) that require manual verification",
        },
      };
  for (let C of G) {
    let V = nC(C, Q, "read", "deny");
    if (V)
      return {
        behavior: "deny",
        message: `Permission to read ${I} has been denied.`,
        decisionReason: { type: "rule", rule: V },
      };
  }
  for (let C of G) {
    let V = nC(C, Q, "read", "ask");
    if (V)
      return {
        behavior: "ask",
        message: `Claude requested permissions to read from ${I}, but you haven't granted it yet.`,
        decisionReason: { type: "rule", rule: V },
      };
  }
  let Z = ks(A, B, Q);
  if (Z.behavior === "allow") return Z;
  if (qO(I, Q))
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: { type: "mode", mode: "default" },
    };
  let J = M9(I),
    X = AqA(rw(GQ()), "bash-outputs", L0());
  if (J.startsWith(X))
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: {
        type: "other",
        reason:
          "Bash output files from current session are allowed for reading",
      },
    };
  let W = AqA(mB(), "session-memory");
  if (J.startsWith(W))
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: {
        type: "other",
        reason: "Session memory files are allowed for reading",
      },
    };
  let F = nC(I, Q, "read", "allow");
  if (F)
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: { type: "rule", rule: F },
    };
  return {
    behavior: "ask",
    message: `Claude requested permissions to read from ${I}, but you haven't granted it yet.`,
    suggestions: BoA(I, "read", Q),
    decisionReason: {
      type: "workingDir",
      reason: "Path is outside allowed working directories",
    },
  };
}
function ks(A, B, Q) {
  if (typeof A.getPath !== "function")
    return {
      behavior: "ask",
      message: `Claude requested permissions to use ${A.name}, but you haven't granted it yet.`,
    };
  let I = A.getPath(B),
    G = Il(I);
  for (let X of G) {
    let W = nC(X, Q, "edit", "deny");
    if (W)
      return {
        behavior: "deny",
        message: `Permission to edit ${I} has been denied.`,
        decisionReason: { type: "rule", rule: W },
      };
  }
  let Z = Hj1(I);
  if (!Z.safe)
    return {
      behavior: "ask",
      message: Z.message,
      decisionReason: { type: "other", reason: Z.message },
    };
  for (let X of G) {
    let W = nC(X, Q, "edit", "ask");
    if (W)
      return {
        behavior: "ask",
        message: `Claude requested permissions to write to ${I}, but you haven't granted it yet.`,
        decisionReason: { type: "rule", rule: W },
      };
  }
  let Y = qO(I, Q);
  if (Q.mode === "acceptEdits" && Y)
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: { type: "mode", mode: Q.mode },
    };
  let J = nC(I, Q, "edit", "allow");
  if (J)
    return {
      behavior: "allow",
      updatedInput: B,
      decisionReason: { type: "rule", rule: J },
    };
  return {
    behavior: "ask",
    message: `Claude requested permissions to write to ${I}, but you haven't granted it yet.`,
    suggestions: BoA(I, "write", Q),
    decisionReason: !Y
      ? {
          type: "workingDir",
          reason: "Path is outside allowed working directories",
        }
      : void 0,
  };
}
function BoA(A, B, Q) {
  let I = !qO(A, Q);
  if (B === "read" && I) {
    let G = yk(A);
    return Il(G)
      .map((J) => mdA(J, "session"))
      .filter((J) => J !== void 0);
  }
  if (B === "write" || B === "create") {
    let G = [{ type: "setMode", mode: "acceptEdits", destination: "session" }];
    if (I) {
      let Z = yk(A),
        Y = Il(Z);
      G.push({
        type: "addDirectories",
        directories: Y,
        destination: "session",
      });
    }
    return G;
  }
  return [{ type: "setMode", mode: "acceptEdits", destination: "session" }];
}
var Qo2, Pj1, jj1, NE;
var KJ = T(() => {
  i0();
  V2();
  hG();
  A0A();
  E7();
  E5();
  hG();
  aC();
  f3();
  WK();
  OQ();
  vB();
  NC();
  m0();
  vGA();
  WB0();
  ((Qo2 = IA(xiA(), 1)),
    (Pj1 = [
      ".gitconfig",
      ".gitmodules",
      ".bashrc",
      ".bash_profile",
      ".zshrc",
      ".zprofile",
      ".profile",
      ".ripgreprc",
      ".mcp.json",
    ]),
    (jj1 = [".git", ".vscode", ".idea", ".claude"]));
  NE = Xp.sep;
});
import { posix as MQI } from "path";
function d4A(A) {
  if (!A) return [];
  return A.flatMap((B) => {
    switch (B.type) {
      case "addRules":
        return B.rules;
      default:
        return [];
    }
  });
}
function aF(A, B) {
  switch (B.type) {
    case "setMode":
      return (
        g(`Applying permission update: Setting mode to '${B.mode}'`),
        { ...A, mode: B.mode }
      );
    case "addRules": {
      let Q = B.rules.map((G) => H5(G));
      g(
        `Applying permission update: Adding ${B.rules.length} ${B.behavior} rule(s) to destination '${B.destination}': ${JSON.stringify(Q)}`,
      );
      let I =
        B.behavior === "allow"
          ? "alwaysAllowRules"
          : B.behavior === "deny"
            ? "alwaysDenyRules"
            : "alwaysAskRules";
      return {
        ...A,
        [I]: {
          ...A[I],
          [B.destination]: [...(A[I][B.destination] || []), ...Q],
        },
      };
    }
    case "replaceRules": {
      let Q = B.rules.map((G) => H5(G));
      g(
        `Replacing all ${B.behavior} rules for destination '${B.destination}' with ${B.rules.length} rule(s): ${JSON.stringify(Q)}`,
      );
      let I =
        B.behavior === "allow"
          ? "alwaysAllowRules"
          : B.behavior === "deny"
            ? "alwaysDenyRules"
            : "alwaysAskRules";
      return { ...A, [I]: { ...A[I], [B.destination]: Q } };
    }
    case "addDirectories": {
      g(
        `Applying permission update: Adding ${B.directories.length} director${B.directories.length === 1 ? "y" : "ies"} with destination '${B.destination}': ${JSON.stringify(B.directories)}`,
      );
      let Q = new Map(A.additionalWorkingDirectories);
      for (let I of B.directories) Q.set(I, { path: I, source: B.destination });
      return { ...A, additionalWorkingDirectories: Q };
    }
    case "removeRules": {
      let Q = B.rules.map((J) => H5(J));
      g(
        `Applying permission update: Removing ${B.rules.length} ${B.behavior} rule(s) from source '${B.destination}': ${JSON.stringify(Q)}`,
      );
      let I =
          B.behavior === "allow"
            ? "alwaysAllowRules"
            : B.behavior === "deny"
              ? "alwaysDenyRules"
              : "alwaysAskRules",
        G = A[I][B.destination] || [],
        Z = new Set(Q),
        Y = G.filter((J) => !Z.has(J));
      return { ...A, [I]: { ...A[I], [B.destination]: Y } };
    }
    case "removeDirectories": {
      g(
        `Applying permission update: Removing ${B.directories.length} director${B.directories.length === 1 ? "y" : "ies"}: ${JSON.stringify(B.directories)}`,
      );
      let Q = new Map(A.additionalWorkingDirectories);
      for (let I of B.directories) Q.delete(I);
      return { ...A, additionalWorkingDirectories: Q };
    }
    default:
      return A;
  }
}
function so(A, B) {
  let Q = A;
  for (let I of B) Q = aF(Q, I);
  return Q;
}
function We1(A) {
  return (
    A === "localSettings" || A === "userSettings" || A === "projectSettings"
  );
}
function wb(A) {
  if (!We1(A.destination)) return;
  switch (
    (g(`Persisting permission update: ${A.type} to source '${A.destination}'`),
    A.type)
  ) {
    case "addRules": {
      (g(
        `Persisting ${A.rules.length} ${A.behavior} rule(s) to ${A.destination}`,
      ),
        $TA({ ruleValues: A.rules, ruleBehavior: A.behavior }, A.destination));
      break;
    }
    case "addDirectories": {
      g(
        `Persisting ${A.directories.length} director${A.directories.length === 1 ? "y" : "ies"} to ${A.destination}`,
      );
      let Q = cQ(A.destination)?.permissions?.additionalDirectories || [],
        I = A.directories.filter((G) => !Q.includes(G));
      if (I.length > 0) {
        let G = [...Q, ...I];
        B2(A.destination, { permissions: { additionalDirectories: G } });
      }
      break;
    }
    case "removeRules": {
      g(
        `Removing ${A.rules.length} ${A.behavior} rule(s) from ${A.destination}`,
      );
      let I = (cQ(A.destination)?.permissions || {})[A.behavior] || [],
        G = new Set(A.rules.map(H5)),
        Z = I.filter((Y) => !G.has(Y));
      B2(A.destination, { permissions: { [A.behavior]: Z } });
      break;
    }
    case "removeDirectories": {
      g(
        `Removing ${A.directories.length} director${A.directories.length === 1 ? "y" : "ies"} from ${A.destination}`,
      );
      let Q = cQ(A.destination)?.permissions?.additionalDirectories || [],
        I = new Set(A.directories),
        G = Q.filter((Z) => !I.has(Z));
      B2(A.destination, { permissions: { additionalDirectories: G } });
      break;
    }
    case "setMode": {
      (g(`Persisting mode '${A.mode}' to ${A.destination}`),
        B2(A.destination, { permissions: { defaultMode: A.mode } }));
      break;
    }
    case "replaceRules": {
      g(
        `Replacing all ${A.behavior} rules in ${A.destination} with ${A.rules.length} rule(s)`,
      );
      let B = A.rules.map(H5);
      B2(A.destination, { permissions: { [A.behavior]: B } });
      break;
    }
  }
}
function n11(A) {
  for (let B of A) wb(B);
}
function mdA(A, B = "session") {
  try {
    if (NA().statSync(A).isDirectory()) {
      let I = NQ1(A);
      if (I === "/") return;
      return {
        type: "addRules",
        rules: [
          {
            toolName: "Read",
            ruleContent: MQI.isAbsolute(I) ? `/${I}/**` : `${I}/**`,
          },
        ],
        behavior: "allow",
        destination: B,
      };
    }
  } catch {}
  return;
}
var h7A, Yo2;
var aC = T(() => {
  ET0();
  MM();
  f3();
  C0();
  OQ();
  Ci();
  m0();
  KJ();
  e2();
  ((h7A = PQ.enum([
    "userSettings",
    "projectSettings",
    "localSettings",
    "session",
    "cliArg",
  ])),
    (Yo2 = PQ.discriminatedUnion("type", [
      PQ.object({
        type: PQ.literal("addRules"),
        rules: PQ.array(zTA),
        behavior: PQ.enum(["allow", "deny", "ask"]),
        destination: h7A,
      }),
      PQ.object({
        type: PQ.literal("replaceRules"),
        rules: PQ.array(zTA),
        behavior: PQ.enum(["allow", "deny", "ask"]),
        destination: h7A,
      }),
      PQ.object({
        type: PQ.literal("removeRules"),
        rules: PQ.array(zTA),
        behavior: PQ.enum(["allow", "deny", "ask"]),
        destination: h7A,
      }),
      PQ.object({ type: PQ.literal("setMode"), mode: VT0, destination: h7A }),
      PQ.object({
        type: PQ.literal("addDirectories"),
        directories: PQ.array(PQ.string()),
        destination: h7A,
      }),
      PQ.object({
        type: PQ.literal("removeDirectories"),
        directories: PQ.array(PQ.string()),
        destination: h7A,
      }),
    ])));
});
var Jo2 = T(() => {
  c1();
});
function H00(A) {
  switch (A) {
    case "cliArg":
      return "CLI argument";
    case "command":
      return "command configuration";
    case "session":
      return "current session";
    case "localSettings":
      return "project local settings";
    case "projectSettings":
      return "project settings";
    case "policySettings":
      return "policy settings";
    case "userSettings":
      return "user settings";
    case "flagSettings":
      return "flag settings";
  }
}
function jZ(A) {
  let B = A.match(/^([^(]+)\(([^)]+)\)$/);
  if (!B) return { toolName: A };
  let Q = B[1],
    I = B[2];
  if (!Q || !I) return { toolName: A };
  return { toolName: Q, ruleContent: I };
}
function H5(A) {
  return A.ruleContent ? `${A.toolName}(${A.ruleContent})` : A.toolName;
}
function P7A(A) {
  return OB0.flatMap((B) =>
    (A.alwaysAllowRules[B] || []).map((Q) => ({
      source: B,
      ruleBehavior: "allow",
      ruleValue: jZ(Q),
    })),
  );
}
function KW(A, B) {
  if (B)
    switch (B.type) {
      case "hook":
        return B.reason
          ? `Hook '${B.hookName}' blocked this action: ${B.reason}`
          : `Hook '${B.hookName}' requires approval for this ${A} command`;
      case "rule": {
        let I = H5(B.rule.ruleValue),
          G = H00(B.rule.source);
        return `Permission rule '${I}' from ${G} requires approval for this ${A} command`;
      }
      case "subcommandResults": {
        let I = [];
        for (let [G, Z] of B.reasons)
          if (Z.behavior === "ask" || Z.behavior === "passthrough")
            if (A === "Bash") {
              let { commandWithoutRedirections: Y, redirections: J } = Ej(G),
                X = J.length > 0 ? Y : G;
              I.push(X);
            } else I.push(G);
        if (I.length > 0)
          return `This ${A} command contains multiple operations. The following part${I.length > 1 ? "s" : ""} require${I.length > 1 ? "" : "s"} approval: ${I.join(", ")}`;
        return `This ${A} command contains multiple operations that require approval`;
      }
      case "permissionPromptTool":
        return `Tool '${B.permissionPromptToolName}' requires approval for this ${A} command`;
      case "sandboxOverride":
        return "Run outside of the sandbox";
      case "classifier":
        return `Classifier '${B.classifier}' requires approval for this ${A} command: ${B.reason}`;
      case "workingDir":
        return B.reason;
      case "other":
        return B.reason;
      case "mode":
        return `Current permission mode (${Sk(B.mode)}) requires approval for this ${A} command`;
      case "asyncAgent":
        return B.reason;
    }
  return `Claude requested permissions to use ${A}, but you haven't granted it yet.`;
}
function U7A(A) {
  return OB0.flatMap((B) =>
    (A.alwaysDenyRules[B] || []).map((Q) => ({
      source: B,
      ruleBehavior: "deny",
      ruleValue: jZ(Q),
    })),
  );
}
function hB1(A) {
  return OB0.flatMap((B) =>
    (A.alwaysAskRules[B] || []).map((Q) => ({
      source: B,
      ruleBehavior: "ask",
      ruleValue: jZ(Q),
    })),
  );
}
function RB0(A, B) {
  if (B.ruleValue.ruleContent !== void 0) return !1;
  if (B.ruleValue.toolName === A.name) return !0;
  let Q = ZE(B.ruleValue.toolName),
    I = ZE(A.name);
  return (
    Q !== null &&
    I !== null &&
    Q.toolName === void 0 &&
    Q.serverName === I.serverName
  );
}
function Lj1(A, B) {
  return P7A(A).find((Q) => RB0(B, Q)) || null;
}
function Mj1(A, B) {
  return U7A(A).find((Q) => RB0(B, Q)) || null;
}
function Oj1(A, B) {
  return hB1(A).find((Q) => RB0(B, Q)) || null;
}
function UK(A, B, Q) {
  return MB0(A, B.name, Q);
}
function MB0(A, B, Q) {
  let I = new Map(),
    G = [];
  switch (Q) {
    case "allow":
      G = P7A(A);
      break;
    case "deny":
      G = U7A(A);
      break;
    case "ask":
      G = hB1(A);
      break;
  }
  for (let Z of G)
    if (
      Z.ruleValue.toolName === B &&
      Z.ruleValue.ruleContent !== void 0 &&
      Z.ruleBehavior === Q
    )
      I.set(Z.ruleValue.ruleContent, Z);
  return I;
}
async function Ni2({
  rule: A,
  initialContext: B,
  setToolPermissionContext: Q,
}) {
  if (A.source === "policySettings")
    throw Error("Cannot delete permission rules from managed settings");
  let I = aF(B, {
    type: "removeRules",
    rules: [A.ruleValue],
    behavior: A.ruleBehavior,
    destination: A.source,
  });
  switch (A.source) {
    case "localSettings":
    case "userSettings":
    case "projectSettings": {
      HT0(A);
      break;
    }
    case "cliArg":
    case "command":
    case "flagSettings":
      break;
    case "session":
      break;
  }
  Q(I);
}
function Xo2(A, B) {
  let Q = new Map();
  for (let G of A) {
    let Z = `${G.source}:${G.ruleBehavior}`;
    if (!Q.has(Z)) Q.set(Z, []);
    Q.get(Z).push(G.ruleValue);
  }
  let I = [];
  for (let [G, Z] of Q) {
    let [Y, J] = G.split(":");
    I.push({ type: B, rules: Z, behavior: J, destination: Y });
  }
  return I;
}
function xr2(A, B) {
  let Q = Xo2(B, "addRules");
  return so(A, Q);
}
function NzB(A, B) {
  let Q = Xo2(B, "replaceRules");
  return so(A, Q);
}
var OB0,
  DL = async (A, B, Q, I) => {
    if (Q.abortController.signal.aborted) throw new IX();
    let G = await Q.getAppState(),
      Z = Mj1(G.toolPermissionContext, A);
    if (Z)
      return {
        behavior: "deny",
        decisionReason: { type: "rule", rule: Z },
        message: `Permission to use ${A.name} has been denied.`,
      };
    let Y = Oj1(G.toolPermissionContext, A);
    if (Y)
      return {
        behavior: "ask",
        decisionReason: { type: "rule", rule: Y },
        message: KW(A.name),
      };
    let J = { behavior: "passthrough", message: KW(A.name) };
    try {
      let F = A.inputSchema.parse(B);
      J = await A.checkPermissions(F, Q);
    } catch (F) {
      BA(F, Ml);
    }
    if (J?.behavior === "deny") return J;
    if (A.requiresUserInteraction?.() && J?.behavior === "ask") return J;
    if (
      ((G = await Q.getAppState()),
      G.toolPermissionContext.mode === "bypassPermissions")
    )
      return {
        behavior: "allow",
        updatedInput: B,
        decisionReason: { type: "mode", mode: G.toolPermissionContext.mode },
      };
    let X = Lj1(G.toolPermissionContext, A);
    if (X)
      return {
        behavior: "allow",
        updatedInput: B,
        decisionReason: { type: "rule", rule: X },
      };
    let W =
      J.behavior === "passthrough"
        ? { ...J, behavior: "ask", message: KW(A.name, J.decisionReason) }
        : J;
    if (W.behavior === "ask" && W.suggestions)
      g(
        `Permission suggestions for ${A.name}: ${JSON.stringify(W.suggestions, null, 2)}`,
      );
    return W;
  };
var f3 = T(() => {
  aC();
  y7();
  c1();
  C0();
  Ci();
  NC();
  kF();
  MM();
  AN();
  Jo2();
  f4();
  OB0 = [...jk, "cliArg", "command", "session"];
});
function Wo2(A) {
  return TB0.filePatternTools.includes(A);
}
function Fo2(A) {
  return TB0.bashPrefixTools.includes(A);
}
function Co2(A) {
  return TB0.customValidation[A];
}
var TB0;
var Vo2 = T(() => {
  TB0 = {
    filePatternTools: [
      "Read",
      "Write",
      "Edit",
      "Glob",
      "NotebookRead",
      "NotebookEdit",
    ],
    bashPrefixTools: ["Bash"],
    customValidation: {
      WebSearch: (A) => {
        if (A.includes("*") || A.includes("?"))
          return {
            valid: !1,
            error: "WebSearch does not support wildcards",
            suggestion: "Use exact search terms without * or ?",
            examples: [
              "WebSearch(claude ai)",
              "WebSearch(typescript tutorial)",
            ],
          };
        return { valid: !0 };
      },
      WebFetch: (A) => {
        if (A.includes("://") || A.startsWith("http"))
          return {
            valid: !1,
            error: "WebFetch permissions use domain format, not URLs",
            suggestion: 'Use "domain:hostname" format',
            examples: [
              "WebFetch(domain:example.com)",
              "WebFetch(domain:github.com)",
            ],
          };
        if (!A.startsWith("domain:"))
          return {
            valid: !1,
            error: 'WebFetch permissions must use "domain:" prefix',
            suggestion: 'Use "domain:hostname" format',
            examples: [
              "WebFetch(domain:example.com)",
              "WebFetch(domain:*.google.com)",
            ],
          };
        return { valid: !0 };
      },
    },
  };
});
function OQI(A) {
  if (!A || A.trim() === "")
    return { valid: !1, error: "Permission rule cannot be empty" };
  let B = (A.match(/\(/g) || []).length,
    Q = (A.match(/\)/g) || []).length;
  if (B !== Q)
    return {
      valid: !1,
      error: "Mismatched parentheses",
      suggestion:
        "Ensure all opening parentheses have matching closing parentheses",
    };
  if (A.includes("()")) {
    let Y = A.substring(0, A.indexOf("("));
    if (!Y)
      return {
        valid: !1,
        error: "Empty parentheses with no tool name",
        suggestion: "Specify a tool name before the parentheses",
      };
    return {
      valid: !1,
      error: "Empty parentheses",
      suggestion: `Either specify a pattern or use just "${Y}" without parentheses`,
      examples: [`${Y}`, `${Y}(some-pattern)`],
    };
  }
  let I = jZ(A),
    G = ZE(I.toolName);
  if (G) {
    if (I.ruleContent !== void 0)
      return {
        valid: !1,
        error: "MCP rules do not support patterns",
        suggestion: `Use "${I.toolName}" without parentheses`,
        examples: [
          `mcp__${G.serverName}`,
          G.toolName ? `mcp__${G.serverName}__${G.toolName}` : void 0,
        ].filter(Boolean),
      };
    return { valid: !0 };
  }
  if (!I.toolName || I.toolName.length === 0)
    return { valid: !1, error: "Tool name cannot be empty" };
  if (I.toolName[0] !== I.toolName[0]?.toUpperCase())
    return {
      valid: !1,
      error: "Tool names must start with uppercase",
      suggestion: `Use "${String(I.toolName).charAt(0).toUpperCase() + String(I.toolName).slice(1)}"`,
    };
  let Z = Co2(I.toolName);
  if (Z && I.ruleContent !== void 0) {
    let Y = Z(I.ruleContent);
    if (!Y.valid) return Y;
  }
  if (Fo2(I.toolName) && I.ruleContent !== void 0) {
    let Y = I.ruleContent;
    if (Y.includes(":*") && !Y.endsWith(":*"))
      return {
        valid: !1,
        error: "The :* pattern must be at the end",
        suggestion: "Move :* to the end for prefix matching",
        examples: ["Bash(npm run:*)", "Bash(git commit:*)"],
      };
    if (Y.includes(" * ") && !Y.endsWith(":*"))
      return {
        valid: !1,
        error: "Wildcards in the middle of commands are not supported",
        suggestion: 'Use prefix matching with ":*" or specify exact commands',
        examples: [
          "Bash(npm run:*) - allows any npm run command",
          "Bash(npm install express) - allows exact command",
          "Bash - allows all commands",
        ],
      };
    if (Y === ":*")
      return {
        valid: !1,
        error: "Prefix cannot be empty before :*",
        suggestion: "Specify a command prefix before :*",
        examples: ["Bash(npm:*)", "Bash(git:*)"],
      };
    let J = ['"', "'"];
    for (let W of J)
      if ((Y.match(new RegExp(W, "g")) || []).length % 2 !== 0)
        return {
          valid: !1,
          error: `Unmatched ${W} in Bash pattern`,
          suggestion: "Ensure all quotes are properly paired",
        };
    if (Y === "*")
      return {
        valid: !1,
        error: 'Use "Bash" without parentheses to allow all commands',
        suggestion: "Remove the parentheses or specify a command pattern",
        examples: ["Bash", "Bash(npm:*)", "Bash(npm install)"],
      };
    let X = Y.indexOf("*");
    if (X !== -1 && !Y.includes("/")) {
      if (!Y.substring(0, X).endsWith(":"))
        return {
          valid: !1,
          error: 'Use ":*" for prefix matching, not just "*"',
          suggestion: `Change to "Bash(${String(Y).replace(/\*/g, ":*")})" for prefix matching`,
          examples: ["Bash(npm run:*)", "Bash(git:*)"],
        };
    }
  }
  if (Wo2(I.toolName) && I.ruleContent !== void 0) {
    let Y = I.ruleContent;
    if (Y.includes(":*"))
      return {
        valid: !1,
        error: 'The ":*" syntax is only for Bash prefix rules',
        suggestion: 'Use glob patterns like "*" or "**" for file matching',
        examples: [
          `${I.toolName}(*.ts) - matches .ts files`,
          `${I.toolName}(src/**) - matches all files in src`,
          `${I.toolName}(**/*.test.ts) - matches test files`,
        ],
      };
    if (
      Y.includes("*") &&
      !Y.match(/^\*|\*$|\*\*|\/\*|\*\.|\*\)/) &&
      !Y.includes("**")
    )
      return {
        valid: !1,
        error: "Wildcard placement might be incorrect",
        suggestion: "Wildcards are typically used at path boundaries",
        examples: [
          `${I.toolName}(*.js) - all .js files`,
          `${I.toolName}(src/*) - all files directly in src`,
          `${I.toolName}(src/**) - all files recursively in src`,
        ],
      };
  }
  return { valid: !0 };
}
var MQ1;
var Ko2 = T(() => {
  e2();
  f3();
  kF();
  Vo2();
  MQ1 = _.string().superRefine((A, B) => {
    let Q = OQI(A);
    if (!Q.valid) {
      let I = Q.error;
      if (Q.suggestion) I += `. ${Q.suggestion}`;
      if (Q.examples && Q.examples.length > 0)
        I += `. Examples: ${Q.examples.join(", ")}`;
      B.addIssue({
        code: _.ZodIssueCode.custom,
        message: I,
        params: { received: A },
      });
    }
  });
});
import { isIP as BqA } from "node:net";
function Do2() {
  return _.array(_.string()).transform((A) => {
    return A.map((B) => {
      if (B.trim() === "") throw Error("Invalid filesystem path: empty string");
      if (
        B.includes("&&") ||
        B.includes("||") ||
        B.includes(";") ||
        B.includes("`") ||
        B.includes("$")
      )
        throw Error(
          `Invalid filesystem path: "${B}" - contains shell metacharacters`,
        );
      return B;
    });
  });
}
var PB0, RQI, TQI, PQI, jQI, Eo2, SQI, yQI, NDG, kQI, _QI, Ho2;
var zo2 = T(() => {
  e2();
  ((PB0 = _.string()
    .regex(/^\d+$/)
    .transform((A) => parseInt(A, 10))
    .refine((A) => A >= 1 && A <= 65535, "Port must be between 1 and 65535")),
    (RQI = _.string()
      .refine((A) => BqA(A) === 6 && !A.includes("[") && !A.includes("]"))
      .transform((A) => ({ host: A, port: void 0 }))),
    (TQI = _.string()
      .regex(/^\[([^\]]+)\]:(\d+)$/)
      .transform((A) => {
        let B = A.match(/^\[([^\]]+)\]:(\d+)$/),
          Q = B[1],
          I = B[2];
        if (BqA(Q) !== 6)
          throw Error("Invalid IPv6 address in bracket notation");
        let G = PB0.safeParse(I);
        if (!G.success) throw Error("Invalid port number");
        let Z = G.data;
        return { host: Q, port: Z };
      })),
    (PQI = _.string()
      .refine((A) => BqA(A) === 4)
      .transform((A) => ({ host: A, port: void 0 }))),
    (jQI = _.string()
      .regex(/^(\d+\.\d+\.\d+\.\d+):(\d+)$/)
      .transform((A) => {
        let B = A.match(/^(\d+\.\d+\.\d+\.\d+):(\d+)$/),
          Q = B[1],
          I = B[2];
        if (BqA(Q) !== 4) throw Error("Invalid IPv4 address format");
        let G = PB0.safeParse(I);
        if (!G.success) throw Error("Invalid port number");
        let Z = G.data;
        return { host: Q, port: Z };
      })),
    (Eo2 = _.string().refine((A) => {
      if (
        A.length === 0 ||
        A.includes(":") ||
        A.includes("/") ||
        A.includes("?") ||
        A.includes("#") ||
        BqA(A)
      )
        return !1;
      if (A === "localhost") return !0;
      if (A.startsWith("*.")) {
        let B = A.slice(2);
        return B.includes(".") && !B.startsWith(".") && !B.endsWith(".");
      }
      return A.includes(".") && !A.startsWith(".") && !A.endsWith(".");
    })),
    (SQI = Eo2.transform((A) => ({ host: A, port: void 0 }))),
    (yQI = _.string()
      .regex(/^([^:]+):(\d+)$/)
      .transform((A) => {
        let B = A.match(/^([^:]+):(\d+)$/),
          Q = B[1],
          I = B[2];
        if (!Eo2.safeParse(Q).success) throw Error("Invalid domain name");
        let Z = PB0.safeParse(I);
        if (!Z.success) throw Error("Invalid port number");
        let Y = Z.data;
        return { host: Q, port: Y };
      })),
    (NDG = _.union([TQI, RQI, jQI, PQI, yQI, SQI])),
    (kQI = _.record(
      _.string(),
      Do2().describe(
        "List of filesystem paths to ignore sandbox violations for when this command pattern matches",
      ),
    ).describe(
      'Map of command patterns to filesystem paths to ignore violations for. Use "*" to match all commands',
    )),
    (_QI = _.object({
      allowUnixSockets: Do2()
        .optional()
        .describe(
          "Allow Unix domain sockets for local IPC (SSH agent, Docker, etc.). Provide an array of specific paths. Defaults to blocking if not specified",
        ),
      allowLocalBinding: _.boolean()
        .optional()
        .describe(
          "Allow binding to local network addresses (e.g., localhost ports). Defaults to false if not specified",
        ),
      httpProxyPort: _.number()
        .int()
        .min(1)
        .max(65535)
        .optional()
        .describe(
          "HTTP proxy port to use for network filtering. If not specified, a proxy server will be started automatically",
        ),
      socksProxyPort: _.number()
        .int()
        .min(1)
        .max(65535)
        .optional()
        .describe(
          "SOCKS proxy port to use for network filtering. If not specified, a proxy server will be started automatically",
        ),
    }).optional()),
    (Ho2 = _.object({
      network: _QI,
      ignoreViolations: kQI.optional(),
      excludedCommands: _.array(_.string())
        .optional()
        .describe(
          'Commands that should never run in the sandbox (e.g., ["git", "docker"])',
        ),
      autoAllowBashIfSandboxed: _.boolean()
        .optional()
        .describe(
          "Automatically allow bash commands without prompting when they run in the sandbox. Only applies to commands that will run sandboxed.",
        ),
      enableWeakerNestedSandbox: _.boolean()
        .optional()
        .describe(
          "Enable weaker sandbox mode for unprivileged docker environments where --proc mounting fails. This significantly reduces the strength of the sandbox and should only be used when this risk is acceptable.Default: false (secure).",
        ),
      allowUnsandboxedCommands: _.boolean()
        .optional()
        .describe(
          "Allow commands to run outside the sandbox via the dangerouslyDisableSandbox parameter. When false, the dangerouslyDisableSandbox parameter is completely ignored and all commands must run sandboxed. Default: true.",
        ),
      enabled: _.boolean().optional().describe("Enable sandboxed bash"),
    })));
});
var xQI, vQI, bQI, fQI, hQI, gQI, _DA, uQI, mQI, dQI, rs;
var xDA = T(() => {
  e2();
  ETA();
  MM();
  Ko2();
  NC();
  zo2();
  Ks();
  ((xQI = _.record(_.coerce.string())),
    (vQI = _.object({
      allow: _.array(MQ1)
        .optional()
        .describe("List of permission rules for allowed operations"),
      deny: _.array(MQ1)
        .optional()
        .describe("List of permission rules for denied operations"),
      ask: _.array(MQ1)
        .optional()
        .describe(
          "List of permission rules that should always prompt for confirmation",
        ),
      defaultMode: _.enum(Wi)
        .optional()
        .describe("Default permission mode when Claude Code needs access"),
      disableBypassPermissionsMode: _.enum(["disable"])
        .optional()
        .describe("Disable the ability to bypass permission prompts"),
      additionalDirectories: _.array(_.string())
        .optional()
        .describe("Additional directories to include in the permission scope"),
    }).passthrough()),
    (bQI = _.object({
      type: _.literal("command").describe("Bash command hook type"),
      command: _.string().describe("Shell command to execute"),
      timeout: _.number()
        .positive()
        .optional()
        .describe("Timeout in seconds for this specific command"),
    })),
    (fQI = _.object({
      type: _.literal("prompt").describe("LLM prompt hook type"),
      prompt: _.string().describe(
        "Prompt to evaluate with LLM. Use $ARGUMENTS placeholder for hook input JSON.",
      ),
      timeout: _.number()
        .positive()
        .optional()
        .describe("Timeout in seconds for this specific prompt evaluation"),
      model: _.string()
        .optional()
        .describe(
          'Model to use for this prompt hook (e.g., "claude-sonnet-4-5-20250929"). If not specified, uses the default small fast model.',
        ),
    })),
    (hQI = _.discriminatedUnion("type", [bQI, fQI])),
    (gQI = _.object({
      matcher: _.string()
        .optional()
        .describe('String pattern to match (e.g. tool names like "Write")'),
      hooks: _.array(hQI).describe(
        "List of hooks to execute when the matcher matches",
      ),
    })),
    (_DA = _.record(_.enum(fYA), _.array(gQI))),
    (uQI = _.object({
      source: Px1.describe("Where to fetch the marketplace from"),
      installLocation: _.string()
        .optional()
        .describe(
          "Local cache path where marketplace manifest is stored (auto-generated if not provided)",
        ),
    })),
    (mQI = _.object({
      serverName: _.string()
        .regex(
          /^[a-zA-Z0-9_-]+$/,
          "Server name can only contain letters, numbers, hyphens, and underscores",
        )
        .describe("Name of the MCP server that users are allowed to configure"),
    })),
    (dQI = _.object({
      serverName: _.string()
        .regex(
          /^[a-zA-Z0-9_-]+$/,
          "Server name can only contain letters, numbers, hyphens, and underscores",
        )
        .describe("Name of the MCP server that is explicitly blocked"),
    })),
    (rs = _.object({
      $schema: _.literal(CT0)
        .optional()
        .describe("JSON Schema reference for Claude Code settings"),
      apiKeyHelper: _.string()
        .optional()
        .describe("Path to a script that outputs authentication values"),
      awsCredentialExport: _.string()
        .optional()
        .describe("Path to a script that exports AWS credentials"),
      awsAuthRefresh: _.string()
        .optional()
        .describe("Path to a script that refreshes AWS authentication"),
      cleanupPeriodDays: _.number()
        .nonnegative()
        .int()
        .optional()
        .describe(
          "Number of days to retain chat transcripts (0 to disable cleanup)",
        ),
      env: xQI
        .optional()
        .describe("Environment variables to set for Claude Code sessions"),
      includeCoAuthoredBy: _.boolean()
        .optional()
        .describe(
          "Whether to include Claude's co-authored by attribution in commits and PRs (defaults to true)",
        ),
      permissions: vQI
        .optional()
        .describe("Tool usage permissions configuration"),
      model: _.string()
        .optional()
        .describe("Override the default model used by Claude Code"),
      enableAllProjectMcpServers: _.boolean()
        .optional()
        .describe(
          "Whether to automatically approve all MCP servers in the project",
        ),
      enabledMcpjsonServers: _.array(_.string())
        .optional()
        .describe("List of approved MCP servers from .mcp.json"),
      disabledMcpjsonServers: _.array(_.string())
        .optional()
        .describe("List of rejected MCP servers from .mcp.json"),
      allowedMcpServers: _.array(mQI)
        .optional()
        .describe(
          "Enterprise allowlist of MCP servers that can be used. Applies to all scopes including enterprise servers from managed-mcp.json. If undefined, all servers are allowed. If empty array, no servers are allowed. Denylist takes precedence - if a server is on both lists, it is denied.",
        ),
      deniedMcpServers: _.array(dQI)
        .optional()
        .describe(
          "Enterprise denylist of MCP servers that are explicitly blocked. If a server is on the denylist, it will be blocked across all scopes including enterprise. Denylist takes precedence over allowlist - if a server is on both lists, it is denied.",
        ),
      hooks: _DA
        .optional()
        .describe("Custom commands to run before/after tool executions"),
      disableAllHooks: _.boolean()
        .optional()
        .describe("Disable all hooks and statusLine execution"),
      statusLine: _.object({
        type: _.literal("command"),
        command: _.string(),
        padding: _.number().optional(),
      })
        .optional()
        .describe("Custom status line display configuration"),
      enabledPlugins: _.record(
        _.union([_.array(_.string()), _.boolean(), _.undefined()]),
      )
        .optional()
        .describe(
          'Enabled plugins using plugin-id@marketplace-id format. Example: { "formatter@anthropic-tools": true }. Also supports extended format with version constraints.',
        ),
      extraKnownMarketplaces: _.record(_.string(), uQI)
        .optional()
        .describe(
          "Additional marketplaces to make available for this repository. Typically used in repository .claude/settings.json to ensure team members have required plugin sources.",
        ),
      skippedMarketplaces: _.array(_.string())
        .optional()
        .describe(
          "List of marketplace names the user has chosen not to install when prompted",
        ),
      skippedPlugins: _.array(_.string())
        .optional()
        .describe(
          "List of plugin IDs (plugin@marketplace format) the user has chosen not to install when prompted",
        ),
      forceLoginMethod: _.enum(["claudeai", "console"])
        .optional()
        .describe(
          'Force a specific login method: "claudeai" for Claude Pro/Max, "console" for Console billing',
        ),
      forceLoginOrgUUID: _.string()
        .optional()
        .describe("Organization UUID to use for OAuth login"),
      otelHeadersHelper: _.string()
        .optional()
        .describe("Path to a script that outputs OpenTelemetry headers"),
      outputStyle: _.string()
        .optional()
        .describe("Controls the output style for assistant responses"),
      skipWebFetchPreflight: _.boolean()
        .optional()
        .describe(
          "Skip the WebFetch blocklist check for enterprise environments with restrictive security policies",
        ),
      sandbox: Ho2.optional(),
      spinnerTipsEnabled: _.boolean()
        .optional()
        .describe("Whether to show tips in the spinner"),
      alwaysThinkingEnabled: _.boolean()
        .optional()
        .describe(
          "Whether extended thinking is always enabled (default: false)",
        ),
      companyAnnouncements: _.array(_.string())
        .optional()
        .describe(
          "Company announcements to display at startup (one will be randomly selected if multiple are provided)",
        ),
      pluginConfigs: _.record(
        _.string(),
        _.object({
          mcpServers: _.record(
            _.string(),
            _.record(
              _.string(),
              _.union([
                _.string(),
                _.number(),
                _.boolean(),
                _.array(_.string()),
              ]),
            ),
          )
            .optional()
            .describe(
              "User configuration values for MCP servers keyed by server name",
            ),
        }),
      )
        .optional()
        .describe(
          "Per-plugin configuration including MCP server user configs, keyed by plugin ID (plugin@marketplace format)",
        ),
    }).passthrough()));
});
import { dirname as Uo2, join as GqA, resolve as QqA } from "path";
function Nw() {
  switch (EB()) {
    case "macos":
      return "/Library/Application Support/ClaudeCode";
    case "windows":
      return "C:\\ProgramData\\ClaudeCode";
    default:
      return "/etc/claude-code";
  }
}
function cQI() {
  return GqA(Nw(), "managed-settings.json");
}
function pQI(A, B) {
  if (typeof A === "object" && A && "code" in A && A.code === "ENOENT")
    g(
      `Broken symlink or missing file encountered for settings.json at path: ${B}`,
    );
  else BA(A instanceof Error ? A : Error(String(A)), cf);
}
function wo2(A) {
  let B = NA();
  if (!B.existsSync(A)) return { settings: null, errors: [] };
  try {
    let { resolvedPath: Q } = KC(B, A),
      I = ww(Q);
    if (I.trim() === "") return { settings: {}, errors: [] };
    let G = b3(I, !1),
      Z = rs.safeParse(G);
    if (!Z.success) return { settings: null, errors: qu1(Z.error, A) };
    return { settings: Z.data, errors: [] };
  } catch (Q) {
    return (pQI(Q, A), { settings: null, errors: [] });
  }
}
function LQ1(A) {
  switch (A) {
    case "userSettings":
      return QqA(mB());
    case "policySettings":
    case "projectSettings":
    case "localSettings":
      return QqA(GQ());
    case "flagSettings": {
      let B = g91();
      return B ? Uo2(QqA(B)) : QqA(GQ());
    }
  }
}
function zU(A) {
  switch (A) {
    case "userSettings":
      return GqA(LQ1(A), "settings.json");
    case "projectSettings":
    case "localSettings":
      return GqA(LQ1(A), p$A(A));
    case "policySettings":
      return cQI();
    case "flagSettings":
      return g91();
  }
}
function p$A(A) {
  switch (A) {
    case "projectSettings":
      return GqA(".claude", "settings.json");
    case "localSettings":
      return GqA(".claude", "settings.local.json");
  }
}
function cQ(A) {
  let B = zU(A);
  if (!B) return null;
  let { settings: Q } = wo2(B);
  return Q;
}
function B2(A, B) {
  if (A === "policySettings" || A === "flagSettings") return { error: null };
  let Q = zU(A);
  if (!Q) return { error: null };
  try {
    let I = Uo2(Q);
    if (!NA().existsSync(I)) NA().mkdirSync(I);
    let G = cQ(A);
    if (!G && NA().existsSync(Q)) {
      let Y = ww(Q),
        J = b3(Y);
      if (J === null)
        return { error: Error(`Invalid JSON syntax in settings file at ${Q}`) };
      if (J && typeof J === "object")
        ((G = J), g(`Using raw settings from ${Q} due to validation failure`));
    }
    let Z = PG1(G || {}, B, (Y, J, X, W) => {
      if (J === void 0 && W && typeof X === "string") {
        delete W[X];
        return;
      }
      if (Array.isArray(J)) return J;
      return;
    });
    if (
      (v0A.markInternalWrite(A),
      fj(
        Q,
        JSON.stringify(Z, null, 2) +
          `
`,
      ),
      f0A(),
      A === "localSettings")
    )
      eHA(p$A("localSettings"), GQ());
  } catch (I) {
    let G = Error(`Failed to read raw settings from ${Q}: ${I}`);
    return (BA(G, cf), { error: G });
  }
  return { error: null };
}
function lQI(A, B) {
  let Q = [...A, ...B];
  return Array.from(new Set(Q));
}
function $o2(A) {
  let B = rs.strip().parse(A),
    Q = ["permissions", "sandbox", "hooks"],
    I = [],
    G = {
      permissions: new Set([
        "allow",
        "deny",
        "ask",
        "defaultMode",
        "disableBypassPermissionsMode",
        "additionalDirectories",
      ]),
      sandbox: new Set([
        "network",
        "ignoreViolations",
        "excludedCommands",
        "autoAllowBashIfSandboxed",
        "enableWeakerNestedSandbox",
      ]),
      hooks: new Set([
        "PreToolUse",
        "PostToolUse",
        "Notification",
        "UserPromptSubmit",
        "SessionStart",
        "SessionEnd",
        "Stop",
        "SubagentStop",
        "PreCompact",
      ]),
    };
  for (let Z of Object.keys(B))
    if (Q.includes(Z) && B[Z] && typeof B[Z] === "object") {
      let Y = B[Z],
        J = G[Z];
      if (J) {
        for (let X of Object.keys(Y)) if (J.has(X)) I.push(`${Z}.${X}`);
      }
    } else I.push(Z);
  return I.sort();
}
function f0A() {
  IqA = null;
}
function iQI() {
  let A = {},
    B = [],
    Q = new Set(),
    I = new Set();
  for (let Z of Xi()) {
    let Y = zU(Z);
    if (!Y) continue;
    let J = QqA(Y);
    if (I.has(J)) continue;
    I.add(J);
    let { settings: X, errors: W } = wo2(Y);
    for (let F of W) {
      let C = `${F.file}:${F.path}:${F.message}`;
      if (!Q.has(C)) (Q.add(C), B.push(F));
    }
    if (X)
      A = PG1(A, X, (F, C) => {
        if (Array.isArray(F) && Array.isArray(C)) return lQI(F, C);
        return;
      });
  }
  let G = ["user", "project", "local"];
  return (
    B.push(...G.flatMap((Z) => SX(Z).errors)),
    { settings: A, errors: B }
  );
}
function N0() {
  let { settings: A } = oc();
  return A || {};
}
function oc() {
  if (IqA !== null) return IqA;
  return ((IqA = iQI()), IqA);
}
var IqA = null;
var OQ = T(() => {
  XT0();
  Z4();
  m0();
  wC();
  c1();
  C0();
  E5();
  NC();
  xDA();
  i0();
  arA();
  vB();
  Lu1();
  aN();
  vjA();
});
function jB0() {
  let A = N80();
  if (A !== void 0) return A;
  let B = process.env.CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR;
  if (!B) return (be(null), null);
  let Q = parseInt(B, 10);
  if (Number.isNaN(Q))
    return (
      g(
        `CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${B}`,
        { level: "error" },
      ),
      be(null),
      null
    );
  try {
    let I = NA(),
      G =
        process.platform === "darwin" || process.platform === "freebsd"
          ? `/dev/fd/${Q}`
          : `/proc/self/fd/${Q}`,
      Z = I.readFileSync(G, { encoding: "utf8" }).trim();
    if (!Z)
      return (
        g("File descriptor contained empty OAuth token", { level: "error" }),
        be(null),
        null
      );
    return (
      g(`Successfully read OAuth token from file descriptor ${Q}`),
      be(Z),
      Z
    );
  } catch (I) {
    return (
      g(
        `Failed to read OAuth token from file descriptor ${Q}: ${I instanceof Error ? I.message : String(I)}`,
        { level: "error" },
      ),
      be(null),
      null
    );
  }
}
function SB0() {
  let A = L80();
  if (A !== void 0) return A;
  let B = process.env.CLAUDE_CODE_API_KEY_FILE_DESCRIPTOR;
  if (!B) return (fe(null), null);
  let Q = parseInt(B, 10);
  if (Number.isNaN(Q))
    return (
      g(
        `CLAUDE_CODE_API_KEY_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${B}`,
        { level: "error" },
      ),
      fe(null),
      null
    );
  try {
    let I = NA(),
      G =
        process.platform === "darwin" || process.platform === "freebsd"
          ? `/dev/fd/${Q}`
          : `/proc/self/fd/${Q}`,
      Z = I.readFileSync(G, { encoding: "utf8" }).trim();
    if (!Z)
      return (
        g("File descriptor contained empty API key", { level: "error" }),
        fe(null),
        null
      );
    return (g(`Successfully read API key from file descriptor ${Q}`), fe(Z), Z);
  } catch (I) {
    return (
      g(
        `Failed to read API key from file descriptor ${Q}: ${I instanceof Error ? I.message : String(I)}`,
        { level: "error" },
      ),
      fe(null),
      null
    );
  }
}
var qo2 = T(() => {
  C0();
  m0();
  i0();
});
import { exec as nQI } from "child_process";
function Sz() {
  let A =
      V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
      V0(process.env.CLAUDE_CODE_USE_VERTEX),
    Q = (N0() || {}).apiKeyHelper,
    I =
      process.env.ANTHROPIC_AUTH_TOKEN ||
      Q ||
      process.env.CLAUDE_CODE_API_KEY_FILE_DESCRIPTOR,
    { source: G } = Bw({ skipRetrievingKeyFromApiKeyHelper: !0 });
  return !(A || I || G === "ANTHROPIC_API_KEY" || G === "apiKeyHelper");
}
function ic() {
  if (process.env.ANTHROPIC_AUTH_TOKEN)
    return { source: "ANTHROPIC_AUTH_TOKEN", hasToken: !0 };
  if (process.env.CLAUDE_CODE_OAUTH_TOKEN)
    return { source: "CLAUDE_CODE_OAUTH_TOKEN", hasToken: !0 };
  if (jB0())
    return { source: "CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR", hasToken: !0 };
  if (ZqA()) return { source: "apiKeyHelper", hasToken: !0 };
  let Q = G5();
  if (sv(Q?.scopes) && Q?.accessToken)
    return { source: "claude.ai", hasToken: !0 };
  return { source: "none", hasToken: !1 };
}
function kU() {
  let { key: A } = Bw();
  return A;
}
function Dp2() {
  let { key: A, source: B } = Bw({ skipRetrievingKeyFromApiKeyHelper: !0 });
  return A !== null && B !== "none";
}
function Bw(A = {}) {
  if (S80() && process.env.ANTHROPIC_API_KEY)
    return { key: process.env.ANTHROPIC_API_KEY, source: "ANTHROPIC_API_KEY" };
  if (V0(!1)) {
    let I = SB0();
    if (I) return { key: I, source: "ANTHROPIC_API_KEY" };
    if (
      !process.env.ANTHROPIC_API_KEY &&
      !process.env.CLAUDE_CODE_OAUTH_TOKEN &&
      !process.env.CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR
    )
      throw Error(
        "ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN env var is required",
      );
    if (process.env.ANTHROPIC_API_KEY)
      return {
        key: process.env.ANTHROPIC_API_KEY,
        source: "ANTHROPIC_API_KEY",
      };
    return { key: null, source: "none" };
  }
  if (
    process.env.ANTHROPIC_API_KEY &&
    L1().customApiKeyResponses?.approved?.includes(
      lw(process.env.ANTHROPIC_API_KEY),
    )
  )
    return { key: process.env.ANTHROPIC_API_KEY, source: "ANTHROPIC_API_KEY" };
  let B = SB0();
  if (B) return { key: B, source: "ANTHROPIC_API_KEY" };
  if (A.skipRetrievingKeyFromApiKeyHelper) {
    if (ZqA()) return { key: null, source: "apiKeyHelper" };
  } else {
    let I = gVA(K5());
    if (I) return { key: I, source: "apiKeyHelper" };
  }
  let Q = awA();
  if (Q) return Q;
  return { key: null, source: "none" };
}
function ZqA() {
  return (N0() || {}).apiKeyHelper;
}
function Lo2() {
  let A = ZqA();
  if (!A) return !1;
  let B = cQ("projectSettings"),
    Q = cQ("localSettings");
  return B?.apiKeyHelper === A || Q?.apiKeyHelper === A;
}
function yB0() {
  return (N0() || {}).awsAuthRefresh;
}
function Mo2() {
  let A = yB0();
  if (!A) return !1;
  let B = cQ("projectSettings"),
    Q = cQ("localSettings");
  return B?.awsAuthRefresh === A || Q?.awsAuthRefresh === A;
}
function kB0() {
  return (N0() || {}).awsCredentialExport;
}
function Oo2() {
  let A = kB0();
  if (!A) return !1;
  let B = cQ("projectSettings"),
    Q = cQ("localSettings");
  return B?.awsCredentialExport === A || Q?.awsCredentialExport === A;
}
function sQI() {
  let A = process.env.CLAUDE_CODE_API_KEY_HELPER_TTL_MS;
  if (A) {
    let B = parseInt(A, 10);
    if (!Number.isNaN(B) && B >= 0) return B;
    g(
      `Found CLAUDE_CODE_API_KEY_HELPER_TTL_MS env var, but it was not a valid number. Got ${A}`,
      { level: "error" },
    );
  }
  return aQI;
}
function rxQ() {
  gVA.cache.clear();
}
function Ro2(A) {
  if (ZqA()) {
    if (Lo2()) {
      if (!fX(!0)) return;
    }
  }
  gVA(A);
}
async function oQI() {
  let A = yB0();
  if (!A) return !1;
  if (Mo2()) {
    if (!fX(!0) && !K5()) {
      let Q = Error(
        `Security: awsAuthRefresh executed before workspace trust is confirmed. If you see this message, post in ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.FEEDBACK_CHANNEL}.`,
      );
      return (
        P$("awsAuthRefresh invoked before trust check", Q),
        GA("tengu_awsAuthRefresh_missing_trust", {}),
        !1
      );
    }
  }
  try {
    return (
      g("Fetching AWS caller identity for AWS auth refresh command"),
      await ih1(),
      g("Fetched AWS caller identity, skipping AWS auth refresh command"),
      !1
    );
  } catch {
    g("Running AWS auth refresh command");
    let B = nK.getInstance();
    return (
      B.startAuthentication(),
      new Promise((Q) => {
        let I = nQI(A);
        (I.stdout.on("data", (G) => {
          let Z = G.toString().trim();
          if (Z) (B.addOutput(Z), g(Z, { level: "debug" }));
        }),
          I.stderr.on("data", (G) => {
            let Z = G.toString().trim();
            if (Z) (B.setError(Z), g(Z, { level: "error" }));
          }),
          I.on("close", (G) => {
            if (G === 0)
              (g("AWS auth refresh completed successfully"),
                B.endAuthentication(!0),
                Q(!0));
            else {
              let Z = iA.red(
                "Error running awsAuthRefresh (in settings or ~/.claude.json):",
              );
              (console.error(Z), B.endAuthentication(!1), Q(!1));
            }
          }));
      })
    );
  }
}
async function tQI() {
  let A = kB0();
  if (!A) return null;
  if (Oo2()) {
    if (!fX(!0) && !K5()) {
      let Q = Error(
        `Security: awsCredentialExport executed before workspace trust is confirmed. If you see this message, post in ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.FEEDBACK_CHANNEL}.`,
      );
      return (
        P$("awsCredentialExport invoked before trust check", Q),
        GA("tengu_awsCredentialExport_missing_trust", {}),
        null
      );
    }
  }
  try {
    return (
      g("Fetching AWS caller identity for credential export command"),
      await ih1(),
      g("Fetched AWS caller identity, skipping AWS credential export command"),
      null
    );
  } catch {
    try {
      g("Running AWS credential export command");
      let B = J7(A)?.toString().trim();
      if (!B) throw Error("awsCredentialExport did not return a valid value");
      let Q = JSON.parse(B);
      if (!lxQ(Q))
        throw Error(
          "awsCredentialExport did not return valid AWS STS output structure",
        );
      return (
        g("AWS credentials retrieved from awsCredentialExport"),
        {
          accessKeyId: Q.Credentials.AccessKeyId,
          secretAccessKey: Q.Credentials.SecretAccessKey,
          sessionToken: Q.Credentials.SessionToken,
        }
      );
    } catch (B) {
      let Q = iA.red(
        "Error getting AWS credentials from awsCredentialExport (in settings or ~/.claude.json):",
      );
      if (B instanceof Error && "stderr" in B)
        console.error(Q, String(B.stderr));
      else if (B instanceof Error) console.error(Q, B.message);
      else console.error(Q, B);
      return null;
    }
  }
}
function oxQ() {
  W2A.cache.clear();
}
function To2() {
  let A = yB0(),
    B = kB0();
  if (!A && !B) return;
  if (Mo2() || Oo2()) {
    if (!fX(!0) && !K5()) return;
  }
  (W2A(), EX());
}
function eQI(A) {
  return /^[a-zA-Z0-9-_]+$/.test(A);
}
function tQ2(A) {
  if (!eQI(A))
    throw Error(
      "Invalid API key format. API key must contain only alphanumeric characters, dashes, and underscores.",
    );
  let B = L1();
  if ((Po2(), process.platform === "darwin"))
    try {
      let I = gm(),
        G = AEA(),
        Z = Buffer.from(A, "utf-8").toString("hex"),
        Y = `add-generic-password -U -a "${G}" -s "${I}" -X "${Z}"
`;
      (J7("security -i", { input: Y, stdio: ["pipe", "pipe", "pipe"] }),
        GA("tengu_api_key_saved_to_keychain", {}));
    } catch (I) {
      (BA(I, rG0),
        GA("tengu_api_key_keychain_error", { error: I.message }),
        (B.primaryApiKey = A),
        GA("tengu_api_key_saved_to_config", {}));
    }
  else ((B.primaryApiKey = A), GA("tengu_api_key_saved_to_config", {}));
  if (!B.customApiKeyResponses)
    B.customApiKeyResponses = { approved: [], rejected: [] };
  if (!B.customApiKeyResponses.approved) B.customApiKeyResponses.approved = [];
  let Q = lw(A);
  if (!B.customApiKeyResponses.approved.includes(Q))
    B.customApiKeyResponses.approved.push(Q);
  (n0(B), awA.cache.clear?.());
}
function kR2() {
  Po2();
  let A = L1();
  ((A.primaryApiKey = void 0), n0(A), awA.cache.clear?.());
}
function Po2() {
  try {
    Ug2();
  } catch (A) {
    BA(A, sG0);
  }
}
function qwA(A) {
  if (!sv(A.scopes))
    return (GA("tengu_oauth_tokens_not_claude_ai", {}), { success: !0 });
  if (!A.refreshToken || !A.expiresAt)
    return (GA("tengu_oauth_tokens_inference_only", {}), { success: !0 });
  let B = kw(),
    Q = B.name;
  try {
    let I = B.read() || {};
    I.claudeAiOauth = {
      accessToken: A.accessToken,
      refreshToken: A.refreshToken,
      expiresAt: A.expiresAt,
      scopes: A.scopes,
      subscriptionType: A.subscriptionType,
      rateLimitTier: A.rateLimitTier,
    };
    let G = B.update(I);
    if (G.success) GA("tengu_oauth_tokens_saved", { storageBackend: Q });
    else GA("tengu_oauth_tokens_save_failed", { storageBackend: Q });
    return (G5.cache?.clear?.(), JdA(), G);
  } catch (I) {
    return (
      BA(I, BZ0),
      GA("tengu_oauth_tokens_save_exception", {
        storageBackend: Q,
        error: I.message,
      }),
      { success: !1, warning: "Failed to save OAuth tokens" }
    );
  }
}
async function qa(A = 0) {
  let Q = G5();
  if (!Q?.refreshToken || !cIA(Q.expiresAt)) return !1;
  if (!sv(Q.scopes)) return !1;
  if ((G5.cache?.clear?.(), (Q = G5()), !Q?.refreshToken || !cIA(Q.expiresAt)))
    return !1;
  let I = mB();
  NA().mkdirSync(I);
  let Z;
  try {
    Z = await No2.lock(I);
  } catch (Y) {
    if (Y.code === "ELOCKED") {
      if (A < 5)
        return (
          GA("tengu_oauth_token_refresh_lock_retry", { retryCount: A + 1 }),
          await new Promise((J) => setTimeout(J, 1000 + Math.random() * 1000)),
          qa(A + 1)
        );
      return (
        GA("tengu_oauth_token_refresh_lock_retry_limit_reached", {
          maxRetries: 5,
        }),
        !1
      );
    }
    return (
      BA(Y, eG0),
      GA("tengu_oauth_token_refresh_lock_error", { error: Y.message }),
      !1
    );
  }
  try {
    if (
      (G5.cache?.clear?.(), (Q = G5()), !Q?.refreshToken || !cIA(Q.expiresAt))
    )
      return (GA("tengu_oauth_token_refresh_race_resolved", {}), !1);
    let Y = await aQ2(Q.refreshToken);
    return (qwA(Y), G5.cache?.clear?.(), !0);
  } catch (Y) {
    return (BA(Y instanceof Error ? Y : Error(String(Y)), tG0), !1);
  } finally {
    await Z();
  }
}
function nB() {
  if (!Sz()) return !1;
  return sv(G5()?.scopes);
}
function jR2() {
  if (
    V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
    V0(process.env.CLAUDE_CODE_USE_VERTEX)
  )
    return !1;
  if (nB()) return !1;
  return !0;
}
function HG() {
  return Sz() ? L1().oauthAccount : void 0;
}
function xU() {
  if (HG()?.organizationBillingType === "aws_marketplace") return !1;
  let B = i3();
  return B === "max" || B === "enterprise" || B === "team" || B === null;
}
function i3() {
  if (n0Q()) return i0Q();
  if (!Sz()) return null;
  let A = G5();
  if (!A) return null;
  return A.subscriptionType ?? null;
}
function zLQ() {
  if (!Sz()) return null;
  let A = G5();
  if (!A) return null;
  return A.rateLimitTier ?? null;
}
function twA() {
  switch (i3()) {
    case "enterprise":
      return "Claude Enterprise";
    case "team":
      return "Claude Team";
    case "max":
      return "Claude Max";
    case "pro":
      return "Claude Pro";
    default:
      return "Claude API";
  }
}
function mc() {
  return !!(
    V0(process.env.CLAUDE_CODE_USE_BEDROCK) ||
    V0(process.env.CLAUDE_CODE_USE_VERTEX)
  );
}
function jo2() {
  return (N0() || {}).otelHeadersHelper;
}
function YqA() {
  let A = jo2();
  if (!A) return !1;
  let B = cQ("projectSettings"),
    Q = cQ("localSettings");
  return B?.otelHeadersHelper === A || Q?.otelHeadersHelper === A;
}
function SR2() {
  let A = jo2();
  if (!A) return {};
  if (YqA()) {
    if (!fX(!0)) return {};
  }
  try {
    let B = J7(A)?.toString().trim();
    if (!B) throw Error("otelHeadersHelper did not return a valid value");
    let Q = JSON.parse(B);
    if (typeof Q !== "object" || Q === null || Array.isArray(Q))
      throw Error(
        "otelHeadersHelper must return a JSON object with string key-value pairs",
      );
    for (let [I, G] of Object.entries(Q))
      if (typeof G !== "string")
        throw Error(
          `otelHeadersHelper returned non-string value for key "${I}": ${typeof G}`,
        );
    return Q;
  } catch (B) {
    throw (
      BA(
        Error(
          `Error getting OpenTelemetry headers from otelHeadersHelper (in settings): ${B instanceof Error ? B.message : String(B)}`,
        ),
        QZ0,
      ),
      B
    );
  }
}
function A2I(A) {
  return A === "max" || A === "pro";
}
function ptA() {
  let A = i3();
  return nB() && A !== null && A2I(A);
}
function h01() {
  if (g3() !== "firstParty") return;
  let { source: B } = ic(),
    Q = {};
  if (nB()) Q.subscription = twA();
  else Q.tokenSource = B;
  let { key: I, source: G } = Bw();
  if (I) Q.apiKeySource = G;
  if (B === "claude.ai" || G === "/login managed key") {
    let Y = HG()?.organizationName;
    if (Y) Q.organization = Y;
  }
  let Z = HG()?.emailAddress;
  if ((B === "claude.ai" || G === "/login managed key") && Z) Q.email = Z;
  return Q;
}
var No2,
  aQI = 300000,
  gVA,
  rQI = 3600000,
  W2A,
  awA,
  G5;
var F2 = T(() => {
  kB();
  OQ();
  Q5();
  a2();
  avA();
  c1();
  C0();
  f2();
  dtA();
  qo2();
  VR();
  WdA();
  Jx();
  m0();
  vB();
  BEA();
  i0();
  nh1();
  H0();
  EH();
  YU1();
  w$A();
  No2 = IA(xYA(), 1);
  gVA = XU1((A) => {
    let B = ZqA();
    if (!B) return null;
    if (Lo2()) {
      if (!fX(!0) && !A) {
        let I = Error(
          `Security: apiKeyHelper executed before workspace trust is confirmed. If you see this message, post in ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.claude.com/s/claude-code", VERSION: "2.0.42", FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues" }.FEEDBACK_CHANNEL}.`,
        );
        (P$("apiKeyHelper invoked before trust check", I),
          GA("tengu_apiKeyHelper_missing_trust5", {}));
      }
    }
    try {
      let Q = J7(B)?.toString().trim();
      if (!Q) throw Error("apiKeyHelper did not return a valid value");
      return Q;
    } catch (Q) {
      let I = iA.red(
        "Error getting API key from apiKeyHelper (in settings or ~/.claude.json):",
      );
      if (Q instanceof Error && "stderr" in Q)
        console.error(I, String(Q.stderr));
      else if (Q instanceof Error) console.error(I, Q.message);
      else console.error(I, Q);
      return " ";
    }
  }, sQI());
  W2A = XU1(async () => {
    let A = await oQI(),
      B = await tQI();
    if (A || B) await ixQ();
    return B;
  }, rQI);
  awA = I0(() => {
    if (process.platform === "darwin") {
      let B = gm();
      try {
        let Q = J7(`security find-generic-password -a $USER -w -s "${B}"`);
        if (Q) return { key: Q, source: "/login managed key" };
      } catch (Q) {
        BA(Q, oG0);
      }
    }
    let A = L1();
    if (!A.primaryApiKey) return null;
    return { key: A.primaryApiKey, source: "/login managed key" };
  });
  G5 = I0(() => {
    if (process.env.CLAUDE_CODE_OAUTH_TOKEN)
      return {
        accessToken: process.env.CLAUDE_CODE_OAUTH_TOKEN,
        refreshToken: null,
        expiresAt: null,
        scopes: ["user:inference"],
        subscriptionType: null,
        rateLimitTier: null,
      };
    let A = jB0();
    if (A)
      return {
        accessToken: A,
        refreshToken: null,
        expiresAt: null,
        scopes: ["user:inference"],
        subscriptionType: null,
        rateLimitTier: null,
      };
    try {
      let I = kw().read()?.claudeAiOauth;
      if (!I?.accessToken) return null;
      return I;
    } catch (B) {
      return (BA(B, AZ0), null);
    }
  });
});
import {
  resolve as yo2,
  dirname as ko2,
  normalize as B2I,
  join as $t,
} from "path";
import { randomBytes as Q2I, randomUUID as I2I } from "crypto";
import { execSync as G2I } from "child_process";
function fX(A) {
  let B = Wp(UC(), Rw);
  if (B.bypassPermissionsModeAccepted) return !0;
  let Q = bB0();
  if (B.projects?.[Q]?.hasTrustDialogAccepted) return !0;
  let G = G0();
  if (A) return B.projects?.[G]?.hasTrustDialogAccepted === !0;
  while (!0) {
    if (B.projects?.[G]?.hasTrustDialogAccepted) return !0;
    let Y = yo2(G, "..");
    if (Y === G) break;
    G = Y;
  }
  return !1;
}
function n0(A) {
  try {
    (vo2(UC(), Rw, (B) => ({ ...A, projects: So2(B.projects) })),
      (yb.config = null),
      (yb.mtime = 0));
  } catch (B) {
    g(`Failed to save config with lock: ${B}`, { level: "error" });
    let Q = Wp(UC(), Rw);
    (xo2(UC(), { ...A, projects: So2(Q.projects) }, Rw),
      (yb.config = null),
      (yb.mtime = 0));
  }
}
function _B0(A) {
  if (A.installMethod !== void 0) return A;
  let B = "unknown",
    Q = A.autoUpdates ?? !0;
  switch (A.autoUpdaterStatus) {
    case "migrated":
      B = "local";
      break;
    case "installed":
      B = "native";
      break;
    case "disabled":
      Q = !1;
      break;
    case "enabled":
    case "no_permissions":
    case "not_configured":
      B = "global";
      break;
    case void 0:
      break;
  }
  return { ...A, installMethod: B, autoUpdates: Q };
}
function So2(A) {
  if (!A) return A;
  let B = {},
    Q = !1;
  for (let [I, G] of Object.entries(A))
    if (G.history !== void 0) {
      Q = !0;
      let { history: Z, ...Y } = G;
      B[I] = Y;
    } else B[I] = G;
  return Q ? B : A;
}
function L1() {
  try {
    let A = NA().existsSync(UC()) ? NA().statSync(UC()) : null;
    if (yb.config && A) {
      if (A.mtimeMs <= yb.mtime) return yb.config;
    }
    let B = _B0(Wp(UC(), Rw));
    if (A) yb = { config: B, mtime: A.mtimeMs };
    else yb = { config: B, mtime: Date.now() };
    return _B0(B);
  } catch {
    return _B0(Wp(UC(), Rw));
  }
}
function OQ1(A) {
  let B = L1();
  if (B.customApiKeyResponses?.approved?.includes(A)) return "approved";
  if (B.customApiKeyResponses?.rejected?.includes(A)) return "rejected";
  return "new";
}
function xo2(A, B, Q) {
  let I = ko2(A),
    G = NA();
  if (!G.existsSync(I)) G.mkdirSync(I);
  let Z = Object.fromEntries(
    Object.entries(B).filter(
      ([Y, J]) => JSON.stringify(J) !== JSON.stringify(Q[Y]),
    ),
  );
  fj(A, JSON.stringify(Z, null, 2), {
    encoding: "utf-8",
    mode: !G.existsSync(A) ? 384 : void 0,
  });
}
function vo2(A, B, Q) {
  let I = ko2(A),
    G = NA();
  if (!G.existsSync(I)) G.mkdirSync(I);
  let Z;
  try {
    let Y = `${A}.lock`,
      J = Date.now();
    if (((Z = _o2.lockSync(A, { lockfilePath: Y })), Date.now() - J > 100))
      g(
        "Lock acquisition took longer than expected - another Claude instance may be running",
      );
    let W = Wp(A, B),
      F = Q(W),
      C = Object.fromEntries(
        Object.entries(F).filter(
          ([V, K]) => JSON.stringify(K) !== JSON.stringify(B[V]),
        ),
      );
    if (G.existsSync(A))
      try {
        let V = `${A}.backup`;
        G.copyFileSync(A, V);
      } catch (V) {
        g(`Failed to backup config: ${V}`, { level: "error" });
      }
    fj(A, JSON.stringify(C, null, 2), {
      encoding: "utf-8",
      mode: !G.existsSync(A) ? 384 : void 0,
    });
  } finally {
    if (Z) Z();
  }
}
function RQ1() {
  if (vB0) return;
  ((vB0 = !0), Wp(UC(), Rw, !0));
}
function Wp(A, B, Q) {
  if (!vB0) throw Error("Config accessed before allowed.");
  let I = NA();
  if (!I.existsSync(A)) {
    let G = `${A}.backup`;
    if (I.existsSync(G))
      process.stdout.write(`
Claude configuration file not found at: ${A}
A backup file exists at: ${G}
You can manually restore it by running: cp "${G}" "${A}"

`);
    return Y1A(B);
  }
  try {
    let G = I.readFileSync(A, { encoding: "utf-8" });
    try {
      let Z = JSON.parse(G);
      return { ...Y1A(B), ...Z };
    } catch (Z) {
      let Y = Z instanceof Error ? Z.message : String(Z);
      throw new XH(Y, A, B);
    }
  } catch (G) {
    if (G instanceof XH && Q) throw G;
    if (G instanceof XH) {
      (g(`Config file corrupted, resetting to defaults: ${G.message}`, {
        level: "error",
      }),
        BA(G, cf),
        process.stdout.write(`
Claude configuration file at ${A} is corrupted: ${G.message}
`));
      let Z = `${A}.corrupted.${Date.now()}`;
      try {
        (I.copyFileSync(A, Z),
          g(`Corrupted config backed up to: ${Z}`, { level: "error" }));
      } catch {}
      let Y = `${A}.backup`;
      if (
        (process.stdout.write(`
Claude configuration file at ${A} is corrupted
The corrupted file has been backed up to: ${Z}
`),
        I.existsSync(Y))
      )
        process.stdout.write(`A backup file exists at: ${Y}
You can manually restore it by running: cp "${Y}" "${A}"

`);
      else
        process.stdout.write(`
`);
    }
    return Y1A(B);
  }
}
function v6() {
  let A = bB0(),
    B = Wp(UC(), Rw);
  if (!B.projects) return xB0;
  let Q = B.projects[A] ?? xB0;
  if (typeof Q.allowedTools === "string")
    Q.allowedTools = b3(Q.allowedTools) ?? [];
  return Q;
}
function uG(A) {
  let B = bB0();
  try {
    vo2(UC(), Rw, (Q) => ({ ...Q, projects: { ...Q.projects, [B]: A } }));
  } catch (Q) {
    g(`Failed to save config with lock: ${Q}`, { level: "error" });
    let I = Wp(UC(), Rw);
    xo2(UC(), { ...I, projects: { ...I.projects, [B]: A } }, Rw);
  }
}
function mv() {
  let A = L1();
  return !!(
    V0(process.env.DISABLE_AUTOUPDATER) ||
    process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC ||
    (A.autoUpdates === !1 &&
      (A.installMethod !== "native" || A.autoUpdatesProtectedForNative !== !0))
  );
}
function fiA() {
  if (V0(process.env.DISABLE_COST_WARNINGS)) return !1;
  if (nB()) return !1;
  let B = ic(),
    Q = kU() !== null;
  if (!B.hasToken && !Q) return !1;
  let I = L1(),
    G = I.oauthAccount?.organizationRole,
    Z = I.oauthAccount?.workspaceRole;
  if (!G || !Z) return !1;
  return (
    ["admin", "billing"].includes(G) ||
    ["workspace_admin", "workspace_billing"].includes(Z)
  );
}
function Id() {
  let A = L1();
  if (A.userID) return A.userID;
  let B = Q2I(32).toString("hex");
  return (n0({ ...A, userID: B }), B);
}
function _10() {
  let A = L1();
  if (A.anonymousId) return A.anonymousId;
  let B = `claudecode.v1.${I2I()}`;
  return (n0({ ...A, anonymousId: B }), B);
}
function bo2() {
  let A = L1();
  if (!A.firstStartTime) n0({ ...A, firstStartTime: new Date().toISOString() });
}
function $s(A) {
  let B = GQ();
  if (A === "ExperimentalUltraClaudeMd") return $s("User");
  switch (A) {
    case "User":
      return $t(mB(), "CLAUDE.md");
    case "Local":
      return $t(B, "CLAUDE.local.md");
    case "Project":
      return $t(B, "CLAUDE.md");
    case "Managed":
      return $t(Nw(), "CLAUDE.md");
    case "ExperimentalUltraClaudeMd":
      return $t(mB(), "ULTRACLAUDE.md");
  }
}
function Wv1() {
  return $t(Nw(), ".claude", "rules");
}
function Fv1() {
  return $t(mB(), ".claude", "rules");
}
var _o2,
  xB0,
  Rw,
  pEG,
  lEG,
  yb,
  vB0 = !1,
  bB0;
var kB = T(() => {
  NI1();
  a2();
  C6();
  vB();
  V2();
  wC();
  y7();
  i0();
  m0();
  Z4();
  F2();
  C0();
  c1();
  OQ();
  ((_o2 = IA(xYA(), 1)),
    (xB0 = {
      allowedTools: [],
      mcpContextUris: [],
      mcpServers: {},
      enabledMcpjsonServers: [],
      disabledMcpjsonServers: [],
      hasTrustDialogAccepted: !1,
      projectOnboardingSeenCount: 0,
      hasClaudeMdExternalIncludesApproved: !1,
      hasClaudeMdExternalIncludesWarningShown: !1,
    }),
    (Rw = {
      numStartups: 0,
      installMethod: void 0,
      autoUpdates: void 0,
      theme: "dark",
      preferredNotifChannel: "auto",
      verbose: !1,
      editorMode: "normal",
      autoCompactEnabled: !0,
      hasSeenTasksHint: !1,
      queuedCommandUpHintCount: 0,
      diffTool: "auto",
      customApiKeyResponses: { approved: [], rejected: [] },
      env: {},
      tipsHistory: {},
      memoryUsageCount: 0,
      promptQueueUseCount: 0,
      todoFeatureEnabled: !0,
      showExpandedTodos: !1,
      messageIdleNotifThresholdMs: 60000,
      autoConnectIde: !1,
      autoInstallIdeExtension: !0,
      autocheckpointingEnabled: !0,
      checkpointingShadowRepos: [],
      fileCheckpointingEnabled: !0,
      cachedStatsigGates: {},
      cachedDynamicConfigs: {},
      respectGitignore: !0,
    }));
  ((pEG = { ...Rw, autoUpdates: !1 }), (lEG = { ...xB0 }));
  yb = { config: null, mtime: 0 };
  bB0 = I0(() => {
    let A = GQ();
    try {
      return B2I(
        G2I("git rev-parse --show-toplevel", {
          cwd: A,
          encoding: "utf8",
          stdio: ["pipe", "pipe", "ignore"],
        }).trim(),
      );
    } catch {
      return yo2(A);
    }
  });
});
import { execSync as Z2I } from "child_process";
function Y2I() {
  return;
}
var Iy;
var U2A = T(() => {
  kB();
  a2();
  i0();
  F2();
  Iy = I0((A) => {
    let B = Id(),
      Q = L1(),
      I = "",
      G = 0,
      Z = void 0;
    if (A) {
      if (((I = i3() ?? ""), I !== "" && Q.claudeCodeFirstTokenDate)) {
        let W = new Date(Q.claudeCodeFirstTokenDate).getTime();
        if (!isNaN(W)) G = W;
      }
      Z = Q.hasOpusPlanDefault;
    }
    let Y = HG(),
      J = Y?.organizationUuid,
      X = Y?.accountUuid;
    return {
      customIDs: { sessionId: L0(), organizationUUID: J, organizationID: J },
      userID: B,
      appVersion: {
        ISSUES_EXPLAINER:
          "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.claude.com/s/claude-code",
        VERSION: "2.0.42",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues",
      }.VERSION,
      email: Y2I(),
      custom: {
        userType: "external",
        organizationUuid: J,
        accountUuid: X,
        subscriptionType: I,
        firstTokenTime: G,
        hasOpusPlanDefault: Z,
        ...(process.env.GITHUB_ACTIONS === "true" && {
          githubActor: process.env.GITHUB_ACTOR,
          githubActorId: process.env.GITHUB_ACTOR_ID,
          githubRepository: process.env.GITHUB_REPOSITORY,
          githubRepositoryId: process.env.GITHUB_REPOSITORY_ID,
          githubRepositoryOwner: process.env.GITHUB_REPOSITORY_OWNER,
          githubRepositoryOwnerId: process.env.GITHUB_REPOSITORY_OWNER_ID,
        }),
      },
    };
  });
});
import { createHash as J2I } from "crypto";
function _R2() {
  ((qt = null),
    (hB0 = !1),
    gB0.cache?.clear?.(),
    TL.cache?.clear?.(),
    av1.cache?.clear?.(),
    _F.cache?.clear?.());
}
function LdQ() {
  return NV();
}
async function er() {
  if (NV()) return;
  try {
    let A = Iy(!0),
      B = await TL();
    if (!B) return;
    await B.updateUserAsync(A);
  } catch (A) {
    BA(
      A instanceof Error ? A : Error(`Statsig: Force refresh failed: ${A}`),
      CJ0,
    );
  }
}
function ho2() {
  if (NV()) return;
  let A = setInterval(() => {
    er();
  }, X2I);
  process.on("beforeExit", () => {
    clearInterval(A);
  });
}
async function uB0(A, B) {
  if (NV()) return;
  try {
    let [Q, I] = await Promise.all([TL(), Bp({ model: B.model })]);
    if (!Q) return;
    let G = Jp2(I, B),
      Z = { eventName: A, metadata: G };
    (Q.logEvent(Z), await Q.flush());
  } catch (Q) {}
}
function go2(A, B) {
  uB0(A, B);
}
function uo2() {
  return { ...fo2 };
}
async function $v(A, B) {
  if (NV()) return B;
  let Q = await TL();
  if (!Q) return B;
  let I = Q.getDynamicConfig(A);
  if (Object.keys(I.value).length === 0) return B;
  return I.value;
}
function _7(A, B, Q) {
  let I = gB0();
  if (!I) return Q;
  let G = I.client.getExperiment(A);
  if (!G) return Q;
  return G.get(B, Q);
}
function xC(A) {
  return (F2I(A), L1().cachedStatsigGates[A] ?? !1);
}
async function vr2(A) {
  if (hB0) return xC(A);
  return _F(A);
}
function T2A(A, B) {
  let I = L1().cachedDynamicConfigs?.[A];
  return (
    W2I(A, B).then((G) => {
      let Z = L1();
      if (G === Z.cachedDynamicConfigs?.[A]) return;
      n0({
        ...Z,
        cachedDynamicConfigs: { ...(Z.cachedDynamicConfigs ?? {}), [A]: G },
      });
    }),
    I ?? B
  );
}
function TS2(A) {
  let B = L1();
  if (B.cachedDynamicConfigs?.[A] === void 0) return;
  n0({
    ...B,
    cachedDynamicConfigs: { ...B.cachedDynamicConfigs, [A]: void 0 },
  });
}
var fB0,
  TQ1,
  X2I = 21600000,
  fo2,
  qt = null,
  hB0 = !1,
  gB0,
  TL,
  _F,
  y11 = (A, B) => {
    let [Q, I] = fB0.default.useState(B);
    return (
      fB0.default.useEffect(() => {
        $v(A, B).then(I);
      }, [A, B]),
      Q
    );
  },
  av1,
  W2I,
  F2I;
var f4 = T(() => {
  a2();
  _I();
  JE0();
  WE0();
  U2A();
  C0();
  c1();
  kB();
  R$A();
  J7A();
  ((fB0 = IA(KA(), 1)),
    (TQ1 = IA(YE0(), 1)),
    (fo2 = {}),
    (gB0 = I0(() => {
      if (NV()) return null;
      let A = Iy(!0),
        B = {
          networkConfig: { api: "https://statsig.anthropic.com/v1/" },
          environment: {
            tier: ["test", "dev"].includes("production")
              ? "development"
              : "production",
          },
          includeCurrentPageUrlWithEvents: !1,
          logLevel: TQ1.LogLevel.None,
          storageProvider: new DI1(),
          customUserCacheKeyFunc: (I, G) => {
            return J2I("sha1")
              .update(I)
              .update(G.userID || "")
              .digest("hex")
              .slice(0, 10);
          },
        };
      ((qt = new TQ1.StatsigClient(CE0, A, B)),
        qt.on("error", () => {
          DB.head("https://api.anthropic.com/api/hello").catch(() => {});
        }));
      let Q = qt.initializeAsync().then(() => {
        hB0 = !0;
      });
      return (
        process.on("beforeExit", async () => {
          await qt?.flush();
        }),
        process.on("exit", () => {
          qt?.flush();
        }),
        { client: qt, initialized: Q }
      );
    })),
    (TL = I0(async () => {
      let A = gB0();
      if (!A) return null;
      return (await A.initialized, A.client);
    })));
  _F = I0(async (A) => {
    if (NV()) return !1;
    let B = await TL();
    if (!B) return !1;
    let Q = B.checkGate(A);
    return ((fo2[A] = Q), Q);
  });
  av1 = I0(async (A, B) => {
    if (NV()) return B;
    let Q = await TL();
    if (!Q) return B;
    let I = Q.getExperiment(A);
    if (Object.keys(I.value).length === 0) return B;
    return I.value;
  });
  W2I = I0($v);
  F2I = I0(async (A) => {
    let B = await _F(A),
      Q = L1();
    ((Q.cachedStatsigGates[A] = B), n0(Q));
  });
});
function mo2(A) {
  return A.replace(/[A-Z]/g, (B) => `_${B.toLowerCase()}`);
}
async function mB0() {
  if (JqA.length === 0) return;
  let A = [...JqA];
  JqA = [];
  try {
    await DB.post(C2I, A, {
      headers: { "Content-Type": "application/json", "DD-API-KEY": V2I },
      timeout: E2I,
    });
  } catch (B) {
    BA(B instanceof Error ? B : Error(String(B)), C61);
  }
}
function U2I() {
  if (kb) return;
  kb = setTimeout(() => {
    ((kb = null), mB0());
  }, K2I).unref();
}
async function dB0(A, B) {
  if (!(await w2I()) || !H2I.has(A)) return;
  try {
    let I = await Bp({ model: B.model }),
      { envContext: G, ...Z } = I,
      Y = { ...Z, ...G, ...B };
    if (typeof Y.toolName === "string" && Y.toolName.startsWith("mcp__"))
      Y.toolName = "mcp";
    if (Y.status !== void 0 && Y.status !== null) {
      let F = String(Y.status);
      Y.http_status = F;
      let C = F.charAt(0);
      if (C >= "1" && C <= "5") Y.http_status_range = `${C}xx`;
      delete Y.status;
    }
    let J = Y,
      W = {
        ddsource: "nodejs",
        ddtags: z2I
          .filter((F) => J[F] !== void 0 && J[F] !== null)
          .map((F) => `${mo2(F)}:${J[F]}`)
          .join(","),
        message: A,
        service: "claude-code",
        hostname: "claude-code",
        env: "external",
      };
    for (let [F, C] of Object.entries(Y))
      if (C !== void 0 && C !== null) W[mo2(F)] = C;
    if ((JqA.push(W), JqA.length >= D2I)) {
      if (kb) (clearTimeout(kb), (kb = null));
      await mB0();
    } else U2I();
  } catch (I) {
    BA(I instanceof Error ? I : Error(String(I)), C61);
  }
}
var C2I = "https://http-intake.logs.datadoghq.com/api/v2/logs",
  V2I = "pubbc113c03434b701e6e00977875d7382f",
  K2I = 15000,
  D2I = 100,
  E2I = 5000,
  H2I,
  z2I,
  JqA,
  kb = null,
  w2I;
var do2 = T(() => {
  _I();
  a2();
  c1();
  R$A();
  J7A();
  ((H2I = new Set([
    "tengu_api_error",
    "tengu_api_query",
    "tengu_api_success",
    "tengu_compact_failed",
    "tengu_model_fallback_triggered",
    "tengu_oauth_error",
    "tengu_oauth_success",
    "tengu_oauth_token_refresh_failure",
    "tengu_oauth_token_refresh_success",
    "tengu_query_error",
    "tengu_tool_use_error",
    "tengu_tool_use_success",
  ])),
    (z2I = [
      "arch",
      "clientType",
      "deploymentEnvironment",
      "errorType",
      "http_status_range",
      "http_status",
      "model",
      "platform",
      "provider",
      "toolName",
      "userType",
      "version",
      "versionBase",
    ]));
  JqA = [];
  w2I = I0(async () => {
    if (NV()) return !1;
    try {
      let A = async () => {
        if (kb) (clearTimeout(kb), (kb = null));
        await mB0();
      };
      return (process.on("beforeExit", A), !0);
    } catch (A) {
      return (BA(A instanceof Error ? A : Error(String(A)), CX0), !1);
    }
  });
});
class cB0 {
  endpoint;
  timeout;
  pendingExports = [];
  isShutdown = !1;
  constructor(A = {}) {
    let B = process.env.ANTHROPIC_BASE_URL || "https://api.anthropic.com";
    ((this.endpoint = `${B}/api/event_logging/batch`),
      (this.timeout = A.timeout || 5000));
  }
  async export(A, B) {
    if (this.isShutdown) {
      B({
        code: XqA.ExportResultCode.FAILED,
        error: Error("Exporter has been shutdown"),
      });
      return;
    }
    let Q = this.doExport(A, B);
    (this.pendingExports.push(Q),
      Q.finally(() => {
        let I = this.pendingExports.indexOf(Q);
        if (I > -1) this.pendingExports.splice(I, 1);
      }));
  }
  async doExport(A, B) {
    try {
      let Q = A.filter(
        (W) =>
          W.instrumentationScope?.name === "com.anthropic.claude_code.events",
      );
      if (Q.length === 0) {
        B({ code: XqA.ExportResultCode.SUCCESS });
        return;
      }
      let I = await this.transformLogsToEvents(Q),
        G = {
          "Content-Type": "application/json",
          "User-Agent": WW(),
          "x-service-name": "claude-code",
        },
        Z = !1;
      if (nB()) {
        let W = G5();
        if (W && cIA(W.expiresAt)) Z = !0;
      }
      let Y = $Y(),
        J = !Y.error && !Z,
        X;
      if (J)
        try {
          X = await DB.post(this.endpoint, I, {
            timeout: this.timeout,
            headers: { ...G, ...Y.headers },
          });
        } catch (W) {
          if (DB.isAxiosError(W) && W.response?.status === 401) J = !1;
          else throw W;
        }
      if (!X)
        X = await DB.post(this.endpoint, I, {
          timeout: this.timeout,
          headers: G,
        });
      B({ code: XqA.ExportResultCode.SUCCESS });
    } catch (Q) {
      (BA(Q, EM),
